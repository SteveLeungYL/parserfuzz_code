%{
// Copyright 2013 The ql Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSES/QL-LICENSE file.

// Copyright 2015 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

// Initial yacc source generated by ebnf2y[1]
// at 2013-10-04 23:10:47.861401015 +0200 CEST
//
//  $ ebnf2y -o ql.y -oe ql.ebnf -start StatementList -pkg ql -p _
//
//   [1]: http://github.com/cznic/ebnf2y

package parser

import (
	"strings"

	"github.com/pingcap/tidb/parser/mysql"
	"github.com/pingcap/tidb/parser/ast"
	"github.com/pingcap/tidb/parser/model"
	"github.com/pingcap/tidb/parser/opcode"
	"github.com/pingcap/tidb/parser/auth"
	"github.com/pingcap/tidb/parser/sql_ir"
	"github.com/pingcap/tidb/parser/charset"
	"github.com/pingcap/tidb/parser/types"
)

%}

%union {
	offset int // offset
	item interface{}
	ident string
	expr ast.ExprNode
	statement ast.StmtNode
}

%token	<ident>

	
	identifier "identifier"
	asof       "AS OF"

	
	underscoreCS "UNDERSCORE_CHARSET"

	
	stringLit          "string literal"
	singleAtIdentifier "identifier with single leading at"
	doubleAtIdentifier "identifier with double leading at"
	invalid            "a special token never used by parser, used by lexer to indicate error"
	hintComment        "an optimizer hint"
	andand             "&&"
	pipes              "||"

	
	odbcDateType      "d"
	odbcTimeType      "t"
	odbcTimestampType "ts"

	
	add               "ADD"
	all               "ALL"
	alter             "ALTER"
	analyze           "ANALYZE"
	and               "AND"
	as                "AS"
	asc               "ASC"
	between           "BETWEEN"
	bigIntType        "BIGINT"
	binaryType        "BINARY"
	blobType          "BLOB"
	both              "BOTH"
	by                "BY"
	call              "CALL"
	cascade           "CASCADE"
	caseKwd           "CASE"
	change            "CHANGE"
	character         "CHARACTER"
	charType          "CHAR"
	check             "CHECK"
	collate           "COLLATE"
	column            "COLUMN"
	constraint        "CONSTRAINT"
	convert           "CONVERT"
	create            "CREATE"
	cross             "CROSS"
	cumeDist          "CUME_DIST"
	currentDate       "CURRENT_DATE"
	currentTime       "CURRENT_TIME"
	currentTs         "CURRENT_TIMESTAMP"
	currentUser       "CURRENT_USER"
	currentRole       "CURRENT_ROLE"
	database          "DATABASE"
	databases         "DATABASES"
	dayHour           "DAY_HOUR"
	dayMicrosecond    "DAY_MICROSECOND"
	dayMinute         "DAY_MINUTE"
	daySecond         "DAY_SECOND"
	decimalType       "DECIMAL"
	defaultKwd        "DEFAULT"
	delayed           "DELAYED"
	deleteKwd         "DELETE"
	denseRank         "DENSE_RANK"
	desc              "DESC"
	describe          "DESCRIBE"
	distinct          "DISTINCT"
	distinctRow       "DISTINCTROW"
	div               "DIV"
	doubleType        "DOUBLE"
	drop              "DROP"
	dual              "DUAL"
	elseKwd           "ELSE"
	enclosed          "ENCLOSED"
	escaped           "ESCAPED"
	exists            "EXISTS"
	explain           "EXPLAIN"
	except            "EXCEPT"
	falseKwd          "FALSE"
	fetch             "FETCH"
	firstValue        "FIRST_VALUE"
	floatType         "FLOAT"
	forKwd            "FOR"
	force             "FORCE"
	foreign           "FOREIGN"
	from              "FROM"
	fulltext          "FULLTEXT"
	generated         "GENERATED"
	grant             "GRANT"
	group             "GROUP"
	groups            "GROUPS"
	having            "HAVING"
	highPriority      "HIGH_PRIORITY"
	hourMicrosecond   "HOUR_MICROSECOND"
	hourMinute        "HOUR_MINUTE"
	hourSecond        "HOUR_SECOND"
	ifKwd             "IF"
	ignore            "IGNORE"
	in                "IN"
	index             "INDEX"
	infile            "INFILE"
	inner             "INNER"
	integerType       "INTEGER"
	intersect         "INTERSECT"
	interval          "INTERVAL"
	into              "INTO"
	outfile           "OUTFILE"
	is                "IS"
	insert            "INSERT"
	intType           "INT"
	int1Type          "INT1"
	int2Type          "INT2"
	int3Type          "INT3"
	int4Type          "INT4"
	int8Type          "INT8"
	join              "JOIN"
	key               "KEY"
	keys              "KEYS"
	kill              "KILL"
	lag               "LAG"
	lastValue         "LAST_VALUE"
	lead              "LEAD"
	leading           "LEADING"
	left              "LEFT"
	like              "LIKE"
	limit             "LIMIT"
	lines             "LINES"
	linear            "LINEAR"
	load              "LOAD"
	localTime         "LOCALTIME"
	localTs           "LOCALTIMESTAMP"
	lock              "LOCK"
	longblobType      "LONGBLOB"
	longtextType      "LONGTEXT"
	lowPriority       "LOW_PRIORITY"
	match             "MATCH"
	maxValue          "MAXVALUE"
	mediumblobType    "MEDIUMBLOB"
	mediumIntType     "MEDIUMINT"
	mediumtextType    "MEDIUMTEXT"
	minuteMicrosecond "MINUTE_MICROSECOND"
	minuteSecond      "MINUTE_SECOND"
	mod               "MOD"
	not               "NOT"
	noWriteToBinLog   "NO_WRITE_TO_BINLOG"
	nthValue          "NTH_VALUE"
	ntile             "NTILE"
	null              "NULL"
	numericType       "NUMERIC"
	of                "OF"
	on                "ON"
	optimize          "OPTIMIZE"
	option            "OPTION"
	optionally        "OPTIONALLY"
	or                "OR"
	order             "ORDER"
	outer             "OUTER"
	over              "OVER"
	partition         "PARTITION"
	percentRank       "PERCENT_RANK"
	precisionType     "PRECISION"
	primary           "PRIMARY"
	procedure         "PROCEDURE"
	rangeKwd          "RANGE"
	rank              "RANK"
	read              "READ"
	realType          "REAL"
	recursive         "RECURSIVE"
	references        "REFERENCES"
	regexpKwd         "REGEXP"
	release           "RELEASE"
	rename            "RENAME"
	repeat            "REPEAT"
	replace           "REPLACE"
	require           "REQUIRE"
	restrict          "RESTRICT"
	revoke            "REVOKE"
	right             "RIGHT"
	rlike             "RLIKE"
	row               "ROW"
	rows              "ROWS"
	rowNumber         "ROW_NUMBER"
	secondMicrosecond "SECOND_MICROSECOND"
	selectKwd         "SELECT"
	set               "SET"
	show              "SHOW"
	smallIntType      "SMALLINT"
	spatial           "SPATIAL"
	sql               "SQL"
	sqlBigResult      "SQL_BIG_RESULT"
	sqlCalcFoundRows  "SQL_CALC_FOUND_ROWS"
	sqlSmallResult    "SQL_SMALL_RESULT"
	ssl               "SSL"
	starting          "STARTING"
	statsExtended     "STATS_EXTENDED"
	straightJoin      "STRAIGHT_JOIN"
	tableKwd          "TABLE"
	tableSample       "TABLESAMPLE"
	stored            "STORED"
	terminated        "TERMINATED"
	then              "THEN"
	tinyblobType      "TINYBLOB"
	tinyIntType       "TINYINT"
	tinytextType      "TINYTEXT"
	to                "TO"
	trailing          "TRAILING"
	trigger           "TRIGGER"
	trueKwd           "TRUE"
	unique            "UNIQUE"
	union             "UNION"
	unlock            "UNLOCK"
	unsigned          "UNSIGNED"
	update            "UPDATE"
	usage             "USAGE"
	use               "USE"
	using             "USING"
	utcDate           "UTC_DATE"
	utcTimestamp      "UTC_TIMESTAMP"
	utcTime           "UTC_TIME"
	values            "VALUES"
	long              "LONG"
	varcharType       "VARCHAR"
	varcharacter      "VARCHARACTER"
	varbinaryType     "VARBINARY"
	varying           "VARYING"
	virtual           "VIRTUAL"
	when              "WHEN"
	where             "WHERE"
	write             "WRITE"
	window            "WINDOW"
	with              "WITH"
	xor               "XOR"
	yearMonth         "YEAR_MONTH"
	zerofill          "ZEROFILL"
	natural           "NATURAL"

	
	account               "ACCOUNT"
	action                "ACTION"
	advise                "ADVISE"
	after                 "AFTER"
	against               "AGAINST"
	ago                   "AGO"
	algorithm             "ALGORITHM"
	always                "ALWAYS"
	any                   "ANY"
	ascii                 "ASCII"
	attributes            "ATTRIBUTES"
	statsOptions          "STATS_OPTIONS"
	statsSampleRate       "STATS_SAMPLE_RATE"
	statsColChoice        "STATS_COL_CHOICE"
	statsColList          "STATS_COL_LIST"
	autoIdCache           "AUTO_ID_CACHE"
	autoIncrement         "AUTO_INCREMENT"
	autoRandom            "AUTO_RANDOM"
	autoRandomBase        "AUTO_RANDOM_BASE"
	avg                   "AVG"
	avgRowLength          "AVG_ROW_LENGTH"
	backend               "BACKEND"
	backup                "BACKUP"
	backups               "BACKUPS"
	begin                 "BEGIN"
	bernoulli             "BERNOULLI"
	binding               "BINDING"
	bindingCache          "BINDING_CACHE"
	bindings              "BINDINGS"
	binlog                "BINLOG"
	bitType               "BIT"
	block                 "BLOCK"
	booleanType           "BOOLEAN"
	boolType              "BOOL"
	btree                 "BTREE"
	byteType              "BYTE"
	cache                 "CACHE"
	capture               "CAPTURE"
	cascaded              "CASCADED"
	causal                "CAUSAL"
	chain                 "CHAIN"
	charsetKwd            "CHARSET"
	checkpoint            "CHECKPOINT"
	checksum              "CHECKSUM"
	cipher                "CIPHER"
	cleanup               "CLEANUP"
	client                "CLIENT"
	clientErrorsSummary   "CLIENT_ERRORS_SUMMARY"
	coalesce              "COALESCE"
	collation             "COLLATION"
	columnFormat          "COLUMN_FORMAT"
	columns               "COLUMNS"
	config                "CONFIG"
	comment               "COMMENT"
	commit                "COMMIT"
	committed             "COMMITTED"
	compact               "COMPACT"
	compressed            "COMPRESSED"
	compression           "COMPRESSION"
	concurrency           "CONCURRENCY"
	connection            "CONNECTION"
	consistency           "CONSISTENCY"
	consistent            "CONSISTENT"
	context               "CONTEXT"
	cpu                   "CPU"
	csvBackslashEscape    "CSV_BACKSLASH_ESCAPE"
	csvDelimiter          "CSV_DELIMITER"
	csvHeader             "CSV_HEADER"
	csvNotNull            "CSV_NOT_NULL"
	csvNull               "CSV_NULL"
	csvSeparator          "CSV_SEPARATOR"
	csvTrimLastSeparators "CSV_TRIM_LAST_SEPARATORS"
	current               "CURRENT"
	clustered             "CLUSTERED"
	cycle                 "CYCLE"
	data                  "DATA"
	datetimeType          "DATETIME"
	dateType              "DATE"
	day                   "DAY"
	deallocate            "DEALLOCATE"
	definer               "DEFINER"
	delayKeyWrite         "DELAY_KEY_WRITE"
	directory             "DIRECTORY"
	disable               "DISABLE"
	disabled              "DISABLED"
	discard               "DISCARD"
	disk                  "DISK"
	do                    "DO"
	duplicate             "DUPLICATE"
	dynamic               "DYNAMIC"
	enable                "ENABLE"
	enabled               "ENABLED"
	encryption            "ENCRYPTION"
	end                   "END"
	enforced              "ENFORCED"
	engine                "ENGINE"
	engines               "ENGINES"
	enum                  "ENUM"
	errorKwd              "ERROR"
	escape                "ESCAPE"
	event                 "EVENT"
	events                "EVENTS"
	evolve                "EVOLVE"
	exchange              "EXCHANGE"
	exclusive             "EXCLUSIVE"
	execute               "EXECUTE"
	expansion             "EXPANSION"
	expire                "EXPIRE"
	extended              "EXTENDED"
	faultsSym             "FAULTS"
	fields                "FIELDS"
	file                  "FILE"
	first                 "FIRST"
	fixed                 "FIXED"
	flush                 "FLUSH"
	following             "FOLLOWING"
	format                "FORMAT"
	full                  "FULL"
	function              "FUNCTION"
	general               "GENERAL"
	global                "GLOBAL"
	grants                "GRANTS"
	hash                  "HASH"
	help                  "HELP"
	histogram             "HISTOGRAM"
	history               "HISTORY"
	hosts                 "HOSTS"
	hour                  "HOUR"
	identified            "IDENTIFIED"
	identSQLErrors        "ERRORS"
	importKwd             "IMPORT"
	imports               "IMPORTS"
	increment             "INCREMENT"
	incremental           "INCREMENTAL"
	indexes               "INDEXES"
	insertMethod          "INSERT_METHOD"
	instance              "INSTANCE"
	invisible             "INVISIBLE"
	invoker               "INVOKER"
	io                    "IO"
	ipc                   "IPC"
	isolation             "ISOLATION"
	issuer                "ISSUER"
	jsonType              "JSON"
	keyBlockSize          "KEY_BLOCK_SIZE"
	labels                "LABELS"
	language              "LANGUAGE"
	last                  "LAST"
	lastBackup            "LAST_BACKUP"
	lastval               "LASTVAL"
	less                  "LESS"
	level                 "LEVEL"
	list                  "LIST"
	local                 "LOCAL"
	locked                "LOCKED"
	location              "LOCATION"
	logs                  "LOGS"
	master                "MASTER"
	max_idxnum            "MAX_IDXNUM"
	max_minutes           "MAX_MINUTES"
	maxConnectionsPerHour "MAX_CONNECTIONS_PER_HOUR"
	maxQueriesPerHour     "MAX_QUERIES_PER_HOUR"
	maxRows               "MAX_ROWS"
	maxUpdatesPerHour     "MAX_UPDATES_PER_HOUR"
	maxUserConnections    "MAX_USER_CONNECTIONS"
	mb                    "MB"
	memory                "MEMORY"
	merge                 "MERGE"
	microsecond           "MICROSECOND"
	minRows               "MIN_ROWS"
	minute                "MINUTE"
	minValue              "MINVALUE"
	mode                  "MODE"
	modify                "MODIFY"
	month                 "MONTH"
	names                 "NAMES"
	national              "NATIONAL"
	ncharType             "NCHAR"
	never                 "NEVER"
	next                  "NEXT"
	nextval               "NEXTVAL"
	no                    "NO"
	nocache               "NOCACHE"
	nocycle               "NOCYCLE"
	nodegroup             "NODEGROUP"
	nomaxvalue            "NOMAXVALUE"
	nominvalue            "NOMINVALUE"
	nonclustered          "NONCLUSTERED"
	none                  "NONE"
	nowait                "NOWAIT"
	nvarcharType          "NVARCHAR"
	nulls                 "NULLS"
	off                   "OFF"
	offset                "OFFSET"
	onDuplicate           "ON_DUPLICATE"
	online                "ONLINE"
	only                  "ONLY"
	open                  "OPEN"
	optional              "OPTIONAL"
	packKeys              "PACK_KEYS"
	pageSym               "PAGE"
	parser                "PARSER"
	partial               "PARTIAL"
	partitioning          "PARTITIONING"
	partitions            "PARTITIONS"
	password              "PASSWORD"
	percent               "PERCENT"
	per_db                "PER_DB"
	per_table             "PER_TABLE"
	pipesAsOr
	plugins               "PLUGINS"
	policy                "POLICY"
	preSplitRegions       "PRE_SPLIT_REGIONS"
	preceding             "PRECEDING"
	prepare               "PREPARE"
	preserve              "PRESERVE"
	privileges            "PRIVILEGES"
	process               "PROCESS"
	processlist           "PROCESSLIST"
	profile               "PROFILE"
	profiles              "PROFILES"
	proxy                 "PROXY"
	purge                 "PURGE"
	quarter               "QUARTER"
	queries               "QUERIES"
	query                 "QUERY"
	quick                 "QUICK"
	rateLimit             "RATE_LIMIT"
	rebuild               "REBUILD"
	recover               "RECOVER"
	redundant             "REDUNDANT"
	reload                "RELOAD"
	remove                "REMOVE"
	reorganize            "REORGANIZE"
	repair                "REPAIR"
	repeatable            "REPEATABLE"
	replica               "REPLICA"
	replicas              "REPLICAS"
	replication           "REPLICATION"
	required              "REQUIRED"
	respect               "RESPECT"
	restart               "RESTART"
	restore               "RESTORE"
	restores              "RESTORES"
	resume                "RESUME"
	reverse               "REVERSE"
	role                  "ROLE"
	rollback              "ROLLBACK"
	routine               "ROUTINE"
	rowCount              "ROW_COUNT"
	rowFormat             "ROW_FORMAT"
	rtree                 "RTREE"
	san                   "SAN"
	second                "SECOND"
	secondaryEngine       "SECONDARY_ENGINE"
	secondaryLoad         "SECONDARY_LOAD"
	secondaryUnload       "SECONDARY_UNLOAD"
	security              "SECURITY"
	sendCredentialsToTiKV "SEND_CREDENTIALS_TO_TIKV"
	separator             "SEPARATOR"
	sequence              "SEQUENCE"
	serial                "SERIAL"
	serializable          "SERIALIZABLE"
	session               "SESSION"
	setval                "SETVAL"
	shardRowIDBits        "SHARD_ROW_ID_BITS"
	share                 "SHARE"
	shared                "SHARED"
	shutdown              "SHUTDOWN"
	signed                "SIGNED"
	simple                "SIMPLE"
	skip                  "SKIP"
	skipSchemaFiles       "SKIP_SCHEMA_FILES"
	slave                 "SLAVE"
	slow                  "SLOW"
	snapshot              "SNAPSHOT"
	some                  "SOME"
	source                "SOURCE"
	sqlBufferResult       "SQL_BUFFER_RESULT"
	sqlCache              "SQL_CACHE"
	sqlNoCache            "SQL_NO_CACHE"
	sqlTsiDay             "SQL_TSI_DAY"
	sqlTsiHour            "SQL_TSI_HOUR"
	sqlTsiMinute          "SQL_TSI_MINUTE"
	sqlTsiMonth           "SQL_TSI_MONTH"
	sqlTsiQuarter         "SQL_TSI_QUARTER"
	sqlTsiSecond          "SQL_TSI_SECOND"
	sqlTsiWeek            "SQL_TSI_WEEK"
	sqlTsiYear            "SQL_TSI_YEAR"
	start                 "START"
	statsAutoRecalc       "STATS_AUTO_RECALC"
	statsPersistent       "STATS_PERSISTENT"
	statsSamplePages      "STATS_SAMPLE_PAGES"
	status                "STATUS"
	storage               "STORAGE"
	strictFormat          "STRICT_FORMAT"
	subject               "SUBJECT"
	subpartition          "SUBPARTITION"
	subpartitions         "SUBPARTITIONS"
	super                 "SUPER"
	swaps                 "SWAPS"
	switchesSym           "SWITCHES"
	system                "SYSTEM"
	systemTime            "SYSTEM_TIME"
	tableChecksum         "TABLE_CHECKSUM"
	tables                "TABLES"
	tablespace            "TABLESPACE"
	temporary             "TEMPORARY"
	temptable             "TEMPTABLE"
	textType              "TEXT"
	than                  "THAN"
	tikvImporter          "TIKV_IMPORTER"
	timestampType         "TIMESTAMP"
	timeType              "TIME"
	tp                    "TYPE"
	trace                 "TRACE"
	traditional           "TRADITIONAL"
	transaction           "TRANSACTION"
	triggers              "TRIGGERS"
	truncate              "TRUNCATE"
	unbounded             "UNBOUNDED"
	uncommitted           "UNCOMMITTED"
	undefined             "UNDEFINED"
	unicodeSym            "UNICODE"
	unknown               "UNKNOWN"
	user                  "USER"
	validation            "VALIDATION"
	value                 "VALUE"
	variables             "VARIABLES"
	view                  "VIEW"
	visible               "VISIBLE"
	warnings              "WARNINGS"
	week                  "WEEK"
	weightString          "WEIGHT_STRING"
	without               "WITHOUT"
	x509                  "X509"
	yearType              "YEAR"
	wait                  "WAIT"

	
	addDate               "ADDDATE"
	approxCountDistinct   "APPROX_COUNT_DISTINCT"
	approxPercentile      "APPROX_PERCENTILE"
	bitAnd                "BIT_AND"
	bitOr                 "BIT_OR"
	bitXor                "BIT_XOR"
	bound                 "BOUND"
	briefType             "BRIEF"
	cast                  "CAST"
	copyKwd               "COPY"
	constraints           "CONSTRAINTS"
	curTime               "CURTIME"
	dateAdd               "DATE_ADD"
	dateSub               "DATE_SUB"
	dotType               "DOT"
	dump                  "DUMP"
	exact                 "EXACT"
	exprPushdownBlacklist "EXPR_PUSHDOWN_BLACKLIST"
	extract               "EXTRACT"
	flashback             "FLASHBACK"
	follower              "FOLLOWER"
	followerConstraints   "FOLLOWER_CONSTRAINTS"
	followers             "FOLLOWERS"
	getFormat             "GET_FORMAT"
	groupConcat           "GROUP_CONCAT"
	next_row_id           "NEXT_ROW_ID"
	inplace               "INPLACE"
	instant               "INSTANT"
	internal              "INTERNAL"
	jsonArrayagg          "JSON_ARRAYAGG"
	jsonObjectAgg         "JSON_OBJECTAGG"
	leader                "LEADER"
	leaderConstraints     "LEADER_CONSTRAINTS"
	learner               "LEARNER"
	learnerConstraints    "LEARNER_CONSTRAINTS"
	learners              "LEARNERS"
	min                   "MIN"
	max                   "MAX"
	now                   "NOW"
	optRuleBlacklist      "OPT_RULE_BLACKLIST"
	placement             "PLACEMENT"
	plan                  "PLAN"
	planCache             "PLAN_CACHE"
	position              "POSITION"
	predicate             "PREDICATE"
	primaryRegion         "PRIMARY_REGION"
	recent                "RECENT"
	replayer              "REPLAYER"
	running               "RUNNING"
	s3                    "S3"
	schedule              "SCHEDULE"
	staleness             "STALENESS"
	std                   "STD"
	stddev                "STDDEV"
	stddevPop             "STDDEV_POP"
	stddevSamp            "STDDEV_SAMP"
	stop                  "STOP"
	strict                "STRICT"
	strong                "STRONG"
	subDate               "SUBDATE"
	sum                   "SUM"
	substring             "SUBSTRING"
	target                "TARGET"
	timestampAdd          "TIMESTAMPADD"
	timestampDiff         "TIMESTAMPDIFF"
	tls                   "TLS"
	tokudbDefault         "TOKUDB_DEFAULT"
	tokudbFast            "TOKUDB_FAST"
	tokudbLzma            "TOKUDB_LZMA"
	tokudbQuickLZ         "TOKUDB_QUICKLZ"
	tokudbSnappy          "TOKUDB_SNAPPY"
	tokudbSmall           "TOKUDB_SMALL"
	tokudbUncompressed    "TOKUDB_UNCOMPRESSED"
	tokudbZlib            "TOKUDB_ZLIB"
	top                   "TOP"
	trim                  "TRIM"
	variance              "VARIANCE"
	varPop                "VAR_POP"
	varSamp               "VAR_SAMP"
	verboseType           "VERBOSE"
	trueCardCost          "TRUE_CARD_COST"
	voter                 "VOTER"
	voterConstraints      "VOTER_CONSTRAINTS"
	voters                "VOTERS"

	
	admin                      "ADMIN"
	batch                      "BATCH"
	buckets                    "BUCKETS"
	builtins                   "BUILTINS"
	cancel                     "CANCEL"
	cardinality                "CARDINALITY"
	cmSketch                   "CMSKETCH"
	columnStatsUsage           "COLUMN_STATS_USAGE"
	correlation                "CORRELATION"
	ddl                        "DDL"
	dependency                 "DEPENDENCY"
	depth                      "DEPTH"
	drainer                    "DRAINER"
	dry                        "DRY"
	jobs                       "JOBS"
	job                        "JOB"
	nodeID                     "NODE_ID"
	nodeState                  "NODE_STATE"
	optimistic                 "OPTIMISTIC"
	pessimistic                "PESSIMISTIC"
	pump                       "PUMP"
	run                        "RUN"
	samples                    "SAMPLES"
	sampleRate                 "SAMPLERATE"
	statistics                 "STATISTICS"
	stats                      "STATS"
	statsMeta                  "STATS_META"
	statsHistograms            "STATS_HISTOGRAMS"
	statsBuckets               "STATS_BUCKETS"
	statsHealthy               "STATS_HEALTHY"
	statsTopN                  "STATS_TOPN"
	histogramsInFlight         "HISTOGRAMS_IN_FLIGHT"
	telemetry                  "TELEMETRY"
	telemetryID                "TELEMETRY_ID"
	tidb                       "TIDB"
	tiFlash                    "TIFLASH"
	topn                       "TOPN"
	split                      "SPLIT"
	width                      "WIDTH"
	reset                      "RESET"
	regions                    "REGIONS"
	region                     "REGION"
	builtinBitAnd
	builtinBitOr
	builtinBitXor
	builtinCast
	builtinCount
	builtinApproxCountDistinct
	builtinApproxPercentile
	builtinCurDate
	builtinCurTime
	builtinDateAdd
	builtinDateSub
	builtinExtract
	builtinGroupConcat
	builtinMax
	builtinMin
	builtinNow
	builtinPosition
	builtinSubstring
	builtinSum
	builtinSysDate
	builtinStddevPop
	builtinStddevSamp
	builtinTranslate
	builtinTrim
	builtinUser
	builtinVarPop
	builtinVarSamp

%token	<item>

	
	floatLit "floating-point literal"

	
	decLit "decimal literal"

	
	intLit "integer literal"

	
	hexLit "hexadecimal literal"

	
	bitLit       "bit literal"
	andnot       "&^"
	assignmentEq ":="
	eq           "="
	ge           ">="
	le           "<="
	jss          "->"
	juss         "->>"
	lsh          "<<"
	neq          "!="
	neqSynonym   "<>"
	nulleq       "<=>"
	paramMarker  "?"
	rsh          ">>"

%token not2
%type	<expr>
	Expression                      "expression"
	MaxValueOrExpression            "maxvalue or expression"
	BoolPri                         "boolean primary expression"
	ExprOrDefault                   "expression or default"
	PredicateExpr                   "Predicate expression factor"
	SetExpr                         "Set variable statement value's expression"
	BitExpr                         "bit expression"
	SimpleExpr                      "simple expression"
	SimpleIdent                     "Simple Identifier expression"
	SumExpr                         "aggregate functions"
	FunctionCallGeneric             "Function call with Identifier"
	FunctionCallKeyword             "Function call with keyword as function name"
	FunctionCallNonKeyword          "Function call with nonkeyword as function name"
	Literal                         "literal value"
	Variable                        "User or system variable"
	SystemVariable                  "System defined variable name"
	UserVariable                    "User defined variable name"
	SubSelect                       "Sub Select"
	StringLiteral                   "text literal"
	ExpressionOpt                   "Optional expression"
	SignedLiteral                   "Literal or NumLiteral with sign"
	DefaultValueExpr                "DefaultValueExpr(Now or Signed Literal)"
	NowSymOptionFraction            "NowSym with optional fraction part"
	NowSymOptionFractionParentheses "NowSym with optional fraction part within potential parentheses"
	CharsetNameOrDefault            "Character set name or default"
	NextValueForSequence            "Default nextval expression"
	BuiltinFunction                 "Default builtin functions for columns"
	FunctionNameSequence            "Function with sequence function call"
	WindowFuncCall                  "WINDOW function call"
	RepeatableOpt                   "Repeatable optional in sample clause"
	ProcedureCall                   "Procedure call with Identifier or identifier"

%type	<statement>
	AdminStmt                  "Check table statement or show ddl statement"
	AlterDatabaseStmt          "Alter database statement"
	AlterTableStmt             "Alter table statement"
	AlterUserStmt              "Alter user statement"
	AlterImportStmt            "ALTER IMPORT statement"
	AlterInstanceStmt          "Alter instance statement"
	AlterPolicyStmt            "Alter Placement Policy statement"
	AlterSequenceStmt          "Alter sequence statement"
	AnalyzeTableStmt           "Analyze table statement"
	BeginTransactionStmt       "BEGIN TRANSACTION statement"
	BinlogStmt                 "Binlog base64 statement"
	BRIEStmt                   "BACKUP or RESTORE statement"
	CommitStmt                 "COMMIT statement"
	CreateTableStmt            "CREATE TABLE statement"
	CreateViewStmt             "CREATE VIEW  statement"
	CreateUserStmt             "CREATE User statement"
	CreateRoleStmt             "CREATE Role statement"
	CreateDatabaseStmt         "Create Database Statement"
	CreateIndexStmt            "CREATE INDEX statement"
	CreateImportStmt           "CREATE IMPORT statement"
	CreateBindingStmt          "CREATE BINDING  statement"
	CreatePolicyStmt           "CREATE PLACEMENT POLICY statement"
	CreateSequenceStmt         "CREATE SEQUENCE statement"
	CreateStatisticsStmt       "CREATE STATISTICS statement"
	DoStmt                     "Do statement"
	DropDatabaseStmt           "DROP DATABASE statement"
	DropImportStmt             "DROP IMPORT statement"
	DropIndexStmt              "DROP INDEX statement"
	DropStatisticsStmt         "DROP STATISTICS statement"
	DropStatsStmt              "DROP STATS statement"
	DropTableStmt              "DROP TABLE statement"
	DropSequenceStmt           "DROP SEQUENCE statement"
	DropUserStmt               "DROP USER"
	DropRoleStmt               "DROP ROLE"
	DropViewStmt               "DROP VIEW statement"
	DropBindingStmt            "DROP BINDING  statement"
	DropPolicyStmt             "DROP PLACEMENT POLICY statement"
	DeallocateStmt             "Deallocate prepared statement"
	DeleteFromStmt             "DELETE FROM statement"
	DeleteWithoutUsingStmt     "Normal DELETE statement"
	DeleteWithUsingStmt        "DELETE USING statement"
	EmptyStmt                  "empty statement"
	ExecuteStmt                "Execute statement"
	ExplainStmt                "EXPLAIN statement"
	ExplainableStmt            "explainable statement"
	FlushStmt                  "Flush statement"
	FlashbackTableStmt         "Flashback table statement"
	GrantStmt                  "Grant statement"
	GrantProxyStmt             "Grant proxy statement"
	GrantRoleStmt              "Grant role statement"
	InsertIntoStmt             "INSERT INTO statement"
	CallStmt                   "CALL statement"
	IndexAdviseStmt            "INDEX ADVISE statement"
	KillStmt                   "Kill statement"
	LoadDataStmt               "Load data statement"
	LoadStatsStmt              "Load statistic statement"
	LockTablesStmt             "Lock tables statement"
	NonTransactionalDeleteStmt "Non-transactional delete statement"
	PlanReplayerStmt           "Plan replayer statement"
	PreparedStmt               "PreparedStmt"
	PurgeImportStmt            "PURGE IMPORT statement that removes a IMPORT task record"
	SelectStmt                 "SELECT statement"
	SelectStmtWithClause       "common table expression SELECT statement"
	RenameTableStmt            "rename table statement"
	RenameUserStmt             "rename user statement"
	ReplaceIntoStmt            "REPLACE INTO statement"
	RecoverTableStmt           "recover table statement"
	ResumeImportStmt           "RESUME IMPORT statement"
	RevokeStmt                 "Revoke statement"
	RevokeRoleStmt             "Revoke role statement"
	RollbackStmt               "ROLLBACK statement"
	SplitRegionStmt            "Split index region statement"
	SetStmt                    "Set variable statement"
	ChangeStmt                 "Change statement"
	SetBindingStmt             "Set binding statement"
	SetRoleStmt                "Set active role statement"
	SetDefaultRoleStmt         "Set default statement for some user"
	ShowImportStmt             "SHOW IMPORT statement"
	ShowStmt                   "Show engines/databases/tables/user/columns/warnings/status statement"
	Statement                  "statement"
	StopImportStmt             "STOP IMPORT statement"
	TraceStmt                  "TRACE statement"
	TraceableStmt              "traceable statement"
	TruncateTableStmt          "TRUNCATE TABLE statement"
	UnlockTablesStmt           "Unlock tables statement"
	UpdateStmt                 "UPDATE statement"
	SetOprStmt                 "Union/Except/Intersect select statement"
	SetOprStmtWithLimitOrderBy "Union/Except/Intersect select statement with limit and order by"
	SetOprStmtWoutLimitOrderBy "Union/Except/Intersect select statement without limit and order by"
	UseStmt                    "USE statement"
	ShutdownStmt               "SHUTDOWN statement"
	RestartStmt                "RESTART statement"
	CreateViewSelectOpt        "Select/Union/Except/Intersect statement in CREATE VIEW ... AS SELECT"
	BindableStmt               "Statement that can be created binding on"
	UpdateStmtNoWith           "Update statement without CTE clause"
	HelpStmt                   "HELP statement"

%type	<item>
	AdminShowSlow                          "Admin Show Slow statement"
	AllOrPartitionNameList                 "All or partition name list"
	AlgorithmClause                        "Alter table algorithm"
	AlterTablePartitionOpt                 "Alter table partition option"
	AlterTableSpec                         "Alter table specification"
	AlterTableSpecList                     "Alter table specification list"
	AlterTableSpecListOpt                  "Alter table specification list optional"
	AlterSequenceOption                    "Alter sequence option"
	AlterSequenceOptionList                "Alter sequence option list"
	AnalyzeOption                          "Analyze option"
	AnalyzeOptionList                      "Analyze option list"
	AnalyzeOptionListOpt                   "Optional analyze option list"
	AnyOrAll                               "Any or All for subquery"
	Assignment                             "assignment"
	AssignmentList                         "assignment list"
	AssignmentListOpt                      "assignment list opt"
	AuthOption                             "User auth option"
	Boolean                                "Boolean (0, 1, false, true)"
	OptionalBraces                         "optional braces"
	CastType                               "Cast function target type"
	ClearPasswordExpireOptions             "Clear password expire options"
	ColumnDef                              "table column definition"
	ColumnDefList                          "table column definition list"
	ColumnName                             "column name"
	ColumnNameOrUserVariable               "column name or user variable"
	ColumnNameList                         "column name list"
	ColumnNameOrUserVariableList           "column name or user variable list"
	ColumnList                             "column list"
	ColumnNameListOpt                      "column name list opt"
	IdentList                              "identifier list"
	IdentListWithParenOpt                  "column name list opt with parentheses"
	ColumnNameOrUserVarListOpt             "column name or user vairiabe list opt"
	ColumnNameOrUserVarListOptWithBrackets "column name or user variable list opt with brackets"
	ColumnSetValue                         "insert statement set value by column name"
	ColumnSetValueList                     "insert statement set value by column name list"
	CompareOp                              "Compare opcode"
	ColumnOption                           "column definition option"
	ColumnOptionList                       "column definition option list"
	VirtualOrStored                        "indicate generated column is stored or not"
	ColumnOptionListOpt                    "optional column definition option list"
	CommonTableExpr                        "Common table expression"
	CompletionTypeWithinTransaction        "overwrite system variable completion_type within current transaction"
	ConnectionOption                       "single connection options"
	ConnectionOptionList                   "connection options for CREATE USER statement"
	ConnectionOptions                      "optional connection options for CREATE USER statement"
	Constraint                             "table constraint"
	ConstraintElem                         "table constraint element"
	ConstraintKeywordOpt                   "Constraint Keyword or empty"
	CreateSequenceOptionListOpt            "create sequence list opt"
	CreateTableOptionListOpt               "create table option list opt"
	CreateTableSelectOpt                   "Select/Union statement in CREATE TABLE ... SELECT"
	DatabaseOption                         "CREATE Database specification"
	DatabaseOptionList                     "CREATE Database specification list"
	DatabaseOptionListOpt                  "CREATE Database specification list opt"
	DistinctOpt                            "Explicit distinct option"
	DefaultFalseDistinctOpt                "Distinct option which defaults to false"
	DefaultTrueDistinctOpt                 "Distinct option which defaults to true"
	BuggyDefaultFalseDistinctOpt           "Distinct option which accepts DISTINCT ALL and defaults to false"
	RequireClause                          "Encrypted connections options"
	RequireClauseOpt                       "optional Encrypted connections options"
	EqOpt                                  "= or empty"
	ErrorHandling                          "specify exit, replace or skip when meet error"
	EscapedTableRef                        "escaped table reference"
	ExpressionList                         "expression list"
	ExtendedPriv                           "Extended privileges like LOAD FROM S3 or dynamic privileges"
	MaxValueOrExpressionList               "maxvalue or expression list"
	ExpressionListOpt                      "expression list opt"
	FetchFirstOpt                          "Fetch First/Next Option"
	FuncDatetimePrecListOpt                "Function datetime precision list opt"
	FuncDatetimePrecList                   "Function datetime precision list"
	Field                                  "field expression"
	Fields                                 "Fields clause"
	FieldList                              "field expression list"
	FlushOption                            "Flush option"
	ForceOpt                               "Force opt"
	InstanceOption                         "Instance option"
	FulltextSearchModifierOpt              "Fulltext modifier"
	PluginNameList                         "Plugin Name List"
	TableRefsClause                        "Table references clause"
	FieldItem                              "Field item for load data clause"
	FieldItemList                          "Field items for load data clause"
	FuncDatetimePrec                       "Function datetime precision"
	GetFormatSelector                      "{DATE|DATETIME|TIME|TIMESTAMP}"
	GlobalScope                            "The scope of variable"
	StatementScope                         "The scope of statement"
	GroupByClause                          "GROUP BY clause"
	HavingClause                           "HAVING clause"
	AsOfClause                             "AS OF clause"
	AsOfClauseOpt                          "AS OF clause optional"
	HandleRange                            "handle range"
	HandleRangeList                        "handle range list"
	IfExists                               "If Exists"
	IfNotExists                            "If Not Exists"
	IfNotRunning                           "If Not Running"
	IfRunning                              "If Running"
	IgnoreOptional                         "IGNORE or empty"
	ImportTruncate                         "truncate all data or data related to errors"
	IndexHint                              "index hint"
	IndexHintList                          "index hint list"
	IndexHintListOpt                       "index hint list opt"
	IndexHintScope                         "index hint scope"
	IndexHintType                          "index hint type"
	IndexInvisible                         "index visible/invisible"
	IndexKeyTypeOpt                        "index key type"
	IndexLockAndAlgorithmOpt               "index lock and algorithm"
	IndexNameAndTypeOpt                    "index name and index type"
	IndexNameList                          "index name list"
	IndexOption                            "Index Option"
	IndexOptionList                        "Index Option List or empty"
	IndexType                              "index type"
	IndexName                              "index name"
	IndexTypeName                          "index type name"
	IndexTypeOpt                           "optional index type"
	IndexPartSpecification                 "Index column name or expression"
	IndexPartSpecificationList             "List of index column name or expression"
	IndexPartSpecificationListOpt          "Optional list of index column name or expression"
	InsertValues                           "Rest part of INSERT/REPLACE INTO statement"
	JoinTable                              "join table"
	JoinType                               "join type"
	KillOrKillTiDB                         "Kill or Kill TiDB"
	LocationLabelList                      "location label name list"
	LikeTableWithOrWithoutParen            "LIKE table_name or ( LIKE table_name )"
	LimitClause                            "LIMIT clause"
	LimitOption                            "Limit option could be integer or parameter marker."
	Lines                                  "Lines clause"
	LoadDataSetSpecOpt                     "Optional load data specification"
	LoadDataSetList                        "Load data specifications"
	LoadDataSetItem                        "Single load data specification"
	LocalOpt                               "Local opt"
	LockClause                             "Alter table lock clause"
	LogTypeOpt                             "Optional log type used in FLUSH statements"
	NumLiteral                             "Num/Int/Float/Decimal Literal"
	NoWriteToBinLogAliasOpt                "NO_WRITE_TO_BINLOG alias LOCAL or empty"
	ObjectType                             "Grant statement object type"
	OnDuplicateKeyUpdate                   "ON DUPLICATE KEY UPDATE value list"
	OnCommitOpt                            "ON COMMIT DELETE |PRESERVE ROWS"
	DuplicateOpt                           "[IGNORE|REPLACE] in CREATE TABLE ... SELECT statement or LOAD DATA statement"
	OfTablesOpt                            "OF table_name [, ...]"
	OptErrors                              "ERRORS or empty"
	OptFull                                "Full or empty"
	OptTemporary                           "TEMPORARY or empty"
	OptOrder                               "Optional ordering keyword: ASC/DESC. Default to ASC"
	Order                                  "Ordering keyword: ASC or DESC"
	OptionLevel                            "3 levels used by lightning config"
	OrderBy                                "ORDER BY clause"
	OrReplace                              "or replace"
	ByItem                                 "BY item"
	OrderByOptional                        "Optional ORDER BY clause optional"
	ByList                                 "BY list"
	AlterOrderItem                         "Alter Order item"
	AlterOrderList                         "Alter Order list"
	QuickOptional                          "QUICK or empty"
	PartitionDefinition                    "Partition definition"
	PartitionDefinitionList                "Partition definition list"
	PartitionDefinitionListOpt             "Partition definition list option"
	PartitionKeyAlgorithmOpt               "ALGORITHM = n option for KEY partition"
	PartitionMethod                        "Partition method"
	PartitionOpt                           "Partition option"
	PartitionNameList                      "Partition name list"
	PartitionNameListOpt                   "table partition names list optional"
	PartitionNumOpt                        "PARTITION NUM option"
	PartDefValuesOpt                       "VALUES {LESS THAN {(expr | value_list) | MAXVALUE} | IN {value_list}"
	PartDefOptionList                      "PartDefOption list"
	PartDefOption                          "COMMENT [=] xxx | TABLESPACE [=] tablespace_name | ENGINE [=] xxx"
	PasswordExpire                         "Single password option for create user statement"
	PasswordOrLockOption                   "Single password or lock option for create user statement"
	PasswordOrLockOptionList               "Password or lock options for create user statement"
	PasswordOrLockOptions                  "Optional password or lock options for create user statement"
	ColumnPosition                         "Column position [First|After ColumnName]"
	PrepareSQL                             "Prepare statement sql string"
	Priority                               "Statement priority"
	PriorityOpt                            "Statement priority option"
	PrivElem                               "Privilege element"
	PrivLevel                              "Privilege scope"
	PrivType                               "Privilege type"
	ReferDef                               "Reference definition"
	OnDelete                               "ON DELETE clause"
	OnUpdate                               "ON UPDATE clause"
	OnDeleteUpdateOpt                      "optional ON DELETE and UPDATE clause"
	OptGConcatSeparator                    "optional GROUP_CONCAT SEPARATOR"
	ReferOpt                               "reference option"
	ReorganizePartitionRuleOpt             "optional reorganize partition partition list and definitions"
	RequireList                            "require list"
	RequireListElement                     "require list element"
	Rolename                               "Rolename"
	RolenameComposed                       "Rolename that composed with more than 1 symbol"
	RolenameList                           "RolenameList"
	RolenameWithoutIdent                   "Rolename except identifier"
	RoleOrPrivElem                         "Element that may be a Rolename or PrivElem"
	RoleOrPrivElemList                     "RoleOrPrivElem list"
	RoleSpec                               "Rolename and auth option"
	RoleSpecList                           "Rolename and auth option list"
	RowFormat                              "Row format option"
	RowValue                               "Row value"
	RowStmt                                "Row constructor"
	SelectLockOpt                          "SELECT lock options"
	SelectStmtSQLCache                     "SELECT statement optional SQL_CAHCE/SQL_NO_CACHE"
	SelectStmtFieldList                    "SELECT statement field list"
	SelectStmtLimit                        "SELECT statement LIMIT clause"
	SelectStmtLimitOpt                     "SELECT statement optional LIMIT clause"
	SelectStmtOpt                          "Select statement option"
	SelectStmtOpts                         "Select statement options"
	SelectStmtOptsList                     "Select statement options list"
	SelectStmtBasic                        "SELECT statement from constant value"
	SelectStmtFromDualTable                "SELECT statement from dual table"
	SelectStmtFromTable                    "SELECT statement from table"
	SelectStmtGroup                        "SELECT statement optional GROUP BY clause"
	SelectStmtIntoOption                   "SELECT statement into clause"
	SequenceOption                         "Create sequence option"
	SequenceOptionList                     "Create sequence option list"
	SetRoleOpt                             "Set role options"
	SetDefaultRoleOpt                      "Set default role options"
	SetOpr                                 "Set operator contain UNION, EXCEPT and INTERSECT"
	SetOprClause                           "Union/Except/Intersect select clause"
	SetOprClauseList                       "Union/Except/Intersect select clause list"
	ShowTargetFilterable                   "Show target that can be filtered by WHERE or LIKE"
	ShowTableAliasOpt                      "Show table alias option"
	ShowLikeOrWhereOpt                     "Show like or where clause option"
	ShowPlacementTarget                    "Show placement target"
	ShowProfileArgsOpt                     "Show profile args option"
	ShowProfileTypesOpt                    "Show profile types option"
	ShowProfileType                        "Show profile type"
	ShowProfileTypes                       "Show profile types"
	SplitOption                            "Split Option"
	SplitSyntaxOption                      "Split syntax Option"
	StatementList                          "statement list"
	StatsPersistentVal                     "stats_persistent value"
	StatsType                              "stats type value"
	BindingStatusType                      "binding status type value"
	StringList                             "string list"
	SubPartDefinition                      "SubPartition definition"
	SubPartDefinitionList                  "SubPartition definition list"
	SubPartDefinitionListOpt               "SubPartition definition list optional"
	SubPartitionMethod                     "SubPartition method"
	SubPartitionOpt                        "SubPartition option"
	SubPartitionNumOpt                     "SubPartition NUM option"
	TableAliasRefList                      "table alias reference list"
	TableAsName                            "table alias name"
	TableAsNameOpt                         "table alias name optional"
	TableElement                           "table definition element"
	TableElementList                       "table definition element list"
	TableElementListOpt                    "table definition element list optional"
	TableFactor                            "table factor"
	TableLock                              "Table name and lock type"
	TableLockList                          "Table lock list"
	TableName                              "Table name"
	TableNameOptWild                       "Table name with optional wildcard"
	TableNameList                          "Table name list"
	TableNameListOpt                       "Table name list opt"
	TableNameListOpt2                      "Optional table name list with a preceding TABLE"
	TableOption                            "create table option"
	TableOptionList                        "create table option list"
	TableRef                               "table reference"
	TableRefs                              "table references"
	TableSampleOpt                         "table sample clause optional"
	TableSampleMethodOpt                   "table sample method optional"
	TableSampleUnitOpt                     "table sample unit optional"
	TableToTable                           "rename table to table"
	TableToTableList                       "rename table to table by list"
	TextString                             "text string item"
	TextStringList                         "text string list"
	TimeUnit                               "Time unit for 'DATE_ADD', 'DATE_SUB', 'ADDDATE', 'SUBDATE', 'EXTRACT'"
	TimestampUnit                          "Time unit for 'TIMESTAMPADD' and 'TIMESTAMPDIFF'"
	LockType                               "Table locks type"
	TransactionChar                        "Transaction characteristic"
	TransactionChars                       "Transaction characteristic list"
	TrimDirection                          "Trim string direction"
	SetOprOpt                              "Union/Except/Intersect Option(empty/ALL/DISTINCT)"
	Username                               "Username"
	UsernameList                           "UsernameList"
	UserSpec                               "Username and auth option"
	UserSpecList                           "Username and auth option list"
	UserVariableList                       "User defined variable name list"
	UserToUser                             "rename user to user"
	UserToUserList                         "rename user to user by list"
	UsingRoles                             "UsingRoles is role option for SHOW GRANT"
	Values                                 "values"
	ValuesList                             "values list"
	ValuesOpt                              "values optional"
	ValuesStmtList                         "VALUES statement field list"
	VariableAssignment                     "set variable value"
	VariableAssignmentList                 "set variable value list"
	ViewAlgorithm                          "view algorithm"
	ViewCheckOption                        "view check option"
	ViewDefiner                            "view definer"
	ViewName                               "view name"
	ViewFieldList                          "create view statement field list"
	ViewSQLSecurity                        "view sql security"
	WhereClause                            "WHERE clause"
	WhereClauseOptional                    "Optional WHERE clause"
	WhenClause                             "When clause"
	WhenClauseList                         "When clause list"
	WithClustered                          "With Clustered Index Enabled"
	WithClause                             "With Clause"
	WithList                               "With list"
	WithReadLockOpt                        "With Read Lock opt"
	WithGrantOptionOpt                     "With Grant Option opt"
	WithValidation                         "with validation"
	WithValidationOpt                      "optional with validation"
	Writeable                              "Table writeable status"
	ElseOpt                                "Optional else clause"
	Type                                   "Types"
	OptExistingWindowName                  "Optional existing WINDOW name"
	OptFromFirstLast                       "Optional FROM FIRST/LAST"
	OptLLDefault                           "Optional LEAD/LAG default"
	OptLeadLagInfo                         "Optional LEAD/LAG info"
	OptNullTreatment                       "Optional NULL treatment"
	OptPartitionClause                     "Optional PARTITION clause"
	OptWild                                "Optional Wildcard"
	OptWindowOrderByClause                 "Optional ORDER BY clause in WINDOW"
	OptWindowFrameClause                   "Optional FRAME clause in WINDOW"
	OptWindowingClause                     "Optional OVER clause"
	WindowingClause                        "OVER clause"
	WindowClauseOptional                   "Optional WINDOW clause"
	WindowDefinitionList                   "WINDOW definition list"
	WindowDefinition                       "WINDOW definition"
	WindowFrameUnits                       "WINDOW frame units"
	WindowFrameBetween                     "WINDOW frame between"
	WindowFrameBound                       "WINDOW frame bound"
	WindowFrameExtent                      "WINDOW frame extent"
	WindowFrameStart                       "WINDOW frame start"
	WindowName                             "WINDOW name"
	WindowNameOrSpec                       "WINDOW name or spec"
	WindowSpec                             "WINDOW spec"
	WindowSpecDetails                      "WINDOW spec details"
	BetweenOrNotOp                         "Between predicate"
	IsOrNotOp                              "Is predicate"
	InOrNotOp                              "In predicate"
	LikeOrNotOp                            "Like predicate"
	RegexpOrNotOp                          "Regexp predicate"
	NumericType                            "Numeric types"
	IntegerType                            "Integer Types types"
	BooleanType                            "Boolean Types types"
	FixedPointType                         "Exact value types"
	FloatingPointType                      "Approximate value types"
	BitValueType                           "bit value types"
	StringType                             "String types"
	BlobType                               "Blob types"
	TextType                               "Text types"
	DateAndTimeType                        "Date and Time types"
	OptFieldLen                            "Field length or empty"
	FieldLen                               "Field length"
	FieldOpts                              "Field type definition option list"
	FieldOpt                               "Field type definition option"
	FloatOpt                               "Floating-point type option"
	Precision                              "Floating-point precision option"
	OptBinary                              "Optional BINARY"
	OptBinMod                              "Optional BINARY mode"
	OptCharsetWithOptBinary                "Optional BINARY or ASCII or UNICODE or BYTE"
	IgnoreLines                            "Ignore num(int) lines"
	Int64Num                               "a number that can be safely converted to int64"
	NUM                                    "A number"
	NumList                                "Some numbers"
	LengthNum                              "Field length num(uint64)"
	SignedNum                              "Signed num(int64)"
	TableOptimizerHints                    "Table level optimizer hints"
	TableOptimizerHintsOpt                 "Table level optimizer hints option"
	EnforcedOrNot                          "{ENFORCED|NOT ENFORCED}"
	EnforcedOrNotOpt                       "Optional {ENFORCED|NOT ENFORCED}"
	EnforcedOrNotOrNotNullOpt              "{[ENFORCED|NOT ENFORCED|NOT NULL]}"
	Match                                  "[MATCH FULL | MATCH PARTIAL | MATCH SIMPLE]"
	MatchOpt                               "optional MATCH clause"
	MaxMinutesOpt                          "MAX_MINUTES num(int)"
	MaxIndexNumOpt                         "MAX_IDXNUM clause"
	PerTable                               "Max index number PER_TABLE"
	PerDB                                  "Max index number PER_DB"
	BRIETables                             "List of tables or databases for BRIE statements"
	DBNameList                             "List of database names"
	BRIEOption                             "Single BRIE option"
	BRIEOptions                            "List of BRIE options"
	BRIEIntegerOptionName                  "Name of a BRIE option which takes an integer as input"
	BRIEBooleanOptionName                  "Name of a BRIE option which takes a boolean as input"
	BRIEStringOptionName                   "Name of a BRIE option which takes a string as input"
	BRIEKeywordOptionName                  "Name of a BRIE option which takes a case-insensitive string as input"
	PlacementPolicyOption                  "Anonymous or placement policy option"
	DirectPlacementOption                  "Subset of anonymous or direct placement option"
	PlacementOptionList                    "Anomymous or direct placement option list"
	AttributesOpt                          "Attributes options"
	AllColumnsOrPredicateColumnsOpt        "all columns or predicate columns option"
	StatsOptionsOpt                        "Stats options"
	DryRunOptions                          "Dry run options"
	OptionalShardColumn                    "Optional shard column"

%type	<ident>
	AsOpt             "AS or EmptyString"
	KeyOrIndex        "{KEY|INDEX}"
	ColumnKeywordOpt  "Column keyword or empty"
	PrimaryOpt        "Optional primary keyword"
	NowSym            "CURRENT_TIMESTAMP/LOCALTIME/LOCALTIMESTAMP"
	NowSymFunc        "CURRENT_TIMESTAMP/LOCALTIME/LOCALTIMESTAMP/NOW"
	DefaultKwdOpt     "optional DEFAULT keyword"
	DatabaseSym       "DATABASE or SCHEMA"
	ExplainSym        "EXPLAIN or DESCRIBE or DESC"
	RegexpSym         "REGEXP or RLIKE"
	IntoOpt           "INTO or EmptyString"
	ValueSym          "Value or Values"
	NotSym            "Not token"
	Char              "{CHAR|CHARACTER}"
	NChar             "{NCHAR|NATIONAL CHARACTER|NATIONAL CHAR}"
	Varchar           "{VARCHAR|VARCHARACTER|CHARACTER VARYING|CHAR VARYING}"
	NVarchar          "{NATIONAL VARCHAR|NATIONAL VARCHARACTER|NVARCHAR|NCHAR VARCHAR|NATIONAL CHARACTER VARYING|NATIONAL CHAR VARYING|NCHAR VARYING}"
	Year              "{YEAR|SQL_TSI_YEAR}"
	DeallocateSym     "Deallocate or drop"
	OuterOpt          "optional OUTER clause"
	CrossOpt          "Cross join option"
	TablesTerminalSym "{TABLE|TABLES}"
	IsolationLevel    "Isolation level"
	ShowIndexKwd      "Show index/indexs/key keyword"
	DistinctKwd       "DISTINCT/DISTINCTROW keyword"
	FromOrIn          "From or In"
	OptTable          "Optional table keyword"
	OptInteger        "Optional Integer keyword"
	CharsetKw         "charset or charater set"
	CommaOpt          "optional comma"
	logAnd            "logical and operator"
	logOr             "logical or operator"
	LinearOpt         "linear or empty"
	FieldsOrColumns   "Fields or columns"
	StorageMedia      "{DISK|MEMORY|DEFAULT}"
	EncryptionOpt     "Encryption option 'Y' or 'N'"
	FirstOrNext       "FIRST or NEXT"
	RowOrRows         "ROW or ROWS"

%type	<ident>
	Identifier                      "identifier or unreserved keyword"
	NotKeywordToken                 "Tokens not mysql keyword but treated specially"
	UnReservedKeyword               "MySQL unreserved keywords"
	TiDBKeyword                     "TiDB added keywords"
	FunctionNameConflict            "Built-in function call names which are conflict with keywords"
	FunctionNameOptionalBraces      "Function with optional braces, all of them are reserved keywords."
	FunctionNameDatetimePrecision   "Function with optional datetime precision, all of them are reserved keywords."
	FunctionNameDateArith           "Date arith function call names (date_add or date_sub)"
	FunctionNameDateArithMultiForms "Date arith function call names (adddate or subdate)"
	VariableName                    "A simple Identifier like xx or the xx.xx form"
	ConfigItemName                  "A config item like aa or aa.bb or aa.bb-cc.dd"
	AuthString                      "Password string value"
	AuthPlugin                      "Authentication plugin name"
	CharsetName                     "Character set name"
	CollationName                   "Collation name"
	ColumnFormat                    "Column format"
	DBName                          "Database Name"
	PolicyName                      "Placement Policy Name"
	ExplainFormatType               "explain format type"
	FieldAsName                     "Field alias name"
	FieldAsNameOpt                  "Field alias name opt"
	FieldTerminator                 "Field terminator"
	FlashbackToNewName              "Flashback to new name"
	HashString                      "Hashed string"
	LikeEscapeOpt                   "like escape option"
	LinesTerminated                 "Lines terminated by"
	OptCharset                      "Optional Character setting"
	OptCollate                      "Optional Collate setting"
	PasswordOpt                     "Password option"
	RoleNameString                  "role name string"
	ShowDatabaseNameOpt             "Show tables/columns statement database name option"
	Starting                        "Starting by"
	StringName                      "string literal or identifier"
	StringNameOrBRIEOptionKeyword   "string literal or identifier or keyword used for BRIE options"
	Symbol                          "Constraint Symbol"

%precedence empty
%precedence as
%precedence placement
%precedence lowerThanSelectOpt
%precedence sqlBufferResult
%precedence sqlBigResult
%precedence sqlSmallResult
%precedence sqlCache sqlNoCache
%precedence next
%precedence lowerThanValueKeyword
%precedence value
%precedence lowerThanStringLitToken
%precedence stringLit
%precedence lowerThanSetKeyword
%precedence set
%precedence selectKwd
%precedence lowerThanSelectStmt
%precedence lowerThanInsertValues
%precedence insertValues
%precedence lowerThanCreateTableSelect
%precedence createTableSelect
%precedence lowerThanCharsetKwd
%precedence charsetKwd
%precedence lowerThanKey
%precedence key
%precedence lowerThanLocal
%precedence local
%precedence lowerThanRemove
%precedence remove
%precedence lowerThenOrder
%precedence order
%precedence lowerThanFunction
%precedence function


%left tableRefPriority
%precedence lowerThanParenthese
%right '('
%left ')'
%precedence higherThanParenthese
%left join straightJoin inner cross left right full natural
%precedence lowerThanOn
%precedence on using
%right assignmentEq
%left pipes or pipesAsOr
%left xor
%left andand and
%left between
%precedence lowerThanEq
%left eq ge le neq neqSynonym '>' '<' is like in
%left '|'
%left '&'
%left rsh lsh
%left '-' '+'
%left '*' '/' '%' div mod
%left '^'
%left '~' neg
%precedence lowerThanNot
%right not not2
%right collate
%left interval
%right encryption
%left labels
%precedence quick
%precedence escape
%precedence lowerThanComma
%precedence ','
%precedence higherThanComma

%start	Start


%%


Start:
	StatementList


{
sql_ir.LogGrammarCoverage("Start,StatementList")

}
AlterTableStmt:
	"ALTER" IgnoreOptional "TABLE" TableName AlterTableSpecListOpt AlterTablePartitionOpt
	{
sql_ir.LogGrammarCoverage("AlterTableStmt,IgnoreOptional")
sql_ir.LogGrammarCoverage("AlterTableStmt,TableName")
sql_ir.LogGrammarCoverage("AlterTableStmt,AlterTableSpecListOpt")
sql_ir.LogGrammarCoverage("AlterTableStmt,AlterTablePartitionOpt")


		specs := $5.([]*ast.AlterTableSpec)
		if $6 != nil {
			specs = append(specs, $6.(*ast.AlterTableSpec))
		}
		$$ = &ast.AlterTableStmt{
			Table: $4.(*ast.TableName),
			Specs: specs,
		}
	}
|	"ALTER" IgnoreOptional "TABLE" TableName "ANALYZE" "PARTITION" PartitionNameList AnalyzeOptionListOpt
	{
sql_ir.LogGrammarCoverage("AlterTableStmt,IgnoreOptional")
sql_ir.LogGrammarCoverage("AlterTableStmt,TableName")
sql_ir.LogGrammarCoverage("AlterTableStmt,PartitionNameList")
sql_ir.LogGrammarCoverage("AlterTableStmt,AnalyzeOptionListOpt")


		$$ = &ast.AnalyzeTableStmt{TableNames: []*ast.TableName{$4.(*ast.TableName)}, PartitionNames: $7.([]model.CIStr), AnalyzeOpts: $8.([]ast.AnalyzeOpt)}
	}
|	"ALTER" IgnoreOptional "TABLE" TableName "ANALYZE" "PARTITION" PartitionNameList "INDEX" IndexNameList AnalyzeOptionListOpt
	{
sql_ir.LogGrammarCoverage("AlterTableStmt,IgnoreOptional")
sql_ir.LogGrammarCoverage("AlterTableStmt,TableName")
sql_ir.LogGrammarCoverage("AlterTableStmt,PartitionNameList")
sql_ir.LogGrammarCoverage("AlterTableStmt,IndexNameList")
sql_ir.LogGrammarCoverage("AlterTableStmt,AnalyzeOptionListOpt")


		$$ = &ast.AnalyzeTableStmt{
			TableNames:     []*ast.TableName{$4.(*ast.TableName)},
			PartitionNames: $7.([]model.CIStr),
			IndexNames:     $9.([]model.CIStr),
			IndexFlag:      true,
			AnalyzeOpts:    $10.([]ast.AnalyzeOpt),
		}
	}
|	"ALTER" IgnoreOptional "TABLE" TableName "COMPACT" "TIFLASH" "REPLICA"
	{
sql_ir.LogGrammarCoverage("AlterTableStmt,IgnoreOptional")
sql_ir.LogGrammarCoverage("AlterTableStmt,TableName")


		$$ = &ast.CompactTableStmt{
			Table:       $4.(*ast.TableName),
			ReplicaKind: ast.CompactReplicaKindTiFlash,
		}
	}

PlacementOptionList:
	DirectPlacementOption
	{
sql_ir.LogGrammarCoverage("PlacementOptionList,DirectPlacementOption")


		$$ = []*ast.PlacementOption{$1.(*ast.PlacementOption)}
	}
|	PlacementOptionList DirectPlacementOption
	{
sql_ir.LogGrammarCoverage("PlacementOptionList,PlacementOptionList")
sql_ir.LogGrammarCoverage("PlacementOptionList,DirectPlacementOption")


		$$ = append($1.([]*ast.PlacementOption), $2.(*ast.PlacementOption))
	}
|	PlacementOptionList ',' DirectPlacementOption
	{
sql_ir.LogGrammarCoverage("PlacementOptionList,PlacementOptionList")
sql_ir.LogGrammarCoverage("PlacementOptionList,DirectPlacementOption")


		$$ = append($1.([]*ast.PlacementOption), $3.(*ast.PlacementOption))
	}

DirectPlacementOption:
	"PRIMARY_REGION" EqOpt stringLit
	{
sql_ir.LogGrammarCoverage("DirectPlacementOption,EqOpt")
sql_ir.LogGrammarCoverage("DirectPlacementOption,stringLit")


		$$ = &ast.PlacementOption{Tp: ast.PlacementOptionPrimaryRegion, StrValue: $3}
	}
|	"REGIONS" EqOpt stringLit
	{
sql_ir.LogGrammarCoverage("DirectPlacementOption,EqOpt")
sql_ir.LogGrammarCoverage("DirectPlacementOption,stringLit")


		$$ = &ast.PlacementOption{Tp: ast.PlacementOptionRegions, StrValue: $3}
	}
|	"FOLLOWERS" EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("DirectPlacementOption,EqOpt")
sql_ir.LogGrammarCoverage("DirectPlacementOption,LengthNum")


		cnt := $3.(uint64)
		if cnt == 0 {
			yylex.AppendError(yylex.Errorf("FOLLOWERS must be positive"))
			return 1
		}
		$$ = &ast.PlacementOption{Tp: ast.PlacementOptionFollowerCount, UintValue: cnt}
	}
|	"VOTERS" EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("DirectPlacementOption,EqOpt")
sql_ir.LogGrammarCoverage("DirectPlacementOption,LengthNum")


		$$ = &ast.PlacementOption{Tp: ast.PlacementOptionVoterCount, UintValue: $3.(uint64)}
	}
|	"LEARNERS" EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("DirectPlacementOption,EqOpt")
sql_ir.LogGrammarCoverage("DirectPlacementOption,LengthNum")


		$$ = &ast.PlacementOption{Tp: ast.PlacementOptionLearnerCount, UintValue: $3.(uint64)}
	}
|	"SCHEDULE" EqOpt stringLit
	{
sql_ir.LogGrammarCoverage("DirectPlacementOption,EqOpt")
sql_ir.LogGrammarCoverage("DirectPlacementOption,stringLit")


		$$ = &ast.PlacementOption{Tp: ast.PlacementOptionSchedule, StrValue: $3}
	}
|	"CONSTRAINTS" EqOpt stringLit
	{
sql_ir.LogGrammarCoverage("DirectPlacementOption,EqOpt")
sql_ir.LogGrammarCoverage("DirectPlacementOption,stringLit")


		$$ = &ast.PlacementOption{Tp: ast.PlacementOptionConstraints, StrValue: $3}
	}
|	"LEADER_CONSTRAINTS" EqOpt stringLit
	{
sql_ir.LogGrammarCoverage("DirectPlacementOption,EqOpt")
sql_ir.LogGrammarCoverage("DirectPlacementOption,stringLit")


		$$ = &ast.PlacementOption{Tp: ast.PlacementOptionLeaderConstraints, StrValue: $3}
	}
|	"FOLLOWER_CONSTRAINTS" EqOpt stringLit
	{
sql_ir.LogGrammarCoverage("DirectPlacementOption,EqOpt")
sql_ir.LogGrammarCoverage("DirectPlacementOption,stringLit")


		$$ = &ast.PlacementOption{Tp: ast.PlacementOptionFollowerConstraints, StrValue: $3}
	}
|	"VOTER_CONSTRAINTS" EqOpt stringLit
	{
sql_ir.LogGrammarCoverage("DirectPlacementOption,EqOpt")
sql_ir.LogGrammarCoverage("DirectPlacementOption,stringLit")


		$$ = &ast.PlacementOption{Tp: ast.PlacementOptionVoterConstraints, StrValue: $3}
	}
|	"LEARNER_CONSTRAINTS" EqOpt stringLit
	{
sql_ir.LogGrammarCoverage("DirectPlacementOption,EqOpt")
sql_ir.LogGrammarCoverage("DirectPlacementOption,stringLit")


		$$ = &ast.PlacementOption{Tp: ast.PlacementOptionLearnerConstraints, StrValue: $3}
	}

PlacementPolicyOption:
	"PLACEMENT" "POLICY" EqOpt stringLit
	{
sql_ir.LogGrammarCoverage("PlacementPolicyOption,EqOpt")
sql_ir.LogGrammarCoverage("PlacementPolicyOption,stringLit")


		$$ = &ast.PlacementOption{Tp: ast.PlacementOptionPolicy, StrValue: $4}
	}
|	"PLACEMENT" "POLICY" EqOpt PolicyName
	{
sql_ir.LogGrammarCoverage("PlacementPolicyOption,EqOpt")
sql_ir.LogGrammarCoverage("PlacementPolicyOption,PolicyName")


		$$ = &ast.PlacementOption{Tp: ast.PlacementOptionPolicy, StrValue: $4}
	}
|	"PLACEMENT" "POLICY" EqOpt "DEFAULT"
	{
sql_ir.LogGrammarCoverage("PlacementPolicyOption,EqOpt")


		$$ = &ast.PlacementOption{Tp: ast.PlacementOptionPolicy, StrValue: $4}
	}
|	"PLACEMENT" "POLICY" "SET" "DEFAULT"
	{


		$$ = &ast.PlacementOption{Tp: ast.PlacementOptionPolicy, StrValue: $4}
	}

AttributesOpt:
	"ATTRIBUTES" EqOpt "DEFAULT"
	{
sql_ir.LogGrammarCoverage("AttributesOpt,EqOpt")


		$$ = &ast.AttributesSpec{Default: true}
	}
|	"ATTRIBUTES" EqOpt stringLit
	{
sql_ir.LogGrammarCoverage("AttributesOpt,EqOpt")
sql_ir.LogGrammarCoverage("AttributesOpt,stringLit")


		$$ = &ast.AttributesSpec{Default: false, Attributes: $3}
	}

StatsOptionsOpt:
	"STATS_OPTIONS" EqOpt "DEFAULT"
	{
sql_ir.LogGrammarCoverage("StatsOptionsOpt,EqOpt")


		$$ = &ast.StatsOptionsSpec{Default: true}
	}
|	"STATS_OPTIONS" EqOpt stringLit
	{
sql_ir.LogGrammarCoverage("StatsOptionsOpt,EqOpt")
sql_ir.LogGrammarCoverage("StatsOptionsOpt,stringLit")


		$$ = &ast.StatsOptionsSpec{Default: false, StatsOptions: $3}
	}

AlterTablePartitionOpt:
	PartitionOpt
	{
sql_ir.LogGrammarCoverage("AlterTablePartitionOpt,PartitionOpt")


		if $1 != nil {
			$$ = &ast.AlterTableSpec{
				Tp:        ast.AlterTablePartition,
				Partition: $1.(*ast.PartitionOptions),
			}
		} else {
			$$ = nil
		}
	}
|	"REMOVE" "PARTITIONING"
	{


		$$ = &ast.AlterTableSpec{
			Tp: ast.AlterTableRemovePartitioning,
		}
	}
|	"REORGANIZE" "PARTITION" NoWriteToBinLogAliasOpt ReorganizePartitionRuleOpt
	{
sql_ir.LogGrammarCoverage("AlterTablePartitionOpt,NoWriteToBinLogAliasOpt")
sql_ir.LogGrammarCoverage("AlterTablePartitionOpt,ReorganizePartitionRuleOpt")


		ret := $4.(*ast.AlterTableSpec)
		ret.NoWriteToBinlog = $3.(bool)
		$$ = ret
	}
|	"PARTITION" Identifier AttributesOpt
	{
sql_ir.LogGrammarCoverage("AlterTablePartitionOpt,Identifier")
sql_ir.LogGrammarCoverage("AlterTablePartitionOpt,AttributesOpt")


		$$ = &ast.AlterTableSpec{
			Tp:             ast.AlterTablePartitionAttributes,
			PartitionNames: []model.CIStr{model.NewCIStr($2)},
			AttributesSpec: $3.(*ast.AttributesSpec),
		}
	}
|	"PARTITION" Identifier PartDefOptionList
	{
sql_ir.LogGrammarCoverage("AlterTablePartitionOpt,Identifier")
sql_ir.LogGrammarCoverage("AlterTablePartitionOpt,PartDefOptionList")


		$$ = &ast.AlterTableSpec{
			Tp:             ast.AlterTablePartitionOptions,
			PartitionNames: []model.CIStr{model.NewCIStr($2)},
			Options:        $3.([]*ast.TableOption),
		}
	}

LocationLabelList:
	{


		$$ = []string{}
	}
|	"LOCATION" "LABELS" StringList
	{
sql_ir.LogGrammarCoverage("LocationLabelList,StringList")


		$$ = $3
	}

AlterTableSpec:
	TableOptionList %prec higherThanComma
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,TableOptionList")


		$$ = &ast.AlterTableSpec{
			Tp:      ast.AlterTableOption,
			Options: $1.([]*ast.TableOption),
		}
	}
|	"SET" "TIFLASH" "REPLICA" LengthNum LocationLabelList
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,LengthNum")
sql_ir.LogGrammarCoverage("AlterTableSpec,LocationLabelList")


		tiflashReplicaSpec := &ast.TiFlashReplicaSpec{
			Count:  $4.(uint64),
			Labels: $5.([]string),
		}
		$$ = &ast.AlterTableSpec{
			Tp:             ast.AlterTableSetTiFlashReplica,
			TiFlashReplica: tiflashReplicaSpec,
		}
	}
|	"CONVERT" "TO" CharsetKw CharsetName OptCollate
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,CharsetKw")
sql_ir.LogGrammarCoverage("AlterTableSpec,CharsetName")
sql_ir.LogGrammarCoverage("AlterTableSpec,OptCollate")


		op := &ast.AlterTableSpec{
			Tp: ast.AlterTableOption,
			Options: []*ast.TableOption{{Tp: ast.TableOptionCharset, StrValue: $4,
				UintValue: ast.TableOptionCharsetWithConvertTo}},
		}
		if $5 != "" {
			op.Options = append(op.Options, &ast.TableOption{Tp: ast.TableOptionCollate, StrValue: $5})
		}
		$$ = op
	}
|	"CONVERT" "TO" CharsetKw "DEFAULT" OptCollate
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,CharsetKw")
sql_ir.LogGrammarCoverage("AlterTableSpec,OptCollate")


		op := &ast.AlterTableSpec{
			Tp: ast.AlterTableOption,
			Options: []*ast.TableOption{{Tp: ast.TableOptionCharset, Default: true,
				UintValue: ast.TableOptionCharsetWithConvertTo}},
		}
		if $5 != "" {
			op.Options = append(op.Options, &ast.TableOption{Tp: ast.TableOptionCollate, StrValue: $5})
		}
		$$ = op
	}
|	"ADD" ColumnKeywordOpt IfNotExists ColumnDef ColumnPosition
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,ColumnKeywordOpt")
sql_ir.LogGrammarCoverage("AlterTableSpec,IfNotExists")
sql_ir.LogGrammarCoverage("AlterTableSpec,ColumnDef")
sql_ir.LogGrammarCoverage("AlterTableSpec,ColumnPosition")


		$$ = &ast.AlterTableSpec{
			IfNotExists: $3.(bool),
			Tp:          ast.AlterTableAddColumns,
			NewColumns:  []*ast.ColumnDef{$4.(*ast.ColumnDef)},
			Position:    $5.(*ast.ColumnPosition),
		}
	}
|	"ADD" ColumnKeywordOpt IfNotExists '(' TableElementList ')'
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,ColumnKeywordOpt")
sql_ir.LogGrammarCoverage("AlterTableSpec,IfNotExists")
sql_ir.LogGrammarCoverage("AlterTableSpec,TableElementList")


		tes := $5.([]interface{})
		var columnDefs []*ast.ColumnDef
		var constraints []*ast.Constraint
		for _, te := range tes {
			switch te := te.(type) {
			case *ast.ColumnDef:
				columnDefs = append(columnDefs, te)
			case *ast.Constraint:
				constraints = append(constraints, te)
			}
		}
		$$ = &ast.AlterTableSpec{
			IfNotExists:    $3.(bool),
			Tp:             ast.AlterTableAddColumns,
			NewColumns:     columnDefs,
			NewConstraints: constraints,
		}
	}
|	"ADD" Constraint
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,Constraint")


		constraint := $2.(*ast.Constraint)
		$$ = &ast.AlterTableSpec{
			Tp:         ast.AlterTableAddConstraint,
			Constraint: constraint,
		}
	}
|	"ADD" "PARTITION" IfNotExists NoWriteToBinLogAliasOpt PartitionDefinitionListOpt
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,IfNotExists")
sql_ir.LogGrammarCoverage("AlterTableSpec,NoWriteToBinLogAliasOpt")
sql_ir.LogGrammarCoverage("AlterTableSpec,PartitionDefinitionListOpt")


		var defs []*ast.PartitionDefinition
		if $5 != nil {
			defs = $5.([]*ast.PartitionDefinition)
		}
		noWriteToBinlog := $4.(bool)
		if noWriteToBinlog {
			yylex.AppendError(yylex.Errorf("The NO_WRITE_TO_BINLOG option is parsed but ignored for now."))
			parser.lastErrorAsWarn()
		}
		$$ = &ast.AlterTableSpec{
			IfNotExists:     $3.(bool),
			NoWriteToBinlog: noWriteToBinlog,
			Tp:              ast.AlterTableAddPartitions,
			PartDefinitions: defs,
		}
	}
|	"ADD" "PARTITION" IfNotExists NoWriteToBinLogAliasOpt "PARTITIONS" NUM
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,IfNotExists")
sql_ir.LogGrammarCoverage("AlterTableSpec,NoWriteToBinLogAliasOpt")
sql_ir.LogGrammarCoverage("AlterTableSpec,NUM")


		noWriteToBinlog := $4.(bool)
		if noWriteToBinlog {
			yylex.AppendError(yylex.Errorf("The NO_WRITE_TO_BINLOG option is parsed but ignored for now."))
			parser.lastErrorAsWarn()
		}
		$$ = &ast.AlterTableSpec{
			IfNotExists:     $3.(bool),
			NoWriteToBinlog: noWriteToBinlog,
			Tp:              ast.AlterTableAddPartitions,
			Num:             getUint64FromNUM($6),
		}
	}
|	"ADD" "STATS_EXTENDED" IfNotExists Identifier StatsType '(' ColumnNameList ')'
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,IfNotExists")
sql_ir.LogGrammarCoverage("AlterTableSpec,Identifier")
sql_ir.LogGrammarCoverage("AlterTableSpec,StatsType")
sql_ir.LogGrammarCoverage("AlterTableSpec,ColumnNameList")


		statsSpec := &ast.StatisticsSpec{
			StatsName: $4,
			StatsType: $5.(uint8),
			Columns:   $7.([]*ast.ColumnName),
		}
		$$ = &ast.AlterTableSpec{
			Tp:          ast.AlterTableAddStatistics,
			IfNotExists: $3.(bool),
			Statistics:  statsSpec,
		}
	}
|	AttributesOpt
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,AttributesOpt")


		$$ = &ast.AlterTableSpec{
			Tp:             ast.AlterTableAttributes,
			AttributesSpec: $1.(*ast.AttributesSpec),
		}
	}
|	StatsOptionsOpt
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,StatsOptionsOpt")


		$$ = &ast.AlterTableSpec{
			Tp:               ast.AlterTableStatsOptions,
			StatsOptionsSpec: $1.(*ast.StatsOptionsSpec),
		}
	}
|	"CHECK" "PARTITION" AllOrPartitionNameList
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,AllOrPartitionNameList")


		yylex.AppendError(yylex.Errorf("The CHECK PARTITIONING clause is parsed but not implement yet."))
		parser.lastErrorAsWarn()
		ret := &ast.AlterTableSpec{
			Tp: ast.AlterTableCheckPartitions,
		}
		if $3 == nil {
			ret.OnAllPartitions = true
		} else {
			ret.PartitionNames = $3.([]model.CIStr)
		}
		$$ = ret
	}
|	"COALESCE" "PARTITION" NoWriteToBinLogAliasOpt NUM
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,NoWriteToBinLogAliasOpt")
sql_ir.LogGrammarCoverage("AlterTableSpec,NUM")


		noWriteToBinlog := $3.(bool)
		if noWriteToBinlog {
			yylex.AppendError(yylex.Errorf("The NO_WRITE_TO_BINLOG option is parsed but ignored for now."))
			parser.lastErrorAsWarn()
		}
		$$ = &ast.AlterTableSpec{
			Tp:              ast.AlterTableCoalescePartitions,
			NoWriteToBinlog: noWriteToBinlog,
			Num:             getUint64FromNUM($4),
		}
	}
|	"DROP" ColumnKeywordOpt IfExists ColumnName RestrictOrCascadeOpt
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,ColumnKeywordOpt")
sql_ir.LogGrammarCoverage("AlterTableSpec,IfExists")
sql_ir.LogGrammarCoverage("AlterTableSpec,ColumnName")
sql_ir.LogGrammarCoverage("AlterTableSpec,RestrictOrCascadeOpt")


		$$ = &ast.AlterTableSpec{
			IfExists:      $3.(bool),
			Tp:            ast.AlterTableDropColumn,
			OldColumnName: $4.(*ast.ColumnName),
		}
	}
|	"DROP" "PRIMARY" "KEY"
	{


		$$ = &ast.AlterTableSpec{Tp: ast.AlterTableDropPrimaryKey}
	}
|	"DROP" "PARTITION" IfExists PartitionNameList %prec lowerThanComma
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,IfExists")
sql_ir.LogGrammarCoverage("AlterTableSpec,PartitionNameList")


		$$ = &ast.AlterTableSpec{
			IfExists:       $3.(bool),
			Tp:             ast.AlterTableDropPartition,
			PartitionNames: $4.([]model.CIStr),
		}
	}
|	"DROP" "STATS_EXTENDED" IfExists Identifier
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,IfExists")
sql_ir.LogGrammarCoverage("AlterTableSpec,Identifier")


		statsSpec := &ast.StatisticsSpec{
			StatsName: $4,
		}
		$$ = &ast.AlterTableSpec{
			Tp:         ast.AlterTableDropStatistics,
			IfExists:   $3.(bool),
			Statistics: statsSpec,
		}
	}
|	"EXCHANGE" "PARTITION" Identifier "WITH" "TABLE" TableName WithValidationOpt
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,Identifier")
sql_ir.LogGrammarCoverage("AlterTableSpec,TableName")
sql_ir.LogGrammarCoverage("AlterTableSpec,WithValidationOpt")


		$$ = &ast.AlterTableSpec{
			Tp:             ast.AlterTableExchangePartition,
			PartitionNames: []model.CIStr{model.NewCIStr($3)},
			NewTable:       $6.(*ast.TableName),
			WithValidation: $7.(bool),
		}
	}
|	"TRUNCATE" "PARTITION" AllOrPartitionNameList
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,AllOrPartitionNameList")


		ret := &ast.AlterTableSpec{
			Tp: ast.AlterTableTruncatePartition,
		}
		if $3 == nil {
			ret.OnAllPartitions = true
		} else {
			ret.PartitionNames = $3.([]model.CIStr)
		}
		$$ = ret
	}
|	"OPTIMIZE" "PARTITION" NoWriteToBinLogAliasOpt AllOrPartitionNameList
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,NoWriteToBinLogAliasOpt")
sql_ir.LogGrammarCoverage("AlterTableSpec,AllOrPartitionNameList")


		ret := &ast.AlterTableSpec{
			NoWriteToBinlog: $3.(bool),
			Tp:              ast.AlterTableOptimizePartition,
		}
		if $4 == nil {
			ret.OnAllPartitions = true
		} else {
			ret.PartitionNames = $4.([]model.CIStr)
		}
		$$ = ret
	}
|	"REPAIR" "PARTITION" NoWriteToBinLogAliasOpt AllOrPartitionNameList
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,NoWriteToBinLogAliasOpt")
sql_ir.LogGrammarCoverage("AlterTableSpec,AllOrPartitionNameList")


		ret := &ast.AlterTableSpec{
			NoWriteToBinlog: $3.(bool),
			Tp:              ast.AlterTableRepairPartition,
		}
		if $4 == nil {
			ret.OnAllPartitions = true
		} else {
			ret.PartitionNames = $4.([]model.CIStr)
		}
		$$ = ret
	}
|	"IMPORT" "PARTITION" AllOrPartitionNameList "TABLESPACE"
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,AllOrPartitionNameList")


		ret := &ast.AlterTableSpec{
			Tp: ast.AlterTableImportPartitionTablespace,
		}
		if $3 == nil {
			ret.OnAllPartitions = true
		} else {
			ret.PartitionNames = $3.([]model.CIStr)
		}
		$$ = ret
		yylex.AppendError(yylex.Errorf("The IMPORT PARTITION TABLESPACE clause is parsed but ignored by all storage engines."))
		parser.lastErrorAsWarn()
	}
|	"DISCARD" "PARTITION" AllOrPartitionNameList "TABLESPACE"
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,AllOrPartitionNameList")


		ret := &ast.AlterTableSpec{
			Tp: ast.AlterTableDiscardPartitionTablespace,
		}
		if $3 == nil {
			ret.OnAllPartitions = true
		} else {
			ret.PartitionNames = $3.([]model.CIStr)
		}
		$$ = ret
		yylex.AppendError(yylex.Errorf("The DISCARD PARTITION TABLESPACE clause is parsed but ignored by all storage engines."))
		parser.lastErrorAsWarn()
	}
|	"IMPORT" "TABLESPACE"
	{


		ret := &ast.AlterTableSpec{
			Tp: ast.AlterTableImportTablespace,
		}
		$$ = ret
		yylex.AppendError(yylex.Errorf("The IMPORT TABLESPACE clause is parsed but ignored by all storage engines."))
		parser.lastErrorAsWarn()
	}
|	"DISCARD" "TABLESPACE"
	{


		ret := &ast.AlterTableSpec{
			Tp: ast.AlterTableDiscardTablespace,
		}
		$$ = ret
		yylex.AppendError(yylex.Errorf("The DISCARD TABLESPACE clause is parsed but ignored by all storage engines."))
		parser.lastErrorAsWarn()
	}
|	"REBUILD" "PARTITION" NoWriteToBinLogAliasOpt AllOrPartitionNameList
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,NoWriteToBinLogAliasOpt")
sql_ir.LogGrammarCoverage("AlterTableSpec,AllOrPartitionNameList")


		ret := &ast.AlterTableSpec{
			Tp:              ast.AlterTableRebuildPartition,
			NoWriteToBinlog: $3.(bool),
		}
		if $4 == nil {
			ret.OnAllPartitions = true
		} else {
			ret.PartitionNames = $4.([]model.CIStr)
		}
		$$ = ret
	}
|	"DROP" KeyOrIndex IfExists Identifier
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,KeyOrIndex")
sql_ir.LogGrammarCoverage("AlterTableSpec,IfExists")
sql_ir.LogGrammarCoverage("AlterTableSpec,Identifier")


		$$ = &ast.AlterTableSpec{
			IfExists: $3.(bool),
			Tp:       ast.AlterTableDropIndex,
			Name:     $4,
		}
	}
|	"DROP" "FOREIGN" "KEY" IfExists Symbol
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,IfExists")
sql_ir.LogGrammarCoverage("AlterTableSpec,Symbol")


		$$ = &ast.AlterTableSpec{
			IfExists: $4.(bool),
			Tp:       ast.AlterTableDropForeignKey,
			Name:     $5,
		}
	}
|	"ORDER" "BY" AlterOrderList %prec lowerThenOrder
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,AlterOrderList")


		$$ = &ast.AlterTableSpec{
			Tp:          ast.AlterTableOrderByColumns,
			OrderByList: $3.([]*ast.AlterOrderItem),
		}
	}
|	"DISABLE" "KEYS"
	{


		$$ = &ast.AlterTableSpec{
			Tp: ast.AlterTableDisableKeys,
		}
	}
|	"ENABLE" "KEYS"
	{


		$$ = &ast.AlterTableSpec{
			Tp: ast.AlterTableEnableKeys,
		}
	}
|	"MODIFY" ColumnKeywordOpt IfExists ColumnDef ColumnPosition
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,ColumnKeywordOpt")
sql_ir.LogGrammarCoverage("AlterTableSpec,IfExists")
sql_ir.LogGrammarCoverage("AlterTableSpec,ColumnDef")
sql_ir.LogGrammarCoverage("AlterTableSpec,ColumnPosition")


		$$ = &ast.AlterTableSpec{
			IfExists:   $3.(bool),
			Tp:         ast.AlterTableModifyColumn,
			NewColumns: []*ast.ColumnDef{$4.(*ast.ColumnDef)},
			Position:   $5.(*ast.ColumnPosition),
		}
	}
|	"CHANGE" ColumnKeywordOpt IfExists ColumnName ColumnDef ColumnPosition
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,ColumnKeywordOpt")
sql_ir.LogGrammarCoverage("AlterTableSpec,IfExists")
sql_ir.LogGrammarCoverage("AlterTableSpec,ColumnName")
sql_ir.LogGrammarCoverage("AlterTableSpec,ColumnDef")
sql_ir.LogGrammarCoverage("AlterTableSpec,ColumnPosition")


		$$ = &ast.AlterTableSpec{
			IfExists:      $3.(bool),
			Tp:            ast.AlterTableChangeColumn,
			OldColumnName: $4.(*ast.ColumnName),
			NewColumns:    []*ast.ColumnDef{$5.(*ast.ColumnDef)},
			Position:      $6.(*ast.ColumnPosition),
		}
	}
|	"ALTER" ColumnKeywordOpt ColumnName "SET" "DEFAULT" SignedLiteral
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,ColumnKeywordOpt")
sql_ir.LogGrammarCoverage("AlterTableSpec,ColumnName")
sql_ir.LogGrammarCoverage("AlterTableSpec,SignedLiteral")


		option := &ast.ColumnOption{Expr: $6}
		colDef := &ast.ColumnDef{
			Name:    $3.(*ast.ColumnName),
			Options: []*ast.ColumnOption{option},
		}
		$$ = &ast.AlterTableSpec{
			Tp:         ast.AlterTableAlterColumn,
			NewColumns: []*ast.ColumnDef{colDef},
		}
	}
|	"ALTER" ColumnKeywordOpt ColumnName "SET" "DEFAULT" '(' Expression ')'
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,ColumnKeywordOpt")
sql_ir.LogGrammarCoverage("AlterTableSpec,ColumnName")
sql_ir.LogGrammarCoverage("AlterTableSpec,Expression")


		option := &ast.ColumnOption{Expr: $7}
		colDef := &ast.ColumnDef{
			Name:    $3.(*ast.ColumnName),
			Options: []*ast.ColumnOption{option},
		}
		$$ = &ast.AlterTableSpec{
			Tp:         ast.AlterTableAlterColumn,
			NewColumns: []*ast.ColumnDef{colDef},
		}
	}
|	"ALTER" ColumnKeywordOpt ColumnName "DROP" "DEFAULT"
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,ColumnKeywordOpt")
sql_ir.LogGrammarCoverage("AlterTableSpec,ColumnName")


		colDef := &ast.ColumnDef{
			Name: $3.(*ast.ColumnName),
		}
		$$ = &ast.AlterTableSpec{
			Tp:         ast.AlterTableAlterColumn,
			NewColumns: []*ast.ColumnDef{colDef},
		}
	}
|	"RENAME" "COLUMN" Identifier "TO" Identifier
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,Identifier")
sql_ir.LogGrammarCoverage("AlterTableSpec,Identifier")


		oldColName := &ast.ColumnName{Name: model.NewCIStr($3)}
		newColName := &ast.ColumnName{Name: model.NewCIStr($5)}
		$$ = &ast.AlterTableSpec{
			Tp:            ast.AlterTableRenameColumn,
			OldColumnName: oldColName,
			NewColumnName: newColName,
		}
	}
|	"RENAME" "TO" TableName
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,TableName")


		$$ = &ast.AlterTableSpec{
			Tp:       ast.AlterTableRenameTable,
			NewTable: $3.(*ast.TableName),
		}
	}
|	"RENAME" EqOpt TableName
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,EqOpt")
sql_ir.LogGrammarCoverage("AlterTableSpec,TableName")


		$$ = &ast.AlterTableSpec{
			Tp:       ast.AlterTableRenameTable,
			NewTable: $3.(*ast.TableName),
		}
	}
|	"RENAME" "AS" TableName
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,TableName")


		$$ = &ast.AlterTableSpec{
			Tp:       ast.AlterTableRenameTable,
			NewTable: $3.(*ast.TableName),
		}
	}
|	"RENAME" KeyOrIndex Identifier "TO" Identifier
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,KeyOrIndex")
sql_ir.LogGrammarCoverage("AlterTableSpec,Identifier")
sql_ir.LogGrammarCoverage("AlterTableSpec,Identifier")


		$$ = &ast.AlterTableSpec{
			Tp:      ast.AlterTableRenameIndex,
			FromKey: model.NewCIStr($3),
			ToKey:   model.NewCIStr($5),
		}
	}
|	LockClause
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,LockClause")


		$$ = &ast.AlterTableSpec{
			Tp:       ast.AlterTableLock,
			LockType: $1.(ast.LockType),
		}
	}
|	Writeable
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,Writeable")


		$$ = &ast.AlterTableSpec{
			Tp:        ast.AlterTableWriteable,
			Writeable: $1.(bool),
		}
	}
|	AlgorithmClause
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,AlgorithmClause")


		// Parse it and ignore it. Just for compatibility.
		$$ = &ast.AlterTableSpec{
			Tp:        ast.AlterTableAlgorithm,
			Algorithm: $1.(ast.AlgorithmType),
		}
	}
|	"FORCE"
	{


		// Parse it and ignore it. Just for compatibility.
		$$ = &ast.AlterTableSpec{
			Tp: ast.AlterTableForce,
		}
	}
|	"WITH" "VALIDATION"
	{


		// Parse it and ignore it. Just for compatibility.
		$$ = &ast.AlterTableSpec{
			Tp: ast.AlterTableWithValidation,
		}
	}
|	"WITHOUT" "VALIDATION"
	{


		// Parse it and ignore it. Just for compatibility.
		$$ = &ast.AlterTableSpec{
			Tp: ast.AlterTableWithoutValidation,
		}
	}
// Added in MySQL 8.0.13, see: https://dev.mysql.com/doc/refman/8.0/en/keywords.html for details
|	"SECONDARY_LOAD"
	{


		// Parse it and ignore it. Just for compatibility.
		$$ = &ast.AlterTableSpec{
			Tp: ast.AlterTableSecondaryLoad,
		}
		yylex.AppendError(yylex.Errorf("The SECONDARY_LOAD clause is parsed but not implement yet."))
		parser.lastErrorAsWarn()
	}
// Added in MySQL 8.0.13, see: https://dev.mysql.com/doc/refman/8.0/en/keywords.html for details
|	"SECONDARY_UNLOAD"
	{


		// Parse it and ignore it. Just for compatibility.
		$$ = &ast.AlterTableSpec{
			Tp: ast.AlterTableSecondaryUnload,
		}
		yylex.AppendError(yylex.Errorf("The SECONDARY_UNLOAD VALIDATION clause is parsed but not implement yet."))
		parser.lastErrorAsWarn()
	}
|	"ALTER" CheckConstraintKeyword Identifier EnforcedOrNot
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,CheckConstraintKeyword")
sql_ir.LogGrammarCoverage("AlterTableSpec,Identifier")
sql_ir.LogGrammarCoverage("AlterTableSpec,EnforcedOrNot")


		c := &ast.Constraint{
			Name:     $3,
			Enforced: $4.(bool),
		}
		$$ = &ast.AlterTableSpec{
			Tp:         ast.AlterTableAlterCheck,
			Constraint: c,
		}
	}
|	"DROP" CheckConstraintKeyword Identifier
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,CheckConstraintKeyword")
sql_ir.LogGrammarCoverage("AlterTableSpec,Identifier")


		// Parse it and ignore it. Just for compatibility.
		c := &ast.Constraint{
			Name: $3,
		}
		$$ = &ast.AlterTableSpec{
			Tp:         ast.AlterTableDropCheck,
			Constraint: c,
		}
	}
|	"ALTER" "INDEX" Identifier IndexInvisible
	{
sql_ir.LogGrammarCoverage("AlterTableSpec,Identifier")
sql_ir.LogGrammarCoverage("AlterTableSpec,IndexInvisible")


		$$ = &ast.AlterTableSpec{
			Tp:         ast.AlterTableIndexInvisible,
			IndexName:  model.NewCIStr($3),
			Visibility: $4.(ast.IndexVisibility),
		}
	}
// 	Support caching or non-caching a table in memory for tidb, It can be found in the official Oracle document, see: https://docs.oracle.com/database/121/SQLRF/statements_3001.htm
|	"CACHE"
	{


		$$ = &ast.AlterTableSpec{
			Tp: ast.AlterTableCache,
		}
	}
|	"NOCACHE"
	{


		$$ = &ast.AlterTableSpec{
			Tp: ast.AlterTableNoCache,
		}
	}

ReorganizePartitionRuleOpt:
	 %prec lowerThanRemove
	{


		ret := &ast.AlterTableSpec{
			Tp:              ast.AlterTableReorganizePartition,
			OnAllPartitions: true,
		}
		$$ = ret
	}
|	PartitionNameList "INTO" '(' PartitionDefinitionList ')'
	{
sql_ir.LogGrammarCoverage("ReorganizePartitionRuleOpt,PartitionNameList")
sql_ir.LogGrammarCoverage("ReorganizePartitionRuleOpt,PartitionDefinitionList")


		ret := &ast.AlterTableSpec{
			Tp:              ast.AlterTableReorganizePartition,
			PartitionNames:  $1.([]model.CIStr),
			PartDefinitions: $4.([]*ast.PartitionDefinition),
		}
		$$ = ret
	}

AllOrPartitionNameList:
	"ALL"
	{


		$$ = nil
	}
|	PartitionNameList %prec lowerThanComma

{
sql_ir.LogGrammarCoverage("AllOrPartitionNameList,PartitionNameList")

}
WithValidationOpt:
	{


		$$ = true
	}
|	WithValidation

{
sql_ir.LogGrammarCoverage("WithValidationOpt,WithValidation")

}
WithValidation:
	"WITH" "VALIDATION"
	{


		$$ = true
	}
|	"WITHOUT" "VALIDATION"
	{


		$$ = false
	}

WithClustered:
	"CLUSTERED"
	{


		$$ = model.PrimaryKeyTypeClustered
	}
|	"NONCLUSTERED"
	{


		$$ = model.PrimaryKeyTypeNonClustered
	}

AlgorithmClause:
	"ALGORITHM" EqOpt "DEFAULT"
	{
sql_ir.LogGrammarCoverage("AlgorithmClause,EqOpt")


		$$ = ast.AlgorithmTypeDefault
	}
|	"ALGORITHM" EqOpt "COPY"
	{
sql_ir.LogGrammarCoverage("AlgorithmClause,EqOpt")


		$$ = ast.AlgorithmTypeCopy
	}
|	"ALGORITHM" EqOpt "INPLACE"
	{
sql_ir.LogGrammarCoverage("AlgorithmClause,EqOpt")


		$$ = ast.AlgorithmTypeInplace
	}
|	"ALGORITHM" EqOpt "INSTANT"
	{
sql_ir.LogGrammarCoverage("AlgorithmClause,EqOpt")


		$$ = ast.AlgorithmTypeInstant
	}
|	"ALGORITHM" EqOpt identifier
	{
sql_ir.LogGrammarCoverage("AlgorithmClause,EqOpt")


		yylex.AppendError(ErrUnknownAlterAlgorithm.GenWithStackByArgs($1))
		return 1
	}

LockClause:
	"LOCK" EqOpt "DEFAULT"
	{
sql_ir.LogGrammarCoverage("LockClause,EqOpt")


		$$ = ast.LockTypeDefault
	}
|	"LOCK" EqOpt Identifier
	{
sql_ir.LogGrammarCoverage("LockClause,EqOpt")
sql_ir.LogGrammarCoverage("LockClause,Identifier")


		id := strings.ToUpper($3)

		if id == "NONE" {
			$$ = ast.LockTypeNone
		} else if id == "SHARED" {
			$$ = ast.LockTypeShared
		} else if id == "EXCLUSIVE" {
			$$ = ast.LockTypeExclusive
		} else {
			yylex.AppendError(ErrUnknownAlterLock.GenWithStackByArgs($3))
			return 1
		}
	}

Writeable:
	"READ" "WRITE"
	{


		$$ = true
	}
|	"READ" "ONLY"
	{


		$$ = false
	}

KeyOrIndex:
	"KEY"
{

}
|	"INDEX"

{

}
KeyOrIndexOpt:
	{

}
|	KeyOrIndex

{
sql_ir.LogGrammarCoverage("KeyOrIndexOpt,KeyOrIndex")

}
ColumnKeywordOpt:
	 %prec empty
	{

}
|	"COLUMN"

{

}
ColumnPosition:
	{


		$$ = &ast.ColumnPosition{Tp: ast.ColumnPositionNone}
	}
|	"FIRST"
	{


		$$ = &ast.ColumnPosition{Tp: ast.ColumnPositionFirst}
	}
|	"AFTER" ColumnName
	{
sql_ir.LogGrammarCoverage("ColumnPosition,ColumnName")


		$$ = &ast.ColumnPosition{
			Tp:             ast.ColumnPositionAfter,
			RelativeColumn: $2.(*ast.ColumnName),
		}
	}

AlterTableSpecListOpt:
	
	{


		$$ = make([]*ast.AlterTableSpec, 0, 1)
	}
|	AlterTableSpecList

{
sql_ir.LogGrammarCoverage("AlterTableSpecListOpt,AlterTableSpecList")

}
AlterTableSpecList:
	AlterTableSpec
	{
sql_ir.LogGrammarCoverage("AlterTableSpecList,AlterTableSpec")


		$$ = []*ast.AlterTableSpec{$1.(*ast.AlterTableSpec)}
	}
|	AlterTableSpecList ',' AlterTableSpec
	{
sql_ir.LogGrammarCoverage("AlterTableSpecList,AlterTableSpecList")
sql_ir.LogGrammarCoverage("AlterTableSpecList,AlterTableSpec")


		$$ = append($1.([]*ast.AlterTableSpec), $3.(*ast.AlterTableSpec))
	}

PartitionNameList:
	Identifier
	{
sql_ir.LogGrammarCoverage("PartitionNameList,Identifier")


		$$ = []model.CIStr{model.NewCIStr($1)}
	}
|	PartitionNameList ',' Identifier
	{
sql_ir.LogGrammarCoverage("PartitionNameList,PartitionNameList")
sql_ir.LogGrammarCoverage("PartitionNameList,Identifier")


		$$ = append($1.([]model.CIStr), model.NewCIStr($3))
	}

ConstraintKeywordOpt:
	 %prec empty
	{


		$$ = nil
	}
|	"CONSTRAINT"
	{


		$$ = nil
	}
|	"CONSTRAINT" Symbol
	{
sql_ir.LogGrammarCoverage("ConstraintKeywordOpt,Symbol")


		$$ = $2
	}

Symbol:
	Identifier


{
sql_ir.LogGrammarCoverage("Symbol,Identifier")

}
RenameTableStmt:
	"RENAME" "TABLE" TableToTableList
	{
sql_ir.LogGrammarCoverage("RenameTableStmt,TableToTableList")


		$$ = &ast.RenameTableStmt{
			TableToTables: $3.([]*ast.TableToTable),
		}
	}

TableToTableList:
	TableToTable
	{
sql_ir.LogGrammarCoverage("TableToTableList,TableToTable")


		$$ = []*ast.TableToTable{$1.(*ast.TableToTable)}
	}
|	TableToTableList ',' TableToTable
	{
sql_ir.LogGrammarCoverage("TableToTableList,TableToTableList")
sql_ir.LogGrammarCoverage("TableToTableList,TableToTable")


		$$ = append($1.([]*ast.TableToTable), $3.(*ast.TableToTable))
	}

TableToTable:
	TableName "TO" TableName
	{
sql_ir.LogGrammarCoverage("TableToTable,TableName")
sql_ir.LogGrammarCoverage("TableToTable,TableName")


		$$ = &ast.TableToTable{
			OldTable: $1.(*ast.TableName),
			NewTable: $3.(*ast.TableName),
		}
	}


RenameUserStmt:
	"RENAME" "USER" UserToUserList
	{
sql_ir.LogGrammarCoverage("RenameUserStmt,UserToUserList")


		$$ = &ast.RenameUserStmt{
			UserToUsers: $3.([]*ast.UserToUser),
		}
	}

UserToUserList:
	UserToUser
	{
sql_ir.LogGrammarCoverage("UserToUserList,UserToUser")


		$$ = []*ast.UserToUser{$1.(*ast.UserToUser)}
	}
|	UserToUserList ',' UserToUser
	{
sql_ir.LogGrammarCoverage("UserToUserList,UserToUserList")
sql_ir.LogGrammarCoverage("UserToUserList,UserToUser")


		$$ = append($1.([]*ast.UserToUser), $3.(*ast.UserToUser))
	}

UserToUser:
	Username "TO" Username
	{
sql_ir.LogGrammarCoverage("UserToUser,Username")
sql_ir.LogGrammarCoverage("UserToUser,Username")


		$$ = &ast.UserToUser{
			OldUser: $1.(*auth.UserIdentity),
			NewUser: $3.(*auth.UserIdentity),
		}
	}


RecoverTableStmt:
	"RECOVER" "TABLE" "BY" "JOB" Int64Num
	{
sql_ir.LogGrammarCoverage("RecoverTableStmt,Int64Num")


		$$ = &ast.RecoverTableStmt{
			JobID: $5.(int64),
		}
	}
|	"RECOVER" "TABLE" TableName
	{
sql_ir.LogGrammarCoverage("RecoverTableStmt,TableName")


		$$ = &ast.RecoverTableStmt{
			Table: $3.(*ast.TableName),
		}
	}
|	"RECOVER" "TABLE" TableName Int64Num
	{
sql_ir.LogGrammarCoverage("RecoverTableStmt,TableName")
sql_ir.LogGrammarCoverage("RecoverTableStmt,Int64Num")


		$$ = &ast.RecoverTableStmt{
			Table:  $3.(*ast.TableName),
			JobNum: $4.(int64),
		}
	}


FlashbackTableStmt:
	"FLASHBACK" "TABLE" TableName FlashbackToNewName
	{
sql_ir.LogGrammarCoverage("FlashbackTableStmt,TableName")
sql_ir.LogGrammarCoverage("FlashbackTableStmt,FlashbackToNewName")


		$$ = &ast.FlashBackTableStmt{
			Table:   $3.(*ast.TableName),
			NewName: $4,
		}
	}

FlashbackToNewName:
	{


		$$ = ""
	}
|	"TO" Identifier
	{
sql_ir.LogGrammarCoverage("FlashbackToNewName,Identifier")


		$$ = $2
	}


SplitRegionStmt:
	"SPLIT" SplitSyntaxOption "TABLE" TableName PartitionNameListOpt SplitOption
	{
sql_ir.LogGrammarCoverage("SplitRegionStmt,SplitSyntaxOption")
sql_ir.LogGrammarCoverage("SplitRegionStmt,TableName")
sql_ir.LogGrammarCoverage("SplitRegionStmt,PartitionNameListOpt")
sql_ir.LogGrammarCoverage("SplitRegionStmt,SplitOption")


		$$ = &ast.SplitRegionStmt{
			SplitSyntaxOpt: $2.(*ast.SplitSyntaxOption),
			Table:          $4.(*ast.TableName),
			PartitionNames: $5.([]model.CIStr),
			SplitOpt:       $6.(*ast.SplitOption),
		}
	}
|	"SPLIT" SplitSyntaxOption "TABLE" TableName PartitionNameListOpt "INDEX" Identifier SplitOption
	{
sql_ir.LogGrammarCoverage("SplitRegionStmt,SplitSyntaxOption")
sql_ir.LogGrammarCoverage("SplitRegionStmt,TableName")
sql_ir.LogGrammarCoverage("SplitRegionStmt,PartitionNameListOpt")
sql_ir.LogGrammarCoverage("SplitRegionStmt,Identifier")
sql_ir.LogGrammarCoverage("SplitRegionStmt,SplitOption")


		$$ = &ast.SplitRegionStmt{
			SplitSyntaxOpt: $2.(*ast.SplitSyntaxOption),
			Table:          $4.(*ast.TableName),
			PartitionNames: $5.([]model.CIStr),
			IndexName:      model.NewCIStr($7),
			SplitOpt:       $8.(*ast.SplitOption),
		}
	}

SplitOption:
	"BETWEEN" RowValue "AND" RowValue "REGIONS" Int64Num
	{
sql_ir.LogGrammarCoverage("SplitOption,RowValue")
sql_ir.LogGrammarCoverage("SplitOption,RowValue")
sql_ir.LogGrammarCoverage("SplitOption,Int64Num")


		$$ = &ast.SplitOption{
			Lower: $2.([]ast.ExprNode),
			Upper: $4.([]ast.ExprNode),
			Num:   $6.(int64),
		}
	}
|	"BY" ValuesList
	{
sql_ir.LogGrammarCoverage("SplitOption,ValuesList")


		$$ = &ast.SplitOption{
			ValueLists: $2.([][]ast.ExprNode),
		}
	}

SplitSyntaxOption:
	
	{


		$$ = &ast.SplitSyntaxOption{}
	}
|	"REGION" "FOR"
	{


		$$ = &ast.SplitSyntaxOption{
			HasRegionFor: true,
		}
	}
|	"PARTITION"
	{


		$$ = &ast.SplitSyntaxOption{
			HasPartition: true,
		}
	}
|	"REGION" "FOR" "PARTITION"
	{


		$$ = &ast.SplitSyntaxOption{
			HasRegionFor: true,
			HasPartition: true,
		}
	}

AnalyzeTableStmt:
	"ANALYZE" "TABLE" TableNameList AllColumnsOrPredicateColumnsOpt AnalyzeOptionListOpt
	{
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,TableNameList")
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,AllColumnsOrPredicateColumnsOpt")
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,AnalyzeOptionListOpt")


		$$ = &ast.AnalyzeTableStmt{TableNames: $3.([]*ast.TableName), ColumnChoice: $4.(model.ColumnChoice), AnalyzeOpts: $5.([]ast.AnalyzeOpt)}
	}
|	"ANALYZE" "TABLE" TableName "INDEX" IndexNameList AnalyzeOptionListOpt
	{
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,TableName")
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,IndexNameList")
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,AnalyzeOptionListOpt")


		$$ = &ast.AnalyzeTableStmt{TableNames: []*ast.TableName{$3.(*ast.TableName)}, IndexNames: $5.([]model.CIStr), IndexFlag: true, AnalyzeOpts: $6.([]ast.AnalyzeOpt)}
	}
|	"ANALYZE" "INCREMENTAL" "TABLE" TableName "INDEX" IndexNameList AnalyzeOptionListOpt
	{
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,TableName")
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,IndexNameList")
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,AnalyzeOptionListOpt")


		$$ = &ast.AnalyzeTableStmt{TableNames: []*ast.TableName{$4.(*ast.TableName)}, IndexNames: $6.([]model.CIStr), IndexFlag: true, Incremental: true, AnalyzeOpts: $7.([]ast.AnalyzeOpt)}
	}
|	"ANALYZE" "TABLE" TableName "PARTITION" PartitionNameList AllColumnsOrPredicateColumnsOpt AnalyzeOptionListOpt
	{
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,TableName")
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,PartitionNameList")
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,AllColumnsOrPredicateColumnsOpt")
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,AnalyzeOptionListOpt")


		$$ = &ast.AnalyzeTableStmt{TableNames: []*ast.TableName{$3.(*ast.TableName)}, PartitionNames: $5.([]model.CIStr), ColumnChoice: $6.(model.ColumnChoice), AnalyzeOpts: $7.([]ast.AnalyzeOpt)}
	}
|	"ANALYZE" "TABLE" TableName "PARTITION" PartitionNameList "INDEX" IndexNameList AnalyzeOptionListOpt
	{
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,TableName")
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,PartitionNameList")
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,IndexNameList")
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,AnalyzeOptionListOpt")


		$$ = &ast.AnalyzeTableStmt{
			TableNames:     []*ast.TableName{$3.(*ast.TableName)},
			PartitionNames: $5.([]model.CIStr),
			IndexNames:     $7.([]model.CIStr),
			IndexFlag:      true,
			AnalyzeOpts:    $8.([]ast.AnalyzeOpt),
		}
	}
|	"ANALYZE" "INCREMENTAL" "TABLE" TableName "PARTITION" PartitionNameList "INDEX" IndexNameList AnalyzeOptionListOpt
	{
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,TableName")
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,PartitionNameList")
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,IndexNameList")
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,AnalyzeOptionListOpt")


		$$ = &ast.AnalyzeTableStmt{
			TableNames:     []*ast.TableName{$4.(*ast.TableName)},
			PartitionNames: $6.([]model.CIStr),
			IndexNames:     $8.([]model.CIStr),
			IndexFlag:      true,
			Incremental:    true,
			AnalyzeOpts:    $9.([]ast.AnalyzeOpt),
		}
	}
|	"ANALYZE" "TABLE" TableName "UPDATE" "HISTOGRAM" "ON" IdentList AnalyzeOptionListOpt
	{
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,TableName")
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,IdentList")
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,AnalyzeOptionListOpt")


		$$ = &ast.AnalyzeTableStmt{
			TableNames:         []*ast.TableName{$3.(*ast.TableName)},
			ColumnNames:        $7.([]model.CIStr),
			AnalyzeOpts:        $8.([]ast.AnalyzeOpt),
			HistogramOperation: ast.HistogramOperationUpdate,
		}
	}
|	"ANALYZE" "TABLE" TableName "DROP" "HISTOGRAM" "ON" IdentList
	{
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,TableName")
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,IdentList")


		$$ = &ast.AnalyzeTableStmt{
			TableNames:         []*ast.TableName{$3.(*ast.TableName)},
			ColumnNames:        $7.([]model.CIStr),
			HistogramOperation: ast.HistogramOperationDrop,
		}
	}
|	"ANALYZE" "TABLE" TableName "COLUMNS" IdentList AnalyzeOptionListOpt
	{
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,TableName")
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,IdentList")
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,AnalyzeOptionListOpt")


		$$ = &ast.AnalyzeTableStmt{
			TableNames:   []*ast.TableName{$3.(*ast.TableName)},
			ColumnNames:  $5.([]model.CIStr),
			ColumnChoice: model.ColumnList,
			AnalyzeOpts:  $6.([]ast.AnalyzeOpt)}
	}
|	"ANALYZE" "TABLE" TableName "PARTITION" PartitionNameList "COLUMNS" IdentList AnalyzeOptionListOpt
	{
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,TableName")
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,PartitionNameList")
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,IdentList")
sql_ir.LogGrammarCoverage("AnalyzeTableStmt,AnalyzeOptionListOpt")


		$$ = &ast.AnalyzeTableStmt{
			TableNames:     []*ast.TableName{$3.(*ast.TableName)},
			PartitionNames: $5.([]model.CIStr),
			ColumnNames:    $7.([]model.CIStr),
			ColumnChoice:   model.ColumnList,
			AnalyzeOpts:    $8.([]ast.AnalyzeOpt)}
	}

AllColumnsOrPredicateColumnsOpt:
	
	{


		$$ = model.DefaultChoice
	}
|	"ALL" "COLUMNS"
	{


		$$ = model.AllColumns
	}
|	"PREDICATE" "COLUMNS"
	{


		$$ = model.PredicateColumns
	}

AnalyzeOptionListOpt:
	{


		$$ = []ast.AnalyzeOpt{}
	}
|	"WITH" AnalyzeOptionList
	{
sql_ir.LogGrammarCoverage("AnalyzeOptionListOpt,AnalyzeOptionList")


		$$ = $2.([]ast.AnalyzeOpt)
	}

AnalyzeOptionList:
	AnalyzeOption
	{
sql_ir.LogGrammarCoverage("AnalyzeOptionList,AnalyzeOption")


		$$ = []ast.AnalyzeOpt{$1.(ast.AnalyzeOpt)}
	}
|	AnalyzeOptionList ',' AnalyzeOption
	{
sql_ir.LogGrammarCoverage("AnalyzeOptionList,AnalyzeOptionList")
sql_ir.LogGrammarCoverage("AnalyzeOptionList,AnalyzeOption")


		$$ = append($1.([]ast.AnalyzeOpt), $3.(ast.AnalyzeOpt))
	}

AnalyzeOption:
	NUM "BUCKETS"
	{
sql_ir.LogGrammarCoverage("AnalyzeOption,NUM")


		$$ = ast.AnalyzeOpt{Type: ast.AnalyzeOptNumBuckets, Value: ast.NewValueExpr($1, "", "")}
	}
|	NUM "TOPN"
	{
sql_ir.LogGrammarCoverage("AnalyzeOption,NUM")


		$$ = ast.AnalyzeOpt{Type: ast.AnalyzeOptNumTopN, Value: ast.NewValueExpr($1, "", "")}
	}
|	NUM "CMSKETCH" "DEPTH"
	{
sql_ir.LogGrammarCoverage("AnalyzeOption,NUM")


		$$ = ast.AnalyzeOpt{Type: ast.AnalyzeOptCMSketchDepth, Value: ast.NewValueExpr($1, "", "")}
	}
|	NUM "CMSKETCH" "WIDTH"
	{
sql_ir.LogGrammarCoverage("AnalyzeOption,NUM")


		$$ = ast.AnalyzeOpt{Type: ast.AnalyzeOptCMSketchWidth, Value: ast.NewValueExpr($1, "", "")}
	}
|	NUM "SAMPLES"
	{
sql_ir.LogGrammarCoverage("AnalyzeOption,NUM")


		$$ = ast.AnalyzeOpt{Type: ast.AnalyzeOptNumSamples, Value: ast.NewValueExpr($1, "", "")}
	}
|	NumLiteral "SAMPLERATE"
	{
sql_ir.LogGrammarCoverage("AnalyzeOption,NumLiteral")


		$$ = ast.AnalyzeOpt{Type: ast.AnalyzeOptSampleRate, Value: ast.NewValueExpr($1, "", "")}
	}


Assignment:
	ColumnName eq ExprOrDefault
	{
sql_ir.LogGrammarCoverage("Assignment,ColumnName")
sql_ir.LogGrammarCoverage("Assignment,ExprOrDefault")


		$$ = &ast.Assignment{Column: $1.(*ast.ColumnName), Expr: $3}
	}

AssignmentList:
	Assignment
	{
sql_ir.LogGrammarCoverage("AssignmentList,Assignment")


		$$ = []*ast.Assignment{$1.(*ast.Assignment)}
	}
|	AssignmentList ',' Assignment
	{
sql_ir.LogGrammarCoverage("AssignmentList,AssignmentList")
sql_ir.LogGrammarCoverage("AssignmentList,Assignment")


		$$ = append($1.([]*ast.Assignment), $3.(*ast.Assignment))
	}

AssignmentListOpt:
	/* EMPTY */
	{


		$$ = []*ast.Assignment{}
	}
|	AssignmentList

{
sql_ir.LogGrammarCoverage("AssignmentListOpt,AssignmentList")

}
BeginTransactionStmt:
	"BEGIN"
	{


		$$ = &ast.BeginStmt{}
	}
|	"BEGIN" "PESSIMISTIC"
	{


		$$ = &ast.BeginStmt{
			Mode: ast.Pessimistic,
		}
	}
|	"BEGIN" "OPTIMISTIC"
	{


		$$ = &ast.BeginStmt{
			Mode: ast.Optimistic,
		}
	}
|	"START" "TRANSACTION"
	{


		$$ = &ast.BeginStmt{}
	}
|	"START" "TRANSACTION" "READ" "WRITE"
	{


		$$ = &ast.BeginStmt{}
	}
|	"START" "TRANSACTION" "WITH" "CONSISTENT" "SNAPSHOT"
	{


		$$ = &ast.BeginStmt{}
	}
|	"START" "TRANSACTION" "WITH" "CAUSAL" "CONSISTENCY" "ONLY"
	{


		$$ = &ast.BeginStmt{
			CausalConsistencyOnly: true,
		}
	}
|	"START" "TRANSACTION" "READ" "ONLY"
	{


		$$ = &ast.BeginStmt{
			ReadOnly: true,
		}
	}
|	"START" "TRANSACTION" "READ" "ONLY" AsOfClause
	{
sql_ir.LogGrammarCoverage("BeginTransactionStmt,AsOfClause")


		$$ = &ast.BeginStmt{
			ReadOnly: true,
			AsOf:     $5.(*ast.AsOfClause),
		}
	}

BinlogStmt:
	"BINLOG" stringLit
	{
sql_ir.LogGrammarCoverage("BinlogStmt,stringLit")


		$$ = &ast.BinlogStmt{Str: $2}
	}

ColumnDefList:
	ColumnDef
	{
sql_ir.LogGrammarCoverage("ColumnDefList,ColumnDef")


		$$ = []*ast.ColumnDef{$1.(*ast.ColumnDef)}
	}
|	ColumnDefList ',' ColumnDef
	{
sql_ir.LogGrammarCoverage("ColumnDefList,ColumnDefList")
sql_ir.LogGrammarCoverage("ColumnDefList,ColumnDef")


		$$ = append($1.([]*ast.ColumnDef), $3.(*ast.ColumnDef))
	}

ColumnDef:
	ColumnName Type ColumnOptionListOpt
	{
sql_ir.LogGrammarCoverage("ColumnDef,ColumnName")
sql_ir.LogGrammarCoverage("ColumnDef,Type")
sql_ir.LogGrammarCoverage("ColumnDef,ColumnOptionListOpt")


		colDef := &ast.ColumnDef{Name: $1.(*ast.ColumnName), Tp: $2.(*types.FieldType), Options: $3.([]*ast.ColumnOption)}
		if !colDef.Validate() {
			yylex.AppendError(yylex.Errorf("Invalid column definition"))
			return 1
		}
		$$ = colDef
	}
|	ColumnName "SERIAL" ColumnOptionListOpt
	{
sql_ir.LogGrammarCoverage("ColumnDef,ColumnName")
sql_ir.LogGrammarCoverage("ColumnDef,ColumnOptionListOpt")


		// TODO: check flen 0
		tp := types.NewFieldType(mysql.TypeLonglong)
		options := []*ast.ColumnOption{{Tp: ast.ColumnOptionNotNull}, {Tp: ast.ColumnOptionAutoIncrement}, {Tp: ast.ColumnOptionUniqKey}}
		options = append(options, $3.([]*ast.ColumnOption)...)
		tp.AddFlag(mysql.UnsignedFlag)
		colDef := &ast.ColumnDef{Name: $1.(*ast.ColumnName), Tp: tp, Options: options}
		if !colDef.Validate() {
			yylex.AppendError(yylex.Errorf("Invalid column definition"))
			return 1
		}
		$$ = colDef
	}

ColumnName:
	Identifier
	{
sql_ir.LogGrammarCoverage("ColumnName,Identifier")


		$$ = &ast.ColumnName{Name: model.NewCIStr($1)}
	}
|	Identifier '.' Identifier
	{
sql_ir.LogGrammarCoverage("ColumnName,Identifier")
sql_ir.LogGrammarCoverage("ColumnName,Identifier")


		$$ = &ast.ColumnName{Table: model.NewCIStr($1), Name: model.NewCIStr($3)}
	}
|	Identifier '.' Identifier '.' Identifier
	{
sql_ir.LogGrammarCoverage("ColumnName,Identifier")
sql_ir.LogGrammarCoverage("ColumnName,Identifier")
sql_ir.LogGrammarCoverage("ColumnName,Identifier")


		$$ = &ast.ColumnName{Schema: model.NewCIStr($1), Table: model.NewCIStr($3), Name: model.NewCIStr($5)}
	}

ColumnNameList:
	ColumnName
	{
sql_ir.LogGrammarCoverage("ColumnNameList,ColumnName")


		$$ = []*ast.ColumnName{$1.(*ast.ColumnName)}
	}
|	ColumnNameList ',' ColumnName
	{
sql_ir.LogGrammarCoverage("ColumnNameList,ColumnNameList")
sql_ir.LogGrammarCoverage("ColumnNameList,ColumnName")


		$$ = append($1.([]*ast.ColumnName), $3.(*ast.ColumnName))
	}

ColumnNameListOpt:
	/* EMPTY */
	{


		$$ = []*ast.ColumnName{}
	}
|	ColumnNameList

{
sql_ir.LogGrammarCoverage("ColumnNameListOpt,ColumnNameList")

}
IdentListWithParenOpt:
	/* EMPTY */
	{


		$$ = []model.CIStr{}
	}
|	'(' IdentList ')'
	{
sql_ir.LogGrammarCoverage("IdentListWithParenOpt,IdentList")


		$$ = $2
	}

IdentList:
	Identifier
	{
sql_ir.LogGrammarCoverage("IdentList,Identifier")


		$$ = []model.CIStr{model.NewCIStr($1)}
	}
|	IdentList ',' Identifier
	{
sql_ir.LogGrammarCoverage("IdentList,IdentList")
sql_ir.LogGrammarCoverage("IdentList,Identifier")


		$$ = append($1.([]model.CIStr), model.NewCIStr($3))
	}

ColumnNameOrUserVarListOpt:
	/* EMPTY */
	{


		$$ = []*ast.ColumnNameOrUserVar{}
	}
|	ColumnNameOrUserVariableList

{
sql_ir.LogGrammarCoverage("ColumnNameOrUserVarListOpt,ColumnNameOrUserVariableList")

}
ColumnNameOrUserVariableList:
	ColumnNameOrUserVariable
	{
sql_ir.LogGrammarCoverage("ColumnNameOrUserVariableList,ColumnNameOrUserVariable")


		$$ = []*ast.ColumnNameOrUserVar{$1.(*ast.ColumnNameOrUserVar)}
	}
|	ColumnNameOrUserVariableList ',' ColumnNameOrUserVariable
	{
sql_ir.LogGrammarCoverage("ColumnNameOrUserVariableList,ColumnNameOrUserVariableList")
sql_ir.LogGrammarCoverage("ColumnNameOrUserVariableList,ColumnNameOrUserVariable")


		$$ = append($1.([]*ast.ColumnNameOrUserVar), $3.(*ast.ColumnNameOrUserVar))
	}

ColumnNameOrUserVariable:
	ColumnName
	{
sql_ir.LogGrammarCoverage("ColumnNameOrUserVariable,ColumnName")


		$$ = &ast.ColumnNameOrUserVar{ColumnName: $1.(*ast.ColumnName)}
	}
|	UserVariable
	{
sql_ir.LogGrammarCoverage("ColumnNameOrUserVariable,UserVariable")


		$$ = &ast.ColumnNameOrUserVar{UserVar: $1.(*ast.VariableExpr)}
	}

ColumnNameOrUserVarListOptWithBrackets:
	/* EMPTY */
	{


		$$ = []*ast.ColumnNameOrUserVar{}
	}
|	'(' ColumnNameOrUserVarListOpt ')'
	{
sql_ir.LogGrammarCoverage("ColumnNameOrUserVarListOptWithBrackets,ColumnNameOrUserVarListOpt")


		$$ = $2.([]*ast.ColumnNameOrUserVar)
	}

CommitStmt:
	"COMMIT"
	{


		$$ = &ast.CommitStmt{}
	}
|	"COMMIT" CompletionTypeWithinTransaction
	{
sql_ir.LogGrammarCoverage("CommitStmt,CompletionTypeWithinTransaction")


		$$ = &ast.CommitStmt{CompletionType: $2.(ast.CompletionType)}
	}

PrimaryOpt:
	{

}
|	"PRIMARY"

{

}
NotSym:
	not
{

}
|	not2
	{


		$$ = "NOT"
	}

EnforcedOrNot:
	"ENFORCED"
	{


		$$ = true
	}
|	NotSym "ENFORCED"
	{
sql_ir.LogGrammarCoverage("EnforcedOrNot,NotSym")


		$$ = false
	}

EnforcedOrNotOpt:
	%prec lowerThanNot
	{


		$$ = true
	}
|	EnforcedOrNot

{
sql_ir.LogGrammarCoverage("EnforcedOrNotOpt,EnforcedOrNot")

}
EnforcedOrNotOrNotNullOpt:
	//	 This branch is needed to workaround the need of a lookahead of 2 for the grammar:
	//
	//	  { [NOT] NULL | CHECK(...) [NOT] ENFORCED } ...
	NotSym "NULL"
	{
sql_ir.LogGrammarCoverage("EnforcedOrNotOrNotNullOpt,NotSym")


		$$ = 0
	}
|	EnforcedOrNotOpt
	{
sql_ir.LogGrammarCoverage("EnforcedOrNotOrNotNullOpt,EnforcedOrNotOpt")


		if $1.(bool) {
			$$ = 1
		} else {
			$$ = 2
		}
	}

ColumnOption:
	NotSym "NULL"
	{
sql_ir.LogGrammarCoverage("ColumnOption,NotSym")


		$$ = &ast.ColumnOption{Tp: ast.ColumnOptionNotNull}
	}
|	"NULL"
	{


		$$ = &ast.ColumnOption{Tp: ast.ColumnOptionNull}
	}
|	"AUTO_INCREMENT"
	{


		$$ = &ast.ColumnOption{Tp: ast.ColumnOptionAutoIncrement}
	}
|	PrimaryOpt "KEY"
	{
sql_ir.LogGrammarCoverage("ColumnOption,PrimaryOpt")


		// KEY is normally a synonym for INDEX. The key attribute PRIMARY KEY
		// can also be specified as just KEY when given in a column definition.
		// See http://dev.mysql.com/doc/refman/5.7/en/create-table.html
		$$ = &ast.ColumnOption{Tp: ast.ColumnOptionPrimaryKey}
	}
|	PrimaryOpt "KEY" WithClustered
	{
sql_ir.LogGrammarCoverage("ColumnOption,PrimaryOpt")
sql_ir.LogGrammarCoverage("ColumnOption,WithClustered")


		// KEY is normally a synonym for INDEX. The key attribute PRIMARY KEY
		// can also be specified as just KEY when given in a column definition.
		// See http://dev.mysql.com/doc/refman/5.7/en/create-table.html
		$$ = &ast.ColumnOption{Tp: ast.ColumnOptionPrimaryKey, PrimaryKeyTp: $3.(model.PrimaryKeyType)}
	}
|	"UNIQUE" %prec lowerThanKey
	{


		$$ = &ast.ColumnOption{Tp: ast.ColumnOptionUniqKey}
	}
|	"UNIQUE" "KEY"
	{


		$$ = &ast.ColumnOption{Tp: ast.ColumnOptionUniqKey}
	}
|	"DEFAULT" DefaultValueExpr
	{
sql_ir.LogGrammarCoverage("ColumnOption,DefaultValueExpr")


		$$ = &ast.ColumnOption{Tp: ast.ColumnOptionDefaultValue, Expr: $2}
	}
|	"SERIAL" "DEFAULT" "VALUE"
	{


		$$ = []*ast.ColumnOption{{Tp: ast.ColumnOptionNotNull}, {Tp: ast.ColumnOptionAutoIncrement}, {Tp: ast.ColumnOptionUniqKey}}
	}
|	"ON" "UPDATE" NowSymOptionFraction
	{
sql_ir.LogGrammarCoverage("ColumnOption,NowSymOptionFraction")


		$$ = &ast.ColumnOption{Tp: ast.ColumnOptionOnUpdate, Expr: $3}
	}
|	"COMMENT" stringLit
	{
sql_ir.LogGrammarCoverage("ColumnOption,stringLit")


		$$ = &ast.ColumnOption{Tp: ast.ColumnOptionComment, Expr: ast.NewValueExpr($2, "", "")}
	}
|	ConstraintKeywordOpt "CHECK" '(' Expression ')' EnforcedOrNotOrNotNullOpt
	{
sql_ir.LogGrammarCoverage("ColumnOption,ConstraintKeywordOpt")
sql_ir.LogGrammarCoverage("ColumnOption,Expression")
sql_ir.LogGrammarCoverage("ColumnOption,EnforcedOrNotOrNotNullOpt")


		// See https://dev.mysql.com/doc/refman/5.7/en/create-table.html
		// The CHECK clause is parsed but ignored by all storage engines.
		// See the branch named `EnforcedOrNotOrNotNullOpt`.

		optionCheck := &ast.ColumnOption{
			Tp:       ast.ColumnOptionCheck,
			Expr:     $4,
			Enforced: true,
		}
		// Keep the column type check constraint name.
		if $1 != nil {
			optionCheck.ConstraintName = $1.(string)
		}
		switch $6.(int) {
		case 0:
			$$ = []*ast.ColumnOption{optionCheck, {Tp: ast.ColumnOptionNotNull}}
		case 1:
			optionCheck.Enforced = true
			$$ = optionCheck
		case 2:
			optionCheck.Enforced = false
			$$ = optionCheck
		default:
		}
	}
|	GeneratedAlways "AS" '(' Expression ')' VirtualOrStored
	{
sql_ir.LogGrammarCoverage("ColumnOption,GeneratedAlways")
sql_ir.LogGrammarCoverage("ColumnOption,Expression")
sql_ir.LogGrammarCoverage("ColumnOption,VirtualOrStored")


		startOffset := parser.startOffset(&yyS[yypt-2])
		endOffset := parser.endOffset(&yyS[yypt-1])
		expr := $4
		expr.SetText(parser.lexer.client, parser.src[startOffset:endOffset])

		$$ = &ast.ColumnOption{
			Tp:     ast.ColumnOptionGenerated,
			Expr:   expr,
			Stored: $6.(bool),
		}
	}
|	ReferDef
	{
sql_ir.LogGrammarCoverage("ColumnOption,ReferDef")


		$$ = &ast.ColumnOption{
			Tp:    ast.ColumnOptionReference,
			Refer: $1.(*ast.ReferenceDef),
		}
	}
|	"COLLATE" CollationName
	{
sql_ir.LogGrammarCoverage("ColumnOption,CollationName")


		$$ = &ast.ColumnOption{Tp: ast.ColumnOptionCollate, StrValue: $2}
	}
|	"COLUMN_FORMAT" ColumnFormat
	{
sql_ir.LogGrammarCoverage("ColumnOption,ColumnFormat")


		$$ = &ast.ColumnOption{Tp: ast.ColumnOptionColumnFormat, StrValue: $2}
	}
|	"STORAGE" StorageMedia
	{
sql_ir.LogGrammarCoverage("ColumnOption,StorageMedia")


		$$ = &ast.ColumnOption{Tp: ast.ColumnOptionStorage, StrValue: $2}
		yylex.AppendError(yylex.Errorf("The STORAGE clause is parsed but ignored by all storage engines."))
		parser.lastErrorAsWarn()
	}
|	"AUTO_RANDOM" OptFieldLen
	{
sql_ir.LogGrammarCoverage("ColumnOption,OptFieldLen")


		$$ = &ast.ColumnOption{Tp: ast.ColumnOptionAutoRandom, AutoRandomBitLength: $2.(int)}
	}

StorageMedia:
	"DEFAULT"
{

}
|	"DISK"
{

}
|	"MEMORY"

{

}
ColumnFormat:
	"DEFAULT"
	{


		$$ = "DEFAULT"
	}
|	"FIXED"
	{


		$$ = "FIXED"
	}
|	"DYNAMIC"
	{


		$$ = "DYNAMIC"
	}

GeneratedAlways:

{

}
|	"GENERATED" "ALWAYS"

{

}
VirtualOrStored:
	{


		$$ = false
	}
|	"VIRTUAL"
	{


		$$ = false
	}
|	"STORED"
	{


		$$ = true
	}

ColumnOptionList:
	ColumnOption
	{
sql_ir.LogGrammarCoverage("ColumnOptionList,ColumnOption")


		if columnOption, ok := $1.(*ast.ColumnOption); ok {
			$$ = []*ast.ColumnOption{columnOption}
		} else {
			$$ = $1
		}
	}
|	ColumnOptionList ColumnOption
	{
sql_ir.LogGrammarCoverage("ColumnOptionList,ColumnOptionList")
sql_ir.LogGrammarCoverage("ColumnOptionList,ColumnOption")


		if columnOption, ok := $2.(*ast.ColumnOption); ok {
			$$ = append($1.([]*ast.ColumnOption), columnOption)
		} else {
			$$ = append($1.([]*ast.ColumnOption), $2.([]*ast.ColumnOption)...)
		}
	}

ColumnOptionListOpt:
	{


		$$ = []*ast.ColumnOption{}
	}
|	ColumnOptionList

{
sql_ir.LogGrammarCoverage("ColumnOptionListOpt,ColumnOptionList")

}
ConstraintElem:
	"PRIMARY" "KEY" IndexNameAndTypeOpt '(' IndexPartSpecificationList ')' IndexOptionList
	{
sql_ir.LogGrammarCoverage("ConstraintElem,IndexNameAndTypeOpt")
sql_ir.LogGrammarCoverage("ConstraintElem,IndexPartSpecificationList")
sql_ir.LogGrammarCoverage("ConstraintElem,IndexOptionList")


		c := &ast.Constraint{
			Tp:           ast.ConstraintPrimaryKey,
			Keys:         $5.([]*ast.IndexPartSpecification),
			Name:         $3.([]interface{})[0].(*ast.NullString).String,
			IsEmptyIndex: $3.([]interface{})[0].(*ast.NullString).Empty,
		}
		if $7 != nil {
			c.Option = $7.(*ast.IndexOption)
		}
		if indexType := $3.([]interface{})[1]; indexType != nil {
			if c.Option == nil {
				c.Option = &ast.IndexOption{}
			}
			c.Option.Tp = indexType.(model.IndexType)
		}
		$$ = c
	}
|	"FULLTEXT" KeyOrIndexOpt IndexName '(' IndexPartSpecificationList ')' IndexOptionList
	{
sql_ir.LogGrammarCoverage("ConstraintElem,KeyOrIndexOpt")
sql_ir.LogGrammarCoverage("ConstraintElem,IndexName")
sql_ir.LogGrammarCoverage("ConstraintElem,IndexPartSpecificationList")
sql_ir.LogGrammarCoverage("ConstraintElem,IndexOptionList")


		c := &ast.Constraint{
			Tp:           ast.ConstraintFulltext,
			Keys:         $5.([]*ast.IndexPartSpecification),
			Name:         $3.(*ast.NullString).String,
			IsEmptyIndex: $3.(*ast.NullString).Empty,
		}
		if $7 != nil {
			c.Option = $7.(*ast.IndexOption)
		}
		$$ = c
	}
|	KeyOrIndex IfNotExists IndexNameAndTypeOpt '(' IndexPartSpecificationList ')' IndexOptionList
	{
sql_ir.LogGrammarCoverage("ConstraintElem,KeyOrIndex")
sql_ir.LogGrammarCoverage("ConstraintElem,IfNotExists")
sql_ir.LogGrammarCoverage("ConstraintElem,IndexNameAndTypeOpt")
sql_ir.LogGrammarCoverage("ConstraintElem,IndexPartSpecificationList")
sql_ir.LogGrammarCoverage("ConstraintElem,IndexOptionList")


		c := &ast.Constraint{
			IfNotExists:  $2.(bool),
			Tp:           ast.ConstraintIndex,
			Keys:         $5.([]*ast.IndexPartSpecification),
			Name:         $3.([]interface{})[0].(*ast.NullString).String,
			IsEmptyIndex: $3.([]interface{})[0].(*ast.NullString).Empty,
		}
		if $7 != nil {
			c.Option = $7.(*ast.IndexOption)
		}
		if indexType := $3.([]interface{})[1]; indexType != nil {
			if c.Option == nil {
				c.Option = &ast.IndexOption{}
			}
			c.Option.Tp = indexType.(model.IndexType)
		}
		$$ = c
	}
|	"UNIQUE" KeyOrIndexOpt IndexNameAndTypeOpt '(' IndexPartSpecificationList ')' IndexOptionList
	{
sql_ir.LogGrammarCoverage("ConstraintElem,KeyOrIndexOpt")
sql_ir.LogGrammarCoverage("ConstraintElem,IndexNameAndTypeOpt")
sql_ir.LogGrammarCoverage("ConstraintElem,IndexPartSpecificationList")
sql_ir.LogGrammarCoverage("ConstraintElem,IndexOptionList")


		c := &ast.Constraint{
			Tp:           ast.ConstraintUniq,
			Keys:         $5.([]*ast.IndexPartSpecification),
			Name:         $3.([]interface{})[0].(*ast.NullString).String,
			IsEmptyIndex: $3.([]interface{})[0].(*ast.NullString).Empty,
		}
		if $7 != nil {
			c.Option = $7.(*ast.IndexOption)
		}

		if indexType := $3.([]interface{})[1]; indexType != nil {
			if c.Option == nil {
				c.Option = &ast.IndexOption{}
			}
			c.Option.Tp = indexType.(model.IndexType)
		}
		$$ = c
	}
|	"FOREIGN" "KEY" IfNotExists IndexName '(' IndexPartSpecificationList ')' ReferDef
	{
sql_ir.LogGrammarCoverage("ConstraintElem,IfNotExists")
sql_ir.LogGrammarCoverage("ConstraintElem,IndexName")
sql_ir.LogGrammarCoverage("ConstraintElem,IndexPartSpecificationList")
sql_ir.LogGrammarCoverage("ConstraintElem,ReferDef")


		$$ = &ast.Constraint{
			IfNotExists:  $3.(bool),
			Tp:           ast.ConstraintForeignKey,
			Keys:         $6.([]*ast.IndexPartSpecification),
			Name:         $4.(*ast.NullString).String,
			Refer:        $8.(*ast.ReferenceDef),
			IsEmptyIndex: $4.(*ast.NullString).Empty,
		}
	}
|	"CHECK" '(' Expression ')' EnforcedOrNotOpt
	{
sql_ir.LogGrammarCoverage("ConstraintElem,Expression")
sql_ir.LogGrammarCoverage("ConstraintElem,EnforcedOrNotOpt")


		$$ = &ast.Constraint{
			Tp:       ast.ConstraintCheck,
			Expr:     $3.(ast.ExprNode),
			Enforced: $5.(bool),
		}
	}

Match:
	"MATCH" "FULL"
	{


		$$ = ast.MatchFull
	}
|	"MATCH" "PARTIAL"
	{


		$$ = ast.MatchPartial
	}
|	"MATCH" "SIMPLE"
	{


		$$ = ast.MatchSimple
	}

MatchOpt:
	{


		$$ = ast.MatchNone
	}
|	Match
	{
sql_ir.LogGrammarCoverage("MatchOpt,Match")


		$$ = $1
		yylex.AppendError(yylex.Errorf("The MATCH clause is parsed but ignored by all storage engines."))
		parser.lastErrorAsWarn()
	}

ReferDef:
	"REFERENCES" TableName IndexPartSpecificationListOpt MatchOpt OnDeleteUpdateOpt
	{
sql_ir.LogGrammarCoverage("ReferDef,TableName")
sql_ir.LogGrammarCoverage("ReferDef,IndexPartSpecificationListOpt")
sql_ir.LogGrammarCoverage("ReferDef,MatchOpt")
sql_ir.LogGrammarCoverage("ReferDef,OnDeleteUpdateOpt")


		onDeleteUpdate := $5.([2]interface{})
		$$ = &ast.ReferenceDef{
			Table:                   $2.(*ast.TableName),
			IndexPartSpecifications: $3.([]*ast.IndexPartSpecification),
			OnDelete:                onDeleteUpdate[0].(*ast.OnDeleteOpt),
			OnUpdate:                onDeleteUpdate[1].(*ast.OnUpdateOpt),
			Match:                   $4.(ast.MatchType),
		}
	}

OnDelete:
	"ON" "DELETE" ReferOpt
	{
sql_ir.LogGrammarCoverage("OnDelete,ReferOpt")


		$$ = &ast.OnDeleteOpt{ReferOpt: $3.(ast.ReferOptionType)}
	}

OnUpdate:
	"ON" "UPDATE" ReferOpt
	{
sql_ir.LogGrammarCoverage("OnUpdate,ReferOpt")


		$$ = &ast.OnUpdateOpt{ReferOpt: $3.(ast.ReferOptionType)}
	}

OnDeleteUpdateOpt:
	%prec lowerThanOn
	{


		$$ = [2]interface{}{&ast.OnDeleteOpt{}, &ast.OnUpdateOpt{}}
	}
|	OnDelete %prec lowerThanOn
	{
sql_ir.LogGrammarCoverage("OnDeleteUpdateOpt,OnDelete")


		$$ = [2]interface{}{$1, &ast.OnUpdateOpt{}}
	}
|	OnUpdate %prec lowerThanOn
	{
sql_ir.LogGrammarCoverage("OnDeleteUpdateOpt,OnUpdate")


		$$ = [2]interface{}{&ast.OnDeleteOpt{}, $1}
	}
|	OnDelete OnUpdate
	{
sql_ir.LogGrammarCoverage("OnDeleteUpdateOpt,OnDelete")
sql_ir.LogGrammarCoverage("OnDeleteUpdateOpt,OnUpdate")


		$$ = [2]interface{}{$1, $2}
	}
|	OnUpdate OnDelete
	{
sql_ir.LogGrammarCoverage("OnDeleteUpdateOpt,OnUpdate")
sql_ir.LogGrammarCoverage("OnDeleteUpdateOpt,OnDelete")


		$$ = [2]interface{}{$2, $1}
	}

ReferOpt:
	"RESTRICT"
	{


		$$ = ast.ReferOptionRestrict
	}
|	"CASCADE"
	{


		$$ = ast.ReferOptionCascade
	}
|	"SET" "NULL"
	{


		$$ = ast.ReferOptionSetNull
	}
|	"NO" "ACTION"
	{


		$$ = ast.ReferOptionNoAction
	}
|	"SET" "DEFAULT"
	{


		$$ = ast.ReferOptionSetDefault
		yylex.AppendError(yylex.Errorf("The SET DEFAULT clause is parsed but ignored by all storage engines."))
		parser.lastErrorAsWarn()
	}


DefaultValueExpr:
	NowSymOptionFractionParentheses
{
sql_ir.LogGrammarCoverage("DefaultValueExpr,NowSymOptionFractionParentheses")

}
|	SignedLiteral
{
sql_ir.LogGrammarCoverage("DefaultValueExpr,SignedLiteral")

}
|	NextValueForSequence
{
sql_ir.LogGrammarCoverage("DefaultValueExpr,NextValueForSequence")

}
|	BuiltinFunction

{
sql_ir.LogGrammarCoverage("DefaultValueExpr,BuiltinFunction")

}
BuiltinFunction:
	'(' BuiltinFunction ')'
	{
sql_ir.LogGrammarCoverage("BuiltinFunction,BuiltinFunction")


		$$ = $2.(*ast.FuncCallExpr)
	}
|	identifier '(' ')'
	{


		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr($1),
		}
	}
|	identifier '(' ExpressionList ')'
	{
sql_ir.LogGrammarCoverage("BuiltinFunction,ExpressionList")


		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr($1),
			Args:   $3.([]ast.ExprNode),
		}
	}

NowSymOptionFractionParentheses:
	'(' NowSymOptionFractionParentheses ')'
	{
sql_ir.LogGrammarCoverage("NowSymOptionFractionParentheses,NowSymOptionFractionParentheses")


		$$ = $2.(*ast.FuncCallExpr)
	}
|	NowSymOptionFraction

{
sql_ir.LogGrammarCoverage("NowSymOptionFractionParentheses,NowSymOptionFraction")

}
NowSymOptionFraction:
	NowSym
	{
sql_ir.LogGrammarCoverage("NowSymOptionFraction,NowSym")


		$$ = &ast.FuncCallExpr{FnName: model.NewCIStr("CURRENT_TIMESTAMP")}
	}
|	NowSymFunc '(' ')'
	{
sql_ir.LogGrammarCoverage("NowSymOptionFraction,NowSymFunc")


		$$ = &ast.FuncCallExpr{FnName: model.NewCIStr("CURRENT_TIMESTAMP")}
	}
|	NowSymFunc '(' NUM ')'
	{
sql_ir.LogGrammarCoverage("NowSymOptionFraction,NowSymFunc")
sql_ir.LogGrammarCoverage("NowSymOptionFraction,NUM")


		$$ = &ast.FuncCallExpr{FnName: model.NewCIStr("CURRENT_TIMESTAMP"), Args: []ast.ExprNode{ast.NewValueExpr($3, parser.charset, parser.collation)}}
	}

NextValueForSequence:
	"NEXT" "VALUE" forKwd TableName
	{
sql_ir.LogGrammarCoverage("NextValueForSequence,TableName")


		objNameExpr := &ast.TableNameExpr{
			Name: $4.(*ast.TableName),
		}
		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr(ast.NextVal),
			Args:   []ast.ExprNode{objNameExpr},
		}
	}
|	"NEXTVAL" '(' TableName ')'
	{
sql_ir.LogGrammarCoverage("NextValueForSequence,TableName")


		objNameExpr := &ast.TableNameExpr{
			Name: $3.(*ast.TableName),
		}
		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr(ast.NextVal),
			Args:   []ast.ExprNode{objNameExpr},
		}
	}


NowSymFunc:
	"CURRENT_TIMESTAMP"
{

}
|	"LOCALTIME"
{

}
|	"LOCALTIMESTAMP"
{

}
|	builtinNow

{

}
NowSym:
	"CURRENT_TIMESTAMP"
{

}
|	"LOCALTIME"
{

}
|	"LOCALTIMESTAMP"

{

}
SignedLiteral:
	Literal
	{
sql_ir.LogGrammarCoverage("SignedLiteral,Literal")


		$$ = ast.NewValueExpr($1, parser.charset, parser.collation)
	}
|	'+' NumLiteral
	{
sql_ir.LogGrammarCoverage("SignedLiteral,NumLiteral")


		$$ = &ast.UnaryOperationExpr{Op: opcode.Plus, V: ast.NewValueExpr($2, parser.charset, parser.collation)}
	}
|	'-' NumLiteral
	{
sql_ir.LogGrammarCoverage("SignedLiteral,NumLiteral")


		$$ = &ast.UnaryOperationExpr{Op: opcode.Minus, V: ast.NewValueExpr($2, parser.charset, parser.collation)}
	}

NumLiteral:
	intLit
{

}
|	floatLit
{

}
|	decLit

{

}
StatsType:
	"CARDINALITY"
	{


		$$ = ast.StatsTypeCardinality
	}
|	"DEPENDENCY"
	{


		$$ = ast.StatsTypeDependency
	}
|	"CORRELATION"
	{


		$$ = ast.StatsTypeCorrelation
	}

BindingStatusType:
	"ENABLED"
	{


		$$ = ast.BindingStatusTypeEnabled
	}
|	"DISABLED"
	{


		$$ = ast.BindingStatusTypeDisabled
	}

CreateStatisticsStmt:
	"CREATE" "STATISTICS" IfNotExists Identifier '(' StatsType ')' "ON" TableName '(' ColumnNameList ')'
	{
sql_ir.LogGrammarCoverage("CreateStatisticsStmt,IfNotExists")
sql_ir.LogGrammarCoverage("CreateStatisticsStmt,Identifier")
sql_ir.LogGrammarCoverage("CreateStatisticsStmt,StatsType")
sql_ir.LogGrammarCoverage("CreateStatisticsStmt,TableName")
sql_ir.LogGrammarCoverage("CreateStatisticsStmt,ColumnNameList")


		$$ = &ast.CreateStatisticsStmt{
			IfNotExists: $3.(bool),
			StatsName:   $4,
			StatsType:   $6.(uint8),
			Table:       $9.(*ast.TableName),
			Columns:     $11.([]*ast.ColumnName),
		}
	}

DropStatisticsStmt:
	"DROP" "STATISTICS" Identifier
	{
sql_ir.LogGrammarCoverage("DropStatisticsStmt,Identifier")


		$$ = &ast.DropStatisticsStmt{StatsName: $3}
	}


CreateIndexStmt:
	"CREATE" IndexKeyTypeOpt "INDEX" IfNotExists Identifier IndexTypeOpt "ON" TableName '(' IndexPartSpecificationList ')' IndexOptionList IndexLockAndAlgorithmOpt
	{
sql_ir.LogGrammarCoverage("CreateIndexStmt,IndexKeyTypeOpt")
sql_ir.LogGrammarCoverage("CreateIndexStmt,IfNotExists")
sql_ir.LogGrammarCoverage("CreateIndexStmt,Identifier")
sql_ir.LogGrammarCoverage("CreateIndexStmt,IndexTypeOpt")
sql_ir.LogGrammarCoverage("CreateIndexStmt,TableName")
sql_ir.LogGrammarCoverage("CreateIndexStmt,IndexPartSpecificationList")
sql_ir.LogGrammarCoverage("CreateIndexStmt,IndexOptionList")
sql_ir.LogGrammarCoverage("CreateIndexStmt,IndexLockAndAlgorithmOpt")


		var indexOption *ast.IndexOption
		if $12 != nil {
			indexOption = $12.(*ast.IndexOption)
			if indexOption.Tp == model.IndexTypeInvalid {
				if $6 != nil {
					indexOption.Tp = $6.(model.IndexType)
				}
			}
		} else {
			indexOption = &ast.IndexOption{}
			if $6 != nil {
				indexOption.Tp = $6.(model.IndexType)
			}
		}
		var indexLockAndAlgorithm *ast.IndexLockAndAlgorithm
		if $13 != nil {
			indexLockAndAlgorithm = $13.(*ast.IndexLockAndAlgorithm)
			if indexLockAndAlgorithm.LockTp == ast.LockTypeDefault && indexLockAndAlgorithm.AlgorithmTp == ast.AlgorithmTypeDefault {
				indexLockAndAlgorithm = nil
			}
		}
		$$ = &ast.CreateIndexStmt{
			IfNotExists:             $4.(bool),
			IndexName:               $5,
			Table:                   $8.(*ast.TableName),
			IndexPartSpecifications: $10.([]*ast.IndexPartSpecification),
			IndexOption:             indexOption,
			KeyType:                 $2.(ast.IndexKeyType),
			LockAlg:                 indexLockAndAlgorithm,
		}
	}

IndexPartSpecificationListOpt:
	{


		$$ = ([]*ast.IndexPartSpecification)(nil)
	}
|	'(' IndexPartSpecificationList ')'
	{
sql_ir.LogGrammarCoverage("IndexPartSpecificationListOpt,IndexPartSpecificationList")


		$$ = $2
	}

IndexPartSpecificationList:
	IndexPartSpecification
	{
sql_ir.LogGrammarCoverage("IndexPartSpecificationList,IndexPartSpecification")


		$$ = []*ast.IndexPartSpecification{$1.(*ast.IndexPartSpecification)}
	}
|	IndexPartSpecificationList ',' IndexPartSpecification
	{
sql_ir.LogGrammarCoverage("IndexPartSpecificationList,IndexPartSpecificationList")
sql_ir.LogGrammarCoverage("IndexPartSpecificationList,IndexPartSpecification")


		$$ = append($1.([]*ast.IndexPartSpecification), $3.(*ast.IndexPartSpecification))
	}

IndexPartSpecification:
	ColumnName OptFieldLen OptOrder
	{
sql_ir.LogGrammarCoverage("IndexPartSpecification,ColumnName")
sql_ir.LogGrammarCoverage("IndexPartSpecification,OptFieldLen")
sql_ir.LogGrammarCoverage("IndexPartSpecification,OptOrder")


		// Order is parsed but just ignored as MySQL did.
		$$ = &ast.IndexPartSpecification{Column: $1.(*ast.ColumnName), Length: $2.(int)}
	}
|	'(' Expression ')' OptOrder
	{
sql_ir.LogGrammarCoverage("IndexPartSpecification,Expression")
sql_ir.LogGrammarCoverage("IndexPartSpecification,OptOrder")


		$$ = &ast.IndexPartSpecification{Expr: $2}
	}

IndexLockAndAlgorithmOpt:
	{


		$$ = nil
	}
|	LockClause
	{
sql_ir.LogGrammarCoverage("IndexLockAndAlgorithmOpt,LockClause")


		$$ = &ast.IndexLockAndAlgorithm{
			LockTp:      $1.(ast.LockType),
			AlgorithmTp: ast.AlgorithmTypeDefault,
		}
	}
|	AlgorithmClause
	{
sql_ir.LogGrammarCoverage("IndexLockAndAlgorithmOpt,AlgorithmClause")


		$$ = &ast.IndexLockAndAlgorithm{
			LockTp:      ast.LockTypeDefault,
			AlgorithmTp: $1.(ast.AlgorithmType),
		}
	}
|	LockClause AlgorithmClause
	{
sql_ir.LogGrammarCoverage("IndexLockAndAlgorithmOpt,LockClause")
sql_ir.LogGrammarCoverage("IndexLockAndAlgorithmOpt,AlgorithmClause")


		$$ = &ast.IndexLockAndAlgorithm{
			LockTp:      $1.(ast.LockType),
			AlgorithmTp: $2.(ast.AlgorithmType),
		}
	}
|	AlgorithmClause LockClause
	{
sql_ir.LogGrammarCoverage("IndexLockAndAlgorithmOpt,AlgorithmClause")
sql_ir.LogGrammarCoverage("IndexLockAndAlgorithmOpt,LockClause")


		$$ = &ast.IndexLockAndAlgorithm{
			LockTp:      $2.(ast.LockType),
			AlgorithmTp: $1.(ast.AlgorithmType),
		}
	}

IndexKeyTypeOpt:
	{


		$$ = ast.IndexKeyTypeNone
	}
|	"UNIQUE"
	{


		$$ = ast.IndexKeyTypeUnique
	}
|	"SPATIAL"
	{


		$$ = ast.IndexKeyTypeSpatial
	}
|	"FULLTEXT"
	{


		$$ = ast.IndexKeyTypeFullText
	}


AlterDatabaseStmt:
	"ALTER" DatabaseSym DBName DatabaseOptionList
	{
sql_ir.LogGrammarCoverage("AlterDatabaseStmt,DatabaseSym")
sql_ir.LogGrammarCoverage("AlterDatabaseStmt,DBName")
sql_ir.LogGrammarCoverage("AlterDatabaseStmt,DatabaseOptionList")


		$$ = &ast.AlterDatabaseStmt{
			Name:                 $3,
			AlterDefaultDatabase: false,
			Options:              $4.([]*ast.DatabaseOption),
		}
	}
|	"ALTER" DatabaseSym DatabaseOptionList
	{
sql_ir.LogGrammarCoverage("AlterDatabaseStmt,DatabaseSym")
sql_ir.LogGrammarCoverage("AlterDatabaseStmt,DatabaseOptionList")


		$$ = &ast.AlterDatabaseStmt{
			Name:                 "",
			AlterDefaultDatabase: true,
			Options:              $3.([]*ast.DatabaseOption),
		}
	}


CreateDatabaseStmt:
	"CREATE" DatabaseSym IfNotExists DBName DatabaseOptionListOpt
	{
sql_ir.LogGrammarCoverage("CreateDatabaseStmt,DatabaseSym")
sql_ir.LogGrammarCoverage("CreateDatabaseStmt,IfNotExists")
sql_ir.LogGrammarCoverage("CreateDatabaseStmt,DBName")
sql_ir.LogGrammarCoverage("CreateDatabaseStmt,DatabaseOptionListOpt")


		$$ = &ast.CreateDatabaseStmt{
			IfNotExists: $3.(bool),
			Name:        $4,
			Options:     $5.([]*ast.DatabaseOption),
		}
	}

DBName:
	Identifier

{
sql_ir.LogGrammarCoverage("DBName,Identifier")

}
PolicyName:
	Identifier

{
sql_ir.LogGrammarCoverage("PolicyName,Identifier")

}
DatabaseOption:
	DefaultKwdOpt CharsetKw EqOpt CharsetName
	{
sql_ir.LogGrammarCoverage("DatabaseOption,DefaultKwdOpt")
sql_ir.LogGrammarCoverage("DatabaseOption,CharsetKw")
sql_ir.LogGrammarCoverage("DatabaseOption,EqOpt")
sql_ir.LogGrammarCoverage("DatabaseOption,CharsetName")


		$$ = &ast.DatabaseOption{Tp: ast.DatabaseOptionCharset, Value: $4}
	}
|	DefaultKwdOpt "COLLATE" EqOpt CollationName
	{
sql_ir.LogGrammarCoverage("DatabaseOption,DefaultKwdOpt")
sql_ir.LogGrammarCoverage("DatabaseOption,EqOpt")
sql_ir.LogGrammarCoverage("DatabaseOption,CollationName")


		$$ = &ast.DatabaseOption{Tp: ast.DatabaseOptionCollate, Value: $4}
	}
|	DefaultKwdOpt "ENCRYPTION" EqOpt EncryptionOpt
	{
sql_ir.LogGrammarCoverage("DatabaseOption,DefaultKwdOpt")
sql_ir.LogGrammarCoverage("DatabaseOption,EqOpt")
sql_ir.LogGrammarCoverage("DatabaseOption,EncryptionOpt")


		$$ = &ast.DatabaseOption{Tp: ast.DatabaseOptionEncryption, Value: $4}
	}
|	DefaultKwdOpt PlacementPolicyOption
	{
sql_ir.LogGrammarCoverage("DatabaseOption,DefaultKwdOpt")
sql_ir.LogGrammarCoverage("DatabaseOption,PlacementPolicyOption")


		placementOptions := $2.(*ast.PlacementOption)
		$$ = &ast.DatabaseOption{
			// offset trick, enums are identical but of different type
			Tp:        ast.DatabaseOptionType(placementOptions.Tp),
			Value:     placementOptions.StrValue,
			UintValue: placementOptions.UintValue,
		}
	}
|	PlacementPolicyOption
	{
sql_ir.LogGrammarCoverage("DatabaseOption,PlacementPolicyOption")


		placementOptions := $1.(*ast.PlacementOption)
		$$ = &ast.DatabaseOption{
			// offset trick, enums are identical but of different type
			Tp:        ast.DatabaseOptionType(placementOptions.Tp),
			Value:     placementOptions.StrValue,
			UintValue: placementOptions.UintValue,
		}
	}
|	"SET" "TIFLASH" "REPLICA" LengthNum LocationLabelList
	{
sql_ir.LogGrammarCoverage("DatabaseOption,LengthNum")
sql_ir.LogGrammarCoverage("DatabaseOption,LocationLabelList")


		tiflashReplicaSpec := &ast.TiFlashReplicaSpec{
			Count:  $4.(uint64),
			Labels: $5.([]string),
		}
		$$ = &ast.DatabaseOption{
			Tp:             ast.DatabaseSetTiFlashReplica,
			TiFlashReplica: tiflashReplicaSpec,
		}
	}

DatabaseOptionListOpt:
	{


		$$ = []*ast.DatabaseOption{}
	}
|	DatabaseOptionList

{
sql_ir.LogGrammarCoverage("DatabaseOptionListOpt,DatabaseOptionList")

}
DatabaseOptionList:
	DatabaseOption
	{
sql_ir.LogGrammarCoverage("DatabaseOptionList,DatabaseOption")


		$$ = []*ast.DatabaseOption{$1.(*ast.DatabaseOption)}
	}
|	DatabaseOptionList DatabaseOption
	{
sql_ir.LogGrammarCoverage("DatabaseOptionList,DatabaseOptionList")
sql_ir.LogGrammarCoverage("DatabaseOptionList,DatabaseOption")


		$$ = append($1.([]*ast.DatabaseOption), $2.(*ast.DatabaseOption))
	}


CreateTableStmt:
	"CREATE" OptTemporary "TABLE" IfNotExists TableName TableElementListOpt CreateTableOptionListOpt PartitionOpt DuplicateOpt AsOpt CreateTableSelectOpt OnCommitOpt
	{
sql_ir.LogGrammarCoverage("CreateTableStmt,OptTemporary")
sql_ir.LogGrammarCoverage("CreateTableStmt,IfNotExists")
sql_ir.LogGrammarCoverage("CreateTableStmt,TableName")
sql_ir.LogGrammarCoverage("CreateTableStmt,TableElementListOpt")
sql_ir.LogGrammarCoverage("CreateTableStmt,CreateTableOptionListOpt")
sql_ir.LogGrammarCoverage("CreateTableStmt,PartitionOpt")
sql_ir.LogGrammarCoverage("CreateTableStmt,DuplicateOpt")
sql_ir.LogGrammarCoverage("CreateTableStmt,AsOpt")
sql_ir.LogGrammarCoverage("CreateTableStmt,CreateTableSelectOpt")
sql_ir.LogGrammarCoverage("CreateTableStmt,OnCommitOpt")


		stmt := $6.(*ast.CreateTableStmt)
		stmt.Table = $5.(*ast.TableName)
		stmt.IfNotExists = $4.(bool)
		stmt.TemporaryKeyword = $2.(ast.TemporaryKeyword)
		stmt.Options = $7.([]*ast.TableOption)
		if $8 != nil {
			stmt.Partition = $8.(*ast.PartitionOptions)
		}
		stmt.OnDuplicate = $9.(ast.OnDuplicateKeyHandlingType)
		stmt.Select = $11.(*ast.CreateTableStmt).Select
		if ($12 != nil && stmt.TemporaryKeyword != ast.TemporaryGlobal) || (stmt.TemporaryKeyword == ast.TemporaryGlobal && $12 == nil) {
			yylex.AppendError(yylex.Errorf("GLOBAL TEMPORARY and ON COMMIT DELETE ROWS must appear together"))
		} else {
			if stmt.TemporaryKeyword == ast.TemporaryGlobal {
				stmt.OnCommitDelete = $12.(bool)
			}
		}
		$$ = stmt
	}
|	"CREATE" OptTemporary "TABLE" IfNotExists TableName LikeTableWithOrWithoutParen OnCommitOpt
	{
sql_ir.LogGrammarCoverage("CreateTableStmt,OptTemporary")
sql_ir.LogGrammarCoverage("CreateTableStmt,IfNotExists")
sql_ir.LogGrammarCoverage("CreateTableStmt,TableName")
sql_ir.LogGrammarCoverage("CreateTableStmt,LikeTableWithOrWithoutParen")
sql_ir.LogGrammarCoverage("CreateTableStmt,OnCommitOpt")


		tmp := &ast.CreateTableStmt{
			Table:            $5.(*ast.TableName),
			ReferTable:       $6.(*ast.TableName),
			IfNotExists:      $4.(bool),
			TemporaryKeyword: $2.(ast.TemporaryKeyword),
		}
		if ($7 != nil && tmp.TemporaryKeyword != ast.TemporaryGlobal) || (tmp.TemporaryKeyword == ast.TemporaryGlobal && $7 == nil) {
			yylex.AppendError(yylex.Errorf("GLOBAL TEMPORARY and ON COMMIT DELETE ROWS must appear together"))
		} else {
			if tmp.TemporaryKeyword == ast.TemporaryGlobal {
				tmp.OnCommitDelete = $7.(bool)
			}
		}
		$$ = tmp
	}

OnCommitOpt:
	{


		$$ = nil
	}
|	"ON" "COMMIT" "DELETE" "ROWS"
	{


		$$ = true
	}
|	"ON" "COMMIT" "PRESERVE" "ROWS"
	{


		$$ = false
	}

DefaultKwdOpt:
	%prec lowerThanCharsetKwd
	{

}
|	"DEFAULT"

{

}
PartitionOpt:
	{


		$$ = nil
	}
|	"PARTITION" "BY" PartitionMethod PartitionNumOpt SubPartitionOpt PartitionDefinitionListOpt
	{
sql_ir.LogGrammarCoverage("PartitionOpt,PartitionMethod")
sql_ir.LogGrammarCoverage("PartitionOpt,PartitionNumOpt")
sql_ir.LogGrammarCoverage("PartitionOpt,SubPartitionOpt")
sql_ir.LogGrammarCoverage("PartitionOpt,PartitionDefinitionListOpt")


		method := $3.(*ast.PartitionMethod)
		method.Num = $4.(uint64)
		sub, _ := $5.(*ast.PartitionMethod)
		defs, _ := $6.([]*ast.PartitionDefinition)
		opt := &ast.PartitionOptions{
			PartitionMethod: *method,
			Sub:             sub,
			Definitions:     defs,
		}
		if err := opt.Validate(); err != nil {
			yylex.AppendError(err)
			return 1
		}
		$$ = opt
	}

SubPartitionMethod:
	LinearOpt "KEY" PartitionKeyAlgorithmOpt '(' ColumnNameListOpt ')'
	{
sql_ir.LogGrammarCoverage("SubPartitionMethod,LinearOpt")
sql_ir.LogGrammarCoverage("SubPartitionMethod,PartitionKeyAlgorithmOpt")
sql_ir.LogGrammarCoverage("SubPartitionMethod,ColumnNameListOpt")


		keyAlgorithm, _ := $3.(*ast.PartitionKeyAlgorithm)
		$$ = &ast.PartitionMethod{
			Tp:           model.PartitionTypeKey,
			Linear:       len($1) != 0,
			ColumnNames:  $5.([]*ast.ColumnName),
			KeyAlgorithm: keyAlgorithm,
		}
	}
|	LinearOpt "HASH" '(' BitExpr ')'
	{
sql_ir.LogGrammarCoverage("SubPartitionMethod,LinearOpt")
sql_ir.LogGrammarCoverage("SubPartitionMethod,BitExpr")


		$$ = &ast.PartitionMethod{
			Tp:     model.PartitionTypeHash,
			Linear: len($1) != 0,
			Expr:   $4.(ast.ExprNode),
		}
	}

PartitionKeyAlgorithmOpt:
	
	{


		$$ = nil
	}
|	"ALGORITHM" eq NUM
	{
sql_ir.LogGrammarCoverage("PartitionKeyAlgorithmOpt,NUM")


		tp := getUint64FromNUM($3)
		if tp != 1 && tp != 2 {
			yylex.AppendError(ErrSyntax)
			return 1
		}
		$$ = &ast.PartitionKeyAlgorithm{
			Type: tp,
		}
	}

PartitionMethod:
	SubPartitionMethod
{
sql_ir.LogGrammarCoverage("PartitionMethod,SubPartitionMethod")

}
|	"RANGE" '(' BitExpr ')'
	{
sql_ir.LogGrammarCoverage("PartitionMethod,BitExpr")


		$$ = &ast.PartitionMethod{
			Tp:   model.PartitionTypeRange,
			Expr: $3.(ast.ExprNode),
		}
	}
|	"RANGE" FieldsOrColumns '(' ColumnNameList ')'
	{
sql_ir.LogGrammarCoverage("PartitionMethod,FieldsOrColumns")
sql_ir.LogGrammarCoverage("PartitionMethod,ColumnNameList")


		$$ = &ast.PartitionMethod{
			Tp:          model.PartitionTypeRange,
			ColumnNames: $4.([]*ast.ColumnName),
		}
	}
|	"LIST" '(' BitExpr ')'
	{
sql_ir.LogGrammarCoverage("PartitionMethod,BitExpr")


		$$ = &ast.PartitionMethod{
			Tp:   model.PartitionTypeList,
			Expr: $3.(ast.ExprNode),
		}
	}
|	"LIST" FieldsOrColumns '(' ColumnNameList ')'
	{
sql_ir.LogGrammarCoverage("PartitionMethod,FieldsOrColumns")
sql_ir.LogGrammarCoverage("PartitionMethod,ColumnNameList")


		$$ = &ast.PartitionMethod{
			Tp:          model.PartitionTypeList,
			ColumnNames: $4.([]*ast.ColumnName),
		}
	}
|	"SYSTEM_TIME" "INTERVAL" Expression TimeUnit
	{
sql_ir.LogGrammarCoverage("PartitionMethod,Expression")
sql_ir.LogGrammarCoverage("PartitionMethod,TimeUnit")


		$$ = &ast.PartitionMethod{
			Tp:   model.PartitionTypeSystemTime,
			Expr: $3.(ast.ExprNode),
			Unit: $4.(ast.TimeUnitType),
		}
	}
|	"SYSTEM_TIME" "LIMIT" LengthNum
	{
sql_ir.LogGrammarCoverage("PartitionMethod,LengthNum")


		$$ = &ast.PartitionMethod{
			Tp:    model.PartitionTypeSystemTime,
			Limit: $3.(uint64),
		}
	}
|	"SYSTEM_TIME"
	{


		$$ = &ast.PartitionMethod{
			Tp: model.PartitionTypeSystemTime,
		}
	}

LinearOpt:
	{


		$$ = ""
	}
|	"LINEAR"

{

}
SubPartitionOpt:
	{


		$$ = nil
	}
|	"SUBPARTITION" "BY" SubPartitionMethod SubPartitionNumOpt
	{
sql_ir.LogGrammarCoverage("SubPartitionOpt,SubPartitionMethod")
sql_ir.LogGrammarCoverage("SubPartitionOpt,SubPartitionNumOpt")


		method := $3.(*ast.PartitionMethod)
		method.Num = $4.(uint64)
		$$ = method
	}

SubPartitionNumOpt:
	{


		$$ = uint64(0)
	}
|	"SUBPARTITIONS" LengthNum
	{
sql_ir.LogGrammarCoverage("SubPartitionNumOpt,LengthNum")


		res := $2.(uint64)
		if res == 0 {
			yylex.AppendError(ast.ErrNoParts.GenWithStackByArgs("subpartitions"))
			return 1
		}
		$$ = res
	}

PartitionNumOpt:
	{


		$$ = uint64(0)
	}
|	"PARTITIONS" LengthNum
	{
sql_ir.LogGrammarCoverage("PartitionNumOpt,LengthNum")


		res := $2.(uint64)
		if res == 0 {
			yylex.AppendError(ast.ErrNoParts.GenWithStackByArgs("partitions"))
			return 1
		}
		$$ = res
	}

PartitionDefinitionListOpt:
	 %prec lowerThanCreateTableSelect
	{


		$$ = nil
	}
|	'(' PartitionDefinitionList ')'
	{
sql_ir.LogGrammarCoverage("PartitionDefinitionListOpt,PartitionDefinitionList")


		$$ = $2.([]*ast.PartitionDefinition)
	}

PartitionDefinitionList:
	PartitionDefinition
	{
sql_ir.LogGrammarCoverage("PartitionDefinitionList,PartitionDefinition")


		$$ = []*ast.PartitionDefinition{$1.(*ast.PartitionDefinition)}
	}
|	PartitionDefinitionList ',' PartitionDefinition
	{
sql_ir.LogGrammarCoverage("PartitionDefinitionList,PartitionDefinitionList")
sql_ir.LogGrammarCoverage("PartitionDefinitionList,PartitionDefinition")


		$$ = append($1.([]*ast.PartitionDefinition), $3.(*ast.PartitionDefinition))
	}

PartitionDefinition:
	"PARTITION" Identifier PartDefValuesOpt PartDefOptionList SubPartDefinitionListOpt
	{
sql_ir.LogGrammarCoverage("PartitionDefinition,Identifier")
sql_ir.LogGrammarCoverage("PartitionDefinition,PartDefValuesOpt")
sql_ir.LogGrammarCoverage("PartitionDefinition,PartDefOptionList")
sql_ir.LogGrammarCoverage("PartitionDefinition,SubPartDefinitionListOpt")


		$$ = &ast.PartitionDefinition{
			Name:    model.NewCIStr($2),
			Clause:  $3.(ast.PartitionDefinitionClause),
			Options: $4.([]*ast.TableOption),
			Sub:     $5.([]*ast.SubPartitionDefinition),
		}
	}

SubPartDefinitionListOpt:
	
	{


		$$ = make([]*ast.SubPartitionDefinition, 0)
	}
|	'(' SubPartDefinitionList ')'
	{
sql_ir.LogGrammarCoverage("SubPartDefinitionListOpt,SubPartDefinitionList")


		$$ = $2
	}

SubPartDefinitionList:
	SubPartDefinition
	{
sql_ir.LogGrammarCoverage("SubPartDefinitionList,SubPartDefinition")


		$$ = []*ast.SubPartitionDefinition{$1.(*ast.SubPartitionDefinition)}
	}
|	SubPartDefinitionList ',' SubPartDefinition
	{
sql_ir.LogGrammarCoverage("SubPartDefinitionList,SubPartDefinitionList")
sql_ir.LogGrammarCoverage("SubPartDefinitionList,SubPartDefinition")


		list := $1.([]*ast.SubPartitionDefinition)
		$$ = append(list, $3.(*ast.SubPartitionDefinition))
	}

SubPartDefinition:
	"SUBPARTITION" Identifier PartDefOptionList
	{
sql_ir.LogGrammarCoverage("SubPartDefinition,Identifier")
sql_ir.LogGrammarCoverage("SubPartDefinition,PartDefOptionList")


		$$ = &ast.SubPartitionDefinition{
			Name:    model.NewCIStr($2),
			Options: $3.([]*ast.TableOption),
		}
	}

PartDefOptionList:
	
	{


		$$ = make([]*ast.TableOption, 0)
	}
|	PartDefOptionList PartDefOption
	{
sql_ir.LogGrammarCoverage("PartDefOptionList,PartDefOptionList")
sql_ir.LogGrammarCoverage("PartDefOptionList,PartDefOption")


		list := $1.([]*ast.TableOption)
		$$ = append(list, $2.(*ast.TableOption))
	}

PartDefOption:
	"COMMENT" EqOpt stringLit
	{
sql_ir.LogGrammarCoverage("PartDefOption,EqOpt")
sql_ir.LogGrammarCoverage("PartDefOption,stringLit")


		$$ = &ast.TableOption{Tp: ast.TableOptionComment, StrValue: $3}
	}
|	"ENGINE" EqOpt StringName
	{
sql_ir.LogGrammarCoverage("PartDefOption,EqOpt")
sql_ir.LogGrammarCoverage("PartDefOption,StringName")


		$$ = &ast.TableOption{Tp: ast.TableOptionEngine, StrValue: $3}
	}
|	"STORAGE" "ENGINE" EqOpt StringName
	{
sql_ir.LogGrammarCoverage("PartDefOption,EqOpt")
sql_ir.LogGrammarCoverage("PartDefOption,StringName")


		$$ = &ast.TableOption{Tp: ast.TableOptionEngine, StrValue: $4}
	}
|	"INSERT_METHOD" EqOpt StringName
	{
sql_ir.LogGrammarCoverage("PartDefOption,EqOpt")
sql_ir.LogGrammarCoverage("PartDefOption,StringName")


		$$ = &ast.TableOption{Tp: ast.TableOptionInsertMethod, StrValue: $3}
	}
|	"DATA" "DIRECTORY" EqOpt stringLit
	{
sql_ir.LogGrammarCoverage("PartDefOption,EqOpt")
sql_ir.LogGrammarCoverage("PartDefOption,stringLit")


		$$ = &ast.TableOption{Tp: ast.TableOptionDataDirectory, StrValue: $4}
	}
|	"INDEX" "DIRECTORY" EqOpt stringLit
	{
sql_ir.LogGrammarCoverage("PartDefOption,EqOpt")
sql_ir.LogGrammarCoverage("PartDefOption,stringLit")


		$$ = &ast.TableOption{Tp: ast.TableOptionIndexDirectory, StrValue: $4}
	}
|	"MAX_ROWS" EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("PartDefOption,EqOpt")
sql_ir.LogGrammarCoverage("PartDefOption,LengthNum")


		$$ = &ast.TableOption{Tp: ast.TableOptionMaxRows, UintValue: $3.(uint64)}
	}
|	"MIN_ROWS" EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("PartDefOption,EqOpt")
sql_ir.LogGrammarCoverage("PartDefOption,LengthNum")


		$$ = &ast.TableOption{Tp: ast.TableOptionMinRows, UintValue: $3.(uint64)}
	}
|	"TABLESPACE" EqOpt Identifier
	{
sql_ir.LogGrammarCoverage("PartDefOption,EqOpt")
sql_ir.LogGrammarCoverage("PartDefOption,Identifier")


		$$ = &ast.TableOption{Tp: ast.TableOptionTablespace, StrValue: $3}
	}
|	"NODEGROUP" EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("PartDefOption,EqOpt")
sql_ir.LogGrammarCoverage("PartDefOption,LengthNum")


		$$ = &ast.TableOption{Tp: ast.TableOptionNodegroup, UintValue: $3.(uint64)}
	}
|	PlacementPolicyOption
	{
sql_ir.LogGrammarCoverage("PartDefOption,PlacementPolicyOption")


		placementOptions := $1.(*ast.PlacementOption)
		$$ = &ast.TableOption{
			// offset trick, enums are identical but of different type
			Tp:        ast.TableOptionType(placementOptions.Tp),
			StrValue:  placementOptions.StrValue,
			UintValue: placementOptions.UintValue,
		}
	}

PartDefValuesOpt:
	{


		$$ = &ast.PartitionDefinitionClauseNone{}
	}
|	"VALUES" "LESS" "THAN" "MAXVALUE"
	{


		$$ = &ast.PartitionDefinitionClauseLessThan{
			Exprs: []ast.ExprNode{&ast.MaxValueExpr{}},
		}
	}
|	"VALUES" "LESS" "THAN" '(' MaxValueOrExpressionList ')'
	{
sql_ir.LogGrammarCoverage("PartDefValuesOpt,MaxValueOrExpressionList")


		$$ = &ast.PartitionDefinitionClauseLessThan{
			Exprs: $5.([]ast.ExprNode),
		}
	}
|	"DEFAULT"
	{


		$$ = &ast.PartitionDefinitionClauseIn{}
	}
|	"VALUES" "IN" '(' MaxValueOrExpressionList ')'
	{
sql_ir.LogGrammarCoverage("PartDefValuesOpt,MaxValueOrExpressionList")


		exprs := $4.([]ast.ExprNode)
		values := make([][]ast.ExprNode, 0, len(exprs))
		for _, expr := range exprs {
			if row, ok := expr.(*ast.RowExpr); ok {
				values = append(values, row.Values)
			} else {
				values = append(values, []ast.ExprNode{expr})
			}
		}
		$$ = &ast.PartitionDefinitionClauseIn{Values: values}
	}
|	"HISTORY"
	{


		$$ = &ast.PartitionDefinitionClauseHistory{Current: false}
	}
|	"CURRENT"
	{


		$$ = &ast.PartitionDefinitionClauseHistory{Current: true}
	}

DuplicateOpt:
	{


		$$ = ast.OnDuplicateKeyHandlingError
	}
|	"IGNORE"
	{


		$$ = ast.OnDuplicateKeyHandlingIgnore
	}
|	"REPLACE"
	{


		$$ = ast.OnDuplicateKeyHandlingReplace
	}

AsOpt:
	{

}
|	"AS"
	{

}

CreateTableSelectOpt:
	
	{


		$$ = &ast.CreateTableStmt{}
	}
|	SetOprStmt
	{
sql_ir.LogGrammarCoverage("CreateTableSelectOpt,SetOprStmt")


		$$ = &ast.CreateTableStmt{Select: $1.(ast.ResultSetNode)}
	}
|	SelectStmt
	{
sql_ir.LogGrammarCoverage("CreateTableSelectOpt,SelectStmt")


		$$ = &ast.CreateTableStmt{Select: $1.(ast.ResultSetNode)}
	}
|	SelectStmtWithClause
	{
sql_ir.LogGrammarCoverage("CreateTableSelectOpt,SelectStmtWithClause")


		$$ = &ast.CreateTableStmt{Select: $1.(ast.ResultSetNode)}
	}
|	SubSelect
	{
sql_ir.LogGrammarCoverage("CreateTableSelectOpt,SubSelect")


		var sel ast.ResultSetNode
		switch x := $1.(*ast.SubqueryExpr).Query.(type) {
		case *ast.SelectStmt:
			x.IsInBraces = true
			sel = x
		case *ast.SetOprStmt:
			x.IsInBraces = true
			sel = x
		}
		$$ = &ast.CreateTableStmt{Select: sel}
	}

CreateViewSelectOpt:
	SetOprStmt
{
sql_ir.LogGrammarCoverage("CreateViewSelectOpt,SetOprStmt")

}
|	SelectStmt
{
sql_ir.LogGrammarCoverage("CreateViewSelectOpt,SelectStmt")

}
|	SelectStmtWithClause
{
sql_ir.LogGrammarCoverage("CreateViewSelectOpt,SelectStmtWithClause")

}
|	SubSelect
	{
sql_ir.LogGrammarCoverage("CreateViewSelectOpt,SubSelect")


		var sel ast.StmtNode
		switch x := $1.(*ast.SubqueryExpr).Query.(type) {
		case *ast.SelectStmt:
			x.IsInBraces = true
			sel = x
		case *ast.SetOprStmt:
			x.IsInBraces = true
			sel = x
		}
		$$ = sel
	}

LikeTableWithOrWithoutParen:
	"LIKE" TableName
	{
sql_ir.LogGrammarCoverage("LikeTableWithOrWithoutParen,TableName")


		$$ = $2
	}
|	'(' "LIKE" TableName ')'
	{
sql_ir.LogGrammarCoverage("LikeTableWithOrWithoutParen,TableName")


		$$ = $3
	}


CreateViewStmt:
	"CREATE" OrReplace ViewAlgorithm ViewDefiner ViewSQLSecurity "VIEW" ViewName ViewFieldList "AS" CreateViewSelectOpt ViewCheckOption
	{
sql_ir.LogGrammarCoverage("CreateViewStmt,OrReplace")
sql_ir.LogGrammarCoverage("CreateViewStmt,ViewAlgorithm")
sql_ir.LogGrammarCoverage("CreateViewStmt,ViewDefiner")
sql_ir.LogGrammarCoverage("CreateViewStmt,ViewSQLSecurity")
sql_ir.LogGrammarCoverage("CreateViewStmt,ViewName")
sql_ir.LogGrammarCoverage("CreateViewStmt,ViewFieldList")
sql_ir.LogGrammarCoverage("CreateViewStmt,CreateViewSelectOpt")
sql_ir.LogGrammarCoverage("CreateViewStmt,ViewCheckOption")


		startOffset := parser.startOffset(&yyS[yypt-1])
		selStmt := $10.(ast.StmtNode)
		selStmt.SetText(parser.lexer.client, strings.TrimSpace(parser.src[startOffset:]))
		x := &ast.CreateViewStmt{
			OrReplace: $2.(bool),
			ViewName:  $7.(*ast.TableName),
			Select:    selStmt,
			Algorithm: $3.(model.ViewAlgorithm),
			Definer:   $4.(*auth.UserIdentity),
			Security:  $5.(model.ViewSecurity),
		}
		if $8 != nil {
			x.Cols = $8.([]model.CIStr)
		}
		if $11 != nil {
			x.CheckOption = $11.(model.ViewCheckOption)
			endOffset := parser.startOffset(&yyS[yypt])
			selStmt.SetText(parser.lexer.client, strings.TrimSpace(parser.src[startOffset:endOffset]))
		} else {
			x.CheckOption = model.CheckOptionCascaded
		}
		$$ = x
	}

OrReplace:
	/* EMPTY */
	{


		$$ = false
	}
|	"OR" "REPLACE"
	{


		$$ = true
	}

ViewAlgorithm:
	/* EMPTY */
	{


		$$ = model.AlgorithmUndefined
	}
|	"ALGORITHM" "=" "UNDEFINED"
	{


		$$ = model.AlgorithmUndefined
	}
|	"ALGORITHM" "=" "MERGE"
	{


		$$ = model.AlgorithmMerge
	}
|	"ALGORITHM" "=" "TEMPTABLE"
	{


		$$ = model.AlgorithmTemptable
	}

ViewDefiner:
	/* EMPTY */
	{


		$$ = &auth.UserIdentity{CurrentUser: true}
	}
|	"DEFINER" "=" Username
	{
sql_ir.LogGrammarCoverage("ViewDefiner,Username")


		$$ = $3
	}

ViewSQLSecurity:
	/* EMPTY */
	{


		$$ = model.SecurityDefiner
	}
|	"SQL" "SECURITY" "DEFINER"
	{


		$$ = model.SecurityDefiner
	}
|	"SQL" "SECURITY" "INVOKER"
	{


		$$ = model.SecurityInvoker
	}

ViewName:
	TableName

{
sql_ir.LogGrammarCoverage("ViewName,TableName")

}
ViewFieldList:
	/* Empty */
	{
sql_ir.LogGrammarCoverage("ViewFieldList,Empty")


		$$ = nil
	}
|	'(' ColumnList ')'
	{
sql_ir.LogGrammarCoverage("ViewFieldList,ColumnList")


		$$ = $2.([]model.CIStr)
	}

ColumnList:
	Identifier
	{
sql_ir.LogGrammarCoverage("ColumnList,Identifier")


		$$ = []model.CIStr{model.NewCIStr($1)}
	}
|	ColumnList ',' Identifier
	{
sql_ir.LogGrammarCoverage("ColumnList,ColumnList")
sql_ir.LogGrammarCoverage("ColumnList,Identifier")


		$$ = append($1.([]model.CIStr), model.NewCIStr($3))
	}

ViewCheckOption:
	/* EMPTY */
	{


		$$ = nil
	}
|	"WITH" "CASCADED" "CHECK" "OPTION"
	{


		$$ = model.CheckOptionCascaded
	}
|	"WITH" "LOCAL" "CHECK" "OPTION"
	{


		$$ = model.CheckOptionLocal
	}


DoStmt:
	"DO" ExpressionList
	{
sql_ir.LogGrammarCoverage("DoStmt,ExpressionList")


		$$ = &ast.DoStmt{
			Exprs: $2.([]ast.ExprNode),
		}
	}


DeleteWithoutUsingStmt:
	"DELETE" TableOptimizerHintsOpt PriorityOpt QuickOptional IgnoreOptional "FROM" TableName PartitionNameListOpt TableAsNameOpt IndexHintListOpt WhereClauseOptional OrderByOptional LimitClause
	{
sql_ir.LogGrammarCoverage("DeleteWithoutUsingStmt,TableOptimizerHintsOpt")
sql_ir.LogGrammarCoverage("DeleteWithoutUsingStmt,PriorityOpt")
sql_ir.LogGrammarCoverage("DeleteWithoutUsingStmt,QuickOptional")
sql_ir.LogGrammarCoverage("DeleteWithoutUsingStmt,IgnoreOptional")
sql_ir.LogGrammarCoverage("DeleteWithoutUsingStmt,TableName")
sql_ir.LogGrammarCoverage("DeleteWithoutUsingStmt,PartitionNameListOpt")
sql_ir.LogGrammarCoverage("DeleteWithoutUsingStmt,TableAsNameOpt")
sql_ir.LogGrammarCoverage("DeleteWithoutUsingStmt,IndexHintListOpt")
sql_ir.LogGrammarCoverage("DeleteWithoutUsingStmt,WhereClauseOptional")
sql_ir.LogGrammarCoverage("DeleteWithoutUsingStmt,OrderByOptional")
sql_ir.LogGrammarCoverage("DeleteWithoutUsingStmt,LimitClause")


		// Single Table
		tn := $7.(*ast.TableName)
		tn.IndexHints = $10.([]*ast.IndexHint)
		tn.PartitionNames = $8.([]model.CIStr)
		join := &ast.Join{Left: &ast.TableSource{Source: tn, AsName: $9.(model.CIStr)}, Right: nil}
		x := &ast.DeleteStmt{
			TableRefs: &ast.TableRefsClause{TableRefs: join},
			Priority:  $3.(mysql.PriorityEnum),
			Quick:     $4.(bool),
			IgnoreErr: $5.(bool),
		}
		if $2 != nil {
			x.TableHints = $2.([]*ast.TableOptimizerHint)
		}
		if $11 != nil {
			x.Where = $11.(ast.ExprNode)
		}
		if $12 != nil {
			x.Order = $12.(*ast.OrderByClause)
		}
		if $13 != nil {
			x.Limit = $13.(*ast.Limit)
		}

		$$ = x
	}
|	"DELETE" TableOptimizerHintsOpt PriorityOpt QuickOptional IgnoreOptional TableAliasRefList "FROM" TableRefs WhereClauseOptional
	{
sql_ir.LogGrammarCoverage("DeleteWithoutUsingStmt,TableOptimizerHintsOpt")
sql_ir.LogGrammarCoverage("DeleteWithoutUsingStmt,PriorityOpt")
sql_ir.LogGrammarCoverage("DeleteWithoutUsingStmt,QuickOptional")
sql_ir.LogGrammarCoverage("DeleteWithoutUsingStmt,IgnoreOptional")
sql_ir.LogGrammarCoverage("DeleteWithoutUsingStmt,TableAliasRefList")
sql_ir.LogGrammarCoverage("DeleteWithoutUsingStmt,TableRefs")
sql_ir.LogGrammarCoverage("DeleteWithoutUsingStmt,WhereClauseOptional")


		// Multiple Table
		x := &ast.DeleteStmt{
			Priority:     $3.(mysql.PriorityEnum),
			Quick:        $4.(bool),
			IgnoreErr:    $5.(bool),
			IsMultiTable: true,
			BeforeFrom:   true,
			Tables:       &ast.DeleteTableList{Tables: $6.([]*ast.TableName)},
			TableRefs:    &ast.TableRefsClause{TableRefs: $8.(*ast.Join)},
		}
		if $2 != nil {
			x.TableHints = $2.([]*ast.TableOptimizerHint)
		}
		if $9 != nil {
			x.Where = $9.(ast.ExprNode)
		}
		$$ = x
	}

DeleteWithUsingStmt:
	"DELETE" TableOptimizerHintsOpt PriorityOpt QuickOptional IgnoreOptional "FROM" TableAliasRefList "USING" TableRefs WhereClauseOptional
	{
sql_ir.LogGrammarCoverage("DeleteWithUsingStmt,TableOptimizerHintsOpt")
sql_ir.LogGrammarCoverage("DeleteWithUsingStmt,PriorityOpt")
sql_ir.LogGrammarCoverage("DeleteWithUsingStmt,QuickOptional")
sql_ir.LogGrammarCoverage("DeleteWithUsingStmt,IgnoreOptional")
sql_ir.LogGrammarCoverage("DeleteWithUsingStmt,TableAliasRefList")
sql_ir.LogGrammarCoverage("DeleteWithUsingStmt,TableRefs")
sql_ir.LogGrammarCoverage("DeleteWithUsingStmt,WhereClauseOptional")


		// Multiple Table
		x := &ast.DeleteStmt{
			Priority:     $3.(mysql.PriorityEnum),
			Quick:        $4.(bool),
			IgnoreErr:    $5.(bool),
			IsMultiTable: true,
			Tables:       &ast.DeleteTableList{Tables: $7.([]*ast.TableName)},
			TableRefs:    &ast.TableRefsClause{TableRefs: $9.(*ast.Join)},
		}
		if $2 != nil {
			x.TableHints = $2.([]*ast.TableOptimizerHint)
		}
		if $10 != nil {
			x.Where = $10.(ast.ExprNode)
		}
		$$ = x
	}

DeleteFromStmt:
	DeleteWithoutUsingStmt
{
sql_ir.LogGrammarCoverage("DeleteFromStmt,DeleteWithoutUsingStmt")

}
|	DeleteWithUsingStmt
{
sql_ir.LogGrammarCoverage("DeleteFromStmt,DeleteWithUsingStmt")

}
|	WithClause DeleteWithoutUsingStmt
	{
sql_ir.LogGrammarCoverage("DeleteFromStmt,WithClause")
sql_ir.LogGrammarCoverage("DeleteFromStmt,DeleteWithoutUsingStmt")


		d := $2.(*ast.DeleteStmt)
		d.With = $1.(*ast.WithClause)
		$$ = d
	}
|	WithClause DeleteWithUsingStmt
	{
sql_ir.LogGrammarCoverage("DeleteFromStmt,WithClause")
sql_ir.LogGrammarCoverage("DeleteFromStmt,DeleteWithUsingStmt")


		d := $2.(*ast.DeleteStmt)
		d.With = $1.(*ast.WithClause)
		$$ = d
	}

DatabaseSym:
	"DATABASE"

{

}
DropDatabaseStmt:
	"DROP" DatabaseSym IfExists DBName
	{
sql_ir.LogGrammarCoverage("DropDatabaseStmt,DatabaseSym")
sql_ir.LogGrammarCoverage("DropDatabaseStmt,IfExists")
sql_ir.LogGrammarCoverage("DropDatabaseStmt,DBName")


		$$ = &ast.DropDatabaseStmt{IfExists: $3.(bool), Name: $4}
	}


DropIndexStmt:
	"DROP" "INDEX" IfExists Identifier "ON" TableName IndexLockAndAlgorithmOpt
	{
sql_ir.LogGrammarCoverage("DropIndexStmt,IfExists")
sql_ir.LogGrammarCoverage("DropIndexStmt,Identifier")
sql_ir.LogGrammarCoverage("DropIndexStmt,TableName")
sql_ir.LogGrammarCoverage("DropIndexStmt,IndexLockAndAlgorithmOpt")


		var indexLockAndAlgorithm *ast.IndexLockAndAlgorithm
		if $7 != nil {
			indexLockAndAlgorithm = $7.(*ast.IndexLockAndAlgorithm)
			if indexLockAndAlgorithm.LockTp == ast.LockTypeDefault && indexLockAndAlgorithm.AlgorithmTp == ast.AlgorithmTypeDefault {
				indexLockAndAlgorithm = nil
			}
		}
		$$ = &ast.DropIndexStmt{IfExists: $3.(bool), IndexName: $4, Table: $6.(*ast.TableName), LockAlg: indexLockAndAlgorithm}
	}

DropTableStmt:
	"DROP" OptTemporary TableOrTables IfExists TableNameList RestrictOrCascadeOpt
	{
sql_ir.LogGrammarCoverage("DropTableStmt,OptTemporary")
sql_ir.LogGrammarCoverage("DropTableStmt,TableOrTables")
sql_ir.LogGrammarCoverage("DropTableStmt,IfExists")
sql_ir.LogGrammarCoverage("DropTableStmt,TableNameList")
sql_ir.LogGrammarCoverage("DropTableStmt,RestrictOrCascadeOpt")


		$$ = &ast.DropTableStmt{IfExists: $4.(bool), Tables: $5.([]*ast.TableName), IsView: false, TemporaryKeyword: $2.(ast.TemporaryKeyword)}
	}

OptTemporary:
	
	{


		$$ = ast.TemporaryNone
	}
|	"TEMPORARY"
	{


		$$ = ast.TemporaryLocal
	}
|	"GLOBAL" "TEMPORARY"
	{


		$$ = ast.TemporaryGlobal
	}

DropViewStmt:
	"DROP" "VIEW" TableNameList RestrictOrCascadeOpt
	{
sql_ir.LogGrammarCoverage("DropViewStmt,TableNameList")
sql_ir.LogGrammarCoverage("DropViewStmt,RestrictOrCascadeOpt")


		$$ = &ast.DropTableStmt{Tables: $3.([]*ast.TableName), IsView: true}
	}
|	"DROP" "VIEW" "IF" "EXISTS" TableNameList RestrictOrCascadeOpt
	{
sql_ir.LogGrammarCoverage("DropViewStmt,TableNameList")
sql_ir.LogGrammarCoverage("DropViewStmt,RestrictOrCascadeOpt")


		$$ = &ast.DropTableStmt{IfExists: true, Tables: $5.([]*ast.TableName), IsView: true}
	}

DropUserStmt:
	"DROP" "USER" UsernameList
	{
sql_ir.LogGrammarCoverage("DropUserStmt,UsernameList")


		$$ = &ast.DropUserStmt{IsDropRole: false, IfExists: false, UserList: $3.([]*auth.UserIdentity)}
	}
|	"DROP" "USER" "IF" "EXISTS" UsernameList
	{
sql_ir.LogGrammarCoverage("DropUserStmt,UsernameList")


		$$ = &ast.DropUserStmt{IsDropRole: false, IfExists: true, UserList: $5.([]*auth.UserIdentity)}
	}

DropRoleStmt:
	"DROP" "ROLE" RolenameList
	{
sql_ir.LogGrammarCoverage("DropRoleStmt,RolenameList")


		tmp := make([]*auth.UserIdentity, 0, 10)
		roleList := $3.([]*auth.RoleIdentity)
		for _, r := range roleList {
			tmp = append(tmp, &auth.UserIdentity{Username: r.Username, Hostname: r.Hostname})
		}
		$$ = &ast.DropUserStmt{IsDropRole: true, IfExists: false, UserList: tmp}
	}
|	"DROP" "ROLE" "IF" "EXISTS" RolenameList
	{
sql_ir.LogGrammarCoverage("DropRoleStmt,RolenameList")


		tmp := make([]*auth.UserIdentity, 0, 10)
		roleList := $5.([]*auth.RoleIdentity)
		for _, r := range roleList {
			tmp = append(tmp, &auth.UserIdentity{Username: r.Username, Hostname: r.Hostname})
		}
		$$ = &ast.DropUserStmt{IsDropRole: true, IfExists: true, UserList: tmp}
	}

DropStatsStmt:
	"DROP" "STATS" TableName
	{
sql_ir.LogGrammarCoverage("DropStatsStmt,TableName")


		$$ = &ast.DropStatsStmt{Table: $3.(*ast.TableName)}
	}
|	"DROP" "STATS" TableName "PARTITION" PartitionNameList
	{
sql_ir.LogGrammarCoverage("DropStatsStmt,TableName")
sql_ir.LogGrammarCoverage("DropStatsStmt,PartitionNameList")


		$$ = &ast.DropStatsStmt{
			Table:          $3.(*ast.TableName),
			PartitionNames: $5.([]model.CIStr),
		}
	}
|	"DROP" "STATS" TableName "GLOBAL"
	{
sql_ir.LogGrammarCoverage("DropStatsStmt,TableName")


		$$ = &ast.DropStatsStmt{
			Table:         $3.(*ast.TableName),
			IsGlobalStats: true,
		}
	}

RestrictOrCascadeOpt:
	{

}
|	"RESTRICT"
{

}
|	"CASCADE"

{

}
TableOrTables:
	"TABLE"
{

}
|	"TABLES"

{

}
EqOpt:
	{

}
|	eq

{

}
EmptyStmt:
	/* EMPTY */
	{


		$$ = nil
	}

TraceStmt:
	"TRACE" TraceableStmt
	{
sql_ir.LogGrammarCoverage("TraceStmt,TraceableStmt")


		$$ = &ast.TraceStmt{
			Stmt:      $2,
			Format:    "row",
			TracePlan: false,
		}
		startOffset := parser.startOffset(&yyS[yypt])
		$2.SetText(parser.lexer.client, string(parser.src[startOffset:]))
	}
|	"TRACE" "FORMAT" "=" stringLit TraceableStmt
	{
sql_ir.LogGrammarCoverage("TraceStmt,stringLit")
sql_ir.LogGrammarCoverage("TraceStmt,TraceableStmt")


		$$ = &ast.TraceStmt{
			Stmt:      $5,
			Format:    $4,
			TracePlan: false,
		}
		startOffset := parser.startOffset(&yyS[yypt])
		$5.SetText(parser.lexer.client, string(parser.src[startOffset:]))
	}
|	"TRACE" "PLAN" TraceableStmt
	{
sql_ir.LogGrammarCoverage("TraceStmt,TraceableStmt")


		$$ = &ast.TraceStmt{
			Stmt:      $3,
			TracePlan: true,
		}
		startOffset := parser.startOffset(&yyS[yypt])
		$3.SetText(parser.lexer.client, string(parser.src[startOffset:]))
	}
|	"TRACE" "PLAN" "TARGET" "=" stringLit TraceableStmt
	{
sql_ir.LogGrammarCoverage("TraceStmt,stringLit")
sql_ir.LogGrammarCoverage("TraceStmt,TraceableStmt")


		$$ = &ast.TraceStmt{
			Stmt:            $6,
			TracePlan:       true,
			TracePlanTarget: $5,
		}
		startOffset := parser.startOffset(&yyS[yypt])
		$6.SetText(parser.lexer.client, string(parser.src[startOffset:]))
	}

ExplainSym:
	"EXPLAIN"
{

}
|	"DESCRIBE"
{

}
|	"DESC"

{

}
ExplainStmt:
	ExplainSym TableName
	{
sql_ir.LogGrammarCoverage("ExplainStmt,ExplainSym")
sql_ir.LogGrammarCoverage("ExplainStmt,TableName")


		$$ = &ast.ExplainStmt{
			Stmt: &ast.ShowStmt{
				Tp:    ast.ShowColumns,
				Table: $2.(*ast.TableName),
			},
		}
	}
|	ExplainSym TableName ColumnName
	{
sql_ir.LogGrammarCoverage("ExplainStmt,ExplainSym")
sql_ir.LogGrammarCoverage("ExplainStmt,TableName")
sql_ir.LogGrammarCoverage("ExplainStmt,ColumnName")


		$$ = &ast.ExplainStmt{
			Stmt: &ast.ShowStmt{
				Tp:     ast.ShowColumns,
				Table:  $2.(*ast.TableName),
				Column: $3.(*ast.ColumnName),
			},
		}
	}
|	ExplainSym ExplainableStmt
	{
sql_ir.LogGrammarCoverage("ExplainStmt,ExplainSym")
sql_ir.LogGrammarCoverage("ExplainStmt,ExplainableStmt")


		$$ = &ast.ExplainStmt{
			Stmt:   $2,
			Format: "row",
		}
	}
|	ExplainSym "FOR" "CONNECTION" NUM
	{
sql_ir.LogGrammarCoverage("ExplainStmt,ExplainSym")
sql_ir.LogGrammarCoverage("ExplainStmt,NUM")


		$$ = &ast.ExplainForStmt{
			Format:       "row",
			ConnectionID: getUint64FromNUM($4),
		}
	}
|	ExplainSym "FORMAT" "=" stringLit "FOR" "CONNECTION" NUM
	{
sql_ir.LogGrammarCoverage("ExplainStmt,ExplainSym")
sql_ir.LogGrammarCoverage("ExplainStmt,stringLit")
sql_ir.LogGrammarCoverage("ExplainStmt,NUM")


		$$ = &ast.ExplainForStmt{
			Format:       $4,
			ConnectionID: getUint64FromNUM($7),
		}
	}
|	ExplainSym "FORMAT" "=" stringLit ExplainableStmt
	{
sql_ir.LogGrammarCoverage("ExplainStmt,ExplainSym")
sql_ir.LogGrammarCoverage("ExplainStmt,stringLit")
sql_ir.LogGrammarCoverage("ExplainStmt,ExplainableStmt")


		$$ = &ast.ExplainStmt{
			Stmt:   $5,
			Format: $4,
		}
	}
|	ExplainSym "FORMAT" "=" ExplainFormatType "FOR" "CONNECTION" NUM
	{
sql_ir.LogGrammarCoverage("ExplainStmt,ExplainSym")
sql_ir.LogGrammarCoverage("ExplainStmt,ExplainFormatType")
sql_ir.LogGrammarCoverage("ExplainStmt,NUM")


		$$ = &ast.ExplainForStmt{
			Format:       $4,
			ConnectionID: getUint64FromNUM($7),
		}
	}
|	ExplainSym "FORMAT" "=" ExplainFormatType ExplainableStmt
	{
sql_ir.LogGrammarCoverage("ExplainStmt,ExplainSym")
sql_ir.LogGrammarCoverage("ExplainStmt,ExplainFormatType")
sql_ir.LogGrammarCoverage("ExplainStmt,ExplainableStmt")


		$$ = &ast.ExplainStmt{
			Stmt:   $5,
			Format: $4,
		}
	}
|	ExplainSym "ANALYZE" ExplainableStmt
	{
sql_ir.LogGrammarCoverage("ExplainStmt,ExplainSym")
sql_ir.LogGrammarCoverage("ExplainStmt,ExplainableStmt")


		$$ = &ast.ExplainStmt{
			Stmt:    $3,
			Format:  "row",
			Analyze: true,
		}
	}
|	ExplainSym "ANALYZE" "FORMAT" "=" ExplainFormatType ExplainableStmt
	{
sql_ir.LogGrammarCoverage("ExplainStmt,ExplainSym")
sql_ir.LogGrammarCoverage("ExplainStmt,ExplainFormatType")
sql_ir.LogGrammarCoverage("ExplainStmt,ExplainableStmt")


		$$ = &ast.ExplainStmt{
			Stmt:    $6,
			Format:  $5,
			Analyze: true,
		}
	}
|	ExplainSym "ANALYZE" "FORMAT" "=" stringLit ExplainableStmt
	{
sql_ir.LogGrammarCoverage("ExplainStmt,ExplainSym")
sql_ir.LogGrammarCoverage("ExplainStmt,stringLit")
sql_ir.LogGrammarCoverage("ExplainStmt,ExplainableStmt")


		$$ = &ast.ExplainStmt{
			Stmt:    $6,
			Format:  $5,
			Analyze: true,
		}
	}

ExplainFormatType:
	"TRADITIONAL"
{

}
|	"JSON"
{

}
|	"ROW"
{

}
|	"DOT"
{

}
|	"BRIEF"
{

}
|	"VERBOSE"
{

}
|	"TRUE_CARD_COST"


{

}
BRIEStmt:
	"BACKUP" BRIETables "TO" stringLit BRIEOptions
	{
sql_ir.LogGrammarCoverage("BRIEStmt,BRIETables")
sql_ir.LogGrammarCoverage("BRIEStmt,stringLit")
sql_ir.LogGrammarCoverage("BRIEStmt,BRIEOptions")


		stmt := $2.(*ast.BRIEStmt)
		stmt.Kind = ast.BRIEKindBackup
		stmt.Storage = $4
		stmt.Options = $5.([]*ast.BRIEOption)
		$$ = stmt
	}
|	"RESTORE" BRIETables "FROM" stringLit BRIEOptions
	{
sql_ir.LogGrammarCoverage("BRIEStmt,BRIETables")
sql_ir.LogGrammarCoverage("BRIEStmt,stringLit")
sql_ir.LogGrammarCoverage("BRIEStmt,BRIEOptions")


		stmt := $2.(*ast.BRIEStmt)
		stmt.Kind = ast.BRIEKindRestore
		stmt.Storage = $4
		stmt.Options = $5.([]*ast.BRIEOption)
		$$ = stmt
	}

BRIETables:
	DatabaseSym '*'
	{
sql_ir.LogGrammarCoverage("BRIETables,DatabaseSym")


		$$ = &ast.BRIEStmt{}
	}
|	DatabaseSym DBNameList
	{
sql_ir.LogGrammarCoverage("BRIETables,DatabaseSym")
sql_ir.LogGrammarCoverage("BRIETables,DBNameList")


		$$ = &ast.BRIEStmt{Schemas: $2.([]string)}
	}
|	"TABLE" TableNameList
	{
sql_ir.LogGrammarCoverage("BRIETables,TableNameList")


		$$ = &ast.BRIEStmt{Tables: $2.([]*ast.TableName)}
	}

DBNameList:
	DBName
	{
sql_ir.LogGrammarCoverage("DBNameList,DBName")


		$$ = []string{$1}
	}
|	DBNameList ',' DBName
	{
sql_ir.LogGrammarCoverage("DBNameList,DBNameList")
sql_ir.LogGrammarCoverage("DBNameList,DBName")


		$$ = append($1.([]string), $3)
	}

BRIEOptions:
	%prec empty
	{


		$$ = []*ast.BRIEOption{}
	}
|	BRIEOptions BRIEOption
	{
sql_ir.LogGrammarCoverage("BRIEOptions,BRIEOptions")
sql_ir.LogGrammarCoverage("BRIEOptions,BRIEOption")


		$$ = append($1.([]*ast.BRIEOption), $2.(*ast.BRIEOption))
	}

BRIEIntegerOptionName:
	"CONCURRENCY"
	{


		$$ = ast.BRIEOptionConcurrency
	}
|	"RESUME"
	{


		$$ = ast.BRIEOptionResume
	}

BRIEBooleanOptionName:
	"SEND_CREDENTIALS_TO_TIKV"
	{


		$$ = ast.BRIEOptionSendCreds
	}
|	"ONLINE"
	{


		$$ = ast.BRIEOptionOnline
	}
|	"CHECKPOINT"
	{


		$$ = ast.BRIEOptionCheckpoint
	}
|	"SKIP_SCHEMA_FILES"
	{


		$$ = ast.BRIEOptionSkipSchemaFiles
	}
|	"STRICT_FORMAT"
	{


		$$ = ast.BRIEOptionStrictFormat
	}
|	"CSV_NOT_NULL"
	{


		$$ = ast.BRIEOptionCSVNotNull
	}
|	"CSV_BACKSLASH_ESCAPE"
	{


		$$ = ast.BRIEOptionCSVBackslashEscape
	}
|	"CSV_TRIM_LAST_SEPARATORS"
	{


		$$ = ast.BRIEOptionCSVTrimLastSeparators
	}

BRIEStringOptionName:
	"TIKV_IMPORTER"
	{


		$$ = ast.BRIEOptionTiKVImporter
	}
|	"CSV_SEPARATOR"
	{


		$$ = ast.BRIEOptionCSVSeparator
	}
|	"CSV_DELIMITER"
	{


		$$ = ast.BRIEOptionCSVDelimiter
	}
|	"CSV_NULL"
	{


		$$ = ast.BRIEOptionCSVNull
	}

BRIEKeywordOptionName:
	"BACKEND"
	{


		$$ = ast.BRIEOptionBackend
	}
|	"ON_DUPLICATE"
	{


		$$ = ast.BRIEOptionOnDuplicate
	}
|	"ON" "DUPLICATE"
	{


		$$ = ast.BRIEOptionOnDuplicate
	}

BRIEOption:
	BRIEIntegerOptionName EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("BRIEOption,BRIEIntegerOptionName")
sql_ir.LogGrammarCoverage("BRIEOption,EqOpt")
sql_ir.LogGrammarCoverage("BRIEOption,LengthNum")


		$$ = &ast.BRIEOption{
			Tp:        $1.(ast.BRIEOptionType),
			UintValue: $3.(uint64),
		}
	}
|	BRIEBooleanOptionName EqOpt Boolean
	{
sql_ir.LogGrammarCoverage("BRIEOption,BRIEBooleanOptionName")
sql_ir.LogGrammarCoverage("BRIEOption,EqOpt")
sql_ir.LogGrammarCoverage("BRIEOption,Boolean")


		value := uint64(0)
		if $3.(bool) {
			value = 1
		}
		$$ = &ast.BRIEOption{
			Tp:        $1.(ast.BRIEOptionType),
			UintValue: value,
		}
	}
|	BRIEStringOptionName EqOpt stringLit
	{
sql_ir.LogGrammarCoverage("BRIEOption,BRIEStringOptionName")
sql_ir.LogGrammarCoverage("BRIEOption,EqOpt")
sql_ir.LogGrammarCoverage("BRIEOption,stringLit")


		$$ = &ast.BRIEOption{
			Tp:       $1.(ast.BRIEOptionType),
			StrValue: $3,
		}
	}
|	BRIEKeywordOptionName EqOpt StringNameOrBRIEOptionKeyword
	{
sql_ir.LogGrammarCoverage("BRIEOption,BRIEKeywordOptionName")
sql_ir.LogGrammarCoverage("BRIEOption,EqOpt")
sql_ir.LogGrammarCoverage("BRIEOption,StringNameOrBRIEOptionKeyword")


		$$ = &ast.BRIEOption{
			Tp:       $1.(ast.BRIEOptionType),
			StrValue: strings.ToLower($3),
		}
	}
|	"SNAPSHOT" EqOpt LengthNum TimestampUnit "AGO"
	{
sql_ir.LogGrammarCoverage("BRIEOption,EqOpt")
sql_ir.LogGrammarCoverage("BRIEOption,LengthNum")
sql_ir.LogGrammarCoverage("BRIEOption,TimestampUnit")


		unit, err := $4.(ast.TimeUnitType).Duration()
		if err != nil {
			yylex.AppendError(err)
			return 1
		}
		// TODO: check overflow?
		$$ = &ast.BRIEOption{
			Tp:        ast.BRIEOptionBackupTimeAgo,
			UintValue: $3.(uint64) * uint64(unit),
		}
	}
|	"SNAPSHOT" EqOpt stringLit
	// not including this into BRIEStringOptionName to avoid shift/reduce conflict
	{
sql_ir.LogGrammarCoverage("BRIEOption,EqOpt")
sql_ir.LogGrammarCoverage("BRIEOption,stringLit")


		$$ = &ast.BRIEOption{
			Tp:       ast.BRIEOptionBackupTS,
			StrValue: $3,
		}
	}
|	"SNAPSHOT" EqOpt LengthNum
	// not including this into BRIEIntegerOptionName to avoid shift/reduce conflict
	{
sql_ir.LogGrammarCoverage("BRIEOption,EqOpt")
sql_ir.LogGrammarCoverage("BRIEOption,LengthNum")


		$$ = &ast.BRIEOption{
			Tp:        ast.BRIEOptionBackupTSO,
			UintValue: $3.(uint64),
		}
	}
|	"LAST_BACKUP" EqOpt stringLit
	{
sql_ir.LogGrammarCoverage("BRIEOption,EqOpt")
sql_ir.LogGrammarCoverage("BRIEOption,stringLit")


		$$ = &ast.BRIEOption{
			Tp:       ast.BRIEOptionLastBackupTS,
			StrValue: $3,
		}
	}
|	"LAST_BACKUP" EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("BRIEOption,EqOpt")
sql_ir.LogGrammarCoverage("BRIEOption,LengthNum")


		$$ = &ast.BRIEOption{
			Tp:        ast.BRIEOptionLastBackupTSO,
			UintValue: $3.(uint64),
		}
	}
|	"RATE_LIMIT" EqOpt LengthNum "MB" '/' "SECOND"
	{
sql_ir.LogGrammarCoverage("BRIEOption,EqOpt")
sql_ir.LogGrammarCoverage("BRIEOption,LengthNum")


		// TODO: check overflow?
		$$ = &ast.BRIEOption{
			Tp:        ast.BRIEOptionRateLimit,
			UintValue: $3.(uint64) * 1048576,
		}
	}
|	"CSV_HEADER" EqOpt FieldsOrColumns
	{
sql_ir.LogGrammarCoverage("BRIEOption,EqOpt")
sql_ir.LogGrammarCoverage("BRIEOption,FieldsOrColumns")


		$$ = &ast.BRIEOption{
			Tp:        ast.BRIEOptionCSVHeader,
			UintValue: ast.BRIECSVHeaderIsColumns,
		}
	}
|	"CSV_HEADER" EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("BRIEOption,EqOpt")
sql_ir.LogGrammarCoverage("BRIEOption,LengthNum")


		$$ = &ast.BRIEOption{
			Tp:        ast.BRIEOptionCSVHeader,
			UintValue: $3.(uint64),
		}
	}
|	"CHECKSUM" EqOpt Boolean
	{
sql_ir.LogGrammarCoverage("BRIEOption,EqOpt")
sql_ir.LogGrammarCoverage("BRIEOption,Boolean")


		value := uint64(0)
		if $3.(bool) {
			value = 1
		}
		$$ = &ast.BRIEOption{
			Tp:        ast.BRIEOptionChecksum,
			UintValue: value,
		}
	}
|	"CHECKSUM" EqOpt OptionLevel
	{
sql_ir.LogGrammarCoverage("BRIEOption,EqOpt")
sql_ir.LogGrammarCoverage("BRIEOption,OptionLevel")


		$$ = &ast.BRIEOption{
			Tp:        ast.BRIEOptionChecksum,
			UintValue: uint64($3.(ast.BRIEOptionLevel)),
		}
	}
|	"ANALYZE" EqOpt Boolean
	{
sql_ir.LogGrammarCoverage("BRIEOption,EqOpt")
sql_ir.LogGrammarCoverage("BRIEOption,Boolean")


		value := uint64(0)
		if $3.(bool) {
			value = 1
		}
		$$ = &ast.BRIEOption{
			Tp:        ast.BRIEOptionAnalyze,
			UintValue: value,
		}
	}
|	"ANALYZE" EqOpt OptionLevel
	{
sql_ir.LogGrammarCoverage("BRIEOption,EqOpt")
sql_ir.LogGrammarCoverage("BRIEOption,OptionLevel")


		$$ = &ast.BRIEOption{
			Tp:        ast.BRIEOptionAnalyze,
			UintValue: uint64($3.(ast.BRIEOptionLevel)),
		}
	}

LengthNum:
	NUM
	{
sql_ir.LogGrammarCoverage("LengthNum,NUM")


		$$ = getUint64FromNUM($1)
	}

Int64Num:
	NUM
	{
sql_ir.LogGrammarCoverage("Int64Num,NUM")


		v, rangeErrMsg := getInt64FromNUM($1)
		if len(rangeErrMsg) != 0 {
			yylex.AppendError(yylex.Errorf(rangeErrMsg))
			return 1
		}
		$$ = v
	}

NUM:
	intLit

{

}
Boolean:
	NUM
	{
sql_ir.LogGrammarCoverage("Boolean,NUM")


		$$ = $1.(int64) != 0
	}
|	"FALSE"
	{


		$$ = false
	}
|	"TRUE"
	{


		$$ = true
	}

OptionLevel:
	"OFF"
	{


		$$ = ast.BRIEOptionLevelOff
	}
|	"OPTIONAL"
	{


		$$ = ast.BRIEOptionLevelOptional
	}
|	"REQUIRED"
	{


		$$ = ast.BRIEOptionLevelRequired
	}

PurgeImportStmt:
	"PURGE" "IMPORT" NUM
	{
sql_ir.LogGrammarCoverage("PurgeImportStmt,NUM")


		$$ = &ast.PurgeImportStmt{TaskID: getUint64FromNUM($3)}
	}


CreateImportStmt:
	"CREATE" "IMPORT" IfNotExists Identifier "FROM" stringLit ErrorHandling BRIEOptions
	{
sql_ir.LogGrammarCoverage("CreateImportStmt,IfNotExists")
sql_ir.LogGrammarCoverage("CreateImportStmt,Identifier")
sql_ir.LogGrammarCoverage("CreateImportStmt,stringLit")
sql_ir.LogGrammarCoverage("CreateImportStmt,ErrorHandling")
sql_ir.LogGrammarCoverage("CreateImportStmt,BRIEOptions")


		$$ = &ast.CreateImportStmt{
			IfNotExists:   $3.(bool),
			Name:          $4,
			Storage:       $6,
			ErrorHandling: $7.(ast.ErrorHandlingOption),
			Options:       $8.([]*ast.BRIEOption),
		}
	}

StopImportStmt:
	"STOP" "IMPORT" IfRunning Identifier
	{
sql_ir.LogGrammarCoverage("StopImportStmt,IfRunning")
sql_ir.LogGrammarCoverage("StopImportStmt,Identifier")


		$$ = &ast.StopImportStmt{
			IfRunning: $3.(bool),
			Name:      $4,
		}
	}

ResumeImportStmt:
	"RESUME" "IMPORT" IfNotRunning Identifier
	{
sql_ir.LogGrammarCoverage("ResumeImportStmt,IfNotRunning")
sql_ir.LogGrammarCoverage("ResumeImportStmt,Identifier")


		$$ = &ast.ResumeImportStmt{
			IfNotRunning: $3.(bool),
			Name:         $4,
		}
	}

AlterImportStmt:
	"ALTER" "IMPORT" Identifier ErrorHandling BRIEOptions ImportTruncate
	{
sql_ir.LogGrammarCoverage("AlterImportStmt,Identifier")
sql_ir.LogGrammarCoverage("AlterImportStmt,ErrorHandling")
sql_ir.LogGrammarCoverage("AlterImportStmt,BRIEOptions")
sql_ir.LogGrammarCoverage("AlterImportStmt,ImportTruncate")


		s := &ast.AlterImportStmt{
			Name:          $3,
			ErrorHandling: $4.(ast.ErrorHandlingOption),
			Options:       $5.([]*ast.BRIEOption),
		}
		if $6 != nil {
			s.Truncate = $6.(*ast.ImportTruncate)
		}
		$$ = s
	}

DropImportStmt:
	"DROP" "IMPORT" IfExists Identifier
	{
sql_ir.LogGrammarCoverage("DropImportStmt,IfExists")
sql_ir.LogGrammarCoverage("DropImportStmt,Identifier")


		$$ = &ast.DropImportStmt{
			IfExists: $3.(bool),
			Name:     $4,
		}
	}

ShowImportStmt:
	"SHOW" "IMPORT" Identifier OptErrors TableNameListOpt2
	{
sql_ir.LogGrammarCoverage("ShowImportStmt,Identifier")
sql_ir.LogGrammarCoverage("ShowImportStmt,OptErrors")
sql_ir.LogGrammarCoverage("ShowImportStmt,TableNameListOpt2")


		$$ = &ast.ShowImportStmt{
			Name:       $3,
			ErrorsOnly: $4.(bool),
			TableNames: $5.([]*ast.TableName),
		}
	}

IfRunning:
	{


		$$ = false
	}
|	"IF" "RUNNING"
	{


		$$ = true
	}

IfNotRunning:
	{


		$$ = false
	}
|	"IF" NotSym "RUNNING"
	{
sql_ir.LogGrammarCoverage("IfNotRunning,NotSym")


		$$ = true
	}

OptErrors:
	{


		$$ = false
	}
|	"ERRORS"
	{


		$$ = true
	}

ErrorHandling:
	{


		$$ = ast.ErrorHandleError
	}
|	"REPLACE"
	{


		$$ = ast.ErrorHandleReplace
	}
|	"SKIP" "ALL"
	{


		$$ = ast.ErrorHandleSkipAll
	}
|	"SKIP" "CONSTRAINT"
	{


		$$ = ast.ErrorHandleSkipConstraint
	}
|	"SKIP" "DUPLICATE"
	{


		$$ = ast.ErrorHandleSkipDuplicate
	}
|	"SKIP" "STRICT"
	{


		$$ = ast.ErrorHandleSkipStrict
	}

ImportTruncate:
	{


		$$ = nil
	}
|	"TRUNCATE" "ALL" TableNameListOpt2
	{
sql_ir.LogGrammarCoverage("ImportTruncate,TableNameListOpt2")


		$$ = &ast.ImportTruncate{
			IsErrorsOnly: false,
			TableNames:   $3.([]*ast.TableName),
		}
	}
|	"TRUNCATE" "ERRORS" TableNameListOpt2
	{
sql_ir.LogGrammarCoverage("ImportTruncate,TableNameListOpt2")


		$$ = &ast.ImportTruncate{
			IsErrorsOnly: true,
			TableNames:   $3.([]*ast.TableName),
		}
	}

Expression:
	singleAtIdentifier assignmentEq Expression %prec assignmentEq
	{
sql_ir.LogGrammarCoverage("Expression,Expression")


		v := $1
		v = strings.TrimPrefix(v, "@")
		$$ = &ast.VariableExpr{
			Name:     v,
			IsGlobal: false,
			IsSystem: false,
			Value:    $3,
		}
	}
|	Expression logOr Expression %prec pipes
	{
sql_ir.LogGrammarCoverage("Expression,Expression")
sql_ir.LogGrammarCoverage("Expression,logOr")
sql_ir.LogGrammarCoverage("Expression,Expression")


		$$ = &ast.BinaryOperationExpr{Op: opcode.LogicOr, L: $1, R: $3}
	}
|	Expression "XOR" Expression %prec xor
	{
sql_ir.LogGrammarCoverage("Expression,Expression")
sql_ir.LogGrammarCoverage("Expression,Expression")


		$$ = &ast.BinaryOperationExpr{Op: opcode.LogicXor, L: $1, R: $3}
	}
|	Expression logAnd Expression %prec andand
	{
sql_ir.LogGrammarCoverage("Expression,Expression")
sql_ir.LogGrammarCoverage("Expression,logAnd")
sql_ir.LogGrammarCoverage("Expression,Expression")


		$$ = &ast.BinaryOperationExpr{Op: opcode.LogicAnd, L: $1, R: $3}
	}
|	"NOT" Expression %prec not
	{
sql_ir.LogGrammarCoverage("Expression,Expression")


		expr, ok := $2.(*ast.ExistsSubqueryExpr)
		if ok {
			expr.Not = !expr.Not
			$$ = $2
		} else {
			$$ = &ast.UnaryOperationExpr{Op: opcode.Not, V: $2}
		}
	}
|	"MATCH" '(' ColumnNameList ')' "AGAINST" '(' BitExpr FulltextSearchModifierOpt ')'
	{
sql_ir.LogGrammarCoverage("Expression,ColumnNameList")
sql_ir.LogGrammarCoverage("Expression,BitExpr")
sql_ir.LogGrammarCoverage("Expression,FulltextSearchModifierOpt")


		$$ = &ast.MatchAgainst{
			ColumnNames: $3.([]*ast.ColumnName),
			Against:     $7,
			Modifier:    ast.FulltextSearchModifier($8.(int)),
		}
	}
|	BoolPri IsOrNotOp trueKwd %prec is
	{
sql_ir.LogGrammarCoverage("Expression,BoolPri")
sql_ir.LogGrammarCoverage("Expression,IsOrNotOp")


		$$ = &ast.IsTruthExpr{Expr: $1, Not: !$2.(bool), True: int64(1)}
	}
|	BoolPri IsOrNotOp falseKwd %prec is
	{
sql_ir.LogGrammarCoverage("Expression,BoolPri")
sql_ir.LogGrammarCoverage("Expression,IsOrNotOp")


		$$ = &ast.IsTruthExpr{Expr: $1, Not: !$2.(bool), True: int64(0)}
	}
|	BoolPri IsOrNotOp "UNKNOWN" %prec is
	{
sql_ir.LogGrammarCoverage("Expression,BoolPri")
sql_ir.LogGrammarCoverage("Expression,IsOrNotOp")


		
		$$ = &ast.IsNullExpr{Expr: $1, Not: !$2.(bool)}
	}
|	BoolPri

{
sql_ir.LogGrammarCoverage("Expression,BoolPri")

}
MaxValueOrExpression:
	"MAXVALUE"
	{


		$$ = &ast.MaxValueExpr{}
	}
|	BitExpr

{
sql_ir.LogGrammarCoverage("MaxValueOrExpression,BitExpr")

}
FulltextSearchModifierOpt:
	
	{


		$$ = ast.FulltextSearchModifierNaturalLanguageMode
	}
|	"IN" "NATURAL" "LANGUAGE" "MODE"
	{


		$$ = ast.FulltextSearchModifierNaturalLanguageMode
	}
|	"IN" "NATURAL" "LANGUAGE" "MODE" "WITH" "QUERY" "EXPANSION"
	{


		$$ = ast.FulltextSearchModifierNaturalLanguageMode | ast.FulltextSearchModifierWithQueryExpansion
	}
|	"IN" "BOOLEAN" "MODE"
	{


		$$ = ast.FulltextSearchModifierBooleanMode
	}
|	"WITH" "QUERY" "EXPANSION"
	{


		$$ = ast.FulltextSearchModifierWithQueryExpansion
	}

logOr:
	pipesAsOr
{

}
|	"OR"

{

}
logAnd:
	"&&"
{

}
|	"AND"

{

}
ExpressionList:
	Expression
	{
sql_ir.LogGrammarCoverage("ExpressionList,Expression")


		$$ = []ast.ExprNode{$1}
	}
|	ExpressionList ',' Expression
	{
sql_ir.LogGrammarCoverage("ExpressionList,ExpressionList")
sql_ir.LogGrammarCoverage("ExpressionList,Expression")


		$$ = append($1.([]ast.ExprNode), $3)
	}

MaxValueOrExpressionList:
	MaxValueOrExpression
	{
sql_ir.LogGrammarCoverage("MaxValueOrExpressionList,MaxValueOrExpression")


		$$ = []ast.ExprNode{$1}
	}
|	MaxValueOrExpressionList ',' MaxValueOrExpression
	{
sql_ir.LogGrammarCoverage("MaxValueOrExpressionList,MaxValueOrExpressionList")
sql_ir.LogGrammarCoverage("MaxValueOrExpressionList,MaxValueOrExpression")


		$$ = append($1.([]ast.ExprNode), $3)
	}

ExpressionListOpt:
	{


		$$ = []ast.ExprNode{}
	}
|	ExpressionList

{
sql_ir.LogGrammarCoverage("ExpressionListOpt,ExpressionList")

}
FuncDatetimePrecListOpt:
	{


		$$ = []ast.ExprNode{}
	}
|	FuncDatetimePrecList

{
sql_ir.LogGrammarCoverage("FuncDatetimePrecListOpt,FuncDatetimePrecList")

}
FuncDatetimePrecList:
	intLit
	{


		expr := ast.NewValueExpr($1, parser.charset, parser.collation)
		$$ = []ast.ExprNode{expr}
	}

BoolPri:
	BoolPri IsOrNotOp "NULL" %prec is
	{
sql_ir.LogGrammarCoverage("BoolPri,BoolPri")
sql_ir.LogGrammarCoverage("BoolPri,IsOrNotOp")


		$$ = &ast.IsNullExpr{Expr: $1, Not: !$2.(bool)}
	}
|	BoolPri CompareOp PredicateExpr %prec eq
	{
sql_ir.LogGrammarCoverage("BoolPri,BoolPri")
sql_ir.LogGrammarCoverage("BoolPri,CompareOp")
sql_ir.LogGrammarCoverage("BoolPri,PredicateExpr")


		$$ = &ast.BinaryOperationExpr{Op: $2.(opcode.Op), L: $1, R: $3}
	}
|	BoolPri CompareOp AnyOrAll SubSelect %prec eq
	{
sql_ir.LogGrammarCoverage("BoolPri,BoolPri")
sql_ir.LogGrammarCoverage("BoolPri,CompareOp")
sql_ir.LogGrammarCoverage("BoolPri,AnyOrAll")
sql_ir.LogGrammarCoverage("BoolPri,SubSelect")


		sq := $4.(*ast.SubqueryExpr)
		sq.MultiRows = true
		$$ = &ast.CompareSubqueryExpr{Op: $2.(opcode.Op), L: $1, R: sq, All: $3.(bool)}
	}
|	BoolPri CompareOp singleAtIdentifier assignmentEq PredicateExpr %prec assignmentEq
	{
sql_ir.LogGrammarCoverage("BoolPri,BoolPri")
sql_ir.LogGrammarCoverage("BoolPri,CompareOp")
sql_ir.LogGrammarCoverage("BoolPri,PredicateExpr")


		v := $3
		v = strings.TrimPrefix(v, "@")
		variable := &ast.VariableExpr{
			Name:     v,
			IsGlobal: false,
			IsSystem: false,
			Value:    $5,
		}
		$$ = &ast.BinaryOperationExpr{Op: $2.(opcode.Op), L: $1, R: variable}
	}
|	PredicateExpr

{
sql_ir.LogGrammarCoverage("BoolPri,PredicateExpr")

}
CompareOp:
	">="
	{


		$$ = opcode.GE
	}
|	'>'
	{


		$$ = opcode.GT
	}
|	"<="
	{


		$$ = opcode.LE
	}
|	'<'
	{


		$$ = opcode.LT
	}
|	"!="
	{


		$$ = opcode.NE
	}
|	"<>"
	{


		$$ = opcode.NE
	}
|	"="
	{


		$$ = opcode.EQ
	}
|	"<=>"
	{


		$$ = opcode.NullEQ
	}

BetweenOrNotOp:
	"BETWEEN"
	{


		$$ = true
	}
|	NotSym "BETWEEN"
	{
sql_ir.LogGrammarCoverage("BetweenOrNotOp,NotSym")


		$$ = false
	}

IsOrNotOp:
	"IS"
	{


		$$ = true
	}
|	"IS" NotSym
	{
sql_ir.LogGrammarCoverage("IsOrNotOp,NotSym")


		$$ = false
	}

InOrNotOp:
	"IN"
	{


		$$ = true
	}
|	NotSym "IN"
	{
sql_ir.LogGrammarCoverage("InOrNotOp,NotSym")


		$$ = false
	}

LikeOrNotOp:
	"LIKE"
	{


		$$ = true
	}
|	NotSym "LIKE"
	{
sql_ir.LogGrammarCoverage("LikeOrNotOp,NotSym")


		$$ = false
	}

RegexpOrNotOp:
	RegexpSym
	{
sql_ir.LogGrammarCoverage("RegexpOrNotOp,RegexpSym")


		$$ = true
	}
|	NotSym RegexpSym
	{
sql_ir.LogGrammarCoverage("RegexpOrNotOp,NotSym")
sql_ir.LogGrammarCoverage("RegexpOrNotOp,RegexpSym")


		$$ = false
	}

AnyOrAll:
	"ANY"
	{


		$$ = false
	}
|	"SOME"
	{


		$$ = false
	}
|	"ALL"
	{


		$$ = true
	}

PredicateExpr:
	BitExpr InOrNotOp '(' ExpressionList ')'
	{
sql_ir.LogGrammarCoverage("PredicateExpr,BitExpr")
sql_ir.LogGrammarCoverage("PredicateExpr,InOrNotOp")
sql_ir.LogGrammarCoverage("PredicateExpr,ExpressionList")


		$$ = &ast.PatternInExpr{Expr: $1, Not: !$2.(bool), List: $4.([]ast.ExprNode)}
	}
|	BitExpr InOrNotOp SubSelect
	{
sql_ir.LogGrammarCoverage("PredicateExpr,BitExpr")
sql_ir.LogGrammarCoverage("PredicateExpr,InOrNotOp")
sql_ir.LogGrammarCoverage("PredicateExpr,SubSelect")


		sq := $3.(*ast.SubqueryExpr)
		sq.MultiRows = true
		$$ = &ast.PatternInExpr{Expr: $1, Not: !$2.(bool), Sel: sq}
	}
|	BitExpr BetweenOrNotOp BitExpr "AND" PredicateExpr
	{
sql_ir.LogGrammarCoverage("PredicateExpr,BitExpr")
sql_ir.LogGrammarCoverage("PredicateExpr,BetweenOrNotOp")
sql_ir.LogGrammarCoverage("PredicateExpr,BitExpr")
sql_ir.LogGrammarCoverage("PredicateExpr,PredicateExpr")


		$$ = &ast.BetweenExpr{
			Expr:  $1,
			Left:  $3,
			Right: $5,
			Not:   !$2.(bool),
		}
	}
|	BitExpr LikeOrNotOp SimpleExpr LikeEscapeOpt
	{
sql_ir.LogGrammarCoverage("PredicateExpr,BitExpr")
sql_ir.LogGrammarCoverage("PredicateExpr,LikeOrNotOp")
sql_ir.LogGrammarCoverage("PredicateExpr,SimpleExpr")
sql_ir.LogGrammarCoverage("PredicateExpr,LikeEscapeOpt")


		escape := $4
		if len(escape) > 1 {
			yylex.AppendError(ErrWrongArguments.GenWithStackByArgs("ESCAPE"))
			return 1
		} else if len(escape) == 0 {
			escape = "\\"
		}
		$$ = &ast.PatternLikeExpr{
			Expr:    $1,
			Pattern: $3,
			Not:     !$2.(bool),
			Escape:  escape[0],
		}
	}
|	BitExpr RegexpOrNotOp SimpleExpr
	{
sql_ir.LogGrammarCoverage("PredicateExpr,BitExpr")
sql_ir.LogGrammarCoverage("PredicateExpr,RegexpOrNotOp")
sql_ir.LogGrammarCoverage("PredicateExpr,SimpleExpr")


		$$ = &ast.PatternRegexpExpr{Expr: $1, Pattern: $3, Not: !$2.(bool)}
	}
|	BitExpr

{
sql_ir.LogGrammarCoverage("PredicateExpr,BitExpr")

}
RegexpSym:
	"REGEXP"
{

}
|	"RLIKE"

{

}
LikeEscapeOpt:
	%prec empty
	{


		$$ = "\\"
	}
|	"ESCAPE" stringLit
	{
sql_ir.LogGrammarCoverage("LikeEscapeOpt,stringLit")


		$$ = $2
	}

Field:
	'*' %prec '*'
	{


		$$ = &ast.SelectField{WildCard: &ast.WildCardField{}}
	}
|	Identifier '.' '*' %prec '*'
	{
sql_ir.LogGrammarCoverage("Field,Identifier")


		wildCard := &ast.WildCardField{Table: model.NewCIStr($1)}
		$$ = &ast.SelectField{WildCard: wildCard}
	}
|	Identifier '.' Identifier '.' '*' %prec '*'
	{
sql_ir.LogGrammarCoverage("Field,Identifier")
sql_ir.LogGrammarCoverage("Field,Identifier")


		wildCard := &ast.WildCardField{Schema: model.NewCIStr($1), Table: model.NewCIStr($3)}
		$$ = &ast.SelectField{WildCard: wildCard}
	}
|	Expression FieldAsNameOpt
	{
sql_ir.LogGrammarCoverage("Field,Expression")
sql_ir.LogGrammarCoverage("Field,FieldAsNameOpt")


		expr := $1
		asName := $2
		$$ = &ast.SelectField{Expr: expr, AsName: model.NewCIStr(asName)}
	}

FieldAsNameOpt:
	/* EMPTY */
	{


		$$ = ""
	}
|	FieldAsName

{
sql_ir.LogGrammarCoverage("FieldAsNameOpt,FieldAsName")

}
FieldAsName:
	Identifier
{
sql_ir.LogGrammarCoverage("FieldAsName,Identifier")

}
|	"AS" Identifier
	{
sql_ir.LogGrammarCoverage("FieldAsName,Identifier")


		$$ = $2
	}
|	stringLit
{
sql_ir.LogGrammarCoverage("FieldAsName,stringLit")

}
|	"AS" stringLit
	{
sql_ir.LogGrammarCoverage("FieldAsName,stringLit")


		$$ = $2
	}

FieldList:
	Field
	{
sql_ir.LogGrammarCoverage("FieldList,Field")


		field := $1.(*ast.SelectField)
		field.Offset = parser.startOffset(&yyS[yypt])
		$$ = []*ast.SelectField{field}
	}
|	FieldList ',' Field
	{
sql_ir.LogGrammarCoverage("FieldList,FieldList")
sql_ir.LogGrammarCoverage("FieldList,Field")


		fl := $1.([]*ast.SelectField)
		last := fl[len(fl)-1]
		if last.Expr != nil && last.AsName.O == "" {
			lastEnd := parser.endOffset(&yyS[yypt-1])
			last.SetText(parser.lexer.client, parser.src[last.Offset:lastEnd])
		}
		newField := $3.(*ast.SelectField)
		newField.Offset = parser.startOffset(&yyS[yypt])
		$$ = append(fl, newField)
	}

GroupByClause:
	"GROUP" "BY" ByList
	{
sql_ir.LogGrammarCoverage("GroupByClause,ByList")


		$$ = &ast.GroupByClause{Items: $3.([]*ast.ByItem)}
	}

HavingClause:
	{


		$$ = nil
	}
|	"HAVING" Expression
	{
sql_ir.LogGrammarCoverage("HavingClause,Expression")


		$$ = &ast.HavingClause{Expr: $2}
	}

AsOfClauseOpt:
	%prec empty
	{


		$$ = nil
	}
|	AsOfClause

{
sql_ir.LogGrammarCoverage("AsOfClauseOpt,AsOfClause")

}
AsOfClause:
	asof "TIMESTAMP" Expression
	{
sql_ir.LogGrammarCoverage("AsOfClause,Expression")


		$$ = &ast.AsOfClause{
			TsExpr: $3.(ast.ExprNode),
		}
	}

IfExists:
	{


		$$ = false
	}
|	"IF" "EXISTS"
	{


		$$ = true
	}

IfNotExists:
	{


		$$ = false
	}
|	"IF" NotSym "EXISTS"
	{
sql_ir.LogGrammarCoverage("IfNotExists,NotSym")


		$$ = true
	}

IgnoreOptional:
	{


		$$ = false
	}
|	"IGNORE"
	{


		$$ = true
	}

IndexName:
	{


		$$ = &ast.NullString{
			String: "",
			Empty:  false,
		}
	}
|	Identifier
	{
sql_ir.LogGrammarCoverage("IndexName,Identifier")


		$$ = &ast.NullString{
			String: $1,
			Empty:  len($1) == 0,
		}
	}

IndexOptionList:
	{


		$$ = nil
	}
|	IndexOptionList IndexOption
	{
sql_ir.LogGrammarCoverage("IndexOptionList,IndexOptionList")
sql_ir.LogGrammarCoverage("IndexOptionList,IndexOption")


		// Merge the options
		if $1 == nil {
			$$ = $2
		} else {
			opt1 := $1.(*ast.IndexOption)
			opt2 := $2.(*ast.IndexOption)
			if len(opt2.Comment) > 0 {
				opt1.Comment = opt2.Comment
			} else if opt2.Tp != 0 {
				opt1.Tp = opt2.Tp
			} else if opt2.KeyBlockSize > 0 {
				opt1.KeyBlockSize = opt2.KeyBlockSize
			} else if len(opt2.ParserName.O) > 0 {
				opt1.ParserName = opt2.ParserName
			} else if opt2.Visibility != ast.IndexVisibilityDefault {
				opt1.Visibility = opt2.Visibility
			} else if opt2.PrimaryKeyTp != model.PrimaryKeyTypeDefault {
				opt1.PrimaryKeyTp = opt2.PrimaryKeyTp
			}
			$$ = opt1
		}
	}

IndexOption:
	"KEY_BLOCK_SIZE" EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("IndexOption,EqOpt")
sql_ir.LogGrammarCoverage("IndexOption,LengthNum")


		$$ = &ast.IndexOption{
			KeyBlockSize: $3.(uint64),
		}
	}
|	IndexType
	{
sql_ir.LogGrammarCoverage("IndexOption,IndexType")


		$$ = &ast.IndexOption{
			Tp: $1.(model.IndexType),
		}
	}
|	"WITH" "PARSER" Identifier
	{
sql_ir.LogGrammarCoverage("IndexOption,Identifier")


		$$ = &ast.IndexOption{
			ParserName: model.NewCIStr($3),
		}
		yylex.AppendError(yylex.Errorf("The WITH PARASER clause is parsed but ignored by all storage engines."))
		parser.lastErrorAsWarn()
	}
|	"COMMENT" stringLit
	{
sql_ir.LogGrammarCoverage("IndexOption,stringLit")


		$$ = &ast.IndexOption{
			Comment: $2,
		}
	}
|	IndexInvisible
	{
sql_ir.LogGrammarCoverage("IndexOption,IndexInvisible")


		$$ = &ast.IndexOption{
			Visibility: $1.(ast.IndexVisibility),
		}
	}
|	WithClustered
	{
sql_ir.LogGrammarCoverage("IndexOption,WithClustered")


		$$ = &ast.IndexOption{
			PrimaryKeyTp: $1.(model.PrimaryKeyType),
		}
	}


IndexNameAndTypeOpt:
	IndexName
	{
sql_ir.LogGrammarCoverage("IndexNameAndTypeOpt,IndexName")


		$$ = []interface{}{$1, nil}
	}
|	IndexName "USING" IndexTypeName
	{
sql_ir.LogGrammarCoverage("IndexNameAndTypeOpt,IndexName")
sql_ir.LogGrammarCoverage("IndexNameAndTypeOpt,IndexTypeName")


		$$ = []interface{}{$1, $3}
	}
|	Identifier "TYPE" IndexTypeName
	{
sql_ir.LogGrammarCoverage("IndexNameAndTypeOpt,Identifier")
sql_ir.LogGrammarCoverage("IndexNameAndTypeOpt,IndexTypeName")


		$$ = []interface{}{&ast.NullString{String: $1, Empty: len($1) == 0}, $3}
	}

IndexTypeOpt:
	{


		$$ = nil
	}
|	IndexType

{
sql_ir.LogGrammarCoverage("IndexTypeOpt,IndexType")

}
IndexType:
	"USING" IndexTypeName
	{
sql_ir.LogGrammarCoverage("IndexType,IndexTypeName")


		$$ = $2
	}
|	"TYPE" IndexTypeName
	{
sql_ir.LogGrammarCoverage("IndexType,IndexTypeName")


		$$ = $2
	}

IndexTypeName:
	"BTREE"
	{


		$$ = model.IndexTypeBtree
	}
|	"HASH"
	{


		$$ = model.IndexTypeHash
	}
|	"RTREE"
	{


		$$ = model.IndexTypeRtree
	}

IndexInvisible:
	"VISIBLE"
	{


		$$ = ast.IndexVisibilityVisible
	}
|	"INVISIBLE"
	{


		$$ = ast.IndexVisibilityInvisible
	}


Identifier:
	identifier
{

}
|	UnReservedKeyword
{
sql_ir.LogGrammarCoverage("Identifier,UnReservedKeyword")

}
|	NotKeywordToken
{
sql_ir.LogGrammarCoverage("Identifier,NotKeywordToken")

}
|	TiDBKeyword

{
sql_ir.LogGrammarCoverage("Identifier,TiDBKeyword")

}
UnReservedKeyword:
	"ACTION"
{

}
|	"ADVISE"
{

}
|	"ASCII"
{

}
|	"ATTRIBUTES"
{

}
|	"BINDING_CACHE"
{

}
|	"STATS_OPTIONS"
{

}
|	"STATS_SAMPLE_RATE"
{

}
|	"STATS_COL_CHOICE"
{

}
|	"STATS_COL_LIST"
{

}
|	"AUTO_ID_CACHE"
{

}
|	"AUTO_INCREMENT"
{

}
|	"AFTER"
{

}
|	"ALWAYS"
{

}
|	"AVG"
{

}
|	"BEGIN"
{

}
|	"BIT"
{

}
|	"BOOL"
{

}
|	"BOOLEAN"
{

}
|	"BTREE"
{

}
|	"BYTE"
{

}
|	"CAPTURE"
{

}
|	"CAUSAL"
{

}
|	"CLEANUP"
{

}
|	"CHAIN"
{

}
|	"CHARSET"
{

}
|	"COLUMNS"
{

}
|	"CONFIG"
{

}
|	"SAN"
{

}
|	"COMMIT"
{

}
|	"COMPACT"
{

}
|	"COMPRESSED"
{

}
|	"CONSISTENCY"
{

}
|	"CONSISTENT"
{

}
|	"CURRENT"
{

}
|	"DATA"
{

}
|	"DATE" %prec lowerThanStringLitToken
{

}
|	"DATETIME"
{

}
|	"DAY"
{

}
|	"DEALLOCATE"
{

}
|	"DO"
{

}
|	"DUPLICATE"
{

}
|	"DYNAMIC"
{

}
|	"ENCRYPTION"
{

}
|	"END"
{

}
|	"ENFORCED"
{

}
|	"ENGINE"
{

}
|	"ENGINES"
{

}
|	"ENUM"
{

}
|	"ERROR"
{

}
|	"ERRORS"
{

}
|	"ESCAPE"
{

}
|	"EVOLVE"
{

}
|	"EXECUTE"
{

}
|	"EXTENDED"
{

}
|	"FIELDS"
{

}
|	"FILE"
{

}
|	"FIRST"
{

}
|	"FIXED"
{

}
|	"FLUSH"
{

}
|	"FOLLOWING"
{

}
|	"FORMAT"
{

}
|	"FULL"
{

}
|	"GENERAL"
{

}
|	"GLOBAL"
{

}
|	"HASH"
{

}
|	"HELP"
{

}
|	"HOUR"
{

}
|	"INSERT_METHOD"
{

}
|	"LESS"
{

}
|	"LOCAL"
{

}
|	"LAST"
{

}
|	"NAMES"
{

}
|	"NVARCHAR"
{

}
|	"OFFSET"
{

}
|	"PACK_KEYS"
{

}
|	"PARSER"
{

}
|	"PASSWORD" %prec lowerThanEq
{

}
|	"PREPARE"
{

}
|	"PRE_SPLIT_REGIONS"
{

}
|	"PROXY"
{

}
|	"QUICK"
{

}
|	"REBUILD"
{

}
|	"REDUNDANT"
{

}
|	"REORGANIZE"
{

}
|	"RESTART"
{

}
|	"ROLE"
{

}
|	"ROLLBACK"
{

}
|	"SESSION"
{

}
|	"SIGNED"
{

}
|	"SHARD_ROW_ID_BITS"
{

}
|	"SHUTDOWN"
{

}
|	"SNAPSHOT"
{

}
|	"START"
{

}
|	"STATUS"
{

}
|	"OPEN"
{

}
|	"SUBPARTITIONS"
{

}
|	"SUBPARTITION"
{

}
|	"TABLES"
{

}
|	"TABLESPACE"
{

}
|	"TEXT"
{

}
|	"THAN"
{

}
|	"TIME" %prec lowerThanStringLitToken
{

}
|	"TIMESTAMP" %prec lowerThanStringLitToken
{

}
|	"TRACE"
{

}
|	"TRANSACTION"
{

}
|	"TRUNCATE"
{

}
|	"UNBOUNDED"
{

}
|	"UNKNOWN"
{

}
|	"VALUE" %prec lowerThanValueKeyword
{

}
|	"WARNINGS"
{

}
|	"YEAR"
{

}
|	"MODE"
{

}
|	"WEEK"
{

}
|	"WEIGHT_STRING"
{

}
|	"ANY"
{

}
|	"SOME"
{

}
|	"USER"
{

}
|	"IDENTIFIED"
{

}
|	"COLLATION"
{

}
|	"COMMENT"
{

}
|	"AVG_ROW_LENGTH"
{

}
|	"CONNECTION"
{

}
|	"CHECKSUM"
{

}
|	"COMPRESSION"
{

}
|	"KEY_BLOCK_SIZE"
{

}
|	"MASTER"
{

}
|	"MAX_ROWS"
{

}
|	"MIN_ROWS"
{

}
|	"NATIONAL"
{

}
|	"NCHAR"
{

}
|	"ROW_FORMAT"
{

}
|	"QUARTER"
{

}
|	"GRANTS"
{

}
|	"TRIGGERS"
{

}
|	"DELAY_KEY_WRITE"
{

}
|	"ISOLATION"
{

}
|	"JSON"
{

}
|	"REPEATABLE"
{

}
|	"RESPECT"
{

}
|	"COMMITTED"
{

}
|	"UNCOMMITTED"
{

}
|	"ONLY"
{

}
|	"SERIAL"
{

}
|	"SERIALIZABLE"
{

}
|	"LEVEL"
{

}
|	"VARIABLES"
{

}
|	"SQL_CACHE"
{

}
|	"INDEXES"
{

}
|	"PROCESSLIST"
{

}
|	"SQL_NO_CACHE"
{

}
|	"DISABLE"
{

}
|	"DISABLED"
{

}
|	"ENABLE"
{

}
|	"ENABLED"
{

}
|	"REVERSE"
{

}
|	"PRIVILEGES"
{

}
|	"NO"
{

}
|	"BINLOG"
{

}
|	"FUNCTION"
{

}
|	"VIEW"
{

}
|	"BINDING"
{

}
|	"BINDINGS"
{

}
|	"MODIFY"
{

}
|	"EVENTS"
{

}
|	"PARTITIONS"
{

}
|	"NONE"
{

}
|	"NULLS"
{

}
|	"SUPER"
{

}
|	"EXCLUSIVE"
{

}
|	"STATS_PERSISTENT"
{

}
|	"STATS_AUTO_RECALC"
{

}
|	"ROW_COUNT"
{

}
|	"COALESCE"
{

}
|	"MONTH"
{

}
|	"PROCESS"
{

}
|	"PROFILE"
{

}
|	"PROFILES"
{

}
|	"MICROSECOND"
{

}
|	"MINUTE"
{

}
|	"PLUGINS"
{

}
|	"PRECEDING"
{

}
|	"QUERY"
{

}
|	"QUERIES"
{

}
|	"SECOND"
{

}
|	"SEPARATOR"
{

}
|	"SHARE"
{

}
|	"SHARED"
{

}
|	"SLOW"
{

}
|	"MAX_CONNECTIONS_PER_HOUR"
{

}
|	"MAX_QUERIES_PER_HOUR"
{

}
|	"MAX_UPDATES_PER_HOUR"
{

}
|	"MAX_USER_CONNECTIONS"
{

}
|	"REPLICATION"
{

}
|	"CLIENT"
{

}
|	"SLAVE"
{

}
|	"RELOAD"
{

}
|	"TEMPORARY"
{

}
|	"ROUTINE"
{

}
|	"EVENT"
{

}
|	"ALGORITHM"
{

}
|	"DEFINER"
{

}
|	"INVOKER"
{

}
|	"MERGE"
{

}
|	"TEMPTABLE"
{

}
|	"UNDEFINED"
{

}
|	"SECURITY"
{

}
|	"CASCADED"
{

}
|	"RECOVER"
{

}
|	"CIPHER"
{

}
|	"SUBJECT"
{

}
|	"ISSUER"
{

}
|	"X509"
{

}
|	"NEVER"
{

}
|	"EXPIRE"
{

}
|	"ACCOUNT"
{

}
|	"INCREMENTAL"
{

}
|	"CPU"
{

}
|	"MEMORY"
{

}
|	"BLOCK"
{

}
|	"IO"
{

}
|	"CONTEXT"
{

}
|	"SWITCHES"
{

}
|	"PAGE"
{

}
|	"FAULTS"
{

}
|	"IPC"
{

}
|	"SWAPS"
{

}
|	"SOURCE"
{

}
|	"TRADITIONAL"
{

}
|	"SQL_BUFFER_RESULT"
{

}
|	"DIRECTORY"
{

}
|	"HISTOGRAM"
{

}
|	"HISTORY"
{

}
|	"LIST"
{

}
|	"NODEGROUP"
{

}
|	"SYSTEM_TIME"
{

}
|	"PARTIAL"
{

}
|	"SIMPLE"
{

}
|	"REMOVE"
{

}
|	"PARTITIONING"
{

}
|	"STORAGE"
{

}
|	"DISK"
{

}
|	"STATS_SAMPLE_PAGES"
{

}
|	"SECONDARY_ENGINE"
{

}
|	"SECONDARY_LOAD"
{

}
|	"SECONDARY_UNLOAD"
{

}
|	"VALIDATION"
{

}
|	"WITHOUT"
{

}
|	"RTREE"
{

}
|	"EXCHANGE"
{

}
|	"COLUMN_FORMAT"
{

}
|	"REPAIR"
{

}
|	"IMPORT"
{

}
|	"IMPORTS"
{

}
|	"DISCARD"
{

}
|	"TABLE_CHECKSUM"
{

}
|	"UNICODE"
{

}
|	"AUTO_RANDOM"
{

}
|	"AUTO_RANDOM_BASE"
{

}
|	"SQL_TSI_DAY"
{

}
|	"SQL_TSI_HOUR"
{

}
|	"SQL_TSI_MINUTE"
{

}
|	"SQL_TSI_MONTH"
{

}
|	"SQL_TSI_QUARTER"
{

}
|	"SQL_TSI_SECOND"
{

}
|	"LANGUAGE"
{

}
|	"SQL_TSI_WEEK"
{

}
|	"SQL_TSI_YEAR"
{

}
|	"INVISIBLE"
{

}
|	"VISIBLE"
{

}
|	"TYPE"
{

}
|	"NOWAIT"
{

}
|	"INSTANCE"
{

}
|	"REPLICA"
{

}
|	"LOCATION"
{

}
|	"LABELS"
{

}
|	"LOGS"
{

}
|	"HOSTS"
{

}
|	"AGAINST"
{

}
|	"EXPANSION"
{

}
|	"INCREMENT"
{

}
|	"MINVALUE"
{

}
|	"NOMAXVALUE"
{

}
|	"NOMINVALUE"
{

}
|	"NOCACHE"
{

}
|	"CACHE"
{

}
|	"CYCLE"
{

}
|	"NOCYCLE"
{

}
|	"SEQUENCE"
{

}
|	"MAX_MINUTES"
{

}
|	"MAX_IDXNUM"
{

}
|	"PER_TABLE"
{

}
|	"PER_DB"
{

}
|	"NEXT"
{

}
|	"NEXTVAL"
{

}
|	"LASTVAL"
{

}
|	"SETVAL"
{

}
|	"AGO"
{

}
|	"BACKUP"
{

}
|	"BACKUPS"
{

}
|	"CONCURRENCY"
{

}
|	"MB"
{

}
|	"ONLINE"
{

}
|	"RATE_LIMIT"
{

}
|	"RESTORE"
{

}
|	"RESTORES"
{

}
|	"SEND_CREDENTIALS_TO_TIKV"
{

}
|	"LAST_BACKUP"
{

}
|	"CHECKPOINT"
{

}
|	"SKIP_SCHEMA_FILES"
{

}
|	"STRICT_FORMAT"
{

}
|	"BACKEND"
{

}
|	"CSV_BACKSLASH_ESCAPE"
{

}
|	"CSV_NOT_NULL"
{

}
|	"CSV_TRIM_LAST_SEPARATORS"
{

}
|	"CSV_DELIMITER"
{

}
|	"CSV_HEADER"
{

}
|	"CSV_NULL"
{

}
|	"CSV_SEPARATOR"
{

}
|	"ON_DUPLICATE"
{

}
|	"TIKV_IMPORTER"
{

}
|	"REPLICAS"
{

}
|	"POLICY"
{

}
|	"WAIT"
{

}
|	"CLIENT_ERRORS_SUMMARY"
{

}
|	"BERNOULLI"
{

}
|	"SYSTEM"
{

}
|	"PERCENT"
{

}
|	"RESUME"
{

}
|	"OFF"
{

}
|	"OPTIONAL"
{

}
|	"REQUIRED"
{

}
|	"PURGE"
{

}
|	"SKIP"
{

}
|	"LOCKED"
{

}
|	"CLUSTERED"
{

}
|	"NONCLUSTERED"
{

}
|	"PRESERVE"

{

}
TiDBKeyword:
	"ADMIN"
{

}
|	"BATCH"
{

}
|	"BUCKETS"
{

}
|	"BUILTINS"
{

}
|	"CANCEL"
{

}
|	"CARDINALITY"
{

}
|	"CMSKETCH"
{

}
|	"COLUMN_STATS_USAGE"
{

}
|	"CORRELATION"
{

}
|	"DDL"
{

}
|	"DEPENDENCY"
{

}
|	"DEPTH"
{

}
|	"DRAINER"
{

}
|	"JOBS"
{

}
|	"JOB"
{

}
|	"NODE_ID"
{

}
|	"NODE_STATE"
{

}
|	"PUMP"
{

}
|	"SAMPLES"
{

}
|	"SAMPLERATE"
{

}
|	"STATISTICS"
{

}
|	"STATS"
{

}
|	"STATS_META"
{

}
|	"STATS_HISTOGRAMS"
{

}
|	"STATS_TOPN"
{

}
|	"STATS_BUCKETS"
{

}
|	"STATS_HEALTHY"
{

}
|	"HISTOGRAMS_IN_FLIGHT"
{

}
|	"TELEMETRY"
{

}
|	"TELEMETRY_ID"
{

}
|	"TIDB"
{

}
|	"TIFLASH"
{

}
|	"TOPN"
{

}
|	"SPLIT"
{

}
|	"OPTIMISTIC"
{

}
|	"PESSIMISTIC"
{

}
|	"WIDTH"
{

}
|	"REGIONS"
{

}
|	"REGION"
{

}
|	"RESET"
{

}
|	"DRY"
{

}
|	"RUN"

{

}
NotKeywordToken:
	"ADDDATE"
{

}
|	"APPROX_COUNT_DISTINCT"
{

}
|	"APPROX_PERCENTILE"
{

}
|	"BIT_AND"
{

}
|	"BIT_OR"
{

}
|	"BIT_XOR"
{

}
|	"BRIEF"
{

}
|	"CAST"
{

}
|	"COPY"
{

}
|	"CURTIME"
{

}
|	"DATE_ADD"
{

}
|	"DATE_SUB"
{

}
|	"DOT"
{

}
|	"DUMP"
{

}
|	"EXTRACT"
{

}
|	"GET_FORMAT"
{

}
|	"GROUP_CONCAT"
{

}
|	"INPLACE"
{

}
|	"INSTANT"
{

}
|	"INTERNAL"
{

}
|	"MIN"
{

}
|	"MAX"
{

}
|	"NOW"
{

}
|	"RECENT"
{

}
|	"REPLAYER"
{

}
|	"RUNNING"
{

}
|	"PLACEMENT"
{

}
|	"PLAN"
{

}
|	"PLAN_CACHE"
{

}
|	"POSITION"
{

}
|	"PREDICATE"
{

}
|	"S3"
{

}
|	"STRICT"
{

}
|	"SUBDATE"
{

}
|	"SUBSTRING"
{

}
|	"SUM"
{

}
|	"STD"
{

}
|	"STDDEV"
{

}
|	"STDDEV_POP"
{

}
|	"STDDEV_SAMP"
{

}
|	"STOP"
{

}
|	"VARIANCE"
{

}
|	"VAR_POP"
{

}
|	"VAR_SAMP"
{

}
|	"TARGET"
{

}
|	"TIMESTAMPADD"
{

}
|	"TIMESTAMPDIFF"
{

}
|	"TOKUDB_DEFAULT"
{

}
|	"TOKUDB_FAST"
{

}
|	"TOKUDB_LZMA"
{

}
|	"TOKUDB_QUICKLZ"
{

}
|	"TOKUDB_SNAPPY"
{

}
|	"TOKUDB_SMALL"
{

}
|	"TOKUDB_UNCOMPRESSED"
{

}
|	"TOKUDB_ZLIB"
{

}
|	"TOP"
{

}
|	"TRIM"
{

}
|	"NEXT_ROW_ID"
{

}
|	"EXPR_PUSHDOWN_BLACKLIST"
{

}
|	"OPT_RULE_BLACKLIST"
{

}
|	"BOUND"
{

}
|	"EXACT" %prec lowerThanStringLitToken
{

}
|	"STALENESS"
{

}
|	"STRONG"
{

}
|	"FLASHBACK"
{

}
|	"JSON_OBJECTAGG"
{

}
|	"JSON_ARRAYAGG"
{

}
|	"TLS"
{

}
|	"FOLLOWER"
{

}
|	"FOLLOWERS"
{

}
|	"LEADER"
{

}
|	"LEARNER"
{

}
|	"LEARNERS"
{

}
|	"VERBOSE"
{

}
|	"TRUE_CARD_COST"
{

}
|	"VOTER"
{

}
|	"VOTERS"
{

}
|	"CONSTRAINTS"
{

}
|	"PRIMARY_REGION"
{

}
|	"SCHEDULE"
{

}
|	"LEADER_CONSTRAINTS"
{

}
|	"FOLLOWER_CONSTRAINTS"
{

}
|	"LEARNER_CONSTRAINTS"
{

}
|	"VOTER_CONSTRAINTS"


{

}
CallStmt:
	"CALL" ProcedureCall
	{
sql_ir.LogGrammarCoverage("CallStmt,ProcedureCall")


		$$ = &ast.CallStmt{
			Procedure: $2.(*ast.FuncCallExpr),
		}
	}

ProcedureCall:
	identifier
	{


		$$ = &ast.FuncCallExpr{
			Tp:     ast.FuncCallExprTypeGeneric,
			FnName: model.NewCIStr($1),
			Args:   []ast.ExprNode{},
		}
	}
|	Identifier '.' Identifier
	{
sql_ir.LogGrammarCoverage("ProcedureCall,Identifier")
sql_ir.LogGrammarCoverage("ProcedureCall,Identifier")


		$$ = &ast.FuncCallExpr{
			Tp:     ast.FuncCallExprTypeGeneric,
			Schema: model.NewCIStr($1),
			FnName: model.NewCIStr($3),
			Args:   []ast.ExprNode{},
		}
	}
|	identifier '(' ExpressionListOpt ')'
	{
sql_ir.LogGrammarCoverage("ProcedureCall,ExpressionListOpt")


		$$ = &ast.FuncCallExpr{
			Tp:     ast.FuncCallExprTypeGeneric,
			FnName: model.NewCIStr($1),
			Args:   $3.([]ast.ExprNode),
		}
	}
|	Identifier '.' Identifier '(' ExpressionListOpt ')'
	{
sql_ir.LogGrammarCoverage("ProcedureCall,Identifier")
sql_ir.LogGrammarCoverage("ProcedureCall,Identifier")
sql_ir.LogGrammarCoverage("ProcedureCall,ExpressionListOpt")


		$$ = &ast.FuncCallExpr{
			Tp:     ast.FuncCallExprTypeGeneric,
			Schema: model.NewCIStr($1),
			FnName: model.NewCIStr($3),
			Args:   $5.([]ast.ExprNode),
		}
	}


InsertIntoStmt:
	"INSERT" TableOptimizerHintsOpt PriorityOpt IgnoreOptional IntoOpt TableName PartitionNameListOpt InsertValues OnDuplicateKeyUpdate
	{
sql_ir.LogGrammarCoverage("InsertIntoStmt,TableOptimizerHintsOpt")
sql_ir.LogGrammarCoverage("InsertIntoStmt,PriorityOpt")
sql_ir.LogGrammarCoverage("InsertIntoStmt,IgnoreOptional")
sql_ir.LogGrammarCoverage("InsertIntoStmt,IntoOpt")
sql_ir.LogGrammarCoverage("InsertIntoStmt,TableName")
sql_ir.LogGrammarCoverage("InsertIntoStmt,PartitionNameListOpt")
sql_ir.LogGrammarCoverage("InsertIntoStmt,InsertValues")
sql_ir.LogGrammarCoverage("InsertIntoStmt,OnDuplicateKeyUpdate")


		x := $8.(*ast.InsertStmt)
		x.Priority = $3.(mysql.PriorityEnum)
		x.IgnoreErr = $4.(bool)
		// Wraps many layers here so that it can be processed the same way as select statement.
		ts := &ast.TableSource{Source: $6.(*ast.TableName)}
		x.Table = &ast.TableRefsClause{TableRefs: &ast.Join{Left: ts}}
		if $9 != nil {
			x.OnDuplicate = $9.([]*ast.Assignment)
		}
		if $2 != nil {
			x.TableHints = $2.([]*ast.TableOptimizerHint)
		}
		x.PartitionNames = $7.([]model.CIStr)
		$$ = x
	}

IntoOpt:
	{

}
|	"INTO"

{

}
InsertValues:
	'(' ColumnNameListOpt ')' ValueSym ValuesList
	{
sql_ir.LogGrammarCoverage("InsertValues,ColumnNameListOpt")
sql_ir.LogGrammarCoverage("InsertValues,ValueSym")
sql_ir.LogGrammarCoverage("InsertValues,ValuesList")


		$$ = &ast.InsertStmt{
			Columns: $2.([]*ast.ColumnName),
			Lists:   $5.([][]ast.ExprNode),
		}
	}
|	'(' ColumnNameListOpt ')' SetOprStmt
	{
sql_ir.LogGrammarCoverage("InsertValues,ColumnNameListOpt")
sql_ir.LogGrammarCoverage("InsertValues,SetOprStmt")


		$$ = &ast.InsertStmt{Columns: $2.([]*ast.ColumnName), Select: $4.(ast.ResultSetNode)}
	}
|	'(' ColumnNameListOpt ')' SelectStmt
	{
sql_ir.LogGrammarCoverage("InsertValues,ColumnNameListOpt")
sql_ir.LogGrammarCoverage("InsertValues,SelectStmt")


		$$ = &ast.InsertStmt{Columns: $2.([]*ast.ColumnName), Select: $4.(ast.ResultSetNode)}
	}
|	'(' ColumnNameListOpt ')' SelectStmtWithClause
	{
sql_ir.LogGrammarCoverage("InsertValues,ColumnNameListOpt")
sql_ir.LogGrammarCoverage("InsertValues,SelectStmtWithClause")


		$$ = &ast.InsertStmt{Columns: $2.([]*ast.ColumnName), Select: $4.(ast.ResultSetNode)}
	}
|	'(' ColumnNameListOpt ')' SubSelect
	{
sql_ir.LogGrammarCoverage("InsertValues,ColumnNameListOpt")
sql_ir.LogGrammarCoverage("InsertValues,SubSelect")


		var sel ast.ResultSetNode
		switch x := $4.(*ast.SubqueryExpr).Query.(type) {
		case *ast.SelectStmt:
			x.IsInBraces = true
			sel = x
		case *ast.SetOprStmt:
			x.IsInBraces = true
			sel = x
		}
		$$ = &ast.InsertStmt{Columns: $2.([]*ast.ColumnName), Select: sel}
	}
|	ValueSym ValuesList %prec insertValues
	{
sql_ir.LogGrammarCoverage("InsertValues,ValueSym")
sql_ir.LogGrammarCoverage("InsertValues,ValuesList")


		$$ = &ast.InsertStmt{Lists: $2.([][]ast.ExprNode)}
	}
|	SetOprStmt
	{
sql_ir.LogGrammarCoverage("InsertValues,SetOprStmt")


		$$ = &ast.InsertStmt{Select: $1.(ast.ResultSetNode)}
	}
|	SelectStmt
	{
sql_ir.LogGrammarCoverage("InsertValues,SelectStmt")


		$$ = &ast.InsertStmt{Select: $1.(ast.ResultSetNode)}
	}
|	SelectStmtWithClause
	{
sql_ir.LogGrammarCoverage("InsertValues,SelectStmtWithClause")


		$$ = &ast.InsertStmt{Select: $1.(ast.ResultSetNode)}
	}
|	SubSelect
	{
sql_ir.LogGrammarCoverage("InsertValues,SubSelect")


		var sel ast.ResultSetNode
		switch x := $1.(*ast.SubqueryExpr).Query.(type) {
		case *ast.SelectStmt:
			x.IsInBraces = true
			sel = x
		case *ast.SetOprStmt:
			x.IsInBraces = true
			sel = x
		}
		$$ = &ast.InsertStmt{Select: sel}
	}
|	"SET" ColumnSetValueList
	{
sql_ir.LogGrammarCoverage("InsertValues,ColumnSetValueList")


		$$ = &ast.InsertStmt{Setlist: $2.([]*ast.Assignment)}
	}

ValueSym:
	"VALUE"
{

}
|	"VALUES"

{

}
ValuesList:
	RowValue
	{
sql_ir.LogGrammarCoverage("ValuesList,RowValue")


		$$ = [][]ast.ExprNode{$1.([]ast.ExprNode)}
	}
|	ValuesList ',' RowValue
	{
sql_ir.LogGrammarCoverage("ValuesList,ValuesList")
sql_ir.LogGrammarCoverage("ValuesList,RowValue")


		$$ = append($1.([][]ast.ExprNode), $3.([]ast.ExprNode))
	}

RowValue:
	'(' ValuesOpt ')'
	{
sql_ir.LogGrammarCoverage("RowValue,ValuesOpt")


		$$ = $2
	}

ValuesOpt:
	{


		$$ = []ast.ExprNode{}
	}
|	Values

{
sql_ir.LogGrammarCoverage("ValuesOpt,Values")

}
Values:
	Values ',' ExprOrDefault
	{
sql_ir.LogGrammarCoverage("Values,Values")
sql_ir.LogGrammarCoverage("Values,ExprOrDefault")


		$$ = append($1.([]ast.ExprNode), $3)
	}
|	ExprOrDefault
	{
sql_ir.LogGrammarCoverage("Values,ExprOrDefault")


		$$ = []ast.ExprNode{$1}
	}

ExprOrDefault:
	Expression
{
sql_ir.LogGrammarCoverage("ExprOrDefault,Expression")

}
|	"DEFAULT"
	{


		$$ = &ast.DefaultExpr{}
	}

ColumnSetValue:
	ColumnName eq ExprOrDefault
	{
sql_ir.LogGrammarCoverage("ColumnSetValue,ColumnName")
sql_ir.LogGrammarCoverage("ColumnSetValue,ExprOrDefault")


		$$ = &ast.Assignment{
			Column: $1.(*ast.ColumnName),
			Expr:   $3,
		}
	}

ColumnSetValueList:
	{


		$$ = []*ast.Assignment{}
	}
|	ColumnSetValue
	{
sql_ir.LogGrammarCoverage("ColumnSetValueList,ColumnSetValue")


		$$ = []*ast.Assignment{$1.(*ast.Assignment)}
	}
|	ColumnSetValueList ',' ColumnSetValue
	{
sql_ir.LogGrammarCoverage("ColumnSetValueList,ColumnSetValueList")
sql_ir.LogGrammarCoverage("ColumnSetValueList,ColumnSetValue")


		$$ = append($1.([]*ast.Assignment), $3.(*ast.Assignment))
	}


OnDuplicateKeyUpdate:
	{


		$$ = nil
	}
|	"ON" "DUPLICATE" "KEY" "UPDATE" AssignmentList
	{
sql_ir.LogGrammarCoverage("OnDuplicateKeyUpdate,AssignmentList")


		$$ = $5
	}


ReplaceIntoStmt:
	"REPLACE" PriorityOpt IntoOpt TableName PartitionNameListOpt InsertValues
	{
sql_ir.LogGrammarCoverage("ReplaceIntoStmt,PriorityOpt")
sql_ir.LogGrammarCoverage("ReplaceIntoStmt,IntoOpt")
sql_ir.LogGrammarCoverage("ReplaceIntoStmt,TableName")
sql_ir.LogGrammarCoverage("ReplaceIntoStmt,PartitionNameListOpt")
sql_ir.LogGrammarCoverage("ReplaceIntoStmt,InsertValues")


		x := $6.(*ast.InsertStmt)
		x.IsReplace = true
		x.Priority = $2.(mysql.PriorityEnum)
		ts := &ast.TableSource{Source: $4.(*ast.TableName)}
		x.Table = &ast.TableRefsClause{TableRefs: &ast.Join{Left: ts}}
		x.PartitionNames = $5.([]model.CIStr)
		$$ = x
	}

Literal:
	"FALSE"
	{


		$$ = ast.NewValueExpr(false, parser.charset, parser.collation)
	}
|	"NULL"
	{


		$$ = ast.NewValueExpr(nil, parser.charset, parser.collation)
	}
|	"TRUE"
	{


		$$ = ast.NewValueExpr(true, parser.charset, parser.collation)
	}
|	floatLit
	{


		$$ = ast.NewValueExpr($1, parser.charset, parser.collation)
	}
|	decLit
	{


		$$ = ast.NewValueExpr($1, parser.charset, parser.collation)
	}
|	intLit
	{


		$$ = ast.NewValueExpr($1, parser.charset, parser.collation)
	}
|	StringLiteral %prec lowerThanStringLitToken
{
sql_ir.LogGrammarCoverage("Literal,StringLiteral")

}
|	"UNDERSCORE_CHARSET" stringLit
	{
sql_ir.LogGrammarCoverage("Literal,stringLit")


		// See https://dev.mysql.com/doc/refman/5.7/en/charset-literal.html
		co, err := charset.GetDefaultCollationLegacy($1)
		if err != nil {
			yylex.AppendError(ast.ErrUnknownCharacterSet.GenWithStack("Unsupported character introducer: '%-.64s'", $1))
			return 1
		}
		expr := ast.NewValueExpr($2, $1, co)
		tp := expr.GetType()
		tp.SetCharset($1)
		tp.SetCollate(co)
		if tp.GetCollate() == charset.CollationBin {
			tp.AddFlag(mysql.BinaryFlag)
		}
		$$ = expr
	}
|	hexLit
	{


		$$ = ast.NewValueExpr($1, parser.charset, parser.collation)
	}
|	bitLit
	{


		$$ = ast.NewValueExpr($1, parser.charset, parser.collation)
	}
|	"UNDERSCORE_CHARSET" hexLit
	{


		co, err := charset.GetDefaultCollationLegacy($1)
		if err != nil {
			yylex.AppendError(ast.ErrUnknownCharacterSet.GenWithStack("Unsupported character introducer: '%-.64s'", $1))
			return 1
		}
		expr := ast.NewValueExpr($2, $1, co)
		tp := expr.GetType()
		tp.SetCharset($1)
		tp.SetCollate(co)
		if tp.GetCollate() == charset.CollationBin {
			tp.AddFlag(mysql.BinaryFlag)
		}
		$$ = expr
	}
|	"UNDERSCORE_CHARSET" bitLit
	{


		co, err := charset.GetDefaultCollationLegacy($1)
		if err != nil {
			yylex.AppendError(ast.ErrUnknownCharacterSet.GenWithStack("Unsupported character introducer: '%-.64s'", $1))
			return 1
		}
		expr := ast.NewValueExpr($2, $1, co)
		tp := expr.GetType()
		tp.SetCharset($1)
		tp.SetCollate(co)
		if tp.GetCollate() == charset.CollationBin {
			tp.AddFlag(mysql.BinaryFlag)
		}
		$$ = expr
	}

StringLiteral:
	stringLit
	{
sql_ir.LogGrammarCoverage("StringLiteral,stringLit")


		expr := ast.NewValueExpr($1, parser.charset, parser.collation)
		$$ = expr
	}
|	StringLiteral stringLit
	{
sql_ir.LogGrammarCoverage("StringLiteral,StringLiteral")
sql_ir.LogGrammarCoverage("StringLiteral,stringLit")


		valExpr := $1.(ast.ValueExpr)
		strLit := valExpr.GetString()
		expr := ast.NewValueExpr(strLit+$2, parser.charset, parser.collation)
		// Fix #4239, use first string literal as projection name.
		if valExpr.GetProjectionOffset() >= 0 {
			expr.SetProjectionOffset(valExpr.GetProjectionOffset())
		} else {
			expr.SetProjectionOffset(len(strLit))
		}
		$$ = expr
	}

AlterOrderList:
	AlterOrderItem
	{
sql_ir.LogGrammarCoverage("AlterOrderList,AlterOrderItem")


		$$ = []*ast.AlterOrderItem{$1.(*ast.AlterOrderItem)}
	}
|	AlterOrderList ',' AlterOrderItem
	{
sql_ir.LogGrammarCoverage("AlterOrderList,AlterOrderList")
sql_ir.LogGrammarCoverage("AlterOrderList,AlterOrderItem")


		$$ = append($1.([]*ast.AlterOrderItem), $3.(*ast.AlterOrderItem))
	}

AlterOrderItem:
	ColumnName OptOrder
	{
sql_ir.LogGrammarCoverage("AlterOrderItem,ColumnName")
sql_ir.LogGrammarCoverage("AlterOrderItem,OptOrder")


		$$ = &ast.AlterOrderItem{Column: $1.(*ast.ColumnName), Desc: $2.(bool)}
	}

OrderBy:
	"ORDER" "BY" ByList
	{
sql_ir.LogGrammarCoverage("OrderBy,ByList")


		$$ = &ast.OrderByClause{Items: $3.([]*ast.ByItem)}
	}

ByList:
	ByItem
	{
sql_ir.LogGrammarCoverage("ByList,ByItem")


		$$ = []*ast.ByItem{$1.(*ast.ByItem)}
	}
|	ByList ',' ByItem
	{
sql_ir.LogGrammarCoverage("ByList,ByList")
sql_ir.LogGrammarCoverage("ByList,ByItem")


		$$ = append($1.([]*ast.ByItem), $3.(*ast.ByItem))
	}

ByItem:
	Expression
	{
sql_ir.LogGrammarCoverage("ByItem,Expression")


		expr := $1
		valueExpr, ok := expr.(ast.ValueExpr)
		if ok {
			position, isPosition := valueExpr.GetValue().(int64)
			if isPosition {
				expr = &ast.PositionExpr{N: int(position)}
			}
		}
		$$ = &ast.ByItem{Expr: expr, NullOrder: true}
	}
|	Expression Order
	{
sql_ir.LogGrammarCoverage("ByItem,Expression")
sql_ir.LogGrammarCoverage("ByItem,Order")


		expr := $1
		valueExpr, ok := expr.(ast.ValueExpr)
		if ok {
			position, isPosition := valueExpr.GetValue().(int64)
			if isPosition {
				expr = &ast.PositionExpr{N: int(position)}
			}
		}
		$$ = &ast.ByItem{Expr: expr, Desc: $2.(bool)}
	}

Order:
	"ASC"
	{


		$$ = false
	}
|	"DESC"
	{


		$$ = true
	}

OptOrder:
	/* EMPTY */
	{


		$$ = false // ASC by default
	}
|	"ASC"
	{


		$$ = false
	}
|	"DESC"
	{


		$$ = true
	}

OrderByOptional:
	{


		$$ = nil
	}
|	OrderBy

{
sql_ir.LogGrammarCoverage("OrderByOptional,OrderBy")

}
BitExpr:
	BitExpr '|' BitExpr %prec '|'
	{
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")


		$$ = &ast.BinaryOperationExpr{Op: opcode.Or, L: $1, R: $3}
	}
|	BitExpr '&' BitExpr %prec '&'
	{
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")


		$$ = &ast.BinaryOperationExpr{Op: opcode.And, L: $1, R: $3}
	}
|	BitExpr "<<" BitExpr %prec lsh
	{
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")


		$$ = &ast.BinaryOperationExpr{Op: opcode.LeftShift, L: $1, R: $3}
	}
|	BitExpr ">>" BitExpr %prec rsh
	{
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")


		$$ = &ast.BinaryOperationExpr{Op: opcode.RightShift, L: $1, R: $3}
	}
|	BitExpr '+' BitExpr %prec '+'
	{
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")


		$$ = &ast.BinaryOperationExpr{Op: opcode.Plus, L: $1, R: $3}
	}
|	BitExpr '-' BitExpr %prec '-'
	{
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")


		$$ = &ast.BinaryOperationExpr{Op: opcode.Minus, L: $1, R: $3}
	}
|	BitExpr '+' "INTERVAL" Expression TimeUnit %prec '+'
	{
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")
sql_ir.LogGrammarCoverage("BitExpr,Expression")
sql_ir.LogGrammarCoverage("BitExpr,TimeUnit")


		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr("DATE_ADD"),
			Args: []ast.ExprNode{
				$1,
				$4,
				&ast.TimeUnitExpr{Unit: $5.(ast.TimeUnitType)},
			},
		}
	}
|	BitExpr '-' "INTERVAL" Expression TimeUnit %prec '+'
	{
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")
sql_ir.LogGrammarCoverage("BitExpr,Expression")
sql_ir.LogGrammarCoverage("BitExpr,TimeUnit")


		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr("DATE_SUB"),
			Args: []ast.ExprNode{
				$1,
				$4,
				&ast.TimeUnitExpr{Unit: $5.(ast.TimeUnitType)},
			},
		}
	}
|	BitExpr '*' BitExpr %prec '*'
	{
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")


		$$ = &ast.BinaryOperationExpr{Op: opcode.Mul, L: $1, R: $3}
	}
|	BitExpr '/' BitExpr %prec '/'
	{
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")


		$$ = &ast.BinaryOperationExpr{Op: opcode.Div, L: $1, R: $3}
	}
|	BitExpr '%' BitExpr %prec '%'
	{
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")


		$$ = &ast.BinaryOperationExpr{Op: opcode.Mod, L: $1, R: $3}
	}
|	BitExpr "DIV" BitExpr %prec div
	{
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")


		$$ = &ast.BinaryOperationExpr{Op: opcode.IntDiv, L: $1, R: $3}
	}
|	BitExpr "MOD" BitExpr %prec mod
	{
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")


		$$ = &ast.BinaryOperationExpr{Op: opcode.Mod, L: $1, R: $3}
	}
|	BitExpr '^' BitExpr
	{
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")
sql_ir.LogGrammarCoverage("BitExpr,BitExpr")


		$$ = &ast.BinaryOperationExpr{Op: opcode.Xor, L: $1, R: $3}
	}
|	SimpleExpr

{
sql_ir.LogGrammarCoverage("BitExpr,SimpleExpr")

}
SimpleIdent:
	Identifier
	{
sql_ir.LogGrammarCoverage("SimpleIdent,Identifier")


		$$ = &ast.ColumnNameExpr{Name: &ast.ColumnName{
			Name: model.NewCIStr($1),
		}}
	}
|	Identifier '.' Identifier
	{
sql_ir.LogGrammarCoverage("SimpleIdent,Identifier")
sql_ir.LogGrammarCoverage("SimpleIdent,Identifier")


		$$ = &ast.ColumnNameExpr{Name: &ast.ColumnName{
			Table: model.NewCIStr($1),
			Name:  model.NewCIStr($3),
		}}
	}
|	Identifier '.' Identifier '.' Identifier
	{
sql_ir.LogGrammarCoverage("SimpleIdent,Identifier")
sql_ir.LogGrammarCoverage("SimpleIdent,Identifier")
sql_ir.LogGrammarCoverage("SimpleIdent,Identifier")


		$$ = &ast.ColumnNameExpr{Name: &ast.ColumnName{
			Schema: model.NewCIStr($1),
			Table:  model.NewCIStr($3),
			Name:   model.NewCIStr($5),
		}}
	}

SimpleExpr:
	SimpleIdent
{
sql_ir.LogGrammarCoverage("SimpleExpr,SimpleIdent")

}
|	FunctionCallKeyword
{
sql_ir.LogGrammarCoverage("SimpleExpr,FunctionCallKeyword")

}
|	FunctionCallNonKeyword
{
sql_ir.LogGrammarCoverage("SimpleExpr,FunctionCallNonKeyword")

}
|	FunctionCallGeneric
{
sql_ir.LogGrammarCoverage("SimpleExpr,FunctionCallGeneric")

}
|	SimpleExpr "COLLATE" CollationName
	{
sql_ir.LogGrammarCoverage("SimpleExpr,SimpleExpr")
sql_ir.LogGrammarCoverage("SimpleExpr,CollationName")


		$$ = &ast.SetCollationExpr{Expr: $1, Collate: $3}
	}
|	WindowFuncCall
{
sql_ir.LogGrammarCoverage("SimpleExpr,WindowFuncCall")

}
|	Literal
{
sql_ir.LogGrammarCoverage("SimpleExpr,Literal")

}
|	paramMarker
	{


		$$ = ast.NewParamMarkerExpr(yyS[yypt].offset)
	}
|	Variable
{
sql_ir.LogGrammarCoverage("SimpleExpr,Variable")

}
|	SumExpr
{
sql_ir.LogGrammarCoverage("SimpleExpr,SumExpr")

}
|	'!' SimpleExpr %prec neg
	{
sql_ir.LogGrammarCoverage("SimpleExpr,SimpleExpr")


		$$ = &ast.UnaryOperationExpr{Op: opcode.Not2, V: $2}
	}
|	'~' SimpleExpr %prec neg
	{
sql_ir.LogGrammarCoverage("SimpleExpr,SimpleExpr")


		$$ = &ast.UnaryOperationExpr{Op: opcode.BitNeg, V: $2}
	}
|	'-' SimpleExpr %prec neg
	{
sql_ir.LogGrammarCoverage("SimpleExpr,SimpleExpr")


		$$ = &ast.UnaryOperationExpr{Op: opcode.Minus, V: $2}
	}
|	'+' SimpleExpr %prec neg
	{
sql_ir.LogGrammarCoverage("SimpleExpr,SimpleExpr")


		$$ = &ast.UnaryOperationExpr{Op: opcode.Plus, V: $2}
	}
|	SimpleExpr pipes SimpleExpr
	{
sql_ir.LogGrammarCoverage("SimpleExpr,SimpleExpr")
sql_ir.LogGrammarCoverage("SimpleExpr,SimpleExpr")


		$$ = &ast.FuncCallExpr{FnName: model.NewCIStr(ast.Concat), Args: []ast.ExprNode{$1, $3}}
	}
|	not2 SimpleExpr %prec neg
	{
sql_ir.LogGrammarCoverage("SimpleExpr,SimpleExpr")


		$$ = &ast.UnaryOperationExpr{Op: opcode.Not2, V: $2}
	}
|	SubSelect %prec neg
{
sql_ir.LogGrammarCoverage("SimpleExpr,SubSelect")

}
|	'(' Expression ')'
	{
sql_ir.LogGrammarCoverage("SimpleExpr,Expression")


		startOffset := parser.startOffset(&yyS[yypt-1])
		endOffset := parser.endOffset(&yyS[yypt])
		expr := $2
		expr.SetText(parser.lexer.client, parser.src[startOffset:endOffset])
		$$ = &ast.ParenthesesExpr{Expr: expr}
	}
|	'(' ExpressionList ',' Expression ')'
	{
sql_ir.LogGrammarCoverage("SimpleExpr,ExpressionList")
sql_ir.LogGrammarCoverage("SimpleExpr,Expression")


		values := append($2.([]ast.ExprNode), $4)
		$$ = &ast.RowExpr{Values: values}
	}
|	"ROW" '(' ExpressionList ',' Expression ')'
	{
sql_ir.LogGrammarCoverage("SimpleExpr,ExpressionList")
sql_ir.LogGrammarCoverage("SimpleExpr,Expression")


		values := append($3.([]ast.ExprNode), $5)
		$$ = &ast.RowExpr{Values: values}
	}
|	"EXISTS" SubSelect
	{
sql_ir.LogGrammarCoverage("SimpleExpr,SubSelect")


		sq := $2.(*ast.SubqueryExpr)
		sq.Exists = true
		$$ = &ast.ExistsSubqueryExpr{Sel: sq}
	}
|	'{' Identifier Expression '}'
	{
sql_ir.LogGrammarCoverage("SimpleExpr,Identifier")
sql_ir.LogGrammarCoverage("SimpleExpr,Expression")


		
		tp := $3.GetType()
		switch $2 {
		case "d":
			tp.SetCharset("")
			tp.SetCollate("")
			$$ = &ast.FuncCallExpr{FnName: model.NewCIStr(ast.DateLiteral), Args: []ast.ExprNode{$3}}
		case "t":
			tp.SetCharset("")
			tp.SetCollate("")
			$$ = &ast.FuncCallExpr{FnName: model.NewCIStr(ast.TimeLiteral), Args: []ast.ExprNode{$3}}
		case "ts":
			tp.SetCharset("")
			tp.SetCollate("")
			$$ = &ast.FuncCallExpr{FnName: model.NewCIStr(ast.TimestampLiteral), Args: []ast.ExprNode{$3}}
		default:
			$$ = $3
		}
	}
|	"BINARY" SimpleExpr %prec neg
	{
sql_ir.LogGrammarCoverage("SimpleExpr,SimpleExpr")


		// See https://dev.mysql.com/doc/refman/5.7/en/cast-functions.html#operator_binary
		tp := types.NewFieldType(mysql.TypeString)
		tp.SetCharset(charset.CharsetBin)
		tp.SetCollate(charset.CharsetBin)
		tp.AddFlag(mysql.BinaryFlag)
		$$ = &ast.FuncCastExpr{
			Expr:         $2,
			Tp:           tp,
			FunctionType: ast.CastBinaryOperator,
		}
	}
|	builtinCast '(' Expression "AS" CastType ')'
	{
sql_ir.LogGrammarCoverage("SimpleExpr,Expression")
sql_ir.LogGrammarCoverage("SimpleExpr,CastType")


		
		tp := $5.(*types.FieldType)
		defaultFlen, defaultDecimal := mysql.GetDefaultFieldLengthAndDecimalForCast(tp.GetType())
		if tp.GetFlen() == types.UnspecifiedLength {
			tp.SetFlen(defaultFlen)
		}
		if tp.GetDecimal() == types.UnspecifiedLength {
			tp.SetDecimal(defaultDecimal)
		}
		explicitCharset := parser.explicitCharset
		parser.explicitCharset = false
		$$ = &ast.FuncCastExpr{
			Expr:            $3,
			Tp:              tp,
			FunctionType:    ast.CastFunction,
			ExplicitCharSet: explicitCharset,
		}
	}
|	"CASE" ExpressionOpt WhenClauseList ElseOpt "END"
	{
sql_ir.LogGrammarCoverage("SimpleExpr,ExpressionOpt")
sql_ir.LogGrammarCoverage("SimpleExpr,WhenClauseList")
sql_ir.LogGrammarCoverage("SimpleExpr,ElseOpt")


		x := &ast.CaseExpr{WhenClauses: $3.([]*ast.WhenClause)}
		if $2 != nil {
			x.Value = $2
		}
		if $4 != nil {
			x.ElseClause = $4.(ast.ExprNode)
		}
		$$ = x
	}
|	"CONVERT" '(' Expression ',' CastType ')'
	{
sql_ir.LogGrammarCoverage("SimpleExpr,Expression")
sql_ir.LogGrammarCoverage("SimpleExpr,CastType")


		// See https://dev.mysql.com/doc/refman/5.7/en/cast-functions.html#function_convert
		tp := $5.(*types.FieldType)
		defaultFlen, defaultDecimal := mysql.GetDefaultFieldLengthAndDecimalForCast(tp.GetType())
		if tp.GetFlen() == types.UnspecifiedLength {
			tp.SetFlen(defaultFlen)
		}
		if tp.GetDecimal() == types.UnspecifiedLength {
			tp.SetDecimal(defaultDecimal)
		}
		explicitCharset := parser.explicitCharset
		parser.explicitCharset = false
		$$ = &ast.FuncCastExpr{
			Expr:            $3,
			Tp:              tp,
			FunctionType:    ast.CastConvertFunction,
			ExplicitCharSet: explicitCharset,
		}
	}
|	"CONVERT" '(' Expression "USING" CharsetName ')'
	{
sql_ir.LogGrammarCoverage("SimpleExpr,Expression")
sql_ir.LogGrammarCoverage("SimpleExpr,CharsetName")


		// See https://dev.mysql.com/doc/refman/5.7/en/cast-functions.html#function_convert
		charset1 := ast.NewValueExpr($5, "", "")
		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr($1),
			Args:   []ast.ExprNode{$3, charset1},
		}
	}
|	"DEFAULT" '(' SimpleIdent ')'
	{
sql_ir.LogGrammarCoverage("SimpleExpr,SimpleIdent")


		$$ = &ast.DefaultExpr{Name: $3.(*ast.ColumnNameExpr).Name}
	}
|	"VALUES" '(' SimpleIdent ')' %prec lowerThanInsertValues
	{
sql_ir.LogGrammarCoverage("SimpleExpr,SimpleIdent")


		$$ = &ast.ValuesExpr{Column: $3.(*ast.ColumnNameExpr)}
	}
|	SimpleIdent jss stringLit
	{
sql_ir.LogGrammarCoverage("SimpleExpr,SimpleIdent")
sql_ir.LogGrammarCoverage("SimpleExpr,stringLit")


		expr := ast.NewValueExpr($3, parser.charset, parser.collation)
		$$ = &ast.FuncCallExpr{FnName: model.NewCIStr(ast.JSONExtract), Args: []ast.ExprNode{$1, expr}}
	}
|	SimpleIdent juss stringLit
	{
sql_ir.LogGrammarCoverage("SimpleExpr,SimpleIdent")
sql_ir.LogGrammarCoverage("SimpleExpr,stringLit")


		expr := ast.NewValueExpr($3, parser.charset, parser.collation)
		extract := &ast.FuncCallExpr{FnName: model.NewCIStr(ast.JSONExtract), Args: []ast.ExprNode{$1, expr}}
		$$ = &ast.FuncCallExpr{FnName: model.NewCIStr(ast.JSONUnquote), Args: []ast.ExprNode{extract}}
	}

DistinctKwd:
	"DISTINCT"
{

}
|	"DISTINCTROW"

{

}
DistinctOpt:
	"ALL"
	{


		$$ = false
	}
|	DistinctKwd
	{
sql_ir.LogGrammarCoverage("DistinctOpt,DistinctKwd")


		$$ = true
	}

DefaultFalseDistinctOpt:
	{


		$$ = false
	}
|	DistinctOpt

{
sql_ir.LogGrammarCoverage("DefaultFalseDistinctOpt,DistinctOpt")

}
DefaultTrueDistinctOpt:
	{


		$$ = true
	}
|	DistinctOpt

{
sql_ir.LogGrammarCoverage("DefaultTrueDistinctOpt,DistinctOpt")

}
BuggyDefaultFalseDistinctOpt:
	DefaultFalseDistinctOpt
{
sql_ir.LogGrammarCoverage("BuggyDefaultFalseDistinctOpt,DefaultFalseDistinctOpt")

}
|	DistinctKwd "ALL"
	{
sql_ir.LogGrammarCoverage("BuggyDefaultFalseDistinctOpt,DistinctKwd")


		$$ = true
	}

FunctionNameConflict:
	"ASCII"
{

}
|	"CHARSET"
{

}
|	"COALESCE"
{

}
|	"COLLATION"
{

}
|	"DATE"
{

}
|	"DATABASE"
{

}
|	"DAY"
{

}
|	"HOUR"
{

}
|	"IF"
{

}
|	"INTERVAL"
{

}
|	"FORMAT"
{

}
|	"LEFT"
{

}
|	"MICROSECOND"
{

}
|	"MINUTE"
{

}
|	"MONTH"
{

}
|	builtinNow
{

}
|	"QUARTER"
{

}
|	"REPEAT"
{

}
|	"REPLACE"
{

}
|	"REVERSE"
{

}
|	"RIGHT"
{

}
|	"ROW_COUNT"
{

}
|	"SECOND"
{

}
|	"TIME"
{

}
|	"TIMESTAMP"
{

}
|	"TRUNCATE"
{

}
|	"USER"
{

}
|	"WEEK"
{

}
|	"YEAR"

{

}
OptionalBraces:
	{

}
|	'(' ')'
	{

}

FunctionNameOptionalBraces:
	"CURRENT_USER"
{

}
|	"CURRENT_DATE"
{

}
|	"CURRENT_ROLE"
{

}
|	"UTC_DATE"

{

}
FunctionNameDatetimePrecision:
	"CURRENT_TIME"
{

}
|	"CURRENT_TIMESTAMP"
{

}
|	"LOCALTIME"
{

}
|	"LOCALTIMESTAMP"
{

}
|	"UTC_TIME"
{

}
|	"UTC_TIMESTAMP"

{

}
FunctionCallKeyword:
	FunctionNameConflict '(' ExpressionListOpt ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallKeyword,FunctionNameConflict")
sql_ir.LogGrammarCoverage("FunctionCallKeyword,ExpressionListOpt")


		$$ = &ast.FuncCallExpr{FnName: model.NewCIStr($1), Args: $3.([]ast.ExprNode)}
	}
|	builtinUser '(' ExpressionListOpt ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallKeyword,ExpressionListOpt")


		$$ = &ast.FuncCallExpr{FnName: model.NewCIStr($1), Args: $3.([]ast.ExprNode)}
	}
|	FunctionNameOptionalBraces OptionalBraces
	{
sql_ir.LogGrammarCoverage("FunctionCallKeyword,FunctionNameOptionalBraces")
sql_ir.LogGrammarCoverage("FunctionCallKeyword,OptionalBraces")


		$$ = &ast.FuncCallExpr{FnName: model.NewCIStr($1)}
	}
|	builtinCurDate '(' ')'
	{


		$$ = &ast.FuncCallExpr{FnName: model.NewCIStr($1)}
	}
|	FunctionNameDatetimePrecision FuncDatetimePrec
	{
sql_ir.LogGrammarCoverage("FunctionCallKeyword,FunctionNameDatetimePrecision")
sql_ir.LogGrammarCoverage("FunctionCallKeyword,FuncDatetimePrec")


		args := []ast.ExprNode{}
		if $2 != nil {
			args = append(args, $2.(ast.ExprNode))
		}
		$$ = &ast.FuncCallExpr{FnName: model.NewCIStr($1), Args: args}
	}
|	"CHAR" '(' ExpressionList ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallKeyword,ExpressionList")


		nilVal := ast.NewValueExpr(nil, parser.charset, parser.collation)
		args := $3.([]ast.ExprNode)
		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr(ast.CharFunc),
			Args:   append(args, nilVal),
		}
	}
|	"CHAR" '(' ExpressionList "USING" CharsetName ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallKeyword,ExpressionList")
sql_ir.LogGrammarCoverage("FunctionCallKeyword,CharsetName")


		charset1 := ast.NewValueExpr($5, "", "")
		args := $3.([]ast.ExprNode)
		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr(ast.CharFunc),
			Args:   append(args, charset1),
		}
	}
|	"DATE" stringLit
	{
sql_ir.LogGrammarCoverage("FunctionCallKeyword,stringLit")


		expr := ast.NewValueExpr($2, "", "")
		$$ = &ast.FuncCallExpr{FnName: model.NewCIStr(ast.DateLiteral), Args: []ast.ExprNode{expr}}
	}
|	"TIME" stringLit
	{
sql_ir.LogGrammarCoverage("FunctionCallKeyword,stringLit")


		expr := ast.NewValueExpr($2, "", "")
		$$ = &ast.FuncCallExpr{FnName: model.NewCIStr(ast.TimeLiteral), Args: []ast.ExprNode{expr}}
	}
|	"TIMESTAMP" stringLit
	{
sql_ir.LogGrammarCoverage("FunctionCallKeyword,stringLit")


		expr := ast.NewValueExpr($2, "", "")
		$$ = &ast.FuncCallExpr{FnName: model.NewCIStr(ast.TimestampLiteral), Args: []ast.ExprNode{expr}}
	}
|	"INSERT" '(' ExpressionListOpt ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallKeyword,ExpressionListOpt")


		$$ = &ast.FuncCallExpr{FnName: model.NewCIStr(ast.InsertFunc), Args: $3.([]ast.ExprNode)}
	}
|	"MOD" '(' BitExpr ',' BitExpr ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallKeyword,BitExpr")
sql_ir.LogGrammarCoverage("FunctionCallKeyword,BitExpr")


		$$ = &ast.BinaryOperationExpr{Op: opcode.Mod, L: $3, R: $5}
	}
|	"PASSWORD" '(' ExpressionListOpt ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallKeyword,ExpressionListOpt")


		$$ = &ast.FuncCallExpr{FnName: model.NewCIStr(ast.PasswordFunc), Args: $3.([]ast.ExprNode)}
	}

FunctionCallNonKeyword:
	builtinCurTime '(' FuncDatetimePrecListOpt ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,FuncDatetimePrecListOpt")


		$$ = &ast.FuncCallExpr{FnName: model.NewCIStr($1), Args: $3.([]ast.ExprNode)}
	}
|	builtinSysDate '(' FuncDatetimePrecListOpt ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,FuncDatetimePrecListOpt")


		$$ = &ast.FuncCallExpr{FnName: model.NewCIStr($1), Args: $3.([]ast.ExprNode)}
	}
|	FunctionNameDateArithMultiForms '(' Expression ',' Expression ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,FunctionNameDateArithMultiForms")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")


		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr($1),
			Args: []ast.ExprNode{
				$3,
				$5,
				&ast.TimeUnitExpr{Unit: ast.TimeUnitDay},
			},
		}
	}
|	FunctionNameDateArithMultiForms '(' Expression ',' "INTERVAL" Expression TimeUnit ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,FunctionNameDateArithMultiForms")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,TimeUnit")


		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr($1),
			Args: []ast.ExprNode{
				$3,
				$6,
				&ast.TimeUnitExpr{Unit: $7.(ast.TimeUnitType)},
			},
		}
	}
|	FunctionNameDateArith '(' Expression ',' "INTERVAL" Expression TimeUnit ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,FunctionNameDateArith")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,TimeUnit")


		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr($1),
			Args: []ast.ExprNode{
				$3,
				$6,
				&ast.TimeUnitExpr{Unit: $7.(ast.TimeUnitType)},
			},
		}
	}
|	builtinExtract '(' TimeUnit "FROM" Expression ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,TimeUnit")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")


		timeUnit := &ast.TimeUnitExpr{Unit: $3.(ast.TimeUnitType)}
		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr($1),
			Args:   []ast.ExprNode{timeUnit, $5},
		}
	}
|	"GET_FORMAT" '(' GetFormatSelector ',' Expression ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,GetFormatSelector")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")


		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr($1),
			Args: []ast.ExprNode{
				&ast.GetFormatSelectorExpr{Selector: $3.(ast.GetFormatSelectorType)},
				$5,
			},
		}
	}
|	builtinPosition '(' BitExpr "IN" Expression ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,BitExpr")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")


		$$ = &ast.FuncCallExpr{FnName: model.NewCIStr($1), Args: []ast.ExprNode{$3, $5}}
	}
|	builtinSubstring '(' Expression ',' Expression ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")


		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr($1),
			Args:   []ast.ExprNode{$3, $5},
		}
	}
|	builtinSubstring '(' Expression "FROM" Expression ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")


		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr($1),
			Args:   []ast.ExprNode{$3, $5},
		}
	}
|	builtinSubstring '(' Expression ',' Expression ',' Expression ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")


		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr($1),
			Args:   []ast.ExprNode{$3, $5, $7},
		}
	}
|	builtinSubstring '(' Expression "FROM" Expression "FOR" Expression ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")


		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr($1),
			Args:   []ast.ExprNode{$3, $5, $7},
		}
	}
|	"TIMESTAMPADD" '(' TimestampUnit ',' Expression ',' Expression ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,TimestampUnit")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")


		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr($1),
			Args:   []ast.ExprNode{&ast.TimeUnitExpr{Unit: $3.(ast.TimeUnitType)}, $5, $7},
		}
	}
|	"TIMESTAMPDIFF" '(' TimestampUnit ',' Expression ',' Expression ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,TimestampUnit")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")


		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr($1),
			Args:   []ast.ExprNode{&ast.TimeUnitExpr{Unit: $3.(ast.TimeUnitType)}, $5, $7},
		}
	}
|	builtinTrim '(' Expression ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")


		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr($1),
			Args:   []ast.ExprNode{$3},
		}
	}
|	builtinTrim '(' Expression "FROM" Expression ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")


		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr($1),
			Args:   []ast.ExprNode{$5, $3},
		}
	}
|	builtinTrim '(' TrimDirection "FROM" Expression ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,TrimDirection")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")


		spaceVal := ast.NewValueExpr(" ", parser.charset, parser.collation)
		direction := &ast.TrimDirectionExpr{Direction: $3.(ast.TrimDirectionType)}
		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr($1),
			Args:   []ast.ExprNode{$5, spaceVal, direction},
		}
	}
|	builtinTrim '(' TrimDirection Expression "FROM" Expression ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,TrimDirection")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")


		direction := &ast.TrimDirectionExpr{Direction: $3.(ast.TrimDirectionType)}
		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr($1),
			Args:   []ast.ExprNode{$6, $4, direction},
		}
	}
|	weightString '(' Expression ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")


		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr($1),
			Args:   []ast.ExprNode{$3},
		}
	}
|	weightString '(' Expression "AS" Char FieldLen ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Char")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,FieldLen")


		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr($1),
			Args:   []ast.ExprNode{$3, ast.NewValueExpr("CHAR", parser.charset, parser.collation), ast.NewValueExpr($6, parser.charset, parser.collation)},
		}
	}
|	weightString '(' Expression "AS" "BINARY" FieldLen ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,FieldLen")


		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr($1),
			Args:   []ast.ExprNode{$3, ast.NewValueExpr("BINARY", parser.charset, parser.collation), ast.NewValueExpr($6, parser.charset, parser.collation)},
		}
	}
|	FunctionNameSequence
{
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,FunctionNameSequence")

}
|	builtinTranslate '(' Expression ',' Expression ',' Expression ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")
sql_ir.LogGrammarCoverage("FunctionCallNonKeyword,Expression")


		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr($1),
			Args:   []ast.ExprNode{$3, $5, $7},
		}
	}

GetFormatSelector:
	"DATE"
	{


		$$ = ast.GetFormatSelectorDate
	}
|	"DATETIME"
	{


		$$ = ast.GetFormatSelectorDatetime
	}
|	"TIME"
	{


		$$ = ast.GetFormatSelectorTime
	}
|	"TIMESTAMP"
	{


		$$ = ast.GetFormatSelectorDatetime
	}

FunctionNameDateArith:
	builtinDateAdd
{

}
|	builtinDateSub

{

}
FunctionNameDateArithMultiForms:
	addDate
{

}
|	subDate

{

}
TrimDirection:
	"BOTH"
	{


		$$ = ast.TrimBoth
	}
|	"LEADING"
	{


		$$ = ast.TrimLeading
	}
|	"TRAILING"
	{


		$$ = ast.TrimTrailing
	}

FunctionNameSequence:
	"LASTVAL" '(' TableName ')'
	{
sql_ir.LogGrammarCoverage("FunctionNameSequence,TableName")


		objNameExpr := &ast.TableNameExpr{
			Name: $3.(*ast.TableName),
		}
		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr(ast.LastVal),
			Args:   []ast.ExprNode{objNameExpr},
		}
	}
|	"SETVAL" '(' TableName ',' SignedNum ')'
	{
sql_ir.LogGrammarCoverage("FunctionNameSequence,TableName")
sql_ir.LogGrammarCoverage("FunctionNameSequence,SignedNum")


		objNameExpr := &ast.TableNameExpr{
			Name: $3.(*ast.TableName),
		}
		valueExpr := ast.NewValueExpr($5, parser.charset, parser.collation)
		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr(ast.SetVal),
			Args:   []ast.ExprNode{objNameExpr, valueExpr},
		}
	}
|	NextValueForSequence

{
sql_ir.LogGrammarCoverage("FunctionNameSequence,NextValueForSequence")

}
SumExpr:
	"AVG" '(' BuggyDefaultFalseDistinctOpt Expression ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,BuggyDefaultFalseDistinctOpt")
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		if $6 != nil {
			$$ = &ast.WindowFuncExpr{F: $1, Args: []ast.ExprNode{$4}, Distinct: $3.(bool), Spec: *($6.(*ast.WindowSpec))}
		} else {
			$$ = &ast.AggregateFuncExpr{F: $1, Args: []ast.ExprNode{$4}, Distinct: $3.(bool)}
		}
	}
|	builtinApproxCountDistinct '(' ExpressionList ')'
	{
sql_ir.LogGrammarCoverage("SumExpr,ExpressionList")


		$$ = &ast.AggregateFuncExpr{F: $1, Args: $3.([]ast.ExprNode), Distinct: false}
	}
|	builtinApproxPercentile '(' ExpressionList ')'
	{
sql_ir.LogGrammarCoverage("SumExpr,ExpressionList")


		$$ = &ast.AggregateFuncExpr{F: $1, Args: $3.([]ast.ExprNode)}
	}
|	builtinBitAnd '(' Expression ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		if $5 != nil {
			$$ = &ast.WindowFuncExpr{F: $1, Args: []ast.ExprNode{$3}, Spec: *($5.(*ast.WindowSpec))}
		} else {
			$$ = &ast.AggregateFuncExpr{F: $1, Args: []ast.ExprNode{$3}}
		}
	}
|	builtinBitAnd '(' "ALL" Expression ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		if $6 != nil {
			$$ = &ast.WindowFuncExpr{F: $1, Args: []ast.ExprNode{$4}, Spec: *($6.(*ast.WindowSpec))}
		} else {
			$$ = &ast.AggregateFuncExpr{F: $1, Args: []ast.ExprNode{$4}}
		}
	}
|	builtinBitOr '(' Expression ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		if $5 != nil {
			$$ = &ast.WindowFuncExpr{F: $1, Args: []ast.ExprNode{$3}, Spec: *($5.(*ast.WindowSpec))}
		} else {
			$$ = &ast.AggregateFuncExpr{F: $1, Args: []ast.ExprNode{$3}}
		}
	}
|	builtinBitOr '(' "ALL" Expression ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		if $6 != nil {
			$$ = &ast.WindowFuncExpr{F: $1, Args: []ast.ExprNode{$4}, Spec: *($6.(*ast.WindowSpec))}
		} else {
			$$ = &ast.AggregateFuncExpr{F: $1, Args: []ast.ExprNode{$4}}
		}
	}
|	builtinBitXor '(' Expression ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		if $5 != nil {
			$$ = &ast.WindowFuncExpr{F: $1, Args: []ast.ExprNode{$3}, Spec: *($5.(*ast.WindowSpec))}
		} else {
			$$ = &ast.AggregateFuncExpr{F: $1, Args: []ast.ExprNode{$3}}
		}
	}
|	builtinBitXor '(' "ALL" Expression ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		if $6 != nil {
			$$ = &ast.WindowFuncExpr{F: $1, Args: []ast.ExprNode{$4}, Spec: *($6.(*ast.WindowSpec))}
		} else {
			$$ = &ast.AggregateFuncExpr{F: $1, Args: []ast.ExprNode{$4}}
		}
	}
|	builtinCount '(' DistinctKwd ExpressionList ')'
	{
sql_ir.LogGrammarCoverage("SumExpr,DistinctKwd")
sql_ir.LogGrammarCoverage("SumExpr,ExpressionList")


		$$ = &ast.AggregateFuncExpr{F: $1, Args: $4.([]ast.ExprNode), Distinct: true}
	}
|	builtinCount '(' "ALL" Expression ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		if $6 != nil {
			$$ = &ast.WindowFuncExpr{F: $1, Args: []ast.ExprNode{$4}, Spec: *($6.(*ast.WindowSpec))}
		} else {
			$$ = &ast.AggregateFuncExpr{F: $1, Args: []ast.ExprNode{$4}}
		}
	}
|	builtinCount '(' Expression ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		if $5 != nil {
			$$ = &ast.WindowFuncExpr{F: $1, Args: []ast.ExprNode{$3}, Spec: *($5.(*ast.WindowSpec))}
		} else {
			$$ = &ast.AggregateFuncExpr{F: $1, Args: []ast.ExprNode{$3}}
		}
	}
|	builtinCount '(' '*' ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		args := []ast.ExprNode{ast.NewValueExpr(1, parser.charset, parser.collation)}
		if $5 != nil {
			$$ = &ast.WindowFuncExpr{F: $1, Args: args, Spec: *($5.(*ast.WindowSpec))}
		} else {
			$$ = &ast.AggregateFuncExpr{F: $1, Args: args}
		}
	}
|	builtinGroupConcat '(' BuggyDefaultFalseDistinctOpt ExpressionList OrderByOptional OptGConcatSeparator ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,BuggyDefaultFalseDistinctOpt")
sql_ir.LogGrammarCoverage("SumExpr,ExpressionList")
sql_ir.LogGrammarCoverage("SumExpr,OrderByOptional")
sql_ir.LogGrammarCoverage("SumExpr,OptGConcatSeparator")
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		args := $4.([]ast.ExprNode)
		args = append(args, $6.(ast.ExprNode))
		if $8 != nil {
			$$ = &ast.WindowFuncExpr{F: $1, Args: args, Distinct: $3.(bool), Spec: *($8.(*ast.WindowSpec))}
		} else {
			agg := &ast.AggregateFuncExpr{F: $1, Args: args, Distinct: $3.(bool)}
			if $5 != nil {
				agg.Order = $5.(*ast.OrderByClause)
			}
			$$ = agg
		}
	}
|	builtinMax '(' BuggyDefaultFalseDistinctOpt Expression ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,BuggyDefaultFalseDistinctOpt")
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		if $6 != nil {
			$$ = &ast.WindowFuncExpr{F: $1, Args: []ast.ExprNode{$4}, Distinct: $3.(bool), Spec: *($6.(*ast.WindowSpec))}
		} else {
			$$ = &ast.AggregateFuncExpr{F: $1, Args: []ast.ExprNode{$4}, Distinct: $3.(bool)}
		}
	}
|	builtinMin '(' BuggyDefaultFalseDistinctOpt Expression ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,BuggyDefaultFalseDistinctOpt")
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		if $6 != nil {
			$$ = &ast.WindowFuncExpr{F: $1, Args: []ast.ExprNode{$4}, Distinct: $3.(bool), Spec: *($6.(*ast.WindowSpec))}
		} else {
			$$ = &ast.AggregateFuncExpr{F: $1, Args: []ast.ExprNode{$4}, Distinct: $3.(bool)}
		}
	}
|	builtinSum '(' BuggyDefaultFalseDistinctOpt Expression ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,BuggyDefaultFalseDistinctOpt")
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		if $6 != nil {
			$$ = &ast.WindowFuncExpr{F: $1, Args: []ast.ExprNode{$4}, Distinct: $3.(bool), Spec: *($6.(*ast.WindowSpec))}
		} else {
			$$ = &ast.AggregateFuncExpr{F: $1, Args: []ast.ExprNode{$4}, Distinct: $3.(bool)}
		}
	}
|	builtinStddevPop '(' BuggyDefaultFalseDistinctOpt Expression ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,BuggyDefaultFalseDistinctOpt")
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		if $6 != nil {
			$$ = &ast.WindowFuncExpr{F: ast.AggFuncStddevPop, Args: []ast.ExprNode{$4}, Distinct: $3.(bool), Spec: *($6.(*ast.WindowSpec))}
		} else {
			$$ = &ast.AggregateFuncExpr{F: ast.AggFuncStddevPop, Args: []ast.ExprNode{$4}, Distinct: $3.(bool)}
		}
	}
|	builtinStddevSamp '(' BuggyDefaultFalseDistinctOpt Expression ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,BuggyDefaultFalseDistinctOpt")
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		if $6 != nil {
			$$ = &ast.WindowFuncExpr{F: $1, Args: []ast.ExprNode{$4}, Distinct: $3.(bool), Spec: *($6.(*ast.WindowSpec))}
		} else {
			$$ = &ast.AggregateFuncExpr{F: $1, Args: []ast.ExprNode{$4}, Distinct: $3.(bool)}
		}
	}
|	builtinVarPop '(' BuggyDefaultFalseDistinctOpt Expression ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,BuggyDefaultFalseDistinctOpt")
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		if $6 != nil {
			$$ = &ast.WindowFuncExpr{F: ast.AggFuncVarPop, Args: []ast.ExprNode{$4}, Distinct: $3.(bool), Spec: *($6.(*ast.WindowSpec))}
		} else {
			$$ = &ast.AggregateFuncExpr{F: ast.AggFuncVarPop, Args: []ast.ExprNode{$4}, Distinct: $3.(bool)}
		}
	}
|	builtinVarSamp '(' BuggyDefaultFalseDistinctOpt Expression ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,BuggyDefaultFalseDistinctOpt")
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		$$ = &ast.AggregateFuncExpr{F: $1, Args: []ast.ExprNode{$4}, Distinct: $3.(bool)}
	}
|	"JSON_ARRAYAGG" '(' Expression ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		if $5 != nil {
			$$ = &ast.WindowFuncExpr{F: $1, Args: []ast.ExprNode{$3}, Spec: *($5.(*ast.WindowSpec))}
		} else {
			$$ = &ast.AggregateFuncExpr{F: $1, Args: []ast.ExprNode{$3}}
		}
	}
|	"JSON_ARRAYAGG" '(' "ALL" Expression ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		if $6 != nil {
			$$ = &ast.WindowFuncExpr{F: $1, Args: []ast.ExprNode{$4}, Spec: *($6.(*ast.WindowSpec))}
		} else {
			$$ = &ast.AggregateFuncExpr{F: $1, Args: []ast.ExprNode{$4}}
		}
	}
|	"JSON_OBJECTAGG" '(' Expression ',' Expression ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		if $7 != nil {
			$$ = &ast.WindowFuncExpr{F: $1, Args: []ast.ExprNode{$3, $5}, Spec: *($7.(*ast.WindowSpec))}
		} else {
			$$ = &ast.AggregateFuncExpr{F: $1, Args: []ast.ExprNode{$3, $5}}
		}
	}
|	"JSON_OBJECTAGG" '(' "ALL" Expression ',' Expression ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		if $8 != nil {
			$$ = &ast.WindowFuncExpr{F: $1, Args: []ast.ExprNode{$4, $6}, Spec: *($8.(*ast.WindowSpec))}
		} else {
			$$ = &ast.AggregateFuncExpr{F: $1, Args: []ast.ExprNode{$4, $6}}
		}
	}
|	"JSON_OBJECTAGG" '(' Expression ',' "ALL" Expression ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		if $8 != nil {
			$$ = &ast.WindowFuncExpr{F: $1, Args: []ast.ExprNode{$3, $6}, Spec: *($8.(*ast.WindowSpec))}
		} else {
			$$ = &ast.AggregateFuncExpr{F: $1, Args: []ast.ExprNode{$3, $6}}
		}
	}
|	"JSON_OBJECTAGG" '(' "ALL" Expression ',' "ALL" Expression ')' OptWindowingClause
	{
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,Expression")
sql_ir.LogGrammarCoverage("SumExpr,OptWindowingClause")


		if $9 != nil {
			$$ = &ast.WindowFuncExpr{F: $1, Args: []ast.ExprNode{$4, $7}, Spec: *($9.(*ast.WindowSpec))}
		} else {
			$$ = &ast.AggregateFuncExpr{F: $1, Args: []ast.ExprNode{$4, $7}}
		}
	}

OptGConcatSeparator:
	{


		$$ = ast.NewValueExpr(",", "", "")
	}
|	"SEPARATOR" stringLit
	{
sql_ir.LogGrammarCoverage("OptGConcatSeparator,stringLit")


		$$ = ast.NewValueExpr($2, "", "")
	}

FunctionCallGeneric:
	identifier '(' ExpressionListOpt ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallGeneric,ExpressionListOpt")


		$$ = &ast.FuncCallExpr{
			FnName: model.NewCIStr($1),
			Args:   $3.([]ast.ExprNode),
		}
	}
|	Identifier '.' Identifier '(' ExpressionListOpt ')'
	{
sql_ir.LogGrammarCoverage("FunctionCallGeneric,Identifier")
sql_ir.LogGrammarCoverage("FunctionCallGeneric,Identifier")
sql_ir.LogGrammarCoverage("FunctionCallGeneric,ExpressionListOpt")


		var tp ast.FuncCallExprType
		if isInTokenMap($3) {
			tp = ast.FuncCallExprTypeKeyword
		} else {
			tp = ast.FuncCallExprTypeGeneric
		}
		$$ = &ast.FuncCallExpr{
			Tp:     tp,
			Schema: model.NewCIStr($1),
			FnName: model.NewCIStr($3),
			Args:   $5.([]ast.ExprNode),
		}
	}

FuncDatetimePrec:
	{


		$$ = nil
	}
|	'(' ')'
	{


		$$ = nil
	}
|	'(' intLit ')'
	{


		expr := ast.NewValueExpr($2, parser.charset, parser.collation)
		$$ = expr
	}

TimeUnit:
	TimestampUnit
{
sql_ir.LogGrammarCoverage("TimeUnit,TimestampUnit")

}
|	"SECOND_MICROSECOND"
	{


		$$ = ast.TimeUnitSecondMicrosecond
	}
|	"MINUTE_MICROSECOND"
	{


		$$ = ast.TimeUnitMinuteMicrosecond
	}
|	"MINUTE_SECOND"
	{


		$$ = ast.TimeUnitMinuteSecond
	}
|	"HOUR_MICROSECOND"
	{


		$$ = ast.TimeUnitHourMicrosecond
	}
|	"HOUR_SECOND"
	{


		$$ = ast.TimeUnitHourSecond
	}
|	"HOUR_MINUTE"
	{


		$$ = ast.TimeUnitHourMinute
	}
|	"DAY_MICROSECOND"
	{


		$$ = ast.TimeUnitDayMicrosecond
	}
|	"DAY_SECOND"
	{


		$$ = ast.TimeUnitDaySecond
	}
|	"DAY_MINUTE"
	{


		$$ = ast.TimeUnitDayMinute
	}
|	"DAY_HOUR"
	{


		$$ = ast.TimeUnitDayHour
	}
|	"YEAR_MONTH"
	{


		$$ = ast.TimeUnitYearMonth
	}

TimestampUnit:
	"MICROSECOND"
	{


		$$ = ast.TimeUnitMicrosecond
	}
|	"SECOND"
	{


		$$ = ast.TimeUnitSecond
	}
|	"MINUTE"
	{


		$$ = ast.TimeUnitMinute
	}
|	"HOUR"
	{


		$$ = ast.TimeUnitHour
	}
|	"DAY"
	{


		$$ = ast.TimeUnitDay
	}
|	"WEEK"
	{


		$$ = ast.TimeUnitWeek
	}
|	"MONTH"
	{


		$$ = ast.TimeUnitMonth
	}
|	"QUARTER"
	{


		$$ = ast.TimeUnitQuarter
	}
|	"YEAR"
	{


		$$ = ast.TimeUnitYear
	}
|	"SQL_TSI_SECOND"
	{


		$$ = ast.TimeUnitSecond
	}
|	"SQL_TSI_MINUTE"
	{


		$$ = ast.TimeUnitMinute
	}
|	"SQL_TSI_HOUR"
	{


		$$ = ast.TimeUnitHour
	}
|	"SQL_TSI_DAY"
	{


		$$ = ast.TimeUnitDay
	}
|	"SQL_TSI_WEEK"
	{


		$$ = ast.TimeUnitWeek
	}
|	"SQL_TSI_MONTH"
	{


		$$ = ast.TimeUnitMonth
	}
|	"SQL_TSI_QUARTER"
	{


		$$ = ast.TimeUnitQuarter
	}
|	"SQL_TSI_YEAR"
	{


		$$ = ast.TimeUnitYear
	}

ExpressionOpt:
	{


		$$ = nil
	}
|	Expression

{
sql_ir.LogGrammarCoverage("ExpressionOpt,Expression")

}
WhenClauseList:
	WhenClause
	{
sql_ir.LogGrammarCoverage("WhenClauseList,WhenClause")


		$$ = []*ast.WhenClause{$1.(*ast.WhenClause)}
	}
|	WhenClauseList WhenClause
	{
sql_ir.LogGrammarCoverage("WhenClauseList,WhenClauseList")
sql_ir.LogGrammarCoverage("WhenClauseList,WhenClause")


		$$ = append($1.([]*ast.WhenClause), $2.(*ast.WhenClause))
	}

WhenClause:
	"WHEN" Expression "THEN" Expression
	{
sql_ir.LogGrammarCoverage("WhenClause,Expression")
sql_ir.LogGrammarCoverage("WhenClause,Expression")


		$$ = &ast.WhenClause{
			Expr:   $2,
			Result: $4,
		}
	}

ElseOpt:
	
	{


		$$ = nil
	}
|	"ELSE" Expression
	{
sql_ir.LogGrammarCoverage("ElseOpt,Expression")


		$$ = $2
	}

CastType:
	"BINARY" OptFieldLen
	{
sql_ir.LogGrammarCoverage("CastType,OptFieldLen")


		tp := types.NewFieldType(mysql.TypeVarString)
		tp.SetFlen($2.(int)) // TODO: Flen should be the flen of expression
		if tp.GetFlen() != types.UnspecifiedLength {
			tp.SetType(mysql.TypeString)
		}
		tp.SetCharset(charset.CharsetBin)
		tp.SetCollate(charset.CollationBin)
		tp.AddFlag(mysql.BinaryFlag)
		$$ = tp
	}
|	Char OptFieldLen OptBinary
	{
sql_ir.LogGrammarCoverage("CastType,Char")
sql_ir.LogGrammarCoverage("CastType,OptFieldLen")
sql_ir.LogGrammarCoverage("CastType,OptBinary")


		tp := types.NewFieldType(mysql.TypeVarString)
		tp.SetFlen($2.(int)) // TODO: Flen should be the flen of expression
		tp.SetCharset($3.(*ast.OptBinary).Charset)
		if $3.(*ast.OptBinary).IsBinary {
			tp.AddFlag(mysql.BinaryFlag)
			tp.SetCharset(charset.CharsetBin)
			tp.SetCollate(charset.CollationBin)
		} else if tp.GetCharset() != "" {
			co, err := charset.GetDefaultCollation(tp.GetCharset())
			if err != nil {
				yylex.AppendError(yylex.Errorf("Get collation error for charset: %s", tp.GetCharset()))
				return 1
			}
			tp.SetCollate(co)
			parser.explicitCharset = true
		} else {
			tp.SetCharset(parser.charset)
			tp.SetCollate(parser.collation)
		}
		$$ = tp
	}
|	"DATE"
	{


		tp := types.NewFieldType(mysql.TypeDate)
		tp.SetCharset(charset.CharsetBin)
		tp.SetCollate(charset.CollationBin)
		tp.AddFlag(mysql.BinaryFlag)
		$$ = tp
	}
|	"YEAR"
	{


		tp := types.NewFieldType(mysql.TypeYear)
		tp.SetCharset(charset.CharsetBin)
		tp.SetCollate(charset.CollationBin)
		tp.AddFlag(mysql.BinaryFlag)
		$$ = tp
	}
|	"DATETIME" OptFieldLen
	{
sql_ir.LogGrammarCoverage("CastType,OptFieldLen")


		tp := types.NewFieldType(mysql.TypeDatetime)
		flen, _ := mysql.GetDefaultFieldLengthAndDecimalForCast(mysql.TypeDatetime)
		tp.SetFlen(flen)
		tp.SetDecimal($2.(int))
		if tp.GetDecimal() > 0 {
			tp.SetFlen(tp.GetFlen() + 1 + tp.GetDecimal())
		}
		tp.SetCharset(charset.CharsetBin)
		tp.SetCollate(charset.CollationBin)
		tp.AddFlag(mysql.BinaryFlag)
		$$ = tp
	}
|	"DECIMAL" FloatOpt
	{
sql_ir.LogGrammarCoverage("CastType,FloatOpt")


		fopt := $2.(*ast.FloatOpt)
		tp := types.NewFieldType(mysql.TypeNewDecimal)
		tp.SetFlen(fopt.Flen)
		tp.SetDecimal(fopt.Decimal)
		tp.SetCharset(charset.CharsetBin)
		tp.SetCollate(charset.CollationBin)
		tp.AddFlag(mysql.BinaryFlag)
		$$ = tp
	}
|	"TIME" OptFieldLen
	{
sql_ir.LogGrammarCoverage("CastType,OptFieldLen")


		tp := types.NewFieldType(mysql.TypeDuration)
		flen, _ := mysql.GetDefaultFieldLengthAndDecimalForCast(mysql.TypeDuration)
		tp.SetFlen(flen)
		tp.SetDecimal($2.(int))
		if tp.GetDecimal() > 0 {
			tp.SetFlen(tp.GetFlen() + 1 + tp.GetDecimal())
		}
		tp.SetCharset(charset.CharsetBin)
		tp.SetCollate(charset.CollationBin)
		tp.AddFlag(mysql.BinaryFlag)
		$$ = tp
	}
|	"SIGNED" OptInteger
	{
sql_ir.LogGrammarCoverage("CastType,OptInteger")


		tp := types.NewFieldType(mysql.TypeLonglong)
		tp.SetCharset(charset.CharsetBin)
		tp.SetCollate(charset.CollationBin)
		tp.AddFlag(mysql.BinaryFlag)
		$$ = tp
	}
|	"UNSIGNED" OptInteger
	{
sql_ir.LogGrammarCoverage("CastType,OptInteger")


		tp := types.NewFieldType(mysql.TypeLonglong)
		tp.AddFlag(mysql.UnsignedFlag | mysql.BinaryFlag)
		tp.SetCharset(charset.CharsetBin)
		tp.SetCollate(charset.CollationBin)
		$$ = tp
	}
|	"JSON"
	{


		tp := types.NewFieldType(mysql.TypeJSON)
		tp.AddFlag(mysql.BinaryFlag | mysql.ParseToJSONFlag)
		tp.SetCharset(mysql.DefaultCharset)
		tp.SetCollate(mysql.DefaultCollationName)
		$$ = tp
	}
|	"DOUBLE"
	{


		tp := types.NewFieldType(mysql.TypeDouble)
		flen, decimal := mysql.GetDefaultFieldLengthAndDecimalForCast(mysql.TypeDouble)
		tp.SetFlen(flen)
		tp.SetDecimal(decimal)
		tp.AddFlag(mysql.BinaryFlag)
		tp.SetCharset(charset.CharsetBin)
		tp.SetCollate(charset.CollationBin)
		$$ = tp
	}
|	"FLOAT" FloatOpt
	{
sql_ir.LogGrammarCoverage("CastType,FloatOpt")


		tp := types.NewFieldType(mysql.TypeFloat)
		fopt := $2.(*ast.FloatOpt)
		if fopt.Flen >= 54 {
			yylex.AppendError(ErrTooBigPrecision.GenWithStackByArgs(fopt.Flen, "CAST", 53))
		} else if fopt.Flen >= 25 {
			tp = types.NewFieldType(mysql.TypeDouble)
		}
		flen, decimal := mysql.GetDefaultFieldLengthAndDecimalForCast(tp.GetType())
		tp.SetFlen(flen)
		tp.SetDecimal(decimal)
		tp.AddFlag(mysql.BinaryFlag)
		tp.SetCharset(charset.CharsetBin)
		tp.SetCollate(charset.CollationBin)
		$$ = tp
	}
|	"REAL"
	{


		var tp *types.FieldType
		if parser.lexer.GetSQLMode().HasRealAsFloatMode() {
			tp = types.NewFieldType(mysql.TypeFloat)
		} else {
			tp = types.NewFieldType(mysql.TypeDouble)
		}
		flen, decimal := mysql.GetDefaultFieldLengthAndDecimalForCast(tp.GetType())
		tp.SetFlen(flen)
		tp.SetDecimal(decimal)
		tp.AddFlag(mysql.BinaryFlag)
		tp.SetCharset(charset.CharsetBin)
		tp.SetCollate(charset.CollationBin)
		$$ = tp
	}

Priority:
	"LOW_PRIORITY"
	{


		$$ = mysql.LowPriority
	}
|	"HIGH_PRIORITY"
	{


		$$ = mysql.HighPriority
	}
|	"DELAYED"
	{


		$$ = mysql.DelayedPriority
	}

PriorityOpt:
	{


		$$ = mysql.NoPriority
	}
|	Priority

{
sql_ir.LogGrammarCoverage("PriorityOpt,Priority")

}
TableName:
	Identifier
	{
sql_ir.LogGrammarCoverage("TableName,Identifier")


		$$ = &ast.TableName{Name: model.NewCIStr($1)}
	}
|	Identifier '.' Identifier
	{
sql_ir.LogGrammarCoverage("TableName,Identifier")
sql_ir.LogGrammarCoverage("TableName,Identifier")


		$$ = &ast.TableName{Schema: model.NewCIStr($1), Name: model.NewCIStr($3)}
	}

TableNameList:
	TableName
	{
sql_ir.LogGrammarCoverage("TableNameList,TableName")


		tbl := []*ast.TableName{$1.(*ast.TableName)}
		$$ = tbl
	}
|	TableNameList ',' TableName
	{
sql_ir.LogGrammarCoverage("TableNameList,TableNameList")
sql_ir.LogGrammarCoverage("TableNameList,TableName")


		$$ = append($1.([]*ast.TableName), $3.(*ast.TableName))
	}

TableNameOptWild:
	Identifier OptWild
	{
sql_ir.LogGrammarCoverage("TableNameOptWild,Identifier")
sql_ir.LogGrammarCoverage("TableNameOptWild,OptWild")


		$$ = &ast.TableName{Name: model.NewCIStr($1)}
	}
|	Identifier '.' Identifier OptWild
	{
sql_ir.LogGrammarCoverage("TableNameOptWild,Identifier")
sql_ir.LogGrammarCoverage("TableNameOptWild,Identifier")
sql_ir.LogGrammarCoverage("TableNameOptWild,OptWild")


		$$ = &ast.TableName{Schema: model.NewCIStr($1), Name: model.NewCIStr($3)}
	}

TableAliasRefList:
	TableNameOptWild
	{
sql_ir.LogGrammarCoverage("TableAliasRefList,TableNameOptWild")


		tbl := []*ast.TableName{$1.(*ast.TableName)}
		$$ = tbl
	}
|	TableAliasRefList ',' TableNameOptWild
	{
sql_ir.LogGrammarCoverage("TableAliasRefList,TableAliasRefList")
sql_ir.LogGrammarCoverage("TableAliasRefList,TableNameOptWild")


		$$ = append($1.([]*ast.TableName), $3.(*ast.TableName))
	}

OptWild:
	%prec empty
	{

}
|	'.' '*'
	{

}

QuickOptional:
	%prec empty
	{


		$$ = false
	}
|	"QUICK"
	{


		$$ = true
	}


PreparedStmt:
	"PREPARE" Identifier "FROM" PrepareSQL
	{
sql_ir.LogGrammarCoverage("PreparedStmt,Identifier")
sql_ir.LogGrammarCoverage("PreparedStmt,PrepareSQL")


		var sqlText string
		var sqlVar *ast.VariableExpr
		switch x := $4.(type) {
		case string:
			sqlText = x
		case *ast.VariableExpr:
			sqlVar = x
		}
		$$ = &ast.PrepareStmt{
			Name:    $2,
			SQLText: sqlText,
			SQLVar:  sqlVar,
		}
	}

PrepareSQL:
	stringLit
	{
sql_ir.LogGrammarCoverage("PrepareSQL,stringLit")


		$$ = $1
	}
|	UserVariable
	{
sql_ir.LogGrammarCoverage("PrepareSQL,UserVariable")


		$$ = $1
	}


ExecuteStmt:
	"EXECUTE" Identifier
	{
sql_ir.LogGrammarCoverage("ExecuteStmt,Identifier")


		$$ = &ast.ExecuteStmt{Name: $2}
	}
|	"EXECUTE" Identifier "USING" UserVariableList
	{
sql_ir.LogGrammarCoverage("ExecuteStmt,Identifier")
sql_ir.LogGrammarCoverage("ExecuteStmt,UserVariableList")


		$$ = &ast.ExecuteStmt{
			Name:      $2,
			UsingVars: $4.([]ast.ExprNode),
		}
	}

UserVariableList:
	UserVariable
	{
sql_ir.LogGrammarCoverage("UserVariableList,UserVariable")


		$$ = []ast.ExprNode{$1}
	}
|	UserVariableList ',' UserVariable
	{
sql_ir.LogGrammarCoverage("UserVariableList,UserVariableList")
sql_ir.LogGrammarCoverage("UserVariableList,UserVariable")


		$$ = append($1.([]ast.ExprNode), $3)
	}

DeallocateStmt:
	DeallocateSym "PREPARE" Identifier
	{
sql_ir.LogGrammarCoverage("DeallocateStmt,DeallocateSym")
sql_ir.LogGrammarCoverage("DeallocateStmt,Identifier")


		$$ = &ast.DeallocateStmt{Name: $3}
	}

DeallocateSym:
	"DEALLOCATE"
{

}
|	"DROP"

{

}
RollbackStmt:
	"ROLLBACK"
	{


		$$ = &ast.RollbackStmt{}
	}
|	"ROLLBACK" CompletionTypeWithinTransaction
	{
sql_ir.LogGrammarCoverage("RollbackStmt,CompletionTypeWithinTransaction")


		$$ = &ast.RollbackStmt{CompletionType: $2.(ast.CompletionType)}
	}

CompletionTypeWithinTransaction:
	"AND" "CHAIN" "NO" "RELEASE"
	{


		$$ = ast.CompletionTypeChain
	}
|	"AND" "NO" "CHAIN" "RELEASE"
	{


		$$ = ast.CompletionTypeRelease
	}
|	"AND" "NO" "CHAIN" "NO" "RELEASE"
	{


		$$ = ast.CompletionTypeDefault
	}
|	"AND" "CHAIN"
	{


		$$ = ast.CompletionTypeChain
	}
|	"AND" "NO" "CHAIN"
	{


		$$ = ast.CompletionTypeDefault
	}
|	"RELEASE"
	{


		$$ = ast.CompletionTypeRelease
	}
|	"NO" "RELEASE"
	{


		$$ = ast.CompletionTypeDefault
	}

ShutdownStmt:
	"SHUTDOWN"
	{


		$$ = &ast.ShutdownStmt{}
	}

RestartStmt:
	"RESTART"
	{


		$$ = &ast.RestartStmt{}
	}

HelpStmt:
	"HELP" stringLit
	{
sql_ir.LogGrammarCoverage("HelpStmt,stringLit")


		$$ = &ast.HelpStmt{Topic: $2}
	}

SelectStmtBasic:
	"SELECT" SelectStmtOpts SelectStmtFieldList
	{
sql_ir.LogGrammarCoverage("SelectStmtBasic,SelectStmtOpts")
sql_ir.LogGrammarCoverage("SelectStmtBasic,SelectStmtFieldList")


		st := &ast.SelectStmt{
			SelectStmtOpts: $2.(*ast.SelectStmtOpts),
			Distinct:       $2.(*ast.SelectStmtOpts).Distinct,
			Fields:         $3.(*ast.FieldList),
			Kind:           ast.SelectStmtKindSelect,
		}
		if st.SelectStmtOpts.TableHints != nil {
			st.TableHints = st.SelectStmtOpts.TableHints
		}
		$$ = st
	}

SelectStmtFromDualTable:
	SelectStmtBasic FromDual WhereClauseOptional
	{
sql_ir.LogGrammarCoverage("SelectStmtFromDualTable,SelectStmtBasic")
sql_ir.LogGrammarCoverage("SelectStmtFromDualTable,FromDual")
sql_ir.LogGrammarCoverage("SelectStmtFromDualTable,WhereClauseOptional")


		st := $1.(*ast.SelectStmt)
		lastField := st.Fields.Fields[len(st.Fields.Fields)-1]
		if lastField.Expr != nil && lastField.AsName.O == "" {
			lastEnd := yyS[yypt-1].offset - 1
			lastField.SetText(parser.lexer.client, parser.src[lastField.Offset:lastEnd])
		}
		if $3 != nil {
			st.Where = $3.(ast.ExprNode)
		}
	}

SelectStmtFromTable:
	SelectStmtBasic "FROM" TableRefsClause WhereClauseOptional SelectStmtGroup HavingClause WindowClauseOptional
	{
sql_ir.LogGrammarCoverage("SelectStmtFromTable,SelectStmtBasic")
sql_ir.LogGrammarCoverage("SelectStmtFromTable,TableRefsClause")
sql_ir.LogGrammarCoverage("SelectStmtFromTable,WhereClauseOptional")
sql_ir.LogGrammarCoverage("SelectStmtFromTable,SelectStmtGroup")
sql_ir.LogGrammarCoverage("SelectStmtFromTable,HavingClause")
sql_ir.LogGrammarCoverage("SelectStmtFromTable,WindowClauseOptional")


		st := $1.(*ast.SelectStmt)
		st.From = $3.(*ast.TableRefsClause)
		lastField := st.Fields.Fields[len(st.Fields.Fields)-1]
		if lastField.Expr != nil && lastField.AsName.O == "" {
			lastEnd := parser.endOffset(&yyS[yypt-5])
			lastField.SetText(parser.lexer.client, parser.src[lastField.Offset:lastEnd])
		}
		if $4 != nil {
			st.Where = $4.(ast.ExprNode)
		}
		if $5 != nil {
			st.GroupBy = $5.(*ast.GroupByClause)
		}
		if $6 != nil {
			st.Having = $6.(*ast.HavingClause)
		}
		if $7 != nil {
			st.WindowSpecs = ($7.([]ast.WindowSpec))
		}
		$$ = st
	}

TableSampleOpt:
	%prec empty
	{


		$$ = nil
	}
|	"TABLESAMPLE" TableSampleMethodOpt '(' Expression TableSampleUnitOpt ')' RepeatableOpt
	{
sql_ir.LogGrammarCoverage("TableSampleOpt,TableSampleMethodOpt")
sql_ir.LogGrammarCoverage("TableSampleOpt,Expression")
sql_ir.LogGrammarCoverage("TableSampleOpt,TableSampleUnitOpt")
sql_ir.LogGrammarCoverage("TableSampleOpt,RepeatableOpt")


		var repSeed ast.ExprNode
		if $7 != nil {
			repSeed = ast.NewValueExpr($7, parser.charset, parser.collation)
		}
		$$ = &ast.TableSample{
			SampleMethod:     $2.(ast.SampleMethodType),
			Expr:             ast.NewValueExpr($4, parser.charset, parser.collation),
			SampleClauseUnit: $5.(ast.SampleClauseUnitType),
			RepeatableSeed:   repSeed,
		}
	}
|	"TABLESAMPLE" TableSampleMethodOpt '(' ')' RepeatableOpt
	{
sql_ir.LogGrammarCoverage("TableSampleOpt,TableSampleMethodOpt")
sql_ir.LogGrammarCoverage("TableSampleOpt,RepeatableOpt")


		var repSeed ast.ExprNode
		if $5 != nil {
			repSeed = ast.NewValueExpr($5, parser.charset, parser.collation)
		}
		$$ = &ast.TableSample{
			SampleMethod:   $2.(ast.SampleMethodType),
			RepeatableSeed: repSeed,
		}
	}

TableSampleMethodOpt:
	%prec empty
	{


		$$ = ast.SampleMethodTypeNone
	}
|	"SYSTEM"
	{


		$$ = ast.SampleMethodTypeSystem
	}
|	"BERNOULLI"
	{


		$$ = ast.SampleMethodTypeBernoulli
	}
|	"REGIONS"
	{


		$$ = ast.SampleMethodTypeTiDBRegion
	}

TableSampleUnitOpt:
	%prec empty
	{


		$$ = ast.SampleClauseUnitTypeDefault
	}
|	"ROWS"
	{


		$$ = ast.SampleClauseUnitTypeRow
	}
|	"PERCENT"
	{


		$$ = ast.SampleClauseUnitTypePercent
	}

RepeatableOpt:
	%prec empty
	{


		$$ = nil
	}
|	"REPEATABLE" '(' Expression ')'
	{
sql_ir.LogGrammarCoverage("RepeatableOpt,Expression")


		$$ = $3
	}

SelectStmt:
	SelectStmtBasic WhereClauseOptional SelectStmtGroup OrderByOptional SelectStmtLimitOpt SelectLockOpt SelectStmtIntoOption
	{
sql_ir.LogGrammarCoverage("SelectStmt,SelectStmtBasic")
sql_ir.LogGrammarCoverage("SelectStmt,WhereClauseOptional")
sql_ir.LogGrammarCoverage("SelectStmt,SelectStmtGroup")
sql_ir.LogGrammarCoverage("SelectStmt,OrderByOptional")
sql_ir.LogGrammarCoverage("SelectStmt,SelectStmtLimitOpt")
sql_ir.LogGrammarCoverage("SelectStmt,SelectLockOpt")
sql_ir.LogGrammarCoverage("SelectStmt,SelectStmtIntoOption")


		st := $1.(*ast.SelectStmt)
		if $6 != nil {
			st.LockInfo = $6.(*ast.SelectLockInfo)
		}
		lastField := st.Fields.Fields[len(st.Fields.Fields)-1]
		if lastField.Expr != nil && lastField.AsName.O == "" {
			src := parser.src
			var lastEnd int
			if $2 != nil {
				lastEnd = yyS[yypt-5].offset - 1
			} else if $3 != nil {
				lastEnd = yyS[yypt-4].offset - 1
			} else if $4 != nil {
				lastEnd = yyS[yypt-3].offset - 1
			} else if $5 != nil {
				lastEnd = yyS[yypt-2].offset - 1
			} else if st.LockInfo != nil && st.LockInfo.LockType != ast.SelectLockNone {
				lastEnd = yyS[yypt-1].offset - 1
			} else if $7 != nil {
				lastEnd = yyS[yypt].offset - 1
			} else {
				lastEnd = len(src)
				if src[lastEnd-1] == ';' {
					lastEnd--
				}
			}
			lastField.SetText(parser.lexer.client, src[lastField.Offset:lastEnd])
		}
		if $2 != nil {
			st.Where = $2.(ast.ExprNode)
		}
		if $3 != nil {
			st.GroupBy = $3.(*ast.GroupByClause)
		}
		if $4 != nil {
			st.OrderBy = $4.(*ast.OrderByClause)
		}
		if $5 != nil {
			st.Limit = $5.(*ast.Limit)
		}
		if $7 != nil {
			st.SelectIntoOpt = $7.(*ast.SelectIntoOption)
		}
		$$ = st
	}
|	SelectStmtFromDualTable SelectStmtGroup OrderByOptional SelectStmtLimitOpt SelectLockOpt SelectStmtIntoOption
	{
sql_ir.LogGrammarCoverage("SelectStmt,SelectStmtFromDualTable")
sql_ir.LogGrammarCoverage("SelectStmt,SelectStmtGroup")
sql_ir.LogGrammarCoverage("SelectStmt,OrderByOptional")
sql_ir.LogGrammarCoverage("SelectStmt,SelectStmtLimitOpt")
sql_ir.LogGrammarCoverage("SelectStmt,SelectLockOpt")
sql_ir.LogGrammarCoverage("SelectStmt,SelectStmtIntoOption")


		st := $1.(*ast.SelectStmt)
		if $2 != nil {
			st.GroupBy = $2.(*ast.GroupByClause)
		}
		if $3 != nil {
			st.OrderBy = $3.(*ast.OrderByClause)
		}
		if $4 != nil {
			st.Limit = $4.(*ast.Limit)
		}
		if $5 != nil {
			st.LockInfo = $5.(*ast.SelectLockInfo)
		}
		if $6 != nil {
			st.SelectIntoOpt = $6.(*ast.SelectIntoOption)
		}
		$$ = st
	}
|	SelectStmtFromTable OrderByOptional SelectStmtLimitOpt SelectLockOpt SelectStmtIntoOption
	{
sql_ir.LogGrammarCoverage("SelectStmt,SelectStmtFromTable")
sql_ir.LogGrammarCoverage("SelectStmt,OrderByOptional")
sql_ir.LogGrammarCoverage("SelectStmt,SelectStmtLimitOpt")
sql_ir.LogGrammarCoverage("SelectStmt,SelectLockOpt")
sql_ir.LogGrammarCoverage("SelectStmt,SelectStmtIntoOption")


		st := $1.(*ast.SelectStmt)
		if $4 != nil {
			st.LockInfo = $4.(*ast.SelectLockInfo)
		}
		if $2 != nil {
			st.OrderBy = $2.(*ast.OrderByClause)
		}
		if $3 != nil {
			st.Limit = $3.(*ast.Limit)
		}
		if $5 != nil {
			st.SelectIntoOpt = $5.(*ast.SelectIntoOption)
		}
		$$ = st
	}
|	"TABLE" TableName OrderByOptional SelectStmtLimitOpt SelectLockOpt SelectStmtIntoOption
	{
sql_ir.LogGrammarCoverage("SelectStmt,TableName")
sql_ir.LogGrammarCoverage("SelectStmt,OrderByOptional")
sql_ir.LogGrammarCoverage("SelectStmt,SelectStmtLimitOpt")
sql_ir.LogGrammarCoverage("SelectStmt,SelectLockOpt")
sql_ir.LogGrammarCoverage("SelectStmt,SelectStmtIntoOption")


		st := &ast.SelectStmt{
			Kind:   ast.SelectStmtKindTable,
			Fields: &ast.FieldList{Fields: []*ast.SelectField{{WildCard: &ast.WildCardField{}}}},
		}
		ts := &ast.TableSource{Source: $2.(*ast.TableName)}
		st.From = &ast.TableRefsClause{TableRefs: &ast.Join{Left: ts}}
		if $3 != nil {
			st.OrderBy = $3.(*ast.OrderByClause)
		}
		if $4 != nil {
			st.Limit = $4.(*ast.Limit)
		}
		if $5 != nil {
			st.LockInfo = $5.(*ast.SelectLockInfo)
		}
		if $6 != nil {
			st.SelectIntoOpt = $6.(*ast.SelectIntoOption)
		}
		$$ = st
	}
|	"VALUES" ValuesStmtList OrderByOptional SelectStmtLimitOpt SelectLockOpt SelectStmtIntoOption
	{
sql_ir.LogGrammarCoverage("SelectStmt,ValuesStmtList")
sql_ir.LogGrammarCoverage("SelectStmt,OrderByOptional")
sql_ir.LogGrammarCoverage("SelectStmt,SelectStmtLimitOpt")
sql_ir.LogGrammarCoverage("SelectStmt,SelectLockOpt")
sql_ir.LogGrammarCoverage("SelectStmt,SelectStmtIntoOption")


		st := &ast.SelectStmt{
			Kind:   ast.SelectStmtKindValues,
			Fields: &ast.FieldList{Fields: []*ast.SelectField{{WildCard: &ast.WildCardField{}}}},
			Lists:  $2.([]*ast.RowExpr),
		}
		if $3 != nil {
			st.OrderBy = $3.(*ast.OrderByClause)
		}
		if $4 != nil {
			st.Limit = $4.(*ast.Limit)
		}
		if $5 != nil {
			st.LockInfo = $5.(*ast.SelectLockInfo)
		}
		if $6 != nil {
			st.SelectIntoOpt = $6.(*ast.SelectIntoOption)
		}
		$$ = st
	}

SelectStmtWithClause:
	WithClause SelectStmt
	{
sql_ir.LogGrammarCoverage("SelectStmtWithClause,WithClause")
sql_ir.LogGrammarCoverage("SelectStmtWithClause,SelectStmt")


		sel := $2.(*ast.SelectStmt)
		sel.With = $1.(*ast.WithClause)
		$$ = sel
	}
|	WithClause SubSelect
	{
sql_ir.LogGrammarCoverage("SelectStmtWithClause,WithClause")
sql_ir.LogGrammarCoverage("SelectStmtWithClause,SubSelect")


		var sel ast.StmtNode
		switch x := $2.(*ast.SubqueryExpr).Query.(type) {
		case *ast.SelectStmt:
			x.IsInBraces = true
			x.WithBeforeBraces = true
			x.With = $1.(*ast.WithClause)
			sel = x
		case *ast.SetOprStmt:
			x.IsInBraces = true
			x.With = $1.(*ast.WithClause)
			sel = x
		}
		$$ = sel
	}

WithClause:
	"WITH" WithList
	{
sql_ir.LogGrammarCoverage("WithClause,WithList")


		$$ = $2
	}
|	"WITH" recursive WithList
	{
sql_ir.LogGrammarCoverage("WithClause,WithList")


		ws := $3.(*ast.WithClause)
		ws.IsRecursive = true
		for _, cte := range ws.CTEs {
			cte.IsRecursive = true
		}
		$$ = ws
	}

WithList:
	WithList ',' CommonTableExpr
	{
sql_ir.LogGrammarCoverage("WithList,WithList")
sql_ir.LogGrammarCoverage("WithList,CommonTableExpr")


		ws := $1.(*ast.WithClause)
		ws.CTEs = append(ws.CTEs, $3.(*ast.CommonTableExpression))
		$$ = ws
	}
|	CommonTableExpr
	{
sql_ir.LogGrammarCoverage("WithList,CommonTableExpr")


		ws := &ast.WithClause{}
		ws.CTEs = make([]*ast.CommonTableExpression, 0, 4)
		ws.CTEs = append(ws.CTEs, $1.(*ast.CommonTableExpression))
		$$ = ws
	}

CommonTableExpr:
	Identifier IdentListWithParenOpt "AS" SubSelect
	{
sql_ir.LogGrammarCoverage("CommonTableExpr,Identifier")
sql_ir.LogGrammarCoverage("CommonTableExpr,IdentListWithParenOpt")
sql_ir.LogGrammarCoverage("CommonTableExpr,SubSelect")


		cte := &ast.CommonTableExpression{}
		cte.Name = model.NewCIStr($1)
		cte.ColNameList = $2.([]model.CIStr)
		cte.Query = $4.(*ast.SubqueryExpr)
		$$ = cte
	}

FromDual:
	"FROM" "DUAL"

{

}
WindowClauseOptional:
	{


		$$ = nil
	}
|	"WINDOW" WindowDefinitionList
	{
sql_ir.LogGrammarCoverage("WindowClauseOptional,WindowDefinitionList")


		$$ = $2.([]ast.WindowSpec)
	}

WindowDefinitionList:
	WindowDefinition
	{
sql_ir.LogGrammarCoverage("WindowDefinitionList,WindowDefinition")


		$$ = []ast.WindowSpec{$1.(ast.WindowSpec)}
	}
|	WindowDefinitionList ',' WindowDefinition
	{
sql_ir.LogGrammarCoverage("WindowDefinitionList,WindowDefinitionList")
sql_ir.LogGrammarCoverage("WindowDefinitionList,WindowDefinition")


		$$ = append($1.([]ast.WindowSpec), $3.(ast.WindowSpec))
	}

WindowDefinition:
	WindowName "AS" WindowSpec
	{
sql_ir.LogGrammarCoverage("WindowDefinition,WindowName")
sql_ir.LogGrammarCoverage("WindowDefinition,WindowSpec")


		var spec = $3.(ast.WindowSpec)
		spec.Name = $1.(model.CIStr)
		$$ = spec
	}

WindowName:
	Identifier
	{
sql_ir.LogGrammarCoverage("WindowName,Identifier")


		$$ = model.NewCIStr($1)
	}

WindowSpec:
	'(' WindowSpecDetails ')'
	{
sql_ir.LogGrammarCoverage("WindowSpec,WindowSpecDetails")


		$$ = $2.(ast.WindowSpec)
	}

WindowSpecDetails:
	OptExistingWindowName OptPartitionClause OptWindowOrderByClause OptWindowFrameClause
	{
sql_ir.LogGrammarCoverage("WindowSpecDetails,OptExistingWindowName")
sql_ir.LogGrammarCoverage("WindowSpecDetails,OptPartitionClause")
sql_ir.LogGrammarCoverage("WindowSpecDetails,OptWindowOrderByClause")
sql_ir.LogGrammarCoverage("WindowSpecDetails,OptWindowFrameClause")


		spec := ast.WindowSpec{Ref: $1.(model.CIStr)}
		if $2 != nil {
			spec.PartitionBy = $2.(*ast.PartitionByClause)
		}
		if $3 != nil {
			spec.OrderBy = $3.(*ast.OrderByClause)
		}
		if $4 != nil {
			spec.Frame = $4.(*ast.FrameClause)
		}
		$$ = spec
	}

OptExistingWindowName:
	{


		$$ = model.CIStr{}
	}
|	WindowName

{
sql_ir.LogGrammarCoverage("OptExistingWindowName,WindowName")

}
OptPartitionClause:
	{


		$$ = nil
	}
|	"PARTITION" "BY" ByList
	{
sql_ir.LogGrammarCoverage("OptPartitionClause,ByList")


		$$ = &ast.PartitionByClause{Items: $3.([]*ast.ByItem)}
	}

OptWindowOrderByClause:
	{


		$$ = nil
	}
|	"ORDER" "BY" ByList
	{
sql_ir.LogGrammarCoverage("OptWindowOrderByClause,ByList")


		$$ = &ast.OrderByClause{Items: $3.([]*ast.ByItem)}
	}

OptWindowFrameClause:
	{


		$$ = nil
	}
|	WindowFrameUnits WindowFrameExtent
	{
sql_ir.LogGrammarCoverage("OptWindowFrameClause,WindowFrameUnits")
sql_ir.LogGrammarCoverage("OptWindowFrameClause,WindowFrameExtent")


		$$ = &ast.FrameClause{
			Type:   $1.(ast.FrameType),
			Extent: $2.(ast.FrameExtent),
		}
	}

WindowFrameUnits:
	"ROWS"
	{


		$$ = ast.FrameType(ast.Rows)
	}
|	"RANGE"
	{


		$$ = ast.FrameType(ast.Ranges)
	}
|	"GROUPS"
	{


		$$ = ast.FrameType(ast.Groups)
	}

WindowFrameExtent:
	WindowFrameStart
	{
sql_ir.LogGrammarCoverage("WindowFrameExtent,WindowFrameStart")


		$$ = ast.FrameExtent{
			Start: $1.(ast.FrameBound),
			End:   ast.FrameBound{Type: ast.CurrentRow},
		}
	}
|	WindowFrameBetween

{
sql_ir.LogGrammarCoverage("WindowFrameExtent,WindowFrameBetween")

}
WindowFrameStart:
	"UNBOUNDED" "PRECEDING"
	{


		$$ = ast.FrameBound{Type: ast.Preceding, UnBounded: true}
	}
|	NumLiteral "PRECEDING"
	{
sql_ir.LogGrammarCoverage("WindowFrameStart,NumLiteral")


		$$ = ast.FrameBound{Type: ast.Preceding, Expr: ast.NewValueExpr($1, parser.charset, parser.collation)}
	}
|	paramMarker "PRECEDING"
	{


		$$ = ast.FrameBound{Type: ast.Preceding, Expr: ast.NewParamMarkerExpr(yyS[yypt].offset)}
	}
|	"INTERVAL" Expression TimeUnit "PRECEDING"
	{
sql_ir.LogGrammarCoverage("WindowFrameStart,Expression")
sql_ir.LogGrammarCoverage("WindowFrameStart,TimeUnit")


		$$ = ast.FrameBound{Type: ast.Preceding, Expr: $2, Unit: $3.(ast.TimeUnitType)}
	}
|	"CURRENT" "ROW"
	{


		$$ = ast.FrameBound{Type: ast.CurrentRow}
	}

WindowFrameBetween:
	"BETWEEN" WindowFrameBound "AND" WindowFrameBound
	{
sql_ir.LogGrammarCoverage("WindowFrameBetween,WindowFrameBound")
sql_ir.LogGrammarCoverage("WindowFrameBetween,WindowFrameBound")


		$$ = ast.FrameExtent{Start: $2.(ast.FrameBound), End: $4.(ast.FrameBound)}
	}

WindowFrameBound:
	WindowFrameStart
{
sql_ir.LogGrammarCoverage("WindowFrameBound,WindowFrameStart")

}
|	"UNBOUNDED" "FOLLOWING"
	{


		$$ = ast.FrameBound{Type: ast.Following, UnBounded: true}
	}
|	NumLiteral "FOLLOWING"
	{
sql_ir.LogGrammarCoverage("WindowFrameBound,NumLiteral")


		$$ = ast.FrameBound{Type: ast.Following, Expr: ast.NewValueExpr($1, parser.charset, parser.collation)}
	}
|	paramMarker "FOLLOWING"
	{


		$$ = ast.FrameBound{Type: ast.Following, Expr: ast.NewParamMarkerExpr(yyS[yypt].offset)}
	}
|	"INTERVAL" Expression TimeUnit "FOLLOWING"
	{
sql_ir.LogGrammarCoverage("WindowFrameBound,Expression")
sql_ir.LogGrammarCoverage("WindowFrameBound,TimeUnit")


		$$ = ast.FrameBound{Type: ast.Following, Expr: $2, Unit: $3.(ast.TimeUnitType)}
	}

OptWindowingClause:
	{


		$$ = nil
	}
|	WindowingClause
	{
sql_ir.LogGrammarCoverage("OptWindowingClause,WindowingClause")


		spec := $1.(ast.WindowSpec)
		$$ = &spec
	}

WindowingClause:
	"OVER" WindowNameOrSpec
	{
sql_ir.LogGrammarCoverage("WindowingClause,WindowNameOrSpec")


		$$ = $2.(ast.WindowSpec)
	}

WindowNameOrSpec:
	WindowName
	{
sql_ir.LogGrammarCoverage("WindowNameOrSpec,WindowName")


		$$ = ast.WindowSpec{Name: $1.(model.CIStr), OnlyAlias: true}
	}
|	WindowSpec

{
sql_ir.LogGrammarCoverage("WindowNameOrSpec,WindowSpec")

}
WindowFuncCall:
	"ROW_NUMBER" '(' ')' WindowingClause
	{
sql_ir.LogGrammarCoverage("WindowFuncCall,WindowingClause")


		$$ = &ast.WindowFuncExpr{F: $1, Spec: $4.(ast.WindowSpec)}
	}
|	"RANK" '(' ')' WindowingClause
	{
sql_ir.LogGrammarCoverage("WindowFuncCall,WindowingClause")


		$$ = &ast.WindowFuncExpr{F: $1, Spec: $4.(ast.WindowSpec)}
	}
|	"DENSE_RANK" '(' ')' WindowingClause
	{
sql_ir.LogGrammarCoverage("WindowFuncCall,WindowingClause")


		$$ = &ast.WindowFuncExpr{F: $1, Spec: $4.(ast.WindowSpec)}
	}
|	"CUME_DIST" '(' ')' WindowingClause
	{
sql_ir.LogGrammarCoverage("WindowFuncCall,WindowingClause")


		$$ = &ast.WindowFuncExpr{F: $1, Spec: $4.(ast.WindowSpec)}
	}
|	"PERCENT_RANK" '(' ')' WindowingClause
	{
sql_ir.LogGrammarCoverage("WindowFuncCall,WindowingClause")


		$$ = &ast.WindowFuncExpr{F: $1, Spec: $4.(ast.WindowSpec)}
	}
|	"NTILE" '(' SimpleExpr ')' WindowingClause
	{
sql_ir.LogGrammarCoverage("WindowFuncCall,SimpleExpr")
sql_ir.LogGrammarCoverage("WindowFuncCall,WindowingClause")


		$$ = &ast.WindowFuncExpr{F: $1, Args: []ast.ExprNode{$3}, Spec: $5.(ast.WindowSpec)}
	}
|	"LEAD" '(' Expression OptLeadLagInfo ')' OptNullTreatment WindowingClause
	{
sql_ir.LogGrammarCoverage("WindowFuncCall,Expression")
sql_ir.LogGrammarCoverage("WindowFuncCall,OptLeadLagInfo")
sql_ir.LogGrammarCoverage("WindowFuncCall,OptNullTreatment")
sql_ir.LogGrammarCoverage("WindowFuncCall,WindowingClause")


		args := []ast.ExprNode{$3}
		if $4 != nil {
			args = append(args, $4.([]ast.ExprNode)...)
		}
		$$ = &ast.WindowFuncExpr{F: $1, Args: args, IgnoreNull: $6.(bool), Spec: $7.(ast.WindowSpec)}
	}
|	"LAG" '(' Expression OptLeadLagInfo ')' OptNullTreatment WindowingClause
	{
sql_ir.LogGrammarCoverage("WindowFuncCall,Expression")
sql_ir.LogGrammarCoverage("WindowFuncCall,OptLeadLagInfo")
sql_ir.LogGrammarCoverage("WindowFuncCall,OptNullTreatment")
sql_ir.LogGrammarCoverage("WindowFuncCall,WindowingClause")


		args := []ast.ExprNode{$3}
		if $4 != nil {
			args = append(args, $4.([]ast.ExprNode)...)
		}
		$$ = &ast.WindowFuncExpr{F: $1, Args: args, IgnoreNull: $6.(bool), Spec: $7.(ast.WindowSpec)}
	}
|	"FIRST_VALUE" '(' Expression ')' OptNullTreatment WindowingClause
	{
sql_ir.LogGrammarCoverage("WindowFuncCall,Expression")
sql_ir.LogGrammarCoverage("WindowFuncCall,OptNullTreatment")
sql_ir.LogGrammarCoverage("WindowFuncCall,WindowingClause")


		$$ = &ast.WindowFuncExpr{F: $1, Args: []ast.ExprNode{$3}, IgnoreNull: $5.(bool), Spec: $6.(ast.WindowSpec)}
	}
|	"LAST_VALUE" '(' Expression ')' OptNullTreatment WindowingClause
	{
sql_ir.LogGrammarCoverage("WindowFuncCall,Expression")
sql_ir.LogGrammarCoverage("WindowFuncCall,OptNullTreatment")
sql_ir.LogGrammarCoverage("WindowFuncCall,WindowingClause")


		$$ = &ast.WindowFuncExpr{F: $1, Args: []ast.ExprNode{$3}, IgnoreNull: $5.(bool), Spec: $6.(ast.WindowSpec)}
	}
|	"NTH_VALUE" '(' Expression ',' SimpleExpr ')' OptFromFirstLast OptNullTreatment WindowingClause
	{
sql_ir.LogGrammarCoverage("WindowFuncCall,Expression")
sql_ir.LogGrammarCoverage("WindowFuncCall,SimpleExpr")
sql_ir.LogGrammarCoverage("WindowFuncCall,OptFromFirstLast")
sql_ir.LogGrammarCoverage("WindowFuncCall,OptNullTreatment")
sql_ir.LogGrammarCoverage("WindowFuncCall,WindowingClause")


		$$ = &ast.WindowFuncExpr{F: $1, Args: []ast.ExprNode{$3, $5}, FromLast: $7.(bool), IgnoreNull: $8.(bool), Spec: $9.(ast.WindowSpec)}
	}

OptLeadLagInfo:
	{


		$$ = nil
	}
|	',' NumLiteral OptLLDefault
	{
sql_ir.LogGrammarCoverage("OptLeadLagInfo,NumLiteral")
sql_ir.LogGrammarCoverage("OptLeadLagInfo,OptLLDefault")


		args := []ast.ExprNode{ast.NewValueExpr($2, parser.charset, parser.collation)}
		if $3 != nil {
			args = append(args, $3.(ast.ExprNode))
		}
		$$ = args
	}
|	',' paramMarker OptLLDefault
	{
sql_ir.LogGrammarCoverage("OptLeadLagInfo,OptLLDefault")


		args := []ast.ExprNode{ast.NewParamMarkerExpr(yyS[yypt-1].offset)}
		if $3 != nil {
			args = append(args, $3.(ast.ExprNode))
		}
		$$ = args
	}

OptLLDefault:
	{


		$$ = nil
	}
|	',' Expression
	{
sql_ir.LogGrammarCoverage("OptLLDefault,Expression")


		$$ = $2
	}

OptNullTreatment:
	{


		$$ = false
	}
|	"RESPECT" "NULLS"
	{


		$$ = false
	}
|	"IGNORE" "NULLS"
	{


		$$ = true
	}

OptFromFirstLast:
	{


		$$ = false
	}
|	"FROM" "FIRST"
	{


		$$ = false
	}
|	"FROM" "LAST"
	{


		$$ = true
	}

TableRefsClause:
	TableRefs
	{
sql_ir.LogGrammarCoverage("TableRefsClause,TableRefs")


		$$ = &ast.TableRefsClause{TableRefs: $1.(*ast.Join)}
	}

TableRefs:
	EscapedTableRef
	{
sql_ir.LogGrammarCoverage("TableRefs,EscapedTableRef")


		if j, ok := $1.(*ast.Join); ok {
			// if $1 is Join, use it directly
			$$ = j
		} else {
			$$ = &ast.Join{Left: $1.(ast.ResultSetNode), Right: nil}
		}
	}
|	TableRefs ',' EscapedTableRef
	{
sql_ir.LogGrammarCoverage("TableRefs,TableRefs")
sql_ir.LogGrammarCoverage("TableRefs,EscapedTableRef")


		
		$$ = &ast.Join{Left: $1.(ast.ResultSetNode), Right: $3.(ast.ResultSetNode), Tp: ast.CrossJoin}
	}

EscapedTableRef:
	TableRef %prec lowerThanSetKeyword
{
sql_ir.LogGrammarCoverage("EscapedTableRef,TableRef")

}
|	'{' Identifier TableRef '}'
	{
sql_ir.LogGrammarCoverage("EscapedTableRef,Identifier")
sql_ir.LogGrammarCoverage("EscapedTableRef,TableRef")


		
		$$ = $3
	}

TableRef:
	TableFactor
{
sql_ir.LogGrammarCoverage("TableRef,TableFactor")

}
|	JoinTable

{
sql_ir.LogGrammarCoverage("TableRef,JoinTable")

}
TableFactor:
	TableName PartitionNameListOpt TableAsNameOpt AsOfClauseOpt IndexHintListOpt TableSampleOpt
	{
sql_ir.LogGrammarCoverage("TableFactor,TableName")
sql_ir.LogGrammarCoverage("TableFactor,PartitionNameListOpt")
sql_ir.LogGrammarCoverage("TableFactor,TableAsNameOpt")
sql_ir.LogGrammarCoverage("TableFactor,AsOfClauseOpt")
sql_ir.LogGrammarCoverage("TableFactor,IndexHintListOpt")
sql_ir.LogGrammarCoverage("TableFactor,TableSampleOpt")


		tn := $1.(*ast.TableName)
		tn.PartitionNames = $2.([]model.CIStr)
		tn.IndexHints = $5.([]*ast.IndexHint)
		if $6 != nil {
			tn.TableSample = $6.(*ast.TableSample)
		}
		if $4 != nil {
			tn.AsOf = $4.(*ast.AsOfClause)
		}
		$$ = &ast.TableSource{Source: tn, AsName: $3.(model.CIStr)}
	}
|	SubSelect TableAsNameOpt
	{
sql_ir.LogGrammarCoverage("TableFactor,SubSelect")
sql_ir.LogGrammarCoverage("TableFactor,TableAsNameOpt")


		resultNode := $1.(*ast.SubqueryExpr).Query
		$$ = &ast.TableSource{Source: resultNode, AsName: $2.(model.CIStr)}
	}
|	'(' TableRefs ')'
	{
sql_ir.LogGrammarCoverage("TableFactor,TableRefs")


		j := $2.(*ast.Join)
		j.ExplicitParens = true
		$$ = $2
	}

PartitionNameListOpt:
	
	{


		$$ = []model.CIStr{}
	}
|	"PARTITION" '(' PartitionNameList ')'
	{
sql_ir.LogGrammarCoverage("PartitionNameListOpt,PartitionNameList")


		$$ = $3
	}

TableAsNameOpt:
	%prec empty
	{


		$$ = model.CIStr{}
	}
|	TableAsName

{
sql_ir.LogGrammarCoverage("TableAsNameOpt,TableAsName")

}
TableAsName:
	Identifier
	{
sql_ir.LogGrammarCoverage("TableAsName,Identifier")


		$$ = model.NewCIStr($1)
	}
|	"AS" Identifier
	{
sql_ir.LogGrammarCoverage("TableAsName,Identifier")


		$$ = model.NewCIStr($2)
	}

IndexHintType:
	"USE" KeyOrIndex
	{
sql_ir.LogGrammarCoverage("IndexHintType,KeyOrIndex")


		$$ = ast.HintUse
	}
|	"IGNORE" KeyOrIndex
	{
sql_ir.LogGrammarCoverage("IndexHintType,KeyOrIndex")


		$$ = ast.HintIgnore
	}
|	"FORCE" KeyOrIndex
	{
sql_ir.LogGrammarCoverage("IndexHintType,KeyOrIndex")


		$$ = ast.HintForce
	}

IndexHintScope:
	{


		$$ = ast.HintForScan
	}
|	"FOR" "JOIN"
	{


		$$ = ast.HintForJoin
	}
|	"FOR" "ORDER" "BY"
	{


		$$ = ast.HintForOrderBy
	}
|	"FOR" "GROUP" "BY"
	{


		$$ = ast.HintForGroupBy
	}

IndexHint:
	IndexHintType IndexHintScope '(' IndexNameList ')'
	{
sql_ir.LogGrammarCoverage("IndexHint,IndexHintType")
sql_ir.LogGrammarCoverage("IndexHint,IndexHintScope")
sql_ir.LogGrammarCoverage("IndexHint,IndexNameList")


		$$ = &ast.IndexHint{
			IndexNames: $4.([]model.CIStr),
			HintType:   $1.(ast.IndexHintType),
			HintScope:  $2.(ast.IndexHintScope),
		}
	}

IndexNameList:
	{


		var nameList []model.CIStr
		$$ = nameList
	}
|	Identifier
	{
sql_ir.LogGrammarCoverage("IndexNameList,Identifier")


		$$ = []model.CIStr{model.NewCIStr($1)}
	}
|	IndexNameList ',' Identifier
	{
sql_ir.LogGrammarCoverage("IndexNameList,IndexNameList")
sql_ir.LogGrammarCoverage("IndexNameList,Identifier")


		$$ = append($1.([]model.CIStr), model.NewCIStr($3))
	}
|	"PRIMARY"
	{


		$$ = []model.CIStr{model.NewCIStr($1)}
	}
|	IndexNameList ',' "PRIMARY"
	{
sql_ir.LogGrammarCoverage("IndexNameList,IndexNameList")


		$$ = append($1.([]model.CIStr), model.NewCIStr($3))
	}

IndexHintList:
	IndexHint
	{
sql_ir.LogGrammarCoverage("IndexHintList,IndexHint")


		$$ = []*ast.IndexHint{$1.(*ast.IndexHint)}
	}
|	IndexHintList IndexHint
	{
sql_ir.LogGrammarCoverage("IndexHintList,IndexHintList")
sql_ir.LogGrammarCoverage("IndexHintList,IndexHint")


		$$ = append($1.([]*ast.IndexHint), $2.(*ast.IndexHint))
	}

IndexHintListOpt:
	{


		$$ = []*ast.IndexHint{}
	}
|	IndexHintList

{
sql_ir.LogGrammarCoverage("IndexHintListOpt,IndexHintList")

}
JoinTable:
	
	TableRef CrossOpt TableRef %prec tableRefPriority
	{
sql_ir.LogGrammarCoverage("JoinTable,TableRef")
sql_ir.LogGrammarCoverage("JoinTable,CrossOpt")
sql_ir.LogGrammarCoverage("JoinTable,TableRef")


		$$ = ast.NewCrossJoin($1.(ast.ResultSetNode), $3.(ast.ResultSetNode))
	}
|	TableRef CrossOpt TableRef "ON" Expression
	{
sql_ir.LogGrammarCoverage("JoinTable,TableRef")
sql_ir.LogGrammarCoverage("JoinTable,CrossOpt")
sql_ir.LogGrammarCoverage("JoinTable,TableRef")
sql_ir.LogGrammarCoverage("JoinTable,Expression")


		on := &ast.OnCondition{Expr: $5}
		$$ = &ast.Join{Left: $1.(ast.ResultSetNode), Right: $3.(ast.ResultSetNode), Tp: ast.CrossJoin, On: on}
	}
|	TableRef CrossOpt TableRef "USING" '(' ColumnNameList ')'
	{
sql_ir.LogGrammarCoverage("JoinTable,TableRef")
sql_ir.LogGrammarCoverage("JoinTable,CrossOpt")
sql_ir.LogGrammarCoverage("JoinTable,TableRef")
sql_ir.LogGrammarCoverage("JoinTable,ColumnNameList")


		$$ = &ast.Join{Left: $1.(ast.ResultSetNode), Right: $3.(ast.ResultSetNode), Tp: ast.CrossJoin, Using: $6.([]*ast.ColumnName)}
	}
|	TableRef JoinType OuterOpt "JOIN" TableRef "ON" Expression
	{
sql_ir.LogGrammarCoverage("JoinTable,TableRef")
sql_ir.LogGrammarCoverage("JoinTable,JoinType")
sql_ir.LogGrammarCoverage("JoinTable,OuterOpt")
sql_ir.LogGrammarCoverage("JoinTable,TableRef")
sql_ir.LogGrammarCoverage("JoinTable,Expression")


		on := &ast.OnCondition{Expr: $7}
		$$ = &ast.Join{Left: $1.(ast.ResultSetNode), Right: $5.(ast.ResultSetNode), Tp: $2.(ast.JoinType), On: on}
	}
|	TableRef JoinType OuterOpt "JOIN" TableRef "USING" '(' ColumnNameList ')'
	{
sql_ir.LogGrammarCoverage("JoinTable,TableRef")
sql_ir.LogGrammarCoverage("JoinTable,JoinType")
sql_ir.LogGrammarCoverage("JoinTable,OuterOpt")
sql_ir.LogGrammarCoverage("JoinTable,TableRef")
sql_ir.LogGrammarCoverage("JoinTable,ColumnNameList")


		$$ = &ast.Join{Left: $1.(ast.ResultSetNode), Right: $5.(ast.ResultSetNode), Tp: $2.(ast.JoinType), Using: $8.([]*ast.ColumnName)}
	}
|	TableRef "NATURAL" "JOIN" TableRef
	{
sql_ir.LogGrammarCoverage("JoinTable,TableRef")
sql_ir.LogGrammarCoverage("JoinTable,TableRef")


		$$ = &ast.Join{Left: $1.(ast.ResultSetNode), Right: $4.(ast.ResultSetNode), NaturalJoin: true}
	}
|	TableRef "NATURAL" JoinType OuterOpt "JOIN" TableRef
	{
sql_ir.LogGrammarCoverage("JoinTable,TableRef")
sql_ir.LogGrammarCoverage("JoinTable,JoinType")
sql_ir.LogGrammarCoverage("JoinTable,OuterOpt")
sql_ir.LogGrammarCoverage("JoinTable,TableRef")


		$$ = &ast.Join{Left: $1.(ast.ResultSetNode), Right: $6.(ast.ResultSetNode), Tp: $3.(ast.JoinType), NaturalJoin: true}
	}
|	TableRef "STRAIGHT_JOIN" TableRef
	{
sql_ir.LogGrammarCoverage("JoinTable,TableRef")
sql_ir.LogGrammarCoverage("JoinTable,TableRef")


		$$ = &ast.Join{Left: $1.(ast.ResultSetNode), Right: $3.(ast.ResultSetNode), StraightJoin: true}
	}
|	TableRef "STRAIGHT_JOIN" TableRef "ON" Expression
	{
sql_ir.LogGrammarCoverage("JoinTable,TableRef")
sql_ir.LogGrammarCoverage("JoinTable,TableRef")
sql_ir.LogGrammarCoverage("JoinTable,Expression")


		on := &ast.OnCondition{Expr: $5}
		$$ = &ast.Join{Left: $1.(ast.ResultSetNode), Right: $3.(ast.ResultSetNode), StraightJoin: true, On: on}
	}

JoinType:
	"LEFT"
	{


		$$ = ast.LeftJoin
	}
|	"RIGHT"
	{


		$$ = ast.RightJoin
	}

OuterOpt:
	{

}
|	"OUTER"

{

}
CrossOpt:
	"JOIN"
{

}
|	"CROSS" "JOIN"
{

}
|	"INNER" "JOIN"

{

}
LimitClause:
	{


		$$ = nil
	}
|	"LIMIT" LimitOption
	{
sql_ir.LogGrammarCoverage("LimitClause,LimitOption")


		$$ = &ast.Limit{Count: $2.(ast.ValueExpr)}
	}

LimitOption:
	LengthNum
	{
sql_ir.LogGrammarCoverage("LimitOption,LengthNum")


		$$ = ast.NewValueExpr($1, parser.charset, parser.collation)
	}
|	paramMarker
	{


		$$ = ast.NewParamMarkerExpr(yyS[yypt].offset)
	}

RowOrRows:
	"ROW"
{

}
|	"ROWS"

{

}
FirstOrNext:
	"FIRST"
{

}
|	"NEXT"

{

}
FetchFirstOpt:
	{


		$$ = ast.NewValueExpr(uint64(1), parser.charset, parser.collation)
	}
|	LimitOption

{
sql_ir.LogGrammarCoverage("FetchFirstOpt,LimitOption")

}
SelectStmtLimit:
	"LIMIT" LimitOption
	{
sql_ir.LogGrammarCoverage("SelectStmtLimit,LimitOption")


		$$ = &ast.Limit{Count: $2.(ast.ExprNode)}
	}
|	"LIMIT" LimitOption ',' LimitOption
	{
sql_ir.LogGrammarCoverage("SelectStmtLimit,LimitOption")
sql_ir.LogGrammarCoverage("SelectStmtLimit,LimitOption")


		$$ = &ast.Limit{Offset: $2.(ast.ExprNode), Count: $4.(ast.ExprNode)}
	}
|	"LIMIT" LimitOption "OFFSET" LimitOption
	{
sql_ir.LogGrammarCoverage("SelectStmtLimit,LimitOption")
sql_ir.LogGrammarCoverage("SelectStmtLimit,LimitOption")


		$$ = &ast.Limit{Offset: $4.(ast.ExprNode), Count: $2.(ast.ExprNode)}
	}
|	"FETCH" FirstOrNext FetchFirstOpt RowOrRows "ONLY"
	{
sql_ir.LogGrammarCoverage("SelectStmtLimit,FirstOrNext")
sql_ir.LogGrammarCoverage("SelectStmtLimit,FetchFirstOpt")
sql_ir.LogGrammarCoverage("SelectStmtLimit,RowOrRows")


		$$ = &ast.Limit{Count: $3.(ast.ExprNode)}
	}

SelectStmtLimitOpt:
	{


		$$ = nil
	}
|	SelectStmtLimit

{
sql_ir.LogGrammarCoverage("SelectStmtLimitOpt,SelectStmtLimit")

}
SelectStmtOpt:
	TableOptimizerHints
	{
sql_ir.LogGrammarCoverage("SelectStmtOpt,TableOptimizerHints")


		opt := &ast.SelectStmtOpts{}
		opt.SQLCache = true
		opt.TableHints = $1.([]*ast.TableOptimizerHint)
		$$ = opt
	}
|	DistinctOpt
	{
sql_ir.LogGrammarCoverage("SelectStmtOpt,DistinctOpt")


		opt := &ast.SelectStmtOpts{}
		opt.SQLCache = true
		if $1.(bool) {
			opt.Distinct = true
		} else {
			opt.Distinct = false
			opt.ExplicitAll = true
		}
		$$ = opt
	}
|	Priority
	{
sql_ir.LogGrammarCoverage("SelectStmtOpt,Priority")


		opt := &ast.SelectStmtOpts{}
		opt.SQLCache = true
		opt.Priority = $1.(mysql.PriorityEnum)
		$$ = opt
	}
|	"SQL_SMALL_RESULT"
	{


		opt := &ast.SelectStmtOpts{}
		opt.SQLCache = true
		opt.SQLSmallResult = true
		$$ = opt
	}
|	"SQL_BIG_RESULT"
	{


		opt := &ast.SelectStmtOpts{}
		opt.SQLCache = true
		opt.SQLBigResult = true
		$$ = opt
	}
|	"SQL_BUFFER_RESULT"
	{


		opt := &ast.SelectStmtOpts{}
		opt.SQLCache = true
		opt.SQLBufferResult = true
		$$ = opt
	}
|	SelectStmtSQLCache
	{
sql_ir.LogGrammarCoverage("SelectStmtOpt,SelectStmtSQLCache")


		opt := &ast.SelectStmtOpts{}
		opt.SQLCache = $1.(bool)
		$$ = opt
	}
|	"SQL_CALC_FOUND_ROWS"
	{


		opt := &ast.SelectStmtOpts{}
		opt.SQLCache = true
		opt.CalcFoundRows = true
		$$ = opt
	}
|	"STRAIGHT_JOIN"
	{


		opt := &ast.SelectStmtOpts{}
		opt.SQLCache = true
		opt.StraightJoin = true
		$$ = opt
	}

SelectStmtOpts:
	%prec empty
	{


		opt := &ast.SelectStmtOpts{}
		opt.SQLCache = true
		$$ = opt
	}
|	SelectStmtOptsList %prec lowerThanSelectOpt

{
sql_ir.LogGrammarCoverage("SelectStmtOpts,SelectStmtOptsList")

}
SelectStmtOptsList:
	SelectStmtOptsList SelectStmtOpt
	{
sql_ir.LogGrammarCoverage("SelectStmtOptsList,SelectStmtOptsList")
sql_ir.LogGrammarCoverage("SelectStmtOptsList,SelectStmtOpt")


		opts := $1.(*ast.SelectStmtOpts)
		opt := $2.(*ast.SelectStmtOpts)

		// Merge options.
		// Always use the first hint.
		if opt.TableHints != nil && opts.TableHints == nil {
			opts.TableHints = opt.TableHints
		}
		if opt.Distinct {
			opts.Distinct = true
		}
		if opt.Priority != mysql.NoPriority {
			opts.Priority = opt.Priority
		}
		if opt.SQLSmallResult {
			opts.SQLSmallResult = true
		}
		if opt.SQLBigResult {
			opts.SQLBigResult = true
		}
		if opt.SQLBufferResult {
			opts.SQLBufferResult = true
		}
		if !opt.SQLCache {
			opts.SQLCache = false
		}
		if opt.CalcFoundRows {
			opts.CalcFoundRows = true
		}
		if opt.StraightJoin {
			opts.StraightJoin = true
		}
		if opt.ExplicitAll {
			opts.ExplicitAll = true
		}

		if opts.Distinct && opts.ExplicitAll {
			yylex.AppendError(ErrWrongUsage.GenWithStackByArgs("ALL", "DISTINCT"))
			return 1
		}

		$$ = opts
	}
|	SelectStmtOpt

{
sql_ir.LogGrammarCoverage("SelectStmtOptsList,SelectStmtOpt")

}
TableOptimizerHints:
	hintComment
	{


		hints, warns := parser.parseHint($1)
		for _, w := range warns {
			yylex.AppendError(w)
			parser.lastErrorAsWarn()
		}
		$$ = hints
	}

TableOptimizerHintsOpt:
	
	{


		$$ = nil
	}
|	TableOptimizerHints

{
sql_ir.LogGrammarCoverage("TableOptimizerHintsOpt,TableOptimizerHints")

}
SelectStmtSQLCache:
	"SQL_CACHE"
	{


		$$ = true
	}
|	"SQL_NO_CACHE"
	{


		$$ = false
	}

SelectStmtFieldList:
	FieldList
	{
sql_ir.LogGrammarCoverage("SelectStmtFieldList,FieldList")


		$$ = &ast.FieldList{Fields: $1.([]*ast.SelectField)}
	}

SelectStmtGroup:
	/* EMPTY */
	{


		$$ = nil
	}
|	GroupByClause

{
sql_ir.LogGrammarCoverage("SelectStmtGroup,GroupByClause")

}
SelectStmtIntoOption:
	{


		$$ = nil
	}
|	"INTO" "OUTFILE" stringLit Fields Lines
	{
sql_ir.LogGrammarCoverage("SelectStmtIntoOption,stringLit")
sql_ir.LogGrammarCoverage("SelectStmtIntoOption,Fields")
sql_ir.LogGrammarCoverage("SelectStmtIntoOption,Lines")


		x := &ast.SelectIntoOption{
			Tp:       ast.SelectIntoOutfile,
			FileName: $3,
		}
		if $4 != nil {
			x.FieldsInfo = $4.(*ast.FieldsClause)
		}
		if $5 != nil {
			x.LinesInfo = $5.(*ast.LinesClause)
		}

		$$ = x
	}

// See https://dev.mysql.com/doc/refman/5.7/en/subqueries.html
SubSelect:
	'(' SelectStmt ')'
	{
sql_ir.LogGrammarCoverage("SubSelect,SelectStmt")


		rs := $2.(*ast.SelectStmt)
		endOffset := parser.endOffset(&yyS[yypt])
		parser.setLastSelectFieldText(rs, endOffset)
		src := parser.src
		// See the implementation of yyParse function
		rs.SetText(parser.lexer.client, src[yyS[yypt-1].offset:yyS[yypt].offset])
		$$ = &ast.SubqueryExpr{Query: rs}
	}
|	'(' SetOprStmt ')'
	{
sql_ir.LogGrammarCoverage("SubSelect,SetOprStmt")


		rs := $2.(*ast.SetOprStmt)
		src := parser.src
		rs.SetText(parser.lexer.client, src[yyS[yypt-1].offset:yyS[yypt].offset])
		$$ = &ast.SubqueryExpr{Query: rs}
	}
|	'(' SelectStmtWithClause ')'
	{
sql_ir.LogGrammarCoverage("SubSelect,SelectStmtWithClause")


		rs := $2.(*ast.SelectStmt)
		endOffset := parser.endOffset(&yyS[yypt])
		parser.setLastSelectFieldText(rs, endOffset)
		src := parser.src
		// See the implementation of yyParse function
		rs.SetText(parser.lexer.client, src[yyS[yypt-1].offset:yyS[yypt].offset])
		$$ = &ast.SubqueryExpr{Query: rs}
	}
|	'(' SubSelect ')'
	{
sql_ir.LogGrammarCoverage("SubSelect,SubSelect")


		subQuery := $2.(*ast.SubqueryExpr).Query
		isRecursive := true
		// remove redundant brackets like '((select 1))'
		for isRecursive {
			if _, isRecursive = subQuery.(*ast.SubqueryExpr); isRecursive {
				subQuery = subQuery.(*ast.SubqueryExpr).Query
			}
		}
		switch rs := subQuery.(type) {
		case *ast.SelectStmt:
			endOffset := parser.endOffset(&yyS[yypt])
			parser.setLastSelectFieldText(rs, endOffset)
			src := parser.src
			rs.SetText(parser.lexer.client, src[yyS[yypt-1].offset:yyS[yypt].offset])
			$$ = &ast.SubqueryExpr{Query: rs}
		case *ast.SetOprStmt:
			src := parser.src
			rs.SetText(parser.lexer.client, src[yyS[yypt-1].offset:yyS[yypt].offset])
			$$ = &ast.SubqueryExpr{Query: rs}
		}
	}

// See https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html
SelectLockOpt:
	
	{


		$$ = nil
	}
|	"FOR" "UPDATE" OfTablesOpt
	{
sql_ir.LogGrammarCoverage("SelectLockOpt,OfTablesOpt")


		$$ = &ast.SelectLockInfo{
			LockType: ast.SelectLockForUpdate,
			Tables:   $3.([]*ast.TableName),
		}
	}
|	"FOR" "SHARE" OfTablesOpt
	{
sql_ir.LogGrammarCoverage("SelectLockOpt,OfTablesOpt")


		$$ = &ast.SelectLockInfo{
			LockType: ast.SelectLockForShare,
			Tables:   $3.([]*ast.TableName),
		}
	}
|	"FOR" "UPDATE" OfTablesOpt "NOWAIT"
	{
sql_ir.LogGrammarCoverage("SelectLockOpt,OfTablesOpt")


		$$ = &ast.SelectLockInfo{
			LockType: ast.SelectLockForUpdateNoWait,
			Tables:   $3.([]*ast.TableName),
		}
	}
|	"FOR" "UPDATE" OfTablesOpt "WAIT" NUM
	{
sql_ir.LogGrammarCoverage("SelectLockOpt,OfTablesOpt")
sql_ir.LogGrammarCoverage("SelectLockOpt,NUM")


		$$ = &ast.SelectLockInfo{
			LockType: ast.SelectLockForUpdateWaitN,
			WaitSec:  getUint64FromNUM($5),
			Tables:   $3.([]*ast.TableName),
		}
	}
|	"FOR" "SHARE" OfTablesOpt "NOWAIT"
	{
sql_ir.LogGrammarCoverage("SelectLockOpt,OfTablesOpt")


		$$ = &ast.SelectLockInfo{
			LockType: ast.SelectLockForShareNoWait,
			Tables:   $3.([]*ast.TableName),
		}
	}
|	"FOR" "UPDATE" OfTablesOpt "SKIP" "LOCKED"
	{
sql_ir.LogGrammarCoverage("SelectLockOpt,OfTablesOpt")


		$$ = &ast.SelectLockInfo{
			LockType: ast.SelectLockForUpdateSkipLocked,
			Tables:   $3.([]*ast.TableName),
		}
	}
|	"FOR" "SHARE" OfTablesOpt "SKIP" "LOCKED"
	{
sql_ir.LogGrammarCoverage("SelectLockOpt,OfTablesOpt")


		$$ = &ast.SelectLockInfo{
			LockType: ast.SelectLockForShareSkipLocked,
			Tables:   $3.([]*ast.TableName),
		}
	}
|	"LOCK" "IN" "SHARE" "MODE"
	{


		$$ = &ast.SelectLockInfo{
			LockType: ast.SelectLockForShare,
			Tables:   []*ast.TableName{},
		}
	}

OfTablesOpt:
	
	{


		$$ = []*ast.TableName{}
	}
|	"OF" TableNameList
	{
sql_ir.LogGrammarCoverage("OfTablesOpt,TableNameList")


		$$ = $2.([]*ast.TableName)
	}

SetOprStmt:
	SetOprStmtWoutLimitOrderBy
{
sql_ir.LogGrammarCoverage("SetOprStmt,SetOprStmtWoutLimitOrderBy")

}
|	SetOprStmtWithLimitOrderBy
{
sql_ir.LogGrammarCoverage("SetOprStmt,SetOprStmtWithLimitOrderBy")

}
|	WithClause SetOprStmtWithLimitOrderBy
	{
sql_ir.LogGrammarCoverage("SetOprStmt,WithClause")
sql_ir.LogGrammarCoverage("SetOprStmt,SetOprStmtWithLimitOrderBy")


		setOpr := $2.(*ast.SetOprStmt)
		setOpr.With = $1.(*ast.WithClause)
		$$ = setOpr
	}
|	WithClause SetOprStmtWoutLimitOrderBy
	{
sql_ir.LogGrammarCoverage("SetOprStmt,WithClause")
sql_ir.LogGrammarCoverage("SetOprStmt,SetOprStmtWoutLimitOrderBy")


		setOpr := $2.(*ast.SetOprStmt)
		setOpr.With = $1.(*ast.WithClause)
		$$ = setOpr
	}

// See https://dev.mysql.com/doc/refman/5.7/en/union.html
// See https://mariadb.com/kb/en/intersect/
// See https://mariadb.com/kb/en/except/
SetOprStmtWoutLimitOrderBy:
	SetOprClauseList SetOpr SelectStmt
	{
sql_ir.LogGrammarCoverage("SetOprStmtWoutLimitOrderBy,SetOprClauseList")
sql_ir.LogGrammarCoverage("SetOprStmtWoutLimitOrderBy,SetOpr")
sql_ir.LogGrammarCoverage("SetOprStmtWoutLimitOrderBy,SelectStmt")


		setOprList1 := $1.([]ast.Node)
		if sel, isSelect := setOprList1[len(setOprList1)-1].(*ast.SelectStmt); isSelect && !sel.IsInBraces {
			endOffset := parser.endOffset(&yyS[yypt-1])
			parser.setLastSelectFieldText(sel, endOffset)
		}
		setOpr := &ast.SetOprStmt{SelectList: &ast.SetOprSelectList{Selects: $1.([]ast.Node)}}
		st := $3.(*ast.SelectStmt)
		setOpr.Limit = st.Limit
		setOpr.OrderBy = st.OrderBy
		st.Limit = nil
		st.OrderBy = nil
		st.AfterSetOperator = $2.(*ast.SetOprType)
		setOpr.SelectList.Selects = append(setOpr.SelectList.Selects, st)
		$$ = setOpr
	}
|	SetOprClauseList SetOpr SubSelect
	{
sql_ir.LogGrammarCoverage("SetOprStmtWoutLimitOrderBy,SetOprClauseList")
sql_ir.LogGrammarCoverage("SetOprStmtWoutLimitOrderBy,SetOpr")
sql_ir.LogGrammarCoverage("SetOprStmtWoutLimitOrderBy,SubSelect")


		setOprList1 := $1.([]ast.Node)
		if sel, isSelect := setOprList1[len(setOprList1)-1].(*ast.SelectStmt); isSelect && !sel.IsInBraces {
			endOffset := parser.endOffset(&yyS[yypt-1])
			parser.setLastSelectFieldText(sel, endOffset)
		}
		var setOprList2 []ast.Node
		var with2 *ast.WithClause
		switch x := $3.(*ast.SubqueryExpr).Query.(type) {
		case *ast.SelectStmt:
			setOprList2 = []ast.Node{x}
			with2 = x.With
		case *ast.SetOprStmt:
			setOprList2 = x.SelectList.Selects
			with2 = x.With
		}
		nextSetOprList := &ast.SetOprSelectList{Selects: setOprList2, With: with2}
		nextSetOprList.AfterSetOperator = $2.(*ast.SetOprType)
		setOprList := append(setOprList1, nextSetOprList)
		setOpr := &ast.SetOprStmt{SelectList: &ast.SetOprSelectList{Selects: setOprList}}
		$$ = setOpr
	}

SetOprStmtWithLimitOrderBy:
	SetOprClauseList SetOpr SubSelect OrderBy
	{
sql_ir.LogGrammarCoverage("SetOprStmtWithLimitOrderBy,SetOprClauseList")
sql_ir.LogGrammarCoverage("SetOprStmtWithLimitOrderBy,SetOpr")
sql_ir.LogGrammarCoverage("SetOprStmtWithLimitOrderBy,SubSelect")
sql_ir.LogGrammarCoverage("SetOprStmtWithLimitOrderBy,OrderBy")


		setOprList1 := $1.([]ast.Node)
		if sel, isSelect := setOprList1[len(setOprList1)-1].(*ast.SelectStmt); isSelect && !sel.IsInBraces {
			endOffset := parser.endOffset(&yyS[yypt-2])
			parser.setLastSelectFieldText(sel, endOffset)
		}
		var setOprList2 []ast.Node
		var with2 *ast.WithClause
		switch x := $3.(*ast.SubqueryExpr).Query.(type) {
		case *ast.SelectStmt:
			setOprList2 = []ast.Node{x}
			with2 = x.With
		case *ast.SetOprStmt:
			setOprList2 = x.SelectList.Selects
			with2 = x.With
		}
		nextSetOprList := &ast.SetOprSelectList{Selects: setOprList2, With: with2}
		nextSetOprList.AfterSetOperator = $2.(*ast.SetOprType)
		setOprList := append(setOprList1, nextSetOprList)
		setOpr := &ast.SetOprStmt{SelectList: &ast.SetOprSelectList{Selects: setOprList}}
		setOpr.OrderBy = $4.(*ast.OrderByClause)
		$$ = setOpr
	}
|	SetOprClauseList SetOpr SubSelect SelectStmtLimit
	{
sql_ir.LogGrammarCoverage("SetOprStmtWithLimitOrderBy,SetOprClauseList")
sql_ir.LogGrammarCoverage("SetOprStmtWithLimitOrderBy,SetOpr")
sql_ir.LogGrammarCoverage("SetOprStmtWithLimitOrderBy,SubSelect")
sql_ir.LogGrammarCoverage("SetOprStmtWithLimitOrderBy,SelectStmtLimit")


		setOprList1 := $1.([]ast.Node)
		if sel, isSelect := setOprList1[len(setOprList1)-1].(*ast.SelectStmt); isSelect && !sel.IsInBraces {
			endOffset := parser.endOffset(&yyS[yypt-2])
			parser.setLastSelectFieldText(sel, endOffset)
		}
		var setOprList2 []ast.Node
		var with2 *ast.WithClause
		switch x := $3.(*ast.SubqueryExpr).Query.(type) {
		case *ast.SelectStmt:
			setOprList2 = []ast.Node{x}
			with2 = x.With
		case *ast.SetOprStmt:
			setOprList2 = x.SelectList.Selects
			with2 = x.With
		}
		nextSetOprList := &ast.SetOprSelectList{Selects: setOprList2, With: with2}
		nextSetOprList.AfterSetOperator = $2.(*ast.SetOprType)
		setOprList := append(setOprList1, nextSetOprList)
		setOpr := &ast.SetOprStmt{SelectList: &ast.SetOprSelectList{Selects: setOprList}}
		setOpr.Limit = $4.(*ast.Limit)
		$$ = setOpr
	}
|	SetOprClauseList SetOpr SubSelect OrderBy SelectStmtLimit
	{
sql_ir.LogGrammarCoverage("SetOprStmtWithLimitOrderBy,SetOprClauseList")
sql_ir.LogGrammarCoverage("SetOprStmtWithLimitOrderBy,SetOpr")
sql_ir.LogGrammarCoverage("SetOprStmtWithLimitOrderBy,SubSelect")
sql_ir.LogGrammarCoverage("SetOprStmtWithLimitOrderBy,OrderBy")
sql_ir.LogGrammarCoverage("SetOprStmtWithLimitOrderBy,SelectStmtLimit")


		setOprList1 := $1.([]ast.Node)
		if sel, isSelect := setOprList1[len(setOprList1)-1].(*ast.SelectStmt); isSelect && !sel.IsInBraces {
			endOffset := parser.endOffset(&yyS[yypt-3])
			parser.setLastSelectFieldText(sel, endOffset)
		}
		var setOprList2 []ast.Node
		var with2 *ast.WithClause
		switch x := $3.(*ast.SubqueryExpr).Query.(type) {
		case *ast.SelectStmt:
			setOprList2 = []ast.Node{x}
			with2 = x.With
		case *ast.SetOprStmt:
			setOprList2 = x.SelectList.Selects
			with2 = x.With
		}
		nextSetOprList := &ast.SetOprSelectList{Selects: setOprList2, With: with2}
		nextSetOprList.AfterSetOperator = $2.(*ast.SetOprType)
		setOprList := append(setOprList1, nextSetOprList)
		setOpr := &ast.SetOprStmt{SelectList: &ast.SetOprSelectList{Selects: setOprList}}
		setOpr.OrderBy = $4.(*ast.OrderByClause)
		setOpr.Limit = $5.(*ast.Limit)
		$$ = setOpr
	}
|	SubSelect OrderBy
	{
sql_ir.LogGrammarCoverage("SetOprStmtWithLimitOrderBy,SubSelect")
sql_ir.LogGrammarCoverage("SetOprStmtWithLimitOrderBy,OrderBy")


		var setOprList []ast.Node
		var with *ast.WithClause
		switch x := $1.(*ast.SubqueryExpr).Query.(type) {
		case *ast.SelectStmt:
			setOprList = []ast.Node{x}
			with = x.With
		case *ast.SetOprStmt:
			setOprList = x.SelectList.Selects
			with = x.With
		}
		setOpr := &ast.SetOprStmt{SelectList: &ast.SetOprSelectList{Selects: setOprList}, With: with}
		setOpr.OrderBy = $2.(*ast.OrderByClause)
		$$ = setOpr
	}
|	SubSelect SelectStmtLimit
	{
sql_ir.LogGrammarCoverage("SetOprStmtWithLimitOrderBy,SubSelect")
sql_ir.LogGrammarCoverage("SetOprStmtWithLimitOrderBy,SelectStmtLimit")


		var setOprList []ast.Node
		var with *ast.WithClause
		switch x := $1.(*ast.SubqueryExpr).Query.(type) {
		case *ast.SelectStmt:
			setOprList = []ast.Node{x}
			with = x.With
		case *ast.SetOprStmt:
			setOprList = x.SelectList.Selects
			with = x.With
		}
		setOpr := &ast.SetOprStmt{SelectList: &ast.SetOprSelectList{Selects: setOprList}, With: with}
		setOpr.Limit = $2.(*ast.Limit)
		$$ = setOpr
	}
|	SubSelect OrderBy SelectStmtLimit
	{
sql_ir.LogGrammarCoverage("SetOprStmtWithLimitOrderBy,SubSelect")
sql_ir.LogGrammarCoverage("SetOprStmtWithLimitOrderBy,OrderBy")
sql_ir.LogGrammarCoverage("SetOprStmtWithLimitOrderBy,SelectStmtLimit")


		var setOprList []ast.Node
		var with *ast.WithClause
		switch x := $1.(*ast.SubqueryExpr).Query.(type) {
		case *ast.SelectStmt:
			setOprList = []ast.Node{x}
			with = x.With
		case *ast.SetOprStmt:
			setOprList = x.SelectList.Selects
			with = x.With
		}
		setOpr := &ast.SetOprStmt{SelectList: &ast.SetOprSelectList{Selects: setOprList}, With: with}
		setOpr.OrderBy = $2.(*ast.OrderByClause)
		setOpr.Limit = $3.(*ast.Limit)
		$$ = setOpr
	}

SetOprClauseList:
	SetOprClause
{
sql_ir.LogGrammarCoverage("SetOprClauseList,SetOprClause")

}
|	SetOprClauseList SetOpr SetOprClause
	{
sql_ir.LogGrammarCoverage("SetOprClauseList,SetOprClauseList")
sql_ir.LogGrammarCoverage("SetOprClauseList,SetOpr")
sql_ir.LogGrammarCoverage("SetOprClauseList,SetOprClause")


		setOprList1 := $1.([]ast.Node)
		setOprList2 := $3.([]ast.Node)
		if sel, isSelect := setOprList1[len(setOprList1)-1].(*ast.SelectStmt); isSelect && !sel.IsInBraces {
			endOffset := parser.endOffset(&yyS[yypt-1])
			parser.setLastSelectFieldText(sel, endOffset)
		}
		switch x := setOprList2[0].(type) {
		case *ast.SelectStmt:
			x.AfterSetOperator = $2.(*ast.SetOprType)
		case *ast.SetOprSelectList:
			x.AfterSetOperator = $2.(*ast.SetOprType)
		}
		$$ = append(setOprList1, setOprList2...)
	}

SetOprClause:
	SelectStmt
	{
sql_ir.LogGrammarCoverage("SetOprClause,SelectStmt")


		$$ = []ast.Node{$1.(*ast.SelectStmt)}
	}
|	SubSelect
	{
sql_ir.LogGrammarCoverage("SetOprClause,SubSelect")


		var setOprList []ast.Node
		switch x := $1.(*ast.SubqueryExpr).Query.(type) {
		case *ast.SelectStmt:
			setOprList = []ast.Node{&ast.SetOprSelectList{Selects: []ast.Node{x}}}
		case *ast.SetOprStmt:
			setOprList = []ast.Node{&ast.SetOprSelectList{Selects: x.SelectList.Selects, With: x.With}}
		}
		$$ = setOprList
	}

SetOpr:
	"UNION" SetOprOpt
	{
sql_ir.LogGrammarCoverage("SetOpr,SetOprOpt")


		var tp ast.SetOprType
		tp = ast.Union
		if $2 == false {
			tp = ast.UnionAll
		}
		$$ = &tp
	}
|	"EXCEPT" SetOprOpt
	{
sql_ir.LogGrammarCoverage("SetOpr,SetOprOpt")


		var tp ast.SetOprType
		tp = ast.Except
		if $2 == false {
			tp = ast.ExceptAll
		}
		$$ = &tp
	}
|	"INTERSECT" SetOprOpt
	{
sql_ir.LogGrammarCoverage("SetOpr,SetOprOpt")


		var tp ast.SetOprType
		tp = ast.Intersect
		if $2 == false {
			tp = ast.IntersectAll
		}
		$$ = &tp
	}

SetOprOpt:
	DefaultTrueDistinctOpt


{
sql_ir.LogGrammarCoverage("SetOprOpt,DefaultTrueDistinctOpt")

}
ChangeStmt:
	"CHANGE" "PUMP" "TO" "NODE_STATE" eq stringLit forKwd "NODE_ID" stringLit
	{
sql_ir.LogGrammarCoverage("ChangeStmt,stringLit")
sql_ir.LogGrammarCoverage("ChangeStmt,stringLit")


		$$ = &ast.ChangeStmt{
			NodeType: ast.PumpType,
			State:    $6,
			NodeID:   $9,
		}
	}
|	"CHANGE" "DRAINER" "TO" "NODE_STATE" eq stringLit forKwd "NODE_ID" stringLit
	{
sql_ir.LogGrammarCoverage("ChangeStmt,stringLit")
sql_ir.LogGrammarCoverage("ChangeStmt,stringLit")


		$$ = &ast.ChangeStmt{
			NodeType: ast.DrainerType,
			State:    $6,
			NodeID:   $9,
		}
	}


SetStmt:
	"SET" VariableAssignmentList
	{
sql_ir.LogGrammarCoverage("SetStmt,VariableAssignmentList")


		$$ = &ast.SetStmt{Variables: $2.([]*ast.VariableAssignment)}
	}
|	"SET" "PASSWORD" eq PasswordOpt
	{
sql_ir.LogGrammarCoverage("SetStmt,PasswordOpt")


		$$ = &ast.SetPwdStmt{Password: $4}
	}
|	"SET" "PASSWORD" "FOR" Username eq PasswordOpt
	{
sql_ir.LogGrammarCoverage("SetStmt,Username")
sql_ir.LogGrammarCoverage("SetStmt,PasswordOpt")


		$$ = &ast.SetPwdStmt{User: $4.(*auth.UserIdentity), Password: $6}
	}
|	"SET" "GLOBAL" "TRANSACTION" TransactionChars
	{
sql_ir.LogGrammarCoverage("SetStmt,TransactionChars")


		vars := $4.([]*ast.VariableAssignment)
		for _, v := range vars {
			v.IsGlobal = true
		}
		$$ = &ast.SetStmt{Variables: vars}
	}
|	"SET" "SESSION" "TRANSACTION" TransactionChars
	{
sql_ir.LogGrammarCoverage("SetStmt,TransactionChars")


		$$ = &ast.SetStmt{Variables: $4.([]*ast.VariableAssignment)}
	}
|	"SET" "TRANSACTION" TransactionChars
	{
sql_ir.LogGrammarCoverage("SetStmt,TransactionChars")


		assigns := $3.([]*ast.VariableAssignment)
		for i := 0; i < len(assigns); i++ {
			if assigns[i].Name == "tx_isolation" {
				// A special session variable that make setting tx_isolation take effect one time.
				assigns[i].Name = "tx_isolation_one_shot"
			}
		}
		$$ = &ast.SetStmt{Variables: assigns}
	}
|	"SET" "CONFIG" Identifier ConfigItemName EqOrAssignmentEq SetExpr
	{
sql_ir.LogGrammarCoverage("SetStmt,Identifier")
sql_ir.LogGrammarCoverage("SetStmt,ConfigItemName")
sql_ir.LogGrammarCoverage("SetStmt,EqOrAssignmentEq")
sql_ir.LogGrammarCoverage("SetStmt,SetExpr")


		$$ = &ast.SetConfigStmt{Type: strings.ToLower($3), Name: $4, Value: $6}
	}
|	"SET" "CONFIG" stringLit ConfigItemName EqOrAssignmentEq SetExpr
	{
sql_ir.LogGrammarCoverage("SetStmt,stringLit")
sql_ir.LogGrammarCoverage("SetStmt,ConfigItemName")
sql_ir.LogGrammarCoverage("SetStmt,EqOrAssignmentEq")
sql_ir.LogGrammarCoverage("SetStmt,SetExpr")


		$$ = &ast.SetConfigStmt{Instance: $3, Name: $4, Value: $6}
	}

SetRoleStmt:
	"SET" "ROLE" SetRoleOpt
	{
sql_ir.LogGrammarCoverage("SetRoleStmt,SetRoleOpt")


		$$ = $3.(*ast.SetRoleStmt)
	}

SetDefaultRoleStmt:
	"SET" "DEFAULT" "ROLE" SetDefaultRoleOpt "TO" UsernameList
	{
sql_ir.LogGrammarCoverage("SetDefaultRoleStmt,SetDefaultRoleOpt")
sql_ir.LogGrammarCoverage("SetDefaultRoleStmt,UsernameList")


		tmp := $4.(*ast.SetRoleStmt)
		$$ = &ast.SetDefaultRoleStmt{
			SetRoleOpt: tmp.SetRoleOpt,
			RoleList:   tmp.RoleList,
			UserList:   $6.([]*auth.UserIdentity),
		}
	}

SetDefaultRoleOpt:
	"NONE"
	{


		$$ = &ast.SetRoleStmt{SetRoleOpt: ast.SetRoleNone, RoleList: nil}
	}
|	"ALL"
	{


		$$ = &ast.SetRoleStmt{SetRoleOpt: ast.SetRoleAll, RoleList: nil}
	}
|	RolenameList
	{
sql_ir.LogGrammarCoverage("SetDefaultRoleOpt,RolenameList")


		$$ = &ast.SetRoleStmt{SetRoleOpt: ast.SetRoleRegular, RoleList: $1.([]*auth.RoleIdentity)}
	}

SetRoleOpt:
	"ALL" "EXCEPT" RolenameList
	{
sql_ir.LogGrammarCoverage("SetRoleOpt,RolenameList")


		$$ = &ast.SetRoleStmt{SetRoleOpt: ast.SetRoleAllExcept, RoleList: $3.([]*auth.RoleIdentity)}
	}
|	SetDefaultRoleOpt
{
sql_ir.LogGrammarCoverage("SetRoleOpt,SetDefaultRoleOpt")

}
|	"DEFAULT"
	{


		$$ = &ast.SetRoleStmt{SetRoleOpt: ast.SetRoleDefault, RoleList: nil}
	}

TransactionChars:
	TransactionChar
	{
sql_ir.LogGrammarCoverage("TransactionChars,TransactionChar")


		if $1 != nil {
			$$ = $1
		} else {
			$$ = []*ast.VariableAssignment{}
		}
	}
|	TransactionChars ',' TransactionChar
	{
sql_ir.LogGrammarCoverage("TransactionChars,TransactionChars")
sql_ir.LogGrammarCoverage("TransactionChars,TransactionChar")


		if $3 != nil {
			varAssigns := $3.([]*ast.VariableAssignment)
			$$ = append($1.([]*ast.VariableAssignment), varAssigns...)
		} else {
			$$ = $1
		}
	}

TransactionChar:
	"ISOLATION" "LEVEL" IsolationLevel
	{
sql_ir.LogGrammarCoverage("TransactionChar,IsolationLevel")


		varAssigns := []*ast.VariableAssignment{}
		expr := ast.NewValueExpr($3, parser.charset, parser.collation)
		varAssigns = append(varAssigns, &ast.VariableAssignment{Name: "tx_isolation", Value: expr, IsSystem: true})
		$$ = varAssigns
	}
|	"READ" "WRITE"
	{


		varAssigns := []*ast.VariableAssignment{}
		expr := ast.NewValueExpr("0", parser.charset, parser.collation)
		varAssigns = append(varAssigns, &ast.VariableAssignment{Name: "tx_read_only", Value: expr, IsSystem: true})
		$$ = varAssigns
	}
|	"READ" "ONLY"
	{


		varAssigns := []*ast.VariableAssignment{}
		expr := ast.NewValueExpr("1", parser.charset, parser.collation)
		varAssigns = append(varAssigns, &ast.VariableAssignment{Name: "tx_read_only", Value: expr, IsSystem: true})
		$$ = varAssigns
	}
|	"READ" "ONLY" AsOfClause
	{
sql_ir.LogGrammarCoverage("TransactionChar,AsOfClause")


		varAssigns := []*ast.VariableAssignment{}
		asof := $3.(*ast.AsOfClause)
		if asof != nil {
			varAssigns = append(varAssigns, &ast.VariableAssignment{Name: "tx_read_ts", Value: asof.TsExpr, IsSystem: true})
		}
		$$ = varAssigns
	}

IsolationLevel:
	"REPEATABLE" "READ"
	{


		$$ = ast.RepeatableRead
	}
|	"READ" "COMMITTED"
	{


		$$ = ast.ReadCommitted
	}
|	"READ" "UNCOMMITTED"
	{


		$$ = ast.ReadUncommitted
	}
|	"SERIALIZABLE"
	{


		$$ = ast.Serializable
	}

SetExpr:
	"ON"
	{


		$$ = ast.NewValueExpr("ON", parser.charset, parser.collation)
	}
|	"BINARY"
	{


		$$ = ast.NewValueExpr("BINARY", parser.charset, parser.collation)
	}
|	ExprOrDefault

{
sql_ir.LogGrammarCoverage("SetExpr,ExprOrDefault")

}
EqOrAssignmentEq:
	eq
{

}
|	assignmentEq

{

}
VariableName:
	Identifier
{
sql_ir.LogGrammarCoverage("VariableName,Identifier")

}
|	Identifier '.' Identifier
	{
sql_ir.LogGrammarCoverage("VariableName,Identifier")
sql_ir.LogGrammarCoverage("VariableName,Identifier")


		$$ = $1 + "." + $3
	}

ConfigItemName:
	Identifier
{
sql_ir.LogGrammarCoverage("ConfigItemName,Identifier")

}
|	Identifier '.' ConfigItemName
	{
sql_ir.LogGrammarCoverage("ConfigItemName,Identifier")
sql_ir.LogGrammarCoverage("ConfigItemName,ConfigItemName")


		$$ = $1 + "." + $3
	}
|	Identifier '-' ConfigItemName
	{
sql_ir.LogGrammarCoverage("ConfigItemName,Identifier")
sql_ir.LogGrammarCoverage("ConfigItemName,ConfigItemName")


		$$ = $1 + "-" + $3
	}

VariableAssignment:
	VariableName EqOrAssignmentEq SetExpr
	{
sql_ir.LogGrammarCoverage("VariableAssignment,VariableName")
sql_ir.LogGrammarCoverage("VariableAssignment,EqOrAssignmentEq")
sql_ir.LogGrammarCoverage("VariableAssignment,SetExpr")


		$$ = &ast.VariableAssignment{Name: $1, Value: $3, IsSystem: true}
	}
|	"GLOBAL" VariableName EqOrAssignmentEq SetExpr
	{
sql_ir.LogGrammarCoverage("VariableAssignment,VariableName")
sql_ir.LogGrammarCoverage("VariableAssignment,EqOrAssignmentEq")
sql_ir.LogGrammarCoverage("VariableAssignment,SetExpr")


		$$ = &ast.VariableAssignment{Name: $2, Value: $4, IsGlobal: true, IsSystem: true}
	}
|	"SESSION" VariableName EqOrAssignmentEq SetExpr
	{
sql_ir.LogGrammarCoverage("VariableAssignment,VariableName")
sql_ir.LogGrammarCoverage("VariableAssignment,EqOrAssignmentEq")
sql_ir.LogGrammarCoverage("VariableAssignment,SetExpr")


		$$ = &ast.VariableAssignment{Name: $2, Value: $4, IsSystem: true}
	}
|	"LOCAL" VariableName EqOrAssignmentEq SetExpr
	{
sql_ir.LogGrammarCoverage("VariableAssignment,VariableName")
sql_ir.LogGrammarCoverage("VariableAssignment,EqOrAssignmentEq")
sql_ir.LogGrammarCoverage("VariableAssignment,SetExpr")


		$$ = &ast.VariableAssignment{Name: $2, Value: $4, IsSystem: true}
	}
|	doubleAtIdentifier EqOrAssignmentEq SetExpr
	{
sql_ir.LogGrammarCoverage("VariableAssignment,EqOrAssignmentEq")
sql_ir.LogGrammarCoverage("VariableAssignment,SetExpr")


		v := strings.ToLower($1)
		var isGlobal bool
		if strings.HasPrefix(v, "@@global.") {
			isGlobal = true
			v = strings.TrimPrefix(v, "@@global.")
		} else if strings.HasPrefix(v, "@@session.") {
			v = strings.TrimPrefix(v, "@@session.")
		} else if strings.HasPrefix(v, "@@local.") {
			v = strings.TrimPrefix(v, "@@local.")
		} else if strings.HasPrefix(v, "@@") {
			v = strings.TrimPrefix(v, "@@")
		}
		$$ = &ast.VariableAssignment{Name: v, Value: $3, IsGlobal: isGlobal, IsSystem: true}
	}
|	singleAtIdentifier EqOrAssignmentEq Expression
	{
sql_ir.LogGrammarCoverage("VariableAssignment,EqOrAssignmentEq")
sql_ir.LogGrammarCoverage("VariableAssignment,Expression")


		v := $1
		v = strings.TrimPrefix(v, "@")
		$$ = &ast.VariableAssignment{Name: v, Value: $3}
	}
|	"NAMES" CharsetName
	{
sql_ir.LogGrammarCoverage("VariableAssignment,CharsetName")


		$$ = &ast.VariableAssignment{
			Name:  ast.SetNames,
			Value: ast.NewValueExpr($2, "", ""),
		}
	}
|	"NAMES" CharsetName "COLLATE" "DEFAULT"
	{
sql_ir.LogGrammarCoverage("VariableAssignment,CharsetName")


		$$ = &ast.VariableAssignment{
			Name:  ast.SetNames,
			Value: ast.NewValueExpr($2, "", ""),
		}
	}
|	"NAMES" CharsetName "COLLATE" StringName
	{
sql_ir.LogGrammarCoverage("VariableAssignment,CharsetName")
sql_ir.LogGrammarCoverage("VariableAssignment,StringName")


		$$ = &ast.VariableAssignment{
			Name:        ast.SetNames,
			Value:       ast.NewValueExpr($2, "", ""),
			ExtendValue: ast.NewValueExpr($4, "", ""),
		}
	}
|	"NAMES" "DEFAULT"
	{


		v := &ast.DefaultExpr{}
		$$ = &ast.VariableAssignment{Name: ast.SetNames, Value: v}
	}
|	CharsetKw CharsetNameOrDefault
	{
sql_ir.LogGrammarCoverage("VariableAssignment,CharsetKw")
sql_ir.LogGrammarCoverage("VariableAssignment,CharsetNameOrDefault")


		$$ = &ast.VariableAssignment{Name: ast.SetCharset, Value: $2}
	}

CharsetNameOrDefault:
	CharsetName
	{
sql_ir.LogGrammarCoverage("CharsetNameOrDefault,CharsetName")


		$$ = ast.NewValueExpr($1, "", "")
	}
|	"DEFAULT"
	{


		$$ = &ast.DefaultExpr{}
	}

CharsetName:
	StringName
	{
sql_ir.LogGrammarCoverage("CharsetName,StringName")


		// Validate input charset name to keep the same behavior as parser of MySQL.
		cs, err := charset.GetCharsetInfo($1)
		if err != nil {
			yylex.AppendError(ErrUnknownCharacterSet.GenWithStackByArgs($1))
			return 1
		}
		// Use charset name returned from charset.GetCharsetInfo(),
		// to keep lower case of input for generated column restore.
		$$ = cs.Name
	}
|	binaryType
	{


		$$ = charset.CharsetBin
	}

CollationName:
	StringName
	{
sql_ir.LogGrammarCoverage("CollationName,StringName")


		info, err := charset.GetCollationByName($1)
		if err != nil {
			yylex.AppendError(err)
			return 1
		}
		$$ = info.Name
	}
|	binaryType
	{


		$$ = charset.CollationBin
	}

VariableAssignmentList:
	VariableAssignment
	{
sql_ir.LogGrammarCoverage("VariableAssignmentList,VariableAssignment")


		$$ = []*ast.VariableAssignment{$1.(*ast.VariableAssignment)}
	}
|	VariableAssignmentList ',' VariableAssignment
	{
sql_ir.LogGrammarCoverage("VariableAssignmentList,VariableAssignmentList")
sql_ir.LogGrammarCoverage("VariableAssignmentList,VariableAssignment")


		$$ = append($1.([]*ast.VariableAssignment), $3.(*ast.VariableAssignment))
	}

Variable:
	SystemVariable
{
sql_ir.LogGrammarCoverage("Variable,SystemVariable")

}
|	UserVariable

{
sql_ir.LogGrammarCoverage("Variable,UserVariable")

}
SystemVariable:
	doubleAtIdentifier
	{


		v := strings.ToLower($1)
		var isGlobal bool
		explicitScope := true
		if strings.HasPrefix(v, "@@global.") {
			isGlobal = true
			v = strings.TrimPrefix(v, "@@global.")
		} else if strings.HasPrefix(v, "@@session.") {
			v = strings.TrimPrefix(v, "@@session.")
		} else if strings.HasPrefix(v, "@@local.") {
			v = strings.TrimPrefix(v, "@@local.")
		} else if strings.HasPrefix(v, "@@") {
			v, explicitScope = strings.TrimPrefix(v, "@@"), false
		}
		$$ = &ast.VariableExpr{Name: v, IsGlobal: isGlobal, IsSystem: true, ExplicitScope: explicitScope}
	}

UserVariable:
	singleAtIdentifier
	{


		v := $1
		v = strings.TrimPrefix(v, "@")
		$$ = &ast.VariableExpr{Name: v, IsGlobal: false, IsSystem: false}
	}

Username:
	StringName
	{
sql_ir.LogGrammarCoverage("Username,StringName")


		$$ = &auth.UserIdentity{Username: $1, Hostname: "%"}
	}
|	StringName '@' StringName
	{
sql_ir.LogGrammarCoverage("Username,StringName")
sql_ir.LogGrammarCoverage("Username,StringName")


		$$ = &auth.UserIdentity{Username: $1, Hostname: $3}
	}
|	StringName singleAtIdentifier
	{
sql_ir.LogGrammarCoverage("Username,StringName")


		$$ = &auth.UserIdentity{Username: $1, Hostname: strings.TrimPrefix($2, "@")}
	}
|	"CURRENT_USER" OptionalBraces
	{
sql_ir.LogGrammarCoverage("Username,OptionalBraces")


		$$ = &auth.UserIdentity{CurrentUser: true}
	}

UsernameList:
	Username
	{
sql_ir.LogGrammarCoverage("UsernameList,Username")


		$$ = []*auth.UserIdentity{$1.(*auth.UserIdentity)}
	}
|	UsernameList ',' Username
	{
sql_ir.LogGrammarCoverage("UsernameList,UsernameList")
sql_ir.LogGrammarCoverage("UsernameList,Username")


		$$ = append($1.([]*auth.UserIdentity), $3.(*auth.UserIdentity))
	}

PasswordOpt:
	stringLit
{
sql_ir.LogGrammarCoverage("PasswordOpt,stringLit")

}
|	"PASSWORD" '(' AuthString ')'
	{
sql_ir.LogGrammarCoverage("PasswordOpt,AuthString")


		$$ = $3
	}

AuthString:
	stringLit

{
sql_ir.LogGrammarCoverage("AuthString,stringLit")

}
RoleNameString:
	stringLit
{
sql_ir.LogGrammarCoverage("RoleNameString,stringLit")

}
|	identifier

{

}
RolenameComposed:
	StringName '@' StringName
	{
sql_ir.LogGrammarCoverage("RolenameComposed,StringName")
sql_ir.LogGrammarCoverage("RolenameComposed,StringName")


		$$ = &auth.RoleIdentity{Username: $1, Hostname: $3}
	}
|	StringName singleAtIdentifier
	{
sql_ir.LogGrammarCoverage("RolenameComposed,StringName")


		$$ = &auth.RoleIdentity{Username: $1, Hostname: strings.TrimPrefix($2, "@")}
	}

RolenameWithoutIdent:
	stringLit
	{
sql_ir.LogGrammarCoverage("RolenameWithoutIdent,stringLit")


		$$ = &auth.RoleIdentity{Username: $1, Hostname: "%"}
	}
|	RolenameComposed
	{
sql_ir.LogGrammarCoverage("RolenameWithoutIdent,RolenameComposed")


		$$ = $1
	}

Rolename:
	RoleNameString
	{
sql_ir.LogGrammarCoverage("Rolename,RoleNameString")


		$$ = &auth.RoleIdentity{Username: $1, Hostname: "%"}
	}
|	RolenameComposed
	{
sql_ir.LogGrammarCoverage("Rolename,RolenameComposed")


		$$ = $1
	}

RolenameList:
	Rolename
	{
sql_ir.LogGrammarCoverage("RolenameList,Rolename")


		$$ = []*auth.RoleIdentity{$1.(*auth.RoleIdentity)}
	}
|	RolenameList ',' Rolename
	{
sql_ir.LogGrammarCoverage("RolenameList,RolenameList")
sql_ir.LogGrammarCoverage("RolenameList,Rolename")


		$$ = append($1.([]*auth.RoleIdentity), $3.(*auth.RoleIdentity))
	}


AdminStmt:
	"ADMIN" "SHOW" "DDL"
	{


		$$ = &ast.AdminStmt{Tp: ast.AdminShowDDL}
	}
|	"ADMIN" "SHOW" "DDL" "JOBS" WhereClauseOptional
	{
sql_ir.LogGrammarCoverage("AdminStmt,WhereClauseOptional")


		stmt := &ast.AdminStmt{Tp: ast.AdminShowDDLJobs}
		if $5 != nil {
			stmt.Where = $5.(ast.ExprNode)
		}
		$$ = stmt
	}
|	"ADMIN" "SHOW" "DDL" "JOBS" Int64Num WhereClauseOptional
	{
sql_ir.LogGrammarCoverage("AdminStmt,Int64Num")
sql_ir.LogGrammarCoverage("AdminStmt,WhereClauseOptional")


		stmt := &ast.AdminStmt{
			Tp:        ast.AdminShowDDLJobs,
			JobNumber: $5.(int64),
		}
		if $6 != nil {
			stmt.Where = $6.(ast.ExprNode)
		}
		$$ = stmt
	}
|	"ADMIN" "SHOW" TableName "NEXT_ROW_ID"
	{
sql_ir.LogGrammarCoverage("AdminStmt,TableName")


		$$ = &ast.AdminStmt{
			Tp:     ast.AdminShowNextRowID,
			Tables: []*ast.TableName{$3.(*ast.TableName)},
		}
	}
|	"ADMIN" "CHECK" "TABLE" TableNameList
	{
sql_ir.LogGrammarCoverage("AdminStmt,TableNameList")


		$$ = &ast.AdminStmt{
			Tp:     ast.AdminCheckTable,
			Tables: $4.([]*ast.TableName),
		}
	}
|	"ADMIN" "CHECK" "INDEX" TableName Identifier
	{
sql_ir.LogGrammarCoverage("AdminStmt,TableName")
sql_ir.LogGrammarCoverage("AdminStmt,Identifier")


		$$ = &ast.AdminStmt{
			Tp:     ast.AdminCheckIndex,
			Tables: []*ast.TableName{$4.(*ast.TableName)},
			Index:  string($5),
		}
	}
|	"ADMIN" "RECOVER" "INDEX" TableName Identifier
	{
sql_ir.LogGrammarCoverage("AdminStmt,TableName")
sql_ir.LogGrammarCoverage("AdminStmt,Identifier")


		$$ = &ast.AdminStmt{
			Tp:     ast.AdminRecoverIndex,
			Tables: []*ast.TableName{$4.(*ast.TableName)},
			Index:  string($5),
		}
	}
|	"ADMIN" "CLEANUP" "INDEX" TableName Identifier
	{
sql_ir.LogGrammarCoverage("AdminStmt,TableName")
sql_ir.LogGrammarCoverage("AdminStmt,Identifier")


		$$ = &ast.AdminStmt{
			Tp:     ast.AdminCleanupIndex,
			Tables: []*ast.TableName{$4.(*ast.TableName)},
			Index:  string($5),
		}
	}
|	"ADMIN" "CHECK" "INDEX" TableName Identifier HandleRangeList
	{
sql_ir.LogGrammarCoverage("AdminStmt,TableName")
sql_ir.LogGrammarCoverage("AdminStmt,Identifier")
sql_ir.LogGrammarCoverage("AdminStmt,HandleRangeList")


		$$ = &ast.AdminStmt{
			Tp:           ast.AdminCheckIndexRange,
			Tables:       []*ast.TableName{$4.(*ast.TableName)},
			Index:        string($5),
			HandleRanges: $6.([]ast.HandleRange),
		}
	}
|	"ADMIN" "CHECKSUM" "TABLE" TableNameList
	{
sql_ir.LogGrammarCoverage("AdminStmt,TableNameList")


		$$ = &ast.AdminStmt{
			Tp:     ast.AdminChecksumTable,
			Tables: $4.([]*ast.TableName),
		}
	}
|	"ADMIN" "CANCEL" "DDL" "JOBS" NumList
	{
sql_ir.LogGrammarCoverage("AdminStmt,NumList")


		$$ = &ast.AdminStmt{
			Tp:     ast.AdminCancelDDLJobs,
			JobIDs: $5.([]int64),
		}
	}
|	"ADMIN" "SHOW" "DDL" "JOB" "QUERIES" NumList
	{
sql_ir.LogGrammarCoverage("AdminStmt,NumList")


		$$ = &ast.AdminStmt{
			Tp:     ast.AdminShowDDLJobQueries,
			JobIDs: $6.([]int64),
		}
	}
|	"ADMIN" "SHOW" "SLOW" AdminShowSlow
	{
sql_ir.LogGrammarCoverage("AdminStmt,AdminShowSlow")


		$$ = &ast.AdminStmt{
			Tp:       ast.AdminShowSlow,
			ShowSlow: $4.(*ast.ShowSlow),
		}
	}
|	"ADMIN" "RELOAD" "EXPR_PUSHDOWN_BLACKLIST"
	{


		$$ = &ast.AdminStmt{
			Tp: ast.AdminReloadExprPushdownBlacklist,
		}
	}
|	"ADMIN" "RELOAD" "OPT_RULE_BLACKLIST"
	{


		$$ = &ast.AdminStmt{
			Tp: ast.AdminReloadOptRuleBlacklist,
		}
	}
|	"ADMIN" "PLUGINS" "ENABLE" PluginNameList
	{
sql_ir.LogGrammarCoverage("AdminStmt,PluginNameList")


		$$ = &ast.AdminStmt{
			Tp:      ast.AdminPluginEnable,
			Plugins: $4.([]string),
		}
	}
|	"ADMIN" "PLUGINS" "DISABLE" PluginNameList
	{
sql_ir.LogGrammarCoverage("AdminStmt,PluginNameList")


		$$ = &ast.AdminStmt{
			Tp:      ast.AdminPluginDisable,
			Plugins: $4.([]string),
		}
	}
|	"ADMIN" "CLEANUP" "TABLE" "LOCK" TableNameList
	{
sql_ir.LogGrammarCoverage("AdminStmt,TableNameList")


		$$ = &ast.CleanupTableLockStmt{
			Tables: $5.([]*ast.TableName),
		}
	}
|	"ADMIN" "REPAIR" "TABLE" TableName CreateTableStmt
	{
sql_ir.LogGrammarCoverage("AdminStmt,TableName")
sql_ir.LogGrammarCoverage("AdminStmt,CreateTableStmt")


		$$ = &ast.RepairTableStmt{
			Table:      $4.(*ast.TableName),
			CreateStmt: $5.(*ast.CreateTableStmt),
		}
	}
|	"ADMIN" "FLUSH" "BINDINGS"
	{


		$$ = &ast.AdminStmt{
			Tp: ast.AdminFlushBindings,
		}
	}
|	"ADMIN" "CAPTURE" "BINDINGS"
	{


		$$ = &ast.AdminStmt{
			Tp: ast.AdminCaptureBindings,
		}
	}
|	"ADMIN" "EVOLVE" "BINDINGS"
	{


		$$ = &ast.AdminStmt{
			Tp: ast.AdminEvolveBindings,
		}
	}
|	"ADMIN" "RELOAD" "BINDINGS"
	{


		$$ = &ast.AdminStmt{
			Tp: ast.AdminReloadBindings,
		}
	}
|	"ADMIN" "RELOAD" "STATS_EXTENDED"
	{


		$$ = &ast.AdminStmt{
			Tp: ast.AdminReloadStatistics,
		}
	}
|	"ADMIN" "RELOAD" "STATISTICS"
	{


		$$ = &ast.AdminStmt{
			Tp: ast.AdminReloadStatistics,
		}
	}
|	"ADMIN" "SHOW" "TELEMETRY"
	{


		$$ = &ast.AdminStmt{
			Tp: ast.AdminShowTelemetry,
		}
	}
|	"ADMIN" "RESET" "TELEMETRY_ID"
	{


		$$ = &ast.AdminStmt{
			Tp: ast.AdminResetTelemetryID,
		}
	}
|	"ADMIN" "FLUSH" StatementScope "PLAN_CACHE"
	{
sql_ir.LogGrammarCoverage("AdminStmt,StatementScope")


		$$ = &ast.AdminStmt{
			Tp:             ast.AdminFlushPlanCache,
			StatementScope: $3.(ast.StatementScope),
		}
	}

AdminShowSlow:
	"RECENT" NUM
	{
sql_ir.LogGrammarCoverage("AdminShowSlow,NUM")


		$$ = &ast.ShowSlow{
			Tp:    ast.ShowSlowRecent,
			Count: getUint64FromNUM($2),
		}
	}
|	"TOP" NUM
	{
sql_ir.LogGrammarCoverage("AdminShowSlow,NUM")


		$$ = &ast.ShowSlow{
			Tp:    ast.ShowSlowTop,
			Kind:  ast.ShowSlowKindDefault,
			Count: getUint64FromNUM($2),
		}
	}
|	"TOP" "INTERNAL" NUM
	{
sql_ir.LogGrammarCoverage("AdminShowSlow,NUM")


		$$ = &ast.ShowSlow{
			Tp:    ast.ShowSlowTop,
			Kind:  ast.ShowSlowKindInternal,
			Count: getUint64FromNUM($3),
		}
	}
|	"TOP" "ALL" NUM
	{
sql_ir.LogGrammarCoverage("AdminShowSlow,NUM")


		$$ = &ast.ShowSlow{
			Tp:    ast.ShowSlowTop,
			Kind:  ast.ShowSlowKindAll,
			Count: getUint64FromNUM($3),
		}
	}

HandleRangeList:
	HandleRange
	{
sql_ir.LogGrammarCoverage("HandleRangeList,HandleRange")


		$$ = []ast.HandleRange{$1.(ast.HandleRange)}
	}
|	HandleRangeList ',' HandleRange
	{
sql_ir.LogGrammarCoverage("HandleRangeList,HandleRangeList")
sql_ir.LogGrammarCoverage("HandleRangeList,HandleRange")


		$$ = append($1.([]ast.HandleRange), $3.(ast.HandleRange))
	}

HandleRange:
	'(' Int64Num ',' Int64Num ')'
	{
sql_ir.LogGrammarCoverage("HandleRange,Int64Num")
sql_ir.LogGrammarCoverage("HandleRange,Int64Num")


		$$ = ast.HandleRange{Begin: $2.(int64), End: $4.(int64)}
	}

NumList:
	Int64Num
	{
sql_ir.LogGrammarCoverage("NumList,Int64Num")


		$$ = []int64{$1.(int64)}
	}
|	NumList ',' Int64Num
	{
sql_ir.LogGrammarCoverage("NumList,NumList")
sql_ir.LogGrammarCoverage("NumList,Int64Num")


		$$ = append($1.([]int64), $3.(int64))
	}


ShowStmt:
	"SHOW" ShowTargetFilterable ShowLikeOrWhereOpt
	{
sql_ir.LogGrammarCoverage("ShowStmt,ShowTargetFilterable")
sql_ir.LogGrammarCoverage("ShowStmt,ShowLikeOrWhereOpt")


		stmt := $2.(*ast.ShowStmt)
		if $3 != nil {
			if x, ok := $3.(*ast.PatternLikeExpr); ok && x.Expr == nil {
				stmt.Pattern = x
			} else {
				stmt.Where = $3.(ast.ExprNode)
			}
		}
		$$ = stmt
	}
|	"SHOW" "CREATE" "TABLE" TableName
	{
sql_ir.LogGrammarCoverage("ShowStmt,TableName")


		$$ = &ast.ShowStmt{
			Tp:    ast.ShowCreateTable,
			Table: $4.(*ast.TableName),
		}
	}
|	"SHOW" "CREATE" "VIEW" TableName
	{
sql_ir.LogGrammarCoverage("ShowStmt,TableName")


		$$ = &ast.ShowStmt{
			Tp:    ast.ShowCreateView,
			Table: $4.(*ast.TableName),
		}
	}
|	"SHOW" "CREATE" "DATABASE" IfNotExists DBName
	{
sql_ir.LogGrammarCoverage("ShowStmt,IfNotExists")
sql_ir.LogGrammarCoverage("ShowStmt,DBName")


		$$ = &ast.ShowStmt{
			Tp:          ast.ShowCreateDatabase,
			IfNotExists: $4.(bool),
			DBName:      $5,
		}
	}
|	"SHOW" "CREATE" "SEQUENCE" TableName
	{
sql_ir.LogGrammarCoverage("ShowStmt,TableName")


		$$ = &ast.ShowStmt{
			Tp:    ast.ShowCreateSequence,
			Table: $4.(*ast.TableName),
		}
	}
|	"SHOW" "CREATE" "PLACEMENT" "POLICY" PolicyName
	{
sql_ir.LogGrammarCoverage("ShowStmt,PolicyName")


		$$ = &ast.ShowStmt{
			Tp:     ast.ShowCreatePlacementPolicy,
			DBName: $5,
		}
	}
|	"SHOW" "CREATE" "USER" Username
	{
sql_ir.LogGrammarCoverage("ShowStmt,Username")


		// See https://dev.mysql.com/doc/refman/5.7/en/show-create-user.html
		$$ = &ast.ShowStmt{
			Tp:   ast.ShowCreateUser,
			User: $4.(*auth.UserIdentity),
		}
	}
|	"SHOW" "CREATE" "IMPORT" Identifier
	{
sql_ir.LogGrammarCoverage("ShowStmt,Identifier")


		$$ = &ast.ShowStmt{
			Tp:     ast.ShowCreateImport,
			DBName: $4, // we reuse DBName of ShowStmt
		}
	}
|	"SHOW" "TABLE" TableName PartitionNameListOpt "REGIONS" WhereClauseOptional
	{
sql_ir.LogGrammarCoverage("ShowStmt,TableName")
sql_ir.LogGrammarCoverage("ShowStmt,PartitionNameListOpt")
sql_ir.LogGrammarCoverage("ShowStmt,WhereClauseOptional")


		stmt := &ast.ShowStmt{
			Tp:    ast.ShowRegions,
			Table: $3.(*ast.TableName),
		}
		stmt.Table.PartitionNames = $4.([]model.CIStr)
		if $6 != nil {
			stmt.Where = $6.(ast.ExprNode)
		}
		$$ = stmt
	}
|	"SHOW" "TABLE" TableName "NEXT_ROW_ID"
	{
sql_ir.LogGrammarCoverage("ShowStmt,TableName")


		$$ = &ast.ShowStmt{
			Tp:    ast.ShowTableNextRowId,
			Table: $3.(*ast.TableName),
		}
	}
|	"SHOW" "TABLE" TableName PartitionNameListOpt "INDEX" Identifier "REGIONS" WhereClauseOptional
	{
sql_ir.LogGrammarCoverage("ShowStmt,TableName")
sql_ir.LogGrammarCoverage("ShowStmt,PartitionNameListOpt")
sql_ir.LogGrammarCoverage("ShowStmt,Identifier")
sql_ir.LogGrammarCoverage("ShowStmt,WhereClauseOptional")


		stmt := &ast.ShowStmt{
			Tp:        ast.ShowRegions,
			Table:     $3.(*ast.TableName),
			IndexName: model.NewCIStr($6),
		}
		stmt.Table.PartitionNames = $4.([]model.CIStr)
		if $8 != nil {
			stmt.Where = $8.(ast.ExprNode)
		}
		$$ = stmt
	}
|	"SHOW" "GRANTS"
	{


		// See https://dev.mysql.com/doc/refman/5.7/en/show-grants.html
		$$ = &ast.ShowStmt{Tp: ast.ShowGrants}
	}
|	"SHOW" "GRANTS" "FOR" Username UsingRoles
	{
sql_ir.LogGrammarCoverage("ShowStmt,Username")
sql_ir.LogGrammarCoverage("ShowStmt,UsingRoles")


		// See https://dev.mysql.com/doc/refman/5.7/en/show-grants.html
		if $5 != nil {
			$$ = &ast.ShowStmt{
				Tp:    ast.ShowGrants,
				User:  $4.(*auth.UserIdentity),
				Roles: $5.([]*auth.RoleIdentity),
			}
		} else {
			$$ = &ast.ShowStmt{
				Tp:    ast.ShowGrants,
				User:  $4.(*auth.UserIdentity),
				Roles: nil,
			}
		}
	}
|	"SHOW" "MASTER" "STATUS"
	{


		$$ = &ast.ShowStmt{
			Tp: ast.ShowMasterStatus,
		}
	}
|	"SHOW" OptFull "PROCESSLIST"
	{
sql_ir.LogGrammarCoverage("ShowStmt,OptFull")


		$$ = &ast.ShowStmt{
			Tp:   ast.ShowProcessList,
			Full: $2.(bool),
		}
	}
|	"SHOW" "PROFILES"
	{


		$$ = &ast.ShowStmt{
			Tp: ast.ShowProfiles,
		}
	}
|	"SHOW" "PROFILE" ShowProfileTypesOpt ShowProfileArgsOpt SelectStmtLimitOpt
	{
sql_ir.LogGrammarCoverage("ShowStmt,ShowProfileTypesOpt")
sql_ir.LogGrammarCoverage("ShowStmt,ShowProfileArgsOpt")
sql_ir.LogGrammarCoverage("ShowStmt,SelectStmtLimitOpt")


		v := &ast.ShowStmt{
			Tp: ast.ShowProfile,
		}
		if $3 != nil {
			v.ShowProfileTypes = $3.([]int)
		}
		if $4 != nil {
			v.ShowProfileArgs = $4.(*int64)
		}
		if $5 != nil {
			v.ShowProfileLimit = $5.(*ast.Limit)
		}
		$$ = v
	}
|	"SHOW" "PRIVILEGES"
	{


		$$ = &ast.ShowStmt{
			Tp: ast.ShowPrivileges,
		}
	}
|	"SHOW" "BUILTINS"
	{


		$$ = &ast.ShowStmt{
			Tp: ast.ShowBuiltins,
		}
	}
|	"SHOW" "PLACEMENT" "FOR" ShowPlacementTarget
	{
sql_ir.LogGrammarCoverage("ShowStmt,ShowPlacementTarget")


		$$ = $4.(*ast.ShowStmt)
	}

ShowPlacementTarget:
	DatabaseSym DBName
	{
sql_ir.LogGrammarCoverage("ShowPlacementTarget,DatabaseSym")
sql_ir.LogGrammarCoverage("ShowPlacementTarget,DBName")


		$$ = &ast.ShowStmt{
			Tp:     ast.ShowPlacementForDatabase,
			DBName: $2,
		}
	}
|	"TABLE" TableName
	{
sql_ir.LogGrammarCoverage("ShowPlacementTarget,TableName")


		$$ = &ast.ShowStmt{
			Tp:    ast.ShowPlacementForTable,
			Table: $2.(*ast.TableName),
		}
	}
|	"TABLE" TableName "PARTITION" Identifier
	{
sql_ir.LogGrammarCoverage("ShowPlacementTarget,TableName")
sql_ir.LogGrammarCoverage("ShowPlacementTarget,Identifier")


		$$ = &ast.ShowStmt{
			Tp:        ast.ShowPlacementForPartition,
			Table:     $2.(*ast.TableName),
			Partition: model.NewCIStr($4),
		}
	}

ShowProfileTypesOpt:
	{


		$$ = nil
	}
|	ShowProfileTypes

{
sql_ir.LogGrammarCoverage("ShowProfileTypesOpt,ShowProfileTypes")

}
ShowProfileTypes:
	ShowProfileType
	{
sql_ir.LogGrammarCoverage("ShowProfileTypes,ShowProfileType")


		$$ = []int{$1.(int)}
	}
|	ShowProfileTypes ',' ShowProfileType
	{
sql_ir.LogGrammarCoverage("ShowProfileTypes,ShowProfileTypes")
sql_ir.LogGrammarCoverage("ShowProfileTypes,ShowProfileType")


		l := $1.([]int)
		l = append(l, $3.(int))
		$$ = l
	}

ShowProfileType:
	"CPU"
	{


		$$ = ast.ProfileTypeCPU
	}
|	"MEMORY"
	{


		$$ = ast.ProfileTypeMemory
	}
|	"BLOCK" "IO"
	{


		$$ = ast.ProfileTypeBlockIo
	}
|	"CONTEXT" "SWITCHES"
	{


		$$ = ast.ProfileTypeContextSwitch
	}
|	"PAGE" "FAULTS"
	{


		$$ = ast.ProfileTypePageFaults
	}
|	"IPC"
	{


		$$ = ast.ProfileTypeIpc
	}
|	"SWAPS"
	{


		$$ = ast.ProfileTypeSwaps
	}
|	"SOURCE"
	{


		$$ = ast.ProfileTypeSource
	}
|	"ALL"
	{


		$$ = ast.ProfileTypeAll
	}

ShowProfileArgsOpt:
	{


		$$ = nil
	}
|	"FOR" "QUERY" Int64Num
	{
sql_ir.LogGrammarCoverage("ShowProfileArgsOpt,Int64Num")


		v := $3.(int64)
		$$ = &v
	}

UsingRoles:
	{


		$$ = nil
	}
|	"USING" RolenameList
	{
sql_ir.LogGrammarCoverage("UsingRoles,RolenameList")


		$$ = $2.([]*auth.RoleIdentity)
	}

ShowIndexKwd:
	"INDEX"
{

}
|	"INDEXES"
{

}
|	"KEYS"

{

}
FromOrIn:
	"FROM"
{

}
|	"IN"

{

}
ShowTargetFilterable:
	"ENGINES"
	{


		$$ = &ast.ShowStmt{Tp: ast.ShowEngines}
	}
|	"DATABASES"
	{


		$$ = &ast.ShowStmt{Tp: ast.ShowDatabases}
	}
|	"CONFIG"
	{


		$$ = &ast.ShowStmt{Tp: ast.ShowConfig}
	}
|	CharsetKw
	{
sql_ir.LogGrammarCoverage("ShowTargetFilterable,CharsetKw")


		$$ = &ast.ShowStmt{Tp: ast.ShowCharset}
	}
|	OptFull "TABLES" ShowDatabaseNameOpt
	{
sql_ir.LogGrammarCoverage("ShowTargetFilterable,OptFull")
sql_ir.LogGrammarCoverage("ShowTargetFilterable,ShowDatabaseNameOpt")


		$$ = &ast.ShowStmt{
			Tp:     ast.ShowTables,
			DBName: $3,
			Full:   $1.(bool),
		}
	}
|	"OPEN" "TABLES" ShowDatabaseNameOpt
	{
sql_ir.LogGrammarCoverage("ShowTargetFilterable,ShowDatabaseNameOpt")


		$$ = &ast.ShowStmt{
			Tp:     ast.ShowOpenTables,
			DBName: $3,
		}
	}
|	"TABLE" "STATUS" ShowDatabaseNameOpt
	{
sql_ir.LogGrammarCoverage("ShowTargetFilterable,ShowDatabaseNameOpt")


		$$ = &ast.ShowStmt{
			Tp:     ast.ShowTableStatus,
			DBName: $3,
		}
	}
|	ShowIndexKwd FromOrIn TableName
	{
sql_ir.LogGrammarCoverage("ShowTargetFilterable,ShowIndexKwd")
sql_ir.LogGrammarCoverage("ShowTargetFilterable,FromOrIn")
sql_ir.LogGrammarCoverage("ShowTargetFilterable,TableName")


		$$ = &ast.ShowStmt{
			Tp:    ast.ShowIndex,
			Table: $3.(*ast.TableName),
		}
	}
|	ShowIndexKwd FromOrIn Identifier FromOrIn Identifier
	{
sql_ir.LogGrammarCoverage("ShowTargetFilterable,ShowIndexKwd")
sql_ir.LogGrammarCoverage("ShowTargetFilterable,FromOrIn")
sql_ir.LogGrammarCoverage("ShowTargetFilterable,Identifier")
sql_ir.LogGrammarCoverage("ShowTargetFilterable,FromOrIn")
sql_ir.LogGrammarCoverage("ShowTargetFilterable,Identifier")


		show := &ast.ShowStmt{
			Tp:    ast.ShowIndex,
			Table: &ast.TableName{Name: model.NewCIStr($3), Schema: model.NewCIStr($5)},
		}
		$$ = show
	}
|	OptFull FieldsOrColumns ShowTableAliasOpt ShowDatabaseNameOpt
	{
sql_ir.LogGrammarCoverage("ShowTargetFilterable,OptFull")
sql_ir.LogGrammarCoverage("ShowTargetFilterable,FieldsOrColumns")
sql_ir.LogGrammarCoverage("ShowTargetFilterable,ShowTableAliasOpt")
sql_ir.LogGrammarCoverage("ShowTargetFilterable,ShowDatabaseNameOpt")


		$$ = &ast.ShowStmt{
			Tp:     ast.ShowColumns,
			Table:  $3.(*ast.TableName),
			DBName: $4,
			Full:   $1.(bool),
		}
	}
|	"EXTENDED" OptFull FieldsOrColumns ShowTableAliasOpt ShowDatabaseNameOpt
	{
sql_ir.LogGrammarCoverage("ShowTargetFilterable,OptFull")
sql_ir.LogGrammarCoverage("ShowTargetFilterable,FieldsOrColumns")
sql_ir.LogGrammarCoverage("ShowTargetFilterable,ShowTableAliasOpt")
sql_ir.LogGrammarCoverage("ShowTargetFilterable,ShowDatabaseNameOpt")


		$$ = &ast.ShowStmt{
			Tp:       ast.ShowColumns,
			Table:    $4.(*ast.TableName),
			DBName:   $5,
			Full:     $2.(bool),
			Extended: true,
		}
	}
|	"WARNINGS"
	{


		$$ = &ast.ShowStmt{Tp: ast.ShowWarnings}
	}
|	"ERRORS"
	{


		$$ = &ast.ShowStmt{Tp: ast.ShowErrors}
	}
|	GlobalScope "VARIABLES"
	{
sql_ir.LogGrammarCoverage("ShowTargetFilterable,GlobalScope")


		$$ = &ast.ShowStmt{
			Tp:          ast.ShowVariables,
			GlobalScope: $1.(bool),
		}
	}
|	GlobalScope "STATUS"
	{
sql_ir.LogGrammarCoverage("ShowTargetFilterable,GlobalScope")


		$$ = &ast.ShowStmt{
			Tp:          ast.ShowStatus,
			GlobalScope: $1.(bool),
		}
	}
|	GlobalScope "BINDINGS"
	{
sql_ir.LogGrammarCoverage("ShowTargetFilterable,GlobalScope")


		$$ = &ast.ShowStmt{
			Tp:          ast.ShowBindings,
			GlobalScope: $1.(bool),
		}
	}
|	"COLLATION"
	{


		$$ = &ast.ShowStmt{
			Tp: ast.ShowCollation,
		}
	}
|	"TRIGGERS" ShowDatabaseNameOpt
	{
sql_ir.LogGrammarCoverage("ShowTargetFilterable,ShowDatabaseNameOpt")


		$$ = &ast.ShowStmt{
			Tp:     ast.ShowTriggers,
			DBName: $2,
		}
	}
|	"BINDING_CACHE" "STATUS"
	{


		$$ = &ast.ShowStmt{
			Tp: ast.ShowBindingCacheStatus,
		}
	}
|	"PROCEDURE" "STATUS"
	{


		$$ = &ast.ShowStmt{
			Tp: ast.ShowProcedureStatus,
		}
	}
|	"PUMP" "STATUS"
	{


		$$ = &ast.ShowStmt{
			Tp: ast.ShowPumpStatus,
		}
	}
|	"DRAINER" "STATUS"
	{


		$$ = &ast.ShowStmt{
			Tp: ast.ShowDrainerStatus,
		}
	}
|	"FUNCTION" "STATUS"
	{


		// This statement is similar to SHOW PROCEDURE STATUS but for stored functions.
		// See http://dev.mysql.com/doc/refman/5.7/en/show-function-status.html
		// We do not support neither stored functions nor stored procedures.
		// So we reuse show procedure status process logic.
		$$ = &ast.ShowStmt{
			Tp: ast.ShowProcedureStatus,
		}
	}
|	"EVENTS" ShowDatabaseNameOpt
	{
sql_ir.LogGrammarCoverage("ShowTargetFilterable,ShowDatabaseNameOpt")


		$$ = &ast.ShowStmt{
			Tp:     ast.ShowEvents,
			DBName: $2,
		}
	}
|	"PLUGINS"
	{


		$$ = &ast.ShowStmt{
			Tp: ast.ShowPlugins,
		}
	}
|	"STATS_EXTENDED"
	{


		$$ = &ast.ShowStmt{Tp: ast.ShowStatsExtended}
	}
|	"STATS_META"
	{


		$$ = &ast.ShowStmt{Tp: ast.ShowStatsMeta}
	}
|	"STATS_HISTOGRAMS"
	{


		$$ = &ast.ShowStmt{Tp: ast.ShowStatsHistograms}
	}
|	"STATS_TOPN"
	{


		$$ = &ast.ShowStmt{Tp: ast.ShowStatsTopN}
	}
|	"STATS_BUCKETS"
	{


		$$ = &ast.ShowStmt{Tp: ast.ShowStatsBuckets}
	}
|	"STATS_HEALTHY"
	{


		$$ = &ast.ShowStmt{Tp: ast.ShowStatsHealthy}
	}
|	"HISTOGRAMS_IN_FLIGHT"
	{


		$$ = &ast.ShowStmt{Tp: ast.ShowHistogramsInFlight}
	}
|	"COLUMN_STATS_USAGE"
	{


		$$ = &ast.ShowStmt{Tp: ast.ShowColumnStatsUsage}
	}
|	"ANALYZE" "STATUS"
	{


		$$ = &ast.ShowStmt{Tp: ast.ShowAnalyzeStatus}
	}
|	"BACKUPS"
	{


		$$ = &ast.ShowStmt{Tp: ast.ShowBackups}
	}
|	"RESTORES"
	{


		$$ = &ast.ShowStmt{Tp: ast.ShowRestores}
	}
|	"IMPORTS"
	{


		$$ = &ast.ShowStmt{Tp: ast.ShowImports}
	}
|	"PLACEMENT"
	{


		$$ = &ast.ShowStmt{Tp: ast.ShowPlacement}
	}
|	"PLACEMENT" "LABELS"
	{


		$$ = &ast.ShowStmt{Tp: ast.ShowPlacementLabels}
	}

ShowLikeOrWhereOpt:
	{


		$$ = nil
	}
|	"LIKE" SimpleExpr
	{
sql_ir.LogGrammarCoverage("ShowLikeOrWhereOpt,SimpleExpr")


		$$ = &ast.PatternLikeExpr{
			Pattern: $2,
			Escape:  '\\',
		}
	}
|	"WHERE" Expression
	{
sql_ir.LogGrammarCoverage("ShowLikeOrWhereOpt,Expression")


		$$ = $2
	}

GlobalScope:
	{


		$$ = false
	}
|	"GLOBAL"
	{


		$$ = true
	}
|	"SESSION"
	{


		$$ = false
	}

StatementScope:
	{


		$$ = ast.StatementScopeSession
	}
|	"GLOBAL"
	{


		$$ = ast.StatementScopeGlobal
	}
|	"INSTANCE"
	{


		$$ = ast.StatementScopeInstance
	}
|	"SESSION"
	{


		$$ = ast.StatementScopeSession
	}

OptFull:
	{


		$$ = false
	}
|	"FULL"
	{


		$$ = true
	}

ShowDatabaseNameOpt:
	{


		$$ = ""
	}
|	FromOrIn DBName
	{
sql_ir.LogGrammarCoverage("ShowDatabaseNameOpt,FromOrIn")
sql_ir.LogGrammarCoverage("ShowDatabaseNameOpt,DBName")


		$$ = $2
	}

ShowTableAliasOpt:
	FromOrIn TableName
	{
sql_ir.LogGrammarCoverage("ShowTableAliasOpt,FromOrIn")
sql_ir.LogGrammarCoverage("ShowTableAliasOpt,TableName")


		$$ = $2.(*ast.TableName)
	}

FlushStmt:
	"FLUSH" NoWriteToBinLogAliasOpt FlushOption
	{
sql_ir.LogGrammarCoverage("FlushStmt,NoWriteToBinLogAliasOpt")
sql_ir.LogGrammarCoverage("FlushStmt,FlushOption")


		tmp := $3.(*ast.FlushStmt)
		tmp.NoWriteToBinLog = $2.(bool)
		$$ = tmp
	}

PluginNameList:
	Identifier
	{
sql_ir.LogGrammarCoverage("PluginNameList,Identifier")


		$$ = []string{$1}
	}
|	PluginNameList ',' Identifier
	{
sql_ir.LogGrammarCoverage("PluginNameList,PluginNameList")
sql_ir.LogGrammarCoverage("PluginNameList,Identifier")


		$$ = append($1.([]string), $3)
	}

FlushOption:
	"PRIVILEGES"
	{


		$$ = &ast.FlushStmt{
			Tp: ast.FlushPrivileges,
		}
	}
|	"STATUS"
	{


		$$ = &ast.FlushStmt{
			Tp: ast.FlushStatus,
		}
	}
|	"TIDB" "PLUGINS" PluginNameList
	{
sql_ir.LogGrammarCoverage("FlushOption,PluginNameList")


		$$ = &ast.FlushStmt{
			Tp:      ast.FlushTiDBPlugin,
			Plugins: $3.([]string),
		}
	}
|	"HOSTS"
	{


		$$ = &ast.FlushStmt{
			Tp: ast.FlushHosts,
		}
	}
|	LogTypeOpt "LOGS"
	{
sql_ir.LogGrammarCoverage("FlushOption,LogTypeOpt")


		$$ = &ast.FlushStmt{
			Tp:      ast.FlushLogs,
			LogType: $1.(ast.LogType),
		}
	}
|	TableOrTables TableNameListOpt WithReadLockOpt
	{
sql_ir.LogGrammarCoverage("FlushOption,TableOrTables")
sql_ir.LogGrammarCoverage("FlushOption,TableNameListOpt")
sql_ir.LogGrammarCoverage("FlushOption,WithReadLockOpt")


		$$ = &ast.FlushStmt{
			Tp:       ast.FlushTables,
			Tables:   $2.([]*ast.TableName),
			ReadLock: $3.(bool),
		}
	}
|	"CLIENT_ERRORS_SUMMARY"
	{


		$$ = &ast.FlushStmt{
			Tp: ast.FlushClientErrorsSummary,
		}
	}

LogTypeOpt:
	
	{


		$$ = ast.LogTypeDefault
	}
|	"BINARY"
	{


		$$ = ast.LogTypeBinary
	}
|	"ENGINE"
	{


		$$ = ast.LogTypeEngine
	}
|	"ERROR"
	{


		$$ = ast.LogTypeError
	}
|	"GENERAL"
	{


		$$ = ast.LogTypeGeneral
	}
|	"SLOW"
	{


		$$ = ast.LogTypeSlow
	}

NoWriteToBinLogAliasOpt:
	%prec lowerThanLocal
	{


		$$ = false
	}
|	"NO_WRITE_TO_BINLOG"
	{


		$$ = true
	}
|	"LOCAL"
	{


		$$ = true
	}

TableNameListOpt:
	%prec empty
	{


		$$ = []*ast.TableName{}
	}
|	TableNameList

{
sql_ir.LogGrammarCoverage("TableNameListOpt,TableNameList")

}
TableNameListOpt2:
	%prec empty
	{


		$$ = []*ast.TableName{}
	}
|	"TABLE" TableNameList
	{
sql_ir.LogGrammarCoverage("TableNameListOpt2,TableNameList")


		$$ = $2
	}

WithReadLockOpt:
	{


		$$ = false
	}
|	"WITH" "READ" "LOCK"
	{


		$$ = true
	}

Statement:
	EmptyStmt
{
sql_ir.LogGrammarCoverage("Statement,EmptyStmt")

}
|	AdminStmt
{
sql_ir.LogGrammarCoverage("Statement,AdminStmt")

}
|	AlterDatabaseStmt
{
sql_ir.LogGrammarCoverage("Statement,AlterDatabaseStmt")

}
|	AlterTableStmt
{
sql_ir.LogGrammarCoverage("Statement,AlterTableStmt")

}
|	AlterUserStmt
{
sql_ir.LogGrammarCoverage("Statement,AlterUserStmt")

}
|	AlterImportStmt
{
sql_ir.LogGrammarCoverage("Statement,AlterImportStmt")

}
|	AlterInstanceStmt
{
sql_ir.LogGrammarCoverage("Statement,AlterInstanceStmt")

}
|	AlterSequenceStmt
{
sql_ir.LogGrammarCoverage("Statement,AlterSequenceStmt")

}
|	AlterPolicyStmt
{
sql_ir.LogGrammarCoverage("Statement,AlterPolicyStmt")

}
|	AnalyzeTableStmt
{
sql_ir.LogGrammarCoverage("Statement,AnalyzeTableStmt")

}
|	BeginTransactionStmt
{
sql_ir.LogGrammarCoverage("Statement,BeginTransactionStmt")

}
|	BinlogStmt
{
sql_ir.LogGrammarCoverage("Statement,BinlogStmt")

}
|	BRIEStmt
{
sql_ir.LogGrammarCoverage("Statement,BRIEStmt")

}
|	CommitStmt
{
sql_ir.LogGrammarCoverage("Statement,CommitStmt")

}
|	DeallocateStmt
{
sql_ir.LogGrammarCoverage("Statement,DeallocateStmt")

}
|	DeleteFromStmt
{
sql_ir.LogGrammarCoverage("Statement,DeleteFromStmt")

}
|	ExecuteStmt
{
sql_ir.LogGrammarCoverage("Statement,ExecuteStmt")

}
|	ExplainStmt
{
sql_ir.LogGrammarCoverage("Statement,ExplainStmt")

}
|	ChangeStmt
{
sql_ir.LogGrammarCoverage("Statement,ChangeStmt")

}
|	CreateDatabaseStmt
{
sql_ir.LogGrammarCoverage("Statement,CreateDatabaseStmt")

}
|	CreateImportStmt
{
sql_ir.LogGrammarCoverage("Statement,CreateImportStmt")

}
|	CreateIndexStmt
{
sql_ir.LogGrammarCoverage("Statement,CreateIndexStmt")

}
|	CreateTableStmt
{
sql_ir.LogGrammarCoverage("Statement,CreateTableStmt")

}
|	CreateViewStmt
{
sql_ir.LogGrammarCoverage("Statement,CreateViewStmt")

}
|	CreateUserStmt
{
sql_ir.LogGrammarCoverage("Statement,CreateUserStmt")

}
|	CreateRoleStmt
{
sql_ir.LogGrammarCoverage("Statement,CreateRoleStmt")

}
|	CreateBindingStmt
{
sql_ir.LogGrammarCoverage("Statement,CreateBindingStmt")

}
|	CreatePolicyStmt
{
sql_ir.LogGrammarCoverage("Statement,CreatePolicyStmt")

}
|	CreateSequenceStmt
{
sql_ir.LogGrammarCoverage("Statement,CreateSequenceStmt")

}
|	CreateStatisticsStmt
{
sql_ir.LogGrammarCoverage("Statement,CreateStatisticsStmt")

}
|	DoStmt
{
sql_ir.LogGrammarCoverage("Statement,DoStmt")

}
|	DropDatabaseStmt
{
sql_ir.LogGrammarCoverage("Statement,DropDatabaseStmt")

}
|	DropImportStmt
{
sql_ir.LogGrammarCoverage("Statement,DropImportStmt")

}
|	DropIndexStmt
{
sql_ir.LogGrammarCoverage("Statement,DropIndexStmt")

}
|	DropTableStmt
{
sql_ir.LogGrammarCoverage("Statement,DropTableStmt")

}
|	DropPolicyStmt
{
sql_ir.LogGrammarCoverage("Statement,DropPolicyStmt")

}
|	DropSequenceStmt
{
sql_ir.LogGrammarCoverage("Statement,DropSequenceStmt")

}
|	DropViewStmt
{
sql_ir.LogGrammarCoverage("Statement,DropViewStmt")

}
|	DropUserStmt
{
sql_ir.LogGrammarCoverage("Statement,DropUserStmt")

}
|	DropRoleStmt
{
sql_ir.LogGrammarCoverage("Statement,DropRoleStmt")

}
|	DropStatisticsStmt
{
sql_ir.LogGrammarCoverage("Statement,DropStatisticsStmt")

}
|	DropStatsStmt
{
sql_ir.LogGrammarCoverage("Statement,DropStatsStmt")

}
|	DropBindingStmt
{
sql_ir.LogGrammarCoverage("Statement,DropBindingStmt")

}
|	FlushStmt
{
sql_ir.LogGrammarCoverage("Statement,FlushStmt")

}
|	FlashbackTableStmt
{
sql_ir.LogGrammarCoverage("Statement,FlashbackTableStmt")

}
|	GrantStmt
{
sql_ir.LogGrammarCoverage("Statement,GrantStmt")

}
|	GrantProxyStmt
{
sql_ir.LogGrammarCoverage("Statement,GrantProxyStmt")

}
|	GrantRoleStmt
{
sql_ir.LogGrammarCoverage("Statement,GrantRoleStmt")

}
|	CallStmt
{
sql_ir.LogGrammarCoverage("Statement,CallStmt")

}
|	InsertIntoStmt
{
sql_ir.LogGrammarCoverage("Statement,InsertIntoStmt")

}
|	IndexAdviseStmt
{
sql_ir.LogGrammarCoverage("Statement,IndexAdviseStmt")

}
|	KillStmt
{
sql_ir.LogGrammarCoverage("Statement,KillStmt")

}
|	LoadDataStmt
{
sql_ir.LogGrammarCoverage("Statement,LoadDataStmt")

}
|	LoadStatsStmt
{
sql_ir.LogGrammarCoverage("Statement,LoadStatsStmt")

}
|	PlanReplayerStmt
{
sql_ir.LogGrammarCoverage("Statement,PlanReplayerStmt")

}
|	PreparedStmt
{
sql_ir.LogGrammarCoverage("Statement,PreparedStmt")

}
|	PurgeImportStmt
{
sql_ir.LogGrammarCoverage("Statement,PurgeImportStmt")

}
|	RollbackStmt
{
sql_ir.LogGrammarCoverage("Statement,RollbackStmt")

}
|	RenameTableStmt
{
sql_ir.LogGrammarCoverage("Statement,RenameTableStmt")

}
|	RenameUserStmt
{
sql_ir.LogGrammarCoverage("Statement,RenameUserStmt")

}
|	ReplaceIntoStmt
{
sql_ir.LogGrammarCoverage("Statement,ReplaceIntoStmt")

}
|	RecoverTableStmt
{
sql_ir.LogGrammarCoverage("Statement,RecoverTableStmt")

}
|	ResumeImportStmt
{
sql_ir.LogGrammarCoverage("Statement,ResumeImportStmt")

}
|	RevokeStmt
{
sql_ir.LogGrammarCoverage("Statement,RevokeStmt")

}
|	RevokeRoleStmt
{
sql_ir.LogGrammarCoverage("Statement,RevokeRoleStmt")

}
|	SetOprStmt
{
sql_ir.LogGrammarCoverage("Statement,SetOprStmt")

}
|	SelectStmt
{
sql_ir.LogGrammarCoverage("Statement,SelectStmt")

}
|	SelectStmtWithClause
{
sql_ir.LogGrammarCoverage("Statement,SelectStmtWithClause")

}
|	SubSelect
	{
sql_ir.LogGrammarCoverage("Statement,SubSelect")


		var sel ast.StmtNode
		switch x := $1.(*ast.SubqueryExpr).Query.(type) {
		case *ast.SelectStmt:
			x.IsInBraces = true
			sel = x
		case *ast.SetOprStmt:
			x.IsInBraces = true
			sel = x
		}
		$$ = sel
	}
|	SetStmt
{
sql_ir.LogGrammarCoverage("Statement,SetStmt")

}
|	SetBindingStmt
{
sql_ir.LogGrammarCoverage("Statement,SetBindingStmt")

}
|	SetRoleStmt
{
sql_ir.LogGrammarCoverage("Statement,SetRoleStmt")

}
|	SetDefaultRoleStmt
{
sql_ir.LogGrammarCoverage("Statement,SetDefaultRoleStmt")

}
|	SplitRegionStmt
{
sql_ir.LogGrammarCoverage("Statement,SplitRegionStmt")

}
|	StopImportStmt
{
sql_ir.LogGrammarCoverage("Statement,StopImportStmt")

}
|	ShowImportStmt
{
sql_ir.LogGrammarCoverage("Statement,ShowImportStmt")

}
|	ShowStmt
{
sql_ir.LogGrammarCoverage("Statement,ShowStmt")

}
|	TraceStmt
{
sql_ir.LogGrammarCoverage("Statement,TraceStmt")

}
|	TruncateTableStmt
{
sql_ir.LogGrammarCoverage("Statement,TruncateTableStmt")

}
|	UpdateStmt
{
sql_ir.LogGrammarCoverage("Statement,UpdateStmt")

}
|	UseStmt
{
sql_ir.LogGrammarCoverage("Statement,UseStmt")

}
|	UnlockTablesStmt
{
sql_ir.LogGrammarCoverage("Statement,UnlockTablesStmt")

}
|	LockTablesStmt
{
sql_ir.LogGrammarCoverage("Statement,LockTablesStmt")

}
|	ShutdownStmt
{
sql_ir.LogGrammarCoverage("Statement,ShutdownStmt")

}
|	RestartStmt
{
sql_ir.LogGrammarCoverage("Statement,RestartStmt")

}
|	HelpStmt
{
sql_ir.LogGrammarCoverage("Statement,HelpStmt")

}
|	NonTransactionalDeleteStmt

{
sql_ir.LogGrammarCoverage("Statement,NonTransactionalDeleteStmt")

}
TraceableStmt:
	DeleteFromStmt
{
sql_ir.LogGrammarCoverage("TraceableStmt,DeleteFromStmt")

}
|	UpdateStmt
{
sql_ir.LogGrammarCoverage("TraceableStmt,UpdateStmt")

}
|	InsertIntoStmt
{
sql_ir.LogGrammarCoverage("TraceableStmt,InsertIntoStmt")

}
|	ReplaceIntoStmt
{
sql_ir.LogGrammarCoverage("TraceableStmt,ReplaceIntoStmt")

}
|	SetOprStmt
{
sql_ir.LogGrammarCoverage("TraceableStmt,SetOprStmt")

}
|	SelectStmt
{
sql_ir.LogGrammarCoverage("TraceableStmt,SelectStmt")

}
|	SelectStmtWithClause
{
sql_ir.LogGrammarCoverage("TraceableStmt,SelectStmtWithClause")

}
|	SubSelect
	{
sql_ir.LogGrammarCoverage("TraceableStmt,SubSelect")


		var sel ast.StmtNode
		switch x := $1.(*ast.SubqueryExpr).Query.(type) {
		case *ast.SelectStmt:
			x.IsInBraces = true
			sel = x
		case *ast.SetOprStmt:
			x.IsInBraces = true
			sel = x
		}
		$$ = sel
	}
|	LoadDataStmt
{
sql_ir.LogGrammarCoverage("TraceableStmt,LoadDataStmt")

}
|	BeginTransactionStmt
{
sql_ir.LogGrammarCoverage("TraceableStmt,BeginTransactionStmt")

}
|	CommitStmt
{
sql_ir.LogGrammarCoverage("TraceableStmt,CommitStmt")

}
|	RollbackStmt
{
sql_ir.LogGrammarCoverage("TraceableStmt,RollbackStmt")

}
|	SetStmt

{
sql_ir.LogGrammarCoverage("TraceableStmt,SetStmt")

}
ExplainableStmt:
	DeleteFromStmt
{
sql_ir.LogGrammarCoverage("ExplainableStmt,DeleteFromStmt")

}
|	UpdateStmt
{
sql_ir.LogGrammarCoverage("ExplainableStmt,UpdateStmt")

}
|	InsertIntoStmt
{
sql_ir.LogGrammarCoverage("ExplainableStmt,InsertIntoStmt")

}
|	ReplaceIntoStmt
{
sql_ir.LogGrammarCoverage("ExplainableStmt,ReplaceIntoStmt")

}
|	SetOprStmt
{
sql_ir.LogGrammarCoverage("ExplainableStmt,SetOprStmt")

}
|	SelectStmt
{
sql_ir.LogGrammarCoverage("ExplainableStmt,SelectStmt")

}
|	SelectStmtWithClause
{
sql_ir.LogGrammarCoverage("ExplainableStmt,SelectStmtWithClause")

}
|	SubSelect
	{
sql_ir.LogGrammarCoverage("ExplainableStmt,SubSelect")


		var sel ast.StmtNode
		switch x := $1.(*ast.SubqueryExpr).Query.(type) {
		case *ast.SelectStmt:
			x.IsInBraces = true
			sel = x
		case *ast.SetOprStmt:
			x.IsInBraces = true
			sel = x
		}
		$$ = sel
	}
|	AlterTableStmt

{
sql_ir.LogGrammarCoverage("ExplainableStmt,AlterTableStmt")

}
StatementList:
	Statement
	{
sql_ir.LogGrammarCoverage("StatementList,Statement")


		if $1 != nil {
			s := $1
			if lexer, ok := yylex.(stmtTexter); ok {
				s.SetText(parser.lexer.client, lexer.stmtText())
			}
			parser.result = append(parser.result, s)
		}
	}
|	StatementList ';' Statement
	{
sql_ir.LogGrammarCoverage("StatementList,StatementList")
sql_ir.LogGrammarCoverage("StatementList,Statement")


		if $3 != nil {
			s := $3
			if lexer, ok := yylex.(stmtTexter); ok {
				s.SetText(parser.lexer.client, lexer.stmtText())
			}
			parser.result = append(parser.result, s)
		}
	}

Constraint:
	ConstraintKeywordOpt ConstraintElem
	{
sql_ir.LogGrammarCoverage("Constraint,ConstraintKeywordOpt")
sql_ir.LogGrammarCoverage("Constraint,ConstraintElem")


		cst := $2.(*ast.Constraint)
		if $1 != nil {
			cst.Name = $1.(string)
		}
		$$ = cst
	}

CheckConstraintKeyword:
	"CHECK"
{

}
|	"CONSTRAINT"

{

}
TableElement:
	ColumnDef
{
sql_ir.LogGrammarCoverage("TableElement,ColumnDef")

}
|	Constraint

{
sql_ir.LogGrammarCoverage("TableElement,Constraint")

}
TableElementList:
	TableElement
	{
sql_ir.LogGrammarCoverage("TableElementList,TableElement")


		if $1 != nil {
			$$ = []interface{}{$1.(interface{})}
		} else {
			$$ = []interface{}{}
		}
	}
|	TableElementList ',' TableElement
	{
sql_ir.LogGrammarCoverage("TableElementList,TableElementList")
sql_ir.LogGrammarCoverage("TableElementList,TableElement")


		if $3 != nil {
			$$ = append($1.([]interface{}), $3)
		} else {
			$$ = $1
		}
	}

TableElementListOpt:
	 %prec lowerThanCreateTableSelect
	{


		var columnDefs []*ast.ColumnDef
		var constraints []*ast.Constraint
		$$ = &ast.CreateTableStmt{
			Cols:        columnDefs,
			Constraints: constraints,
		}
	}
|	'(' TableElementList ')'
	{
sql_ir.LogGrammarCoverage("TableElementListOpt,TableElementList")


		tes := $2.([]interface{})
		var columnDefs []*ast.ColumnDef
		var constraints []*ast.Constraint
		for _, te := range tes {
			switch te := te.(type) {
			case *ast.ColumnDef:
				columnDefs = append(columnDefs, te)
			case *ast.Constraint:
				constraints = append(constraints, te)
			}
		}
		$$ = &ast.CreateTableStmt{
			Cols:        columnDefs,
			Constraints: constraints,
		}
	}

TableOption:
	PartDefOption
{
sql_ir.LogGrammarCoverage("TableOption,PartDefOption")

}
|	DefaultKwdOpt CharsetKw EqOpt CharsetName
	{
sql_ir.LogGrammarCoverage("TableOption,DefaultKwdOpt")
sql_ir.LogGrammarCoverage("TableOption,CharsetKw")
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,CharsetName")


		$$ = &ast.TableOption{Tp: ast.TableOptionCharset, StrValue: $4,
			UintValue: ast.TableOptionCharsetWithoutConvertTo}
	}
|	DefaultKwdOpt "COLLATE" EqOpt CollationName
	{
sql_ir.LogGrammarCoverage("TableOption,DefaultKwdOpt")
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,CollationName")


		$$ = &ast.TableOption{Tp: ast.TableOptionCollate, StrValue: $4,
			UintValue: ast.TableOptionCharsetWithoutConvertTo}
	}
|	ForceOpt "AUTO_INCREMENT" EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("TableOption,ForceOpt")
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,LengthNum")


		$$ = &ast.TableOption{Tp: ast.TableOptionAutoIncrement, UintValue: $4.(uint64), BoolValue: $1.(bool)}
	}
|	"AUTO_ID_CACHE" EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,LengthNum")


		$$ = &ast.TableOption{Tp: ast.TableOptionAutoIdCache, UintValue: $3.(uint64)}
	}
|	ForceOpt "AUTO_RANDOM_BASE" EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("TableOption,ForceOpt")
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,LengthNum")


		$$ = &ast.TableOption{Tp: ast.TableOptionAutoRandomBase, UintValue: $4.(uint64), BoolValue: $1.(bool)}
	}
|	"AVG_ROW_LENGTH" EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,LengthNum")


		$$ = &ast.TableOption{Tp: ast.TableOptionAvgRowLength, UintValue: $3.(uint64)}
	}
|	"CONNECTION" EqOpt stringLit
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,stringLit")


		$$ = &ast.TableOption{Tp: ast.TableOptionConnection, StrValue: $3}
	}
|	"CHECKSUM" EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,LengthNum")


		$$ = &ast.TableOption{Tp: ast.TableOptionCheckSum, UintValue: $3.(uint64)}
	}
|	"TABLE_CHECKSUM" EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,LengthNum")


		$$ = &ast.TableOption{Tp: ast.TableOptionTableCheckSum, UintValue: $3.(uint64)}
	}
|	"PASSWORD" EqOpt stringLit
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,stringLit")


		$$ = &ast.TableOption{Tp: ast.TableOptionPassword, StrValue: $3}
	}
|	"COMPRESSION" EqOpt stringLit
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,stringLit")


		$$ = &ast.TableOption{Tp: ast.TableOptionCompression, StrValue: $3}
	}
|	"KEY_BLOCK_SIZE" EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,LengthNum")


		$$ = &ast.TableOption{Tp: ast.TableOptionKeyBlockSize, UintValue: $3.(uint64)}
	}
|	"DELAY_KEY_WRITE" EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,LengthNum")


		$$ = &ast.TableOption{Tp: ast.TableOptionDelayKeyWrite, UintValue: $3.(uint64)}
	}
|	RowFormat
	{
sql_ir.LogGrammarCoverage("TableOption,RowFormat")


		$$ = &ast.TableOption{Tp: ast.TableOptionRowFormat, UintValue: $1.(uint64)}
	}
|	"STATS_PERSISTENT" EqOpt StatsPersistentVal
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,StatsPersistentVal")


		$$ = &ast.TableOption{Tp: ast.TableOptionStatsPersistent}
	}
|	"STATS_AUTO_RECALC" EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,LengthNum")


		n := $3.(uint64)
		if n != 0 && n != 1 {
			yylex.AppendError(yylex.Errorf("The value of STATS_AUTO_RECALC must be one of [0|1|DEFAULT]."))
			return 1
		}
		$$ = &ast.TableOption{Tp: ast.TableOptionStatsAutoRecalc, UintValue: n}
		yylex.AppendError(yylex.Errorf("The STATS_AUTO_RECALC is parsed but ignored by all storage engines."))
		parser.lastErrorAsWarn()
	}
|	"STATS_AUTO_RECALC" EqOpt "DEFAULT"
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")


		$$ = &ast.TableOption{Tp: ast.TableOptionStatsAutoRecalc, Default: true}
		yylex.AppendError(yylex.Errorf("The STATS_AUTO_RECALC is parsed but ignored by all storage engines."))
		parser.lastErrorAsWarn()
	}
|	"STATS_SAMPLE_PAGES" EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,LengthNum")


		// Parse it but will ignore it.
		// In MySQL, STATS_SAMPLE_PAGES=N(Where 0<N<=65535) or STAS_SAMPLE_PAGES=DEFAULT.
		// Cause we don't support it, so we don't check range of the value.
		$$ = &ast.TableOption{Tp: ast.TableOptionStatsSamplePages, UintValue: $3.(uint64)}
		yylex.AppendError(yylex.Errorf("The STATS_SAMPLE_PAGES is parsed but ignored by all storage engines."))
		parser.lastErrorAsWarn()
	}
|	"STATS_SAMPLE_PAGES" EqOpt "DEFAULT"
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")


		// Parse it but will ignore it.
		// In MySQL, default value of STATS_SAMPLE_PAGES is 0.
		$$ = &ast.TableOption{Tp: ast.TableOptionStatsSamplePages, Default: true}
		yylex.AppendError(yylex.Errorf("The STATS_SAMPLE_PAGES is parsed but ignored by all storage engines."))
		parser.lastErrorAsWarn()
	}
|	"STATS_BUCKETS" EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,LengthNum")


		$$ = &ast.TableOption{Tp: ast.TableOptionStatsBuckets, UintValue: $3.(uint64)}
	}
|	"STATS_TOPN" EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,LengthNum")


		$$ = &ast.TableOption{Tp: ast.TableOptionStatsTopN, UintValue: $3.(uint64)}
	}
|	"STATS_SAMPLE_RATE" EqOpt NumLiteral
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,NumLiteral")


		$$ = &ast.TableOption{Tp: ast.TableOptionStatsSampleRate, Value: ast.NewValueExpr($3, "", "")}
	}
|	"STATS_COL_CHOICE" EqOpt stringLit
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,stringLit")


		$$ = &ast.TableOption{Tp: ast.TableOptionStatsColsChoice, StrValue: $3}
	}
|	"STATS_COL_LIST" EqOpt stringLit
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,stringLit")


		$$ = &ast.TableOption{Tp: ast.TableOptionStatsColList, StrValue: $3}
	}
|	"SHARD_ROW_ID_BITS" EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,LengthNum")


		$$ = &ast.TableOption{Tp: ast.TableOptionShardRowID, UintValue: $3.(uint64)}
	}
|	"PRE_SPLIT_REGIONS" EqOpt LengthNum
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,LengthNum")


		$$ = &ast.TableOption{Tp: ast.TableOptionPreSplitRegion, UintValue: $3.(uint64)}
	}
|	"PACK_KEYS" EqOpt StatsPersistentVal
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,StatsPersistentVal")


		// Parse it but will ignore it.
		$$ = &ast.TableOption{Tp: ast.TableOptionPackKeys}
	}
|	"STORAGE" "MEMORY"
	{


		// Parse it but will ignore it.
		$$ = &ast.TableOption{Tp: ast.TableOptionStorageMedia, StrValue: "MEMORY"}
		yylex.AppendError(yylex.Errorf("The STORAGE clause is parsed but ignored by all storage engines."))
		parser.lastErrorAsWarn()
	}
|	"STORAGE" "DISK"
	{


		// Parse it but will ignore it.
		$$ = &ast.TableOption{Tp: ast.TableOptionStorageMedia, StrValue: "DISK"}
		yylex.AppendError(yylex.Errorf("The STORAGE clause is parsed but ignored by all storage engines."))
		parser.lastErrorAsWarn()
	}
|	"SECONDARY_ENGINE" EqOpt "NULL"
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")


		// Parse it but will ignore it
		// See https://github.com/mysql/mysql-server/blob/8.0/sql/sql_yacc.yy#L5977-L5984
		$$ = &ast.TableOption{Tp: ast.TableOptionSecondaryEngineNull}
		yylex.AppendError(yylex.Errorf("The SECONDARY_ENGINE clause is parsed but ignored by all storage engines."))
		parser.lastErrorAsWarn()
	}
|	"SECONDARY_ENGINE" EqOpt StringName
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,StringName")


		// Parse it but will ignore it
		// See https://github.com/mysql/mysql-server/blob/8.0/sql/sql_yacc.yy#L5977-L5984
		$$ = &ast.TableOption{Tp: ast.TableOptionSecondaryEngine, StrValue: $3}
		yylex.AppendError(yylex.Errorf("The SECONDARY_ENGINE clause is parsed but ignored by all storage engines."))
		parser.lastErrorAsWarn()
	}
|	"UNION" EqOpt '(' TableNameListOpt ')'
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,TableNameListOpt")


		// Parse it but will ignore it
		$$ = &ast.TableOption{
			Tp:         ast.TableOptionUnion,
			TableNames: $4.([]*ast.TableName),
		}
		yylex.AppendError(yylex.Errorf("The UNION option is parsed but ignored by all storage engines."))
		parser.lastErrorAsWarn()
	}
|	"ENCRYPTION" EqOpt EncryptionOpt
	{
sql_ir.LogGrammarCoverage("TableOption,EqOpt")
sql_ir.LogGrammarCoverage("TableOption,EncryptionOpt")


		// Parse it but will ignore it
		$$ = &ast.TableOption{Tp: ast.TableOptionEncryption, StrValue: $3}
	}

ForceOpt:
	
	{


		$$ = false
	}
|	"FORCE"
	{


		$$ = true
	}

StatsPersistentVal:
	"DEFAULT"
	{

}
|	LengthNum
	{
sql_ir.LogGrammarCoverage("StatsPersistentVal,LengthNum")

}

CreateTableOptionListOpt:
	 %prec lowerThanCreateTableSelect
	{


		$$ = []*ast.TableOption{}
	}
|	TableOptionList %prec lowerThanComma

{
sql_ir.LogGrammarCoverage("CreateTableOptionListOpt,TableOptionList")

}
TableOptionList:
	TableOption
	{
sql_ir.LogGrammarCoverage("TableOptionList,TableOption")


		$$ = []*ast.TableOption{$1.(*ast.TableOption)}
	}
|	TableOptionList TableOption
	{
sql_ir.LogGrammarCoverage("TableOptionList,TableOptionList")
sql_ir.LogGrammarCoverage("TableOptionList,TableOption")


		$$ = append($1.([]*ast.TableOption), $2.(*ast.TableOption))
	}
|	TableOptionList ',' TableOption
	{
sql_ir.LogGrammarCoverage("TableOptionList,TableOptionList")
sql_ir.LogGrammarCoverage("TableOptionList,TableOption")


		$$ = append($1.([]*ast.TableOption), $3.(*ast.TableOption))
	}

OptTable:
	{

}
|	"TABLE"

{

}
TruncateTableStmt:
	"TRUNCATE" OptTable TableName
	{
sql_ir.LogGrammarCoverage("TruncateTableStmt,OptTable")
sql_ir.LogGrammarCoverage("TruncateTableStmt,TableName")


		$$ = &ast.TruncateTableStmt{Table: $3.(*ast.TableName)}
	}

RowFormat:
	"ROW_FORMAT" EqOpt "DEFAULT"
	{
sql_ir.LogGrammarCoverage("RowFormat,EqOpt")


		$$ = ast.RowFormatDefault
	}
|	"ROW_FORMAT" EqOpt "DYNAMIC"
	{
sql_ir.LogGrammarCoverage("RowFormat,EqOpt")


		$$ = ast.RowFormatDynamic
	}
|	"ROW_FORMAT" EqOpt "FIXED"
	{
sql_ir.LogGrammarCoverage("RowFormat,EqOpt")


		$$ = ast.RowFormatFixed
	}
|	"ROW_FORMAT" EqOpt "COMPRESSED"
	{
sql_ir.LogGrammarCoverage("RowFormat,EqOpt")


		$$ = ast.RowFormatCompressed
	}
|	"ROW_FORMAT" EqOpt "REDUNDANT"
	{
sql_ir.LogGrammarCoverage("RowFormat,EqOpt")


		$$ = ast.RowFormatRedundant
	}
|	"ROW_FORMAT" EqOpt "COMPACT"
	{
sql_ir.LogGrammarCoverage("RowFormat,EqOpt")


		$$ = ast.RowFormatCompact
	}
|	"ROW_FORMAT" EqOpt "TOKUDB_DEFAULT"
	{
sql_ir.LogGrammarCoverage("RowFormat,EqOpt")


		$$ = ast.TokuDBRowFormatDefault
	}
|	"ROW_FORMAT" EqOpt "TOKUDB_FAST"
	{
sql_ir.LogGrammarCoverage("RowFormat,EqOpt")


		$$ = ast.TokuDBRowFormatFast
	}
|	"ROW_FORMAT" EqOpt "TOKUDB_SMALL"
	{
sql_ir.LogGrammarCoverage("RowFormat,EqOpt")


		$$ = ast.TokuDBRowFormatSmall
	}
|	"ROW_FORMAT" EqOpt "TOKUDB_ZLIB"
	{
sql_ir.LogGrammarCoverage("RowFormat,EqOpt")


		$$ = ast.TokuDBRowFormatZlib
	}
|	"ROW_FORMAT" EqOpt "TOKUDB_QUICKLZ"
	{
sql_ir.LogGrammarCoverage("RowFormat,EqOpt")


		$$ = ast.TokuDBRowFormatQuickLZ
	}
|	"ROW_FORMAT" EqOpt "TOKUDB_LZMA"
	{
sql_ir.LogGrammarCoverage("RowFormat,EqOpt")


		$$ = ast.TokuDBRowFormatLzma
	}
|	"ROW_FORMAT" EqOpt "TOKUDB_SNAPPY"
	{
sql_ir.LogGrammarCoverage("RowFormat,EqOpt")


		$$ = ast.TokuDBRowFormatSnappy
	}
|	"ROW_FORMAT" EqOpt "TOKUDB_UNCOMPRESSED"
	{
sql_ir.LogGrammarCoverage("RowFormat,EqOpt")


		$$ = ast.TokuDBRowFormatUncompressed
	}


Type:
	NumericType
{
sql_ir.LogGrammarCoverage("Type,NumericType")

}
|	StringType
{
sql_ir.LogGrammarCoverage("Type,StringType")

}
|	DateAndTimeType

{
sql_ir.LogGrammarCoverage("Type,DateAndTimeType")

}
NumericType:
	IntegerType OptFieldLen FieldOpts
	{
sql_ir.LogGrammarCoverage("NumericType,IntegerType")
sql_ir.LogGrammarCoverage("NumericType,OptFieldLen")
sql_ir.LogGrammarCoverage("NumericType,FieldOpts")


		// TODO: check flen 0
		tp := types.NewFieldType($1.(byte))
		tp.SetFlen($2.(int))
		if $2.(int) != types.UnspecifiedLength && types.TiDBStrictIntegerDisplayWidth {
			yylex.AppendError(ErrWarnDeprecatedIntegerDisplayWidth)
			parser.lastErrorAsWarn()
		}
		for _, o := range $3.([]*ast.TypeOpt) {
			if o.IsUnsigned {
				tp.AddFlag(mysql.UnsignedFlag)
			}
			if o.IsZerofill {
				tp.AddFlag(mysql.ZerofillFlag)
			}
		}
		$$ = tp
	}
|	BooleanType FieldOpts
	{
sql_ir.LogGrammarCoverage("NumericType,BooleanType")
sql_ir.LogGrammarCoverage("NumericType,FieldOpts")


		// TODO: check flen 0
		tp := types.NewFieldType($1.(byte))
		tp.SetFlen(1)
		for _, o := range $2.([]*ast.TypeOpt) {
			if o.IsUnsigned {
				tp.AddFlag(mysql.UnsignedFlag)
			}
			if o.IsZerofill {
				tp.AddFlag(mysql.ZerofillFlag)
			}
		}
		$$ = tp
	}
|	FixedPointType FloatOpt FieldOpts
	{
sql_ir.LogGrammarCoverage("NumericType,FixedPointType")
sql_ir.LogGrammarCoverage("NumericType,FloatOpt")
sql_ir.LogGrammarCoverage("NumericType,FieldOpts")


		fopt := $2.(*ast.FloatOpt)
		tp := types.NewFieldType($1.(byte))
		tp.SetFlen(fopt.Flen)
		tp.SetDecimal(fopt.Decimal)
		for _, o := range $3.([]*ast.TypeOpt) {
			if o.IsUnsigned {
				tp.AddFlag(mysql.UnsignedFlag)
			}
			if o.IsZerofill {
				tp.AddFlag(mysql.ZerofillFlag)
			}
		}
		$$ = tp
	}
|	FloatingPointType FloatOpt FieldOpts
	{
sql_ir.LogGrammarCoverage("NumericType,FloatingPointType")
sql_ir.LogGrammarCoverage("NumericType,FloatOpt")
sql_ir.LogGrammarCoverage("NumericType,FieldOpts")


		fopt := $2.(*ast.FloatOpt)
		tp := types.NewFieldType($1.(byte))
		// check for a double(10) for syntax error
		if tp.GetType() == mysql.TypeDouble && parser.strictDoubleFieldType {
			if fopt.Flen != types.UnspecifiedLength && fopt.Decimal == types.UnspecifiedLength {
				yylex.AppendError(ErrSyntax)
				return 1
			}
		}
		tp.SetFlen(fopt.Flen)
		if tp.GetType() == mysql.TypeFloat && fopt.Decimal == types.UnspecifiedLength && tp.GetFlen() <= mysql.MaxDoublePrecisionLength {
			if tp.GetFlen() > mysql.MaxFloatPrecisionLength {
				tp.SetType(mysql.TypeDouble)
			}
			tp.SetFlen(types.UnspecifiedLength)
		}
		tp.SetDecimal(fopt.Decimal)
		for _, o := range $3.([]*ast.TypeOpt) {
			if o.IsUnsigned {
				tp.AddFlag(mysql.UnsignedFlag)
			}
			if o.IsZerofill {
				tp.AddFlag(mysql.ZerofillFlag)
			}
		}
		$$ = tp
	}
|	BitValueType OptFieldLen
	{
sql_ir.LogGrammarCoverage("NumericType,BitValueType")
sql_ir.LogGrammarCoverage("NumericType,OptFieldLen")


		tp := types.NewFieldType($1.(byte))
		tp.SetFlen($2.(int))
		if tp.GetFlen() == types.UnspecifiedLength {
			tp.SetFlen(1)
		}
		$$ = tp
	}

IntegerType:
	"TINYINT"
	{


		$$ = mysql.TypeTiny
	}
|	"SMALLINT"
	{


		$$ = mysql.TypeShort
	}
|	"MEDIUMINT"
	{


		$$ = mysql.TypeInt24
	}
|	"INT"
	{


		$$ = mysql.TypeLong
	}
|	"INT1"
	{


		$$ = mysql.TypeTiny
	}
|	"INT2"
	{


		$$ = mysql.TypeShort
	}
|	"INT3"
	{


		$$ = mysql.TypeInt24
	}
|	"INT4"
	{


		$$ = mysql.TypeLong
	}
|	"INT8"
	{


		$$ = mysql.TypeLonglong
	}
|	"INTEGER"
	{


		$$ = mysql.TypeLong
	}
|	"BIGINT"
	{


		$$ = mysql.TypeLonglong
	}

BooleanType:
	"BOOL"
	{


		$$ = mysql.TypeTiny
	}
|	"BOOLEAN"
	{


		$$ = mysql.TypeTiny
	}

OptInteger:
	{

}
|	"INTEGER"
{

}
|	"INT"

{

}
FixedPointType:
	"DECIMAL"
	{


		$$ = mysql.TypeNewDecimal
	}
|	"NUMERIC"
	{


		$$ = mysql.TypeNewDecimal
	}
|	"FIXED"
	{


		$$ = mysql.TypeNewDecimal
	}

FloatingPointType:
	"FLOAT"
	{


		$$ = mysql.TypeFloat
	}
|	"REAL"
	{


		if parser.lexer.GetSQLMode().HasRealAsFloatMode() {
			$$ = mysql.TypeFloat
		} else {
			$$ = mysql.TypeDouble
		}
	}
|	"DOUBLE"
	{


		$$ = mysql.TypeDouble
	}
|	"DOUBLE" "PRECISION"
	{


		$$ = mysql.TypeDouble
	}

BitValueType:
	"BIT"
	{


		$$ = mysql.TypeBit
	}

StringType:
	Char FieldLen OptBinary
	{
sql_ir.LogGrammarCoverage("StringType,Char")
sql_ir.LogGrammarCoverage("StringType,FieldLen")
sql_ir.LogGrammarCoverage("StringType,OptBinary")


		tp := types.NewFieldType(mysql.TypeString)
		tp.SetFlen($2.(int))
		tp.SetCharset($3.(*ast.OptBinary).Charset)
		if $3.(*ast.OptBinary).IsBinary {
			tp.AddFlag(mysql.BinaryFlag)
		}
		$$ = tp
	}
|	Char OptBinary
	{
sql_ir.LogGrammarCoverage("StringType,Char")
sql_ir.LogGrammarCoverage("StringType,OptBinary")


		tp := types.NewFieldType(mysql.TypeString)
		tp.SetCharset($2.(*ast.OptBinary).Charset)
		if $2.(*ast.OptBinary).IsBinary {
			tp.AddFlag(mysql.BinaryFlag)
		}
		$$ = tp
	}
|	NChar FieldLen OptBinary
	{
sql_ir.LogGrammarCoverage("StringType,NChar")
sql_ir.LogGrammarCoverage("StringType,FieldLen")
sql_ir.LogGrammarCoverage("StringType,OptBinary")


		tp := types.NewFieldType(mysql.TypeString)
		tp.SetFlen($2.(int))
		tp.SetCharset($3.(*ast.OptBinary).Charset)
		if $3.(*ast.OptBinary).IsBinary {
			tp.AddFlag(mysql.BinaryFlag)
		}
		$$ = tp
	}
|	NChar OptBinary
	{
sql_ir.LogGrammarCoverage("StringType,NChar")
sql_ir.LogGrammarCoverage("StringType,OptBinary")


		tp := types.NewFieldType(mysql.TypeString)
		tp.SetCharset($2.(*ast.OptBinary).Charset)
		if $2.(*ast.OptBinary).IsBinary {
			tp.AddFlag(mysql.BinaryFlag)
		}
		$$ = tp
	}
|	Varchar FieldLen OptBinary
	{
sql_ir.LogGrammarCoverage("StringType,Varchar")
sql_ir.LogGrammarCoverage("StringType,FieldLen")
sql_ir.LogGrammarCoverage("StringType,OptBinary")


		tp := types.NewFieldType(mysql.TypeVarchar)
		tp.SetFlen($2.(int))
		tp.SetCharset($3.(*ast.OptBinary).Charset)
		if $3.(*ast.OptBinary).IsBinary {
			tp.AddFlag(mysql.BinaryFlag)
		}
		$$ = tp
	}
|	NVarchar FieldLen OptBinary
	{
sql_ir.LogGrammarCoverage("StringType,NVarchar")
sql_ir.LogGrammarCoverage("StringType,FieldLen")
sql_ir.LogGrammarCoverage("StringType,OptBinary")


		tp := types.NewFieldType(mysql.TypeVarchar)
		tp.SetFlen($2.(int))
		tp.SetCharset($3.(*ast.OptBinary).Charset)
		if $3.(*ast.OptBinary).IsBinary {
			tp.AddFlag(mysql.BinaryFlag)
		}
		$$ = tp
	}
|	"BINARY" OptFieldLen
	{
sql_ir.LogGrammarCoverage("StringType,OptFieldLen")


		tp := types.NewFieldType(mysql.TypeString)
		tp.SetFlen($2.(int))
		tp.SetCharset(charset.CharsetBin)
		tp.SetCollate(charset.CharsetBin)
		tp.AddFlag(mysql.BinaryFlag)
		$$ = tp
	}
|	"VARBINARY" FieldLen
	{
sql_ir.LogGrammarCoverage("StringType,FieldLen")


		tp := types.NewFieldType(mysql.TypeVarchar)
		tp.SetFlen($2.(int))
		tp.SetCharset(charset.CharsetBin)
		tp.SetCollate(charset.CharsetBin)
		tp.AddFlag(mysql.BinaryFlag)
		$$ = tp
	}
|	BlobType
	{
sql_ir.LogGrammarCoverage("StringType,BlobType")


		tp := $1.(*types.FieldType)
		tp.SetCharset(charset.CharsetBin)
		tp.SetCollate(charset.CharsetBin)
		tp.AddFlag(mysql.BinaryFlag)
		$$ = tp
	}
|	TextType OptCharsetWithOptBinary
	{
sql_ir.LogGrammarCoverage("StringType,TextType")
sql_ir.LogGrammarCoverage("StringType,OptCharsetWithOptBinary")


		tp := $1.(*types.FieldType)
		tp.SetCharset($2.(*ast.OptBinary).Charset)
		if $2.(*ast.OptBinary).IsBinary {
			tp.AddFlag(mysql.BinaryFlag)
		}
		$$ = tp
	}
|	"ENUM" '(' TextStringList ')' OptCharsetWithOptBinary
	{
sql_ir.LogGrammarCoverage("StringType,TextStringList")
sql_ir.LogGrammarCoverage("StringType,OptCharsetWithOptBinary")


		tp := types.NewFieldType(mysql.TypeEnum)
		elems := $3.([]*ast.TextString)
		opt := $5.(*ast.OptBinary)
		tp.SetElems(ast.TransformTextStrings(elems, opt.Charset))
		fieldLen := -1 // enum_flen = max(ele_flen)
		for i := range tp.GetElems() {
			tp.SetElem(i, strings.TrimRight(tp.GetElem(i), " "))
			if len(tp.GetElem(i)) > fieldLen {
				fieldLen = len(tp.GetElem(i))
			}
		}
		tp.SetFlen(fieldLen)
		tp.SetCharset(opt.Charset)
		if opt.IsBinary {
			tp.AddFlag(mysql.BinaryFlag)
		}
		$$ = tp
	}
|	"SET" '(' TextStringList ')' OptCharsetWithOptBinary
	{
sql_ir.LogGrammarCoverage("StringType,TextStringList")
sql_ir.LogGrammarCoverage("StringType,OptCharsetWithOptBinary")


		tp := types.NewFieldType(mysql.TypeSet)
		elems := $3.([]*ast.TextString)
		opt := $5.(*ast.OptBinary)
		tp.SetElems(ast.TransformTextStrings(elems, opt.Charset))
		fieldLen := len(tp.GetElems()) - 1 // set_flen = sum(ele_flen) + number_of_ele - 1
		for i := range tp.GetElems() {
			tp.SetElem(i, strings.TrimRight(tp.GetElem(i), " "))
			fieldLen += len(tp.GetElem(i))
		}
		tp.SetFlen(fieldLen)
		tp.SetCharset(opt.Charset)
		if opt.IsBinary {
			tp.AddFlag(mysql.BinaryFlag)
		}
		$$ = tp
	}
|	"JSON"
	{


		tp := types.NewFieldType(mysql.TypeJSON)
		tp.SetDecimal(0)
		tp.SetCharset(charset.CharsetBin)
		tp.SetCollate(charset.CollationBin)
		$$ = tp
	}
|	"LONG" Varchar OptCharsetWithOptBinary
	{
sql_ir.LogGrammarCoverage("StringType,Varchar")
sql_ir.LogGrammarCoverage("StringType,OptCharsetWithOptBinary")


		tp := types.NewFieldType(mysql.TypeMediumBlob)
		tp.SetCharset($3.(*ast.OptBinary).Charset)
		if $3.(*ast.OptBinary).IsBinary {
			tp.AddFlag(mysql.BinaryFlag)
		}
		$$ = tp
	}
|	"LONG" OptCharsetWithOptBinary
	{
sql_ir.LogGrammarCoverage("StringType,OptCharsetWithOptBinary")


		tp := types.NewFieldType(mysql.TypeMediumBlob)
		tp.SetCharset($2.(*ast.OptBinary).Charset)
		if $2.(*ast.OptBinary).IsBinary {
			tp.AddFlag(mysql.BinaryFlag)
		}
		$$ = tp
	}

Char:
	"CHARACTER"
{

}
|	"CHAR"

{

}
NChar:
	"NCHAR"
{

}
|	"NATIONAL" "CHARACTER"
{

}
|	"NATIONAL" "CHAR"

{

}
Varchar:
	"CHARACTER" "VARYING"
{

}
|	"CHAR" "VARYING"
{

}
|	"VARCHAR"
{

}
|	"VARCHARACTER"

{

}
NVarchar:
	"NATIONAL" "VARCHAR"
{

}
|	"NATIONAL" "VARCHARACTER"
{

}
|	"NVARCHAR"
{

}
|	"NCHAR" "VARCHAR"
{

}
|	"NCHAR" "VARCHARACTER"
{

}
|	"NATIONAL" "CHARACTER" "VARYING"
{

}
|	"NATIONAL" "CHAR" "VARYING"
{

}
|	"NCHAR" "VARYING"

{

}
Year:
	"YEAR"
{

}
|	"SQL_TSI_YEAR"

{

}
BlobType:
	"TINYBLOB"
	{


		tp := types.NewFieldType(mysql.TypeTinyBlob)
		$$ = tp
	}
|	"BLOB" OptFieldLen
	{
sql_ir.LogGrammarCoverage("BlobType,OptFieldLen")


		tp := types.NewFieldType(mysql.TypeBlob)
		tp.SetFlen($2.(int))
		$$ = tp
	}
|	"MEDIUMBLOB"
	{


		tp := types.NewFieldType(mysql.TypeMediumBlob)
		$$ = tp
	}
|	"LONGBLOB"
	{


		tp := types.NewFieldType(mysql.TypeLongBlob)
		$$ = tp
	}
|	"LONG" "VARBINARY"
	{


		tp := types.NewFieldType(mysql.TypeMediumBlob)
		$$ = tp
	}

TextType:
	"TINYTEXT"
	{


		tp := types.NewFieldType(mysql.TypeTinyBlob)
		$$ = tp
	}
|	"TEXT" OptFieldLen
	{
sql_ir.LogGrammarCoverage("TextType,OptFieldLen")


		tp := types.NewFieldType(mysql.TypeBlob)
		tp.SetFlen($2.(int))
		$$ = tp
	}
|	"MEDIUMTEXT"
	{


		tp := types.NewFieldType(mysql.TypeMediumBlob)
		$$ = tp
	}
|	"LONGTEXT"
	{


		tp := types.NewFieldType(mysql.TypeLongBlob)
		$$ = tp
	}

OptCharsetWithOptBinary:
	OptBinary
{
sql_ir.LogGrammarCoverage("OptCharsetWithOptBinary,OptBinary")

}
|	"ASCII"
	{


		$$ = &ast.OptBinary{
			IsBinary: false,
			Charset:  charset.CharsetLatin1,
		}
	}
|	"UNICODE"
	{


		cs, err := charset.GetCharsetInfo("ucs2")
		if err != nil {
			yylex.AppendError(ErrUnknownCharacterSet.GenWithStackByArgs("ucs2"))
			return 1
		}
		$$ = &ast.OptBinary{
			IsBinary: false,
			Charset:  cs.Name,
		}
	}
|	"BYTE"
	{


		$$ = &ast.OptBinary{
			IsBinary: false,
			Charset:  "",
		}
	}

DateAndTimeType:
	"DATE"
	{


		tp := types.NewFieldType(mysql.TypeDate)
		$$ = tp
	}
|	"DATETIME" OptFieldLen
	{
sql_ir.LogGrammarCoverage("DateAndTimeType,OptFieldLen")


		tp := types.NewFieldType(mysql.TypeDatetime)
		tp.SetFlen(mysql.MaxDatetimeWidthNoFsp)
		tp.SetDecimal($2.(int))
		if tp.GetDecimal() > 0 {
			tp.SetFlen(tp.GetFlen() + 1 + tp.GetDecimal())
		}
		$$ = tp
	}
|	"TIMESTAMP" OptFieldLen
	{
sql_ir.LogGrammarCoverage("DateAndTimeType,OptFieldLen")


		tp := types.NewFieldType(mysql.TypeTimestamp)
		tp.SetFlen(mysql.MaxDatetimeWidthNoFsp)
		tp.SetDecimal($2.(int))
		if tp.GetDecimal() > 0 {
			tp.SetFlen(tp.GetFlen() + 1 + tp.GetDecimal())
		}
		$$ = tp
	}
|	"TIME" OptFieldLen
	{
sql_ir.LogGrammarCoverage("DateAndTimeType,OptFieldLen")


		tp := types.NewFieldType(mysql.TypeDuration)
		tp.SetFlen(mysql.MaxDurationWidthNoFsp)
		tp.SetDecimal($2.(int))
		if tp.GetDecimal() > 0 {
			tp.SetFlen(tp.GetFlen() + 1 + tp.GetDecimal())
		}
		$$ = tp
	}
|	Year OptFieldLen FieldOpts
	{
sql_ir.LogGrammarCoverage("DateAndTimeType,Year")
sql_ir.LogGrammarCoverage("DateAndTimeType,OptFieldLen")
sql_ir.LogGrammarCoverage("DateAndTimeType,FieldOpts")


		tp := types.NewFieldType(mysql.TypeYear)
		tp.SetFlen($2.(int))
		if tp.GetFlen() != types.UnspecifiedLength && tp.GetFlen() != 4 {
			yylex.AppendError(ErrInvalidYearColumnLength.GenWithStackByArgs())
			return -1
		}
		$$ = tp
	}

FieldLen:
	'(' LengthNum ')'
	{
sql_ir.LogGrammarCoverage("FieldLen,LengthNum")


		$$ = int($2.(uint64))
	}

OptFieldLen:
	{


		$$ = types.UnspecifiedLength
	}
|	FieldLen

{
sql_ir.LogGrammarCoverage("OptFieldLen,FieldLen")

}
FieldOpt:
	"UNSIGNED"
	{


		$$ = &ast.TypeOpt{IsUnsigned: true}
	}
|	"SIGNED"
	{


		$$ = &ast.TypeOpt{IsUnsigned: false}
	}
|	"ZEROFILL"
	{


		$$ = &ast.TypeOpt{IsZerofill: true, IsUnsigned: true}
	}

FieldOpts:
	{


		$$ = []*ast.TypeOpt{}
	}
|	FieldOpts FieldOpt
	{
sql_ir.LogGrammarCoverage("FieldOpts,FieldOpts")
sql_ir.LogGrammarCoverage("FieldOpts,FieldOpt")


		$$ = append($1.([]*ast.TypeOpt), $2.(*ast.TypeOpt))
	}

FloatOpt:
	{


		$$ = &ast.FloatOpt{Flen: types.UnspecifiedLength, Decimal: types.UnspecifiedLength}
	}
|	FieldLen
	{
sql_ir.LogGrammarCoverage("FloatOpt,FieldLen")


		$$ = &ast.FloatOpt{Flen: $1.(int), Decimal: types.UnspecifiedLength}
	}
|	Precision

{
sql_ir.LogGrammarCoverage("FloatOpt,Precision")

}
Precision:
	'(' LengthNum ',' LengthNum ')'
	{
sql_ir.LogGrammarCoverage("Precision,LengthNum")
sql_ir.LogGrammarCoverage("Precision,LengthNum")


		$$ = &ast.FloatOpt{Flen: int($2.(uint64)), Decimal: int($4.(uint64))}
	}

OptBinMod:
	{


		$$ = false
	}
|	"BINARY"
	{


		$$ = true
	}

OptBinary:
	{


		$$ = &ast.OptBinary{
			IsBinary: false,
			Charset:  "",
		}
	}
|	"BINARY" OptCharset
	{
sql_ir.LogGrammarCoverage("OptBinary,OptCharset")


		$$ = &ast.OptBinary{
			IsBinary: true,
			Charset:  $2,
		}
	}
|	CharsetKw CharsetName OptBinMod
	{
sql_ir.LogGrammarCoverage("OptBinary,CharsetKw")
sql_ir.LogGrammarCoverage("OptBinary,CharsetName")
sql_ir.LogGrammarCoverage("OptBinary,OptBinMod")


		$$ = &ast.OptBinary{
			IsBinary: $3.(bool),
			Charset:  $2,
		}
	}

OptCharset:
	{


		$$ = ""
	}
|	CharsetKw CharsetName
	{
sql_ir.LogGrammarCoverage("OptCharset,CharsetKw")
sql_ir.LogGrammarCoverage("OptCharset,CharsetName")


		$$ = $2
	}

CharsetKw:
	"CHARACTER" "SET"
{

}
|	"CHARSET"
{

}
|	"CHAR" "SET"

{

}
OptCollate:
	{


		$$ = ""
	}
|	"COLLATE" CollationName
	{
sql_ir.LogGrammarCoverage("OptCollate,CollationName")


		$$ = $2
	}

StringList:
	stringLit
	{
sql_ir.LogGrammarCoverage("StringList,stringLit")


		$$ = []string{$1}
	}
|	StringList ',' stringLit
	{
sql_ir.LogGrammarCoverage("StringList,StringList")
sql_ir.LogGrammarCoverage("StringList,stringLit")


		$$ = append($1.([]string), $3)
	}

TextString:
	stringLit
	{
sql_ir.LogGrammarCoverage("TextString,stringLit")


		$$ = &ast.TextString{Value: $1}
	}
|	hexLit
	{


		$$ = &ast.TextString{Value: $1.(ast.BinaryLiteral).ToString(), IsBinaryLiteral: true}
	}
|	bitLit
	{


		$$ = &ast.TextString{Value: $1.(ast.BinaryLiteral).ToString(), IsBinaryLiteral: true}
	}

TextStringList:
	TextString
	{
sql_ir.LogGrammarCoverage("TextStringList,TextString")


		$$ = []*ast.TextString{$1.(*ast.TextString)}
	}
|	TextStringList ',' TextString
	{
sql_ir.LogGrammarCoverage("TextStringList,TextStringList")
sql_ir.LogGrammarCoverage("TextStringList,TextString")


		$$ = append($1.([]*ast.TextString), $3.(*ast.TextString))
	}

StringName:
	stringLit
{
sql_ir.LogGrammarCoverage("StringName,stringLit")

}
|	Identifier

{
sql_ir.LogGrammarCoverage("StringName,Identifier")

}
StringNameOrBRIEOptionKeyword:
	StringName
{
sql_ir.LogGrammarCoverage("StringNameOrBRIEOptionKeyword,StringName")

}
|	"IGNORE"
{

}
|	"REPLACE"


{

}
UpdateStmt:
	UpdateStmtNoWith
{
sql_ir.LogGrammarCoverage("UpdateStmt,UpdateStmtNoWith")

}
|	WithClause UpdateStmtNoWith
	{
sql_ir.LogGrammarCoverage("UpdateStmt,WithClause")
sql_ir.LogGrammarCoverage("UpdateStmt,UpdateStmtNoWith")


		u := $2.(*ast.UpdateStmt)
		u.With = $1.(*ast.WithClause)
		$$ = u
	}

UpdateStmtNoWith:
	"UPDATE" TableOptimizerHintsOpt PriorityOpt IgnoreOptional TableRef "SET" AssignmentList WhereClauseOptional OrderByOptional LimitClause
	{
sql_ir.LogGrammarCoverage("UpdateStmtNoWith,TableOptimizerHintsOpt")
sql_ir.LogGrammarCoverage("UpdateStmtNoWith,PriorityOpt")
sql_ir.LogGrammarCoverage("UpdateStmtNoWith,IgnoreOptional")
sql_ir.LogGrammarCoverage("UpdateStmtNoWith,TableRef")
sql_ir.LogGrammarCoverage("UpdateStmtNoWith,AssignmentList")
sql_ir.LogGrammarCoverage("UpdateStmtNoWith,WhereClauseOptional")
sql_ir.LogGrammarCoverage("UpdateStmtNoWith,OrderByOptional")
sql_ir.LogGrammarCoverage("UpdateStmtNoWith,LimitClause")


		var refs *ast.Join
		if x, ok := $5.(*ast.Join); ok {
			refs = x
		} else {
			refs = &ast.Join{Left: $5.(ast.ResultSetNode)}
		}
		st := &ast.UpdateStmt{
			Priority:  $3.(mysql.PriorityEnum),
			TableRefs: &ast.TableRefsClause{TableRefs: refs},
			List:      $7.([]*ast.Assignment),
			IgnoreErr: $4.(bool),
		}
		if $2 != nil {
			st.TableHints = $2.([]*ast.TableOptimizerHint)
		}
		if $8 != nil {
			st.Where = $8.(ast.ExprNode)
		}
		if $9 != nil {
			st.Order = $9.(*ast.OrderByClause)
		}
		if $10 != nil {
			st.Limit = $10.(*ast.Limit)
		}
		$$ = st
	}
|	"UPDATE" TableOptimizerHintsOpt PriorityOpt IgnoreOptional TableRefs "SET" AssignmentList WhereClauseOptional
	{
sql_ir.LogGrammarCoverage("UpdateStmtNoWith,TableOptimizerHintsOpt")
sql_ir.LogGrammarCoverage("UpdateStmtNoWith,PriorityOpt")
sql_ir.LogGrammarCoverage("UpdateStmtNoWith,IgnoreOptional")
sql_ir.LogGrammarCoverage("UpdateStmtNoWith,TableRefs")
sql_ir.LogGrammarCoverage("UpdateStmtNoWith,AssignmentList")
sql_ir.LogGrammarCoverage("UpdateStmtNoWith,WhereClauseOptional")


		st := &ast.UpdateStmt{
			Priority:  $3.(mysql.PriorityEnum),
			TableRefs: &ast.TableRefsClause{TableRefs: $5.(*ast.Join)},
			List:      $7.([]*ast.Assignment),
			IgnoreErr: $4.(bool),
		}
		if $2 != nil {
			st.TableHints = $2.([]*ast.TableOptimizerHint)
		}
		if $8 != nil {
			st.Where = $8.(ast.ExprNode)
		}
		$$ = st
	}

UseStmt:
	"USE" DBName
	{
sql_ir.LogGrammarCoverage("UseStmt,DBName")


		$$ = &ast.UseStmt{DBName: $2}
	}

WhereClause:
	"WHERE" Expression
	{
sql_ir.LogGrammarCoverage("WhereClause,Expression")


		$$ = $2
	}

WhereClauseOptional:
	{


		$$ = nil
	}
|	WhereClause

{
sql_ir.LogGrammarCoverage("WhereClauseOptional,WhereClause")

}
CommaOpt:
	{

}
|	','
	{

}


CreateUserStmt:
	"CREATE" "USER" IfNotExists UserSpecList RequireClauseOpt ConnectionOptions PasswordOrLockOptions
	{
sql_ir.LogGrammarCoverage("CreateUserStmt,IfNotExists")
sql_ir.LogGrammarCoverage("CreateUserStmt,UserSpecList")
sql_ir.LogGrammarCoverage("CreateUserStmt,RequireClauseOpt")
sql_ir.LogGrammarCoverage("CreateUserStmt,ConnectionOptions")
sql_ir.LogGrammarCoverage("CreateUserStmt,PasswordOrLockOptions")


		// See https://dev.mysql.com/doc/refman/5.7/en/create-user.html
		$$ = &ast.CreateUserStmt{
			IsCreateRole:          false,
			IfNotExists:           $3.(bool),
			Specs:                 $4.([]*ast.UserSpec),
			TLSOptions:            $5.([]*ast.TLSOption),
			ResourceOptions:       $6.([]*ast.ResourceOption),
			PasswordOrLockOptions: $7.([]*ast.PasswordOrLockOption),
		}
	}

CreateRoleStmt:
	"CREATE" "ROLE" IfNotExists RoleSpecList
	{
sql_ir.LogGrammarCoverage("CreateRoleStmt,IfNotExists")
sql_ir.LogGrammarCoverage("CreateRoleStmt,RoleSpecList")


		// See https://dev.mysql.com/doc/refman/8.0/en/create-role.html
		$$ = &ast.CreateUserStmt{
			IsCreateRole: true,
			IfNotExists:  $3.(bool),
			Specs:        $4.([]*ast.UserSpec),
		}
	}


AlterUserStmt:
	"ALTER" "USER" IfExists UserSpecList RequireClauseOpt ConnectionOptions PasswordOrLockOptions
	{
sql_ir.LogGrammarCoverage("AlterUserStmt,IfExists")
sql_ir.LogGrammarCoverage("AlterUserStmt,UserSpecList")
sql_ir.LogGrammarCoverage("AlterUserStmt,RequireClauseOpt")
sql_ir.LogGrammarCoverage("AlterUserStmt,ConnectionOptions")
sql_ir.LogGrammarCoverage("AlterUserStmt,PasswordOrLockOptions")


		$$ = &ast.AlterUserStmt{
			IfExists:              $3.(bool),
			Specs:                 $4.([]*ast.UserSpec),
			TLSOptions:            $5.([]*ast.TLSOption),
			ResourceOptions:       $6.([]*ast.ResourceOption),
			PasswordOrLockOptions: $7.([]*ast.PasswordOrLockOption),
		}
	}
|	"ALTER" "USER" IfExists "USER" '(' ')' "IDENTIFIED" "BY" AuthString
	{
sql_ir.LogGrammarCoverage("AlterUserStmt,IfExists")
sql_ir.LogGrammarCoverage("AlterUserStmt,AuthString")


		auth := &ast.AuthOption{
			AuthString:   $9,
			ByAuthString: true,
		}
		$$ = &ast.AlterUserStmt{
			IfExists:    $3.(bool),
			CurrentAuth: auth,
		}
	}


AlterInstanceStmt:
	"ALTER" "INSTANCE" InstanceOption
	{
sql_ir.LogGrammarCoverage("AlterInstanceStmt,InstanceOption")


		$$ = $3.(*ast.AlterInstanceStmt)
	}

InstanceOption:
	"RELOAD" "TLS"
	{


		$$ = &ast.AlterInstanceStmt{
			ReloadTLS: true,
		}
	}
|	"RELOAD" "TLS" "NO" "ROLLBACK" "ON" "ERROR"
	{


		$$ = &ast.AlterInstanceStmt{
			ReloadTLS:         true,
			NoRollbackOnError: true,
		}
	}

UserSpec:
	Username AuthOption
	{
sql_ir.LogGrammarCoverage("UserSpec,Username")
sql_ir.LogGrammarCoverage("UserSpec,AuthOption")


		userSpec := &ast.UserSpec{
			User: $1.(*auth.UserIdentity),
		}
		if $2 != nil {
			userSpec.AuthOpt = $2.(*ast.AuthOption)
		}
		$$ = userSpec
	}

UserSpecList:
	UserSpec
	{
sql_ir.LogGrammarCoverage("UserSpecList,UserSpec")


		$$ = []*ast.UserSpec{$1.(*ast.UserSpec)}
	}
|	UserSpecList ',' UserSpec
	{
sql_ir.LogGrammarCoverage("UserSpecList,UserSpecList")
sql_ir.LogGrammarCoverage("UserSpecList,UserSpec")


		$$ = append($1.([]*ast.UserSpec), $3.(*ast.UserSpec))
	}

ConnectionOptions:
	{


		l := []*ast.ResourceOption{}
		$$ = l
	}
|	"WITH" ConnectionOptionList
	{
sql_ir.LogGrammarCoverage("ConnectionOptions,ConnectionOptionList")


		$$ = $2
		yylex.AppendError(yylex.Errorf("TiDB does not support WITH ConnectionOptions now, they would be parsed but ignored."))
		parser.lastErrorAsWarn()
	}

ConnectionOptionList:
	ConnectionOption
	{
sql_ir.LogGrammarCoverage("ConnectionOptionList,ConnectionOption")


		$$ = []*ast.ResourceOption{$1.(*ast.ResourceOption)}
	}
|	ConnectionOptionList ConnectionOption
	{
sql_ir.LogGrammarCoverage("ConnectionOptionList,ConnectionOptionList")
sql_ir.LogGrammarCoverage("ConnectionOptionList,ConnectionOption")


		l := $1.([]*ast.ResourceOption)
		l = append(l, $2.(*ast.ResourceOption))
		$$ = l
	}

ConnectionOption:
	"MAX_QUERIES_PER_HOUR" Int64Num
	{
sql_ir.LogGrammarCoverage("ConnectionOption,Int64Num")


		$$ = &ast.ResourceOption{
			Type:  ast.MaxQueriesPerHour,
			Count: $2.(int64),
		}
	}
|	"MAX_UPDATES_PER_HOUR" Int64Num
	{
sql_ir.LogGrammarCoverage("ConnectionOption,Int64Num")


		$$ = &ast.ResourceOption{
			Type:  ast.MaxUpdatesPerHour,
			Count: $2.(int64),
		}
	}
|	"MAX_CONNECTIONS_PER_HOUR" Int64Num
	{
sql_ir.LogGrammarCoverage("ConnectionOption,Int64Num")


		$$ = &ast.ResourceOption{
			Type:  ast.MaxConnectionsPerHour,
			Count: $2.(int64),
		}
	}
|	"MAX_USER_CONNECTIONS" Int64Num
	{
sql_ir.LogGrammarCoverage("ConnectionOption,Int64Num")


		$$ = &ast.ResourceOption{
			Type:  ast.MaxUserConnections,
			Count: $2.(int64),
		}
	}

RequireClauseOpt:
	{


		$$ = []*ast.TLSOption{}
	}
|	RequireClause

{
sql_ir.LogGrammarCoverage("RequireClauseOpt,RequireClause")

}
RequireClause:
	"REQUIRE" "NONE"
	{


		t := &ast.TLSOption{
			Type: ast.TlsNone,
		}
		$$ = []*ast.TLSOption{t}
	}
|	"REQUIRE" "SSL"
	{


		t := &ast.TLSOption{
			Type: ast.Ssl,
		}
		$$ = []*ast.TLSOption{t}
	}
|	"REQUIRE" "X509"
	{


		t := &ast.TLSOption{
			Type: ast.X509,
		}
		$$ = []*ast.TLSOption{t}
	}
|	"REQUIRE" RequireList
	{
sql_ir.LogGrammarCoverage("RequireClause,RequireList")


		$$ = $2
	}

RequireList:
	RequireListElement
	{
sql_ir.LogGrammarCoverage("RequireList,RequireListElement")


		$$ = []*ast.TLSOption{$1.(*ast.TLSOption)}
	}
|	RequireList "AND" RequireListElement
	{
sql_ir.LogGrammarCoverage("RequireList,RequireList")
sql_ir.LogGrammarCoverage("RequireList,RequireListElement")


		l := $1.([]*ast.TLSOption)
		l = append(l, $3.(*ast.TLSOption))
		$$ = l
	}
|	RequireList RequireListElement
	{
sql_ir.LogGrammarCoverage("RequireList,RequireList")
sql_ir.LogGrammarCoverage("RequireList,RequireListElement")


		l := $1.([]*ast.TLSOption)
		l = append(l, $2.(*ast.TLSOption))
		$$ = l
	}

RequireListElement:
	"ISSUER" stringLit
	{
sql_ir.LogGrammarCoverage("RequireListElement,stringLit")


		$$ = &ast.TLSOption{
			Type:  ast.Issuer,
			Value: $2,
		}
	}
|	"SUBJECT" stringLit
	{
sql_ir.LogGrammarCoverage("RequireListElement,stringLit")


		$$ = &ast.TLSOption{
			Type:  ast.Subject,
			Value: $2,
		}
	}
|	"CIPHER" stringLit
	{
sql_ir.LogGrammarCoverage("RequireListElement,stringLit")


		$$ = &ast.TLSOption{
			Type:  ast.Cipher,
			Value: $2,
		}
	}
|	"SAN" stringLit
	{
sql_ir.LogGrammarCoverage("RequireListElement,stringLit")


		$$ = &ast.TLSOption{
			Type:  ast.SAN,
			Value: $2,
		}
	}

PasswordOrLockOptions:
	{


		l := []*ast.PasswordOrLockOption{}
		$$ = l
	}
|	PasswordOrLockOptionList
	{
sql_ir.LogGrammarCoverage("PasswordOrLockOptions,PasswordOrLockOptionList")


		$$ = $1
		yylex.AppendError(yylex.Errorf("TiDB does not support PASSWORD EXPIRE and ACCOUNT LOCK now, they would be parsed but ignored."))
		parser.lastErrorAsWarn()
	}

PasswordOrLockOptionList:
	PasswordOrLockOption
	{
sql_ir.LogGrammarCoverage("PasswordOrLockOptionList,PasswordOrLockOption")


		$$ = []*ast.PasswordOrLockOption{$1.(*ast.PasswordOrLockOption)}
	}
|	PasswordOrLockOptionList PasswordOrLockOption
	{
sql_ir.LogGrammarCoverage("PasswordOrLockOptionList,PasswordOrLockOptionList")
sql_ir.LogGrammarCoverage("PasswordOrLockOptionList,PasswordOrLockOption")


		l := $1.([]*ast.PasswordOrLockOption)
		l = append(l, $2.(*ast.PasswordOrLockOption))
		$$ = l
	}

PasswordOrLockOption:
	"ACCOUNT" "UNLOCK"
	{


		$$ = &ast.PasswordOrLockOption{
			Type: ast.Unlock,
		}
	}
|	"ACCOUNT" "LOCK"
	{


		$$ = &ast.PasswordOrLockOption{
			Type: ast.Lock,
		}
	}
|	PasswordExpire
	{
sql_ir.LogGrammarCoverage("PasswordOrLockOption,PasswordExpire")


		$$ = &ast.PasswordOrLockOption{
			Type: ast.PasswordExpire,
		}
	}
|	PasswordExpire "INTERVAL" Int64Num "DAY"
	{
sql_ir.LogGrammarCoverage("PasswordOrLockOption,PasswordExpire")
sql_ir.LogGrammarCoverage("PasswordOrLockOption,Int64Num")


		$$ = &ast.PasswordOrLockOption{
			Type:  ast.PasswordExpireInterval,
			Count: $3.(int64),
		}
	}
|	PasswordExpire "NEVER"
	{
sql_ir.LogGrammarCoverage("PasswordOrLockOption,PasswordExpire")


		$$ = &ast.PasswordOrLockOption{
			Type: ast.PasswordExpireNever,
		}
	}
|	PasswordExpire "DEFAULT"
	{
sql_ir.LogGrammarCoverage("PasswordOrLockOption,PasswordExpire")


		$$ = &ast.PasswordOrLockOption{
			Type: ast.PasswordExpireDefault,
		}
	}

PasswordExpire:
	"PASSWORD" "EXPIRE" ClearPasswordExpireOptions
	{
sql_ir.LogGrammarCoverage("PasswordExpire,ClearPasswordExpireOptions")


		$$ = nil
	}

ClearPasswordExpireOptions:
	{


		$$ = nil
	}

AuthOption:
	{


		$$ = nil
	}
|	"IDENTIFIED" "BY" AuthString
	{
sql_ir.LogGrammarCoverage("AuthOption,AuthString")


		$$ = &ast.AuthOption{
			AuthString:   $3,
			ByAuthString: true,
		}
	}
|	"IDENTIFIED" "WITH" AuthPlugin
	{
sql_ir.LogGrammarCoverage("AuthOption,AuthPlugin")


		$$ = &ast.AuthOption{
			AuthPlugin: $3,
		}
	}
|	"IDENTIFIED" "WITH" AuthPlugin "BY" AuthString
	{
sql_ir.LogGrammarCoverage("AuthOption,AuthPlugin")
sql_ir.LogGrammarCoverage("AuthOption,AuthString")


		$$ = &ast.AuthOption{
			AuthPlugin:   $3,
			AuthString:   $5,
			ByAuthString: true,
		}
	}
|	"IDENTIFIED" "WITH" AuthPlugin "AS" HashString
	{
sql_ir.LogGrammarCoverage("AuthOption,AuthPlugin")
sql_ir.LogGrammarCoverage("AuthOption,HashString")


		$$ = &ast.AuthOption{
			AuthPlugin: $3,
			HashString: $5,
		}
	}
|	"IDENTIFIED" "BY" "PASSWORD" HashString
	{
sql_ir.LogGrammarCoverage("AuthOption,HashString")


		$$ = &ast.AuthOption{
			AuthPlugin: mysql.AuthNativePassword,
			HashString: $4,
		}
	}

AuthPlugin:
	StringName

{
sql_ir.LogGrammarCoverage("AuthPlugin,StringName")

}
HashString:
	stringLit
{
sql_ir.LogGrammarCoverage("HashString,stringLit")

}
|	hexLit
	{


		$$ = $1.(ast.BinaryLiteral).ToString()
	}

RoleSpec:
	Rolename
	{
sql_ir.LogGrammarCoverage("RoleSpec,Rolename")


		role := $1.(*auth.RoleIdentity)
		roleSpec := &ast.UserSpec{
			User: &auth.UserIdentity{
				Username: role.Username,
				Hostname: role.Hostname,
			},
			IsRole: true,
		}
		$$ = roleSpec
	}

RoleSpecList:
	RoleSpec
	{
sql_ir.LogGrammarCoverage("RoleSpecList,RoleSpec")


		$$ = []*ast.UserSpec{$1.(*ast.UserSpec)}
	}
|	RoleSpecList ',' RoleSpec
	{
sql_ir.LogGrammarCoverage("RoleSpecList,RoleSpecList")
sql_ir.LogGrammarCoverage("RoleSpecList,RoleSpec")


		$$ = append($1.([]*ast.UserSpec), $3.(*ast.UserSpec))
	}

BindableStmt:
	SetOprStmt
{
sql_ir.LogGrammarCoverage("BindableStmt,SetOprStmt")

}
|	SelectStmt
{
sql_ir.LogGrammarCoverage("BindableStmt,SelectStmt")

}
|	SelectStmtWithClause
{
sql_ir.LogGrammarCoverage("BindableStmt,SelectStmtWithClause")

}
|	SubSelect
	{
sql_ir.LogGrammarCoverage("BindableStmt,SubSelect")


		var sel ast.StmtNode
		switch x := $1.(*ast.SubqueryExpr).Query.(type) {
		case *ast.SelectStmt:
			x.IsInBraces = true
			sel = x
		case *ast.SetOprStmt:
			x.IsInBraces = true
			sel = x
		}
		$$ = sel
	}
|	UpdateStmt
{
sql_ir.LogGrammarCoverage("BindableStmt,UpdateStmt")

}
|	DeleteWithoutUsingStmt
{
sql_ir.LogGrammarCoverage("BindableStmt,DeleteWithoutUsingStmt")

}
|	InsertIntoStmt
{
sql_ir.LogGrammarCoverage("BindableStmt,InsertIntoStmt")

}
|	ReplaceIntoStmt


{
sql_ir.LogGrammarCoverage("BindableStmt,ReplaceIntoStmt")

}
CreateBindingStmt:
	"CREATE" GlobalScope "BINDING" "FOR" BindableStmt "USING" BindableStmt
	{
sql_ir.LogGrammarCoverage("CreateBindingStmt,GlobalScope")
sql_ir.LogGrammarCoverage("CreateBindingStmt,BindableStmt")
sql_ir.LogGrammarCoverage("CreateBindingStmt,BindableStmt")


		startOffset := parser.startOffset(&yyS[yypt-2])
		endOffset := parser.startOffset(&yyS[yypt-1])
		originStmt := $5
		originStmt.SetText(parser.lexer.client, strings.TrimSpace(parser.src[startOffset:endOffset]))

		startOffset = parser.startOffset(&yyS[yypt])
		hintedStmt := $7
		hintedStmt.SetText(parser.lexer.client, strings.TrimSpace(parser.src[startOffset:]))

		x := &ast.CreateBindingStmt{
			OriginNode:  originStmt,
			HintedNode:  hintedStmt,
			GlobalScope: $2.(bool),
		}

		$$ = x
	}


DropBindingStmt:
	"DROP" GlobalScope "BINDING" "FOR" BindableStmt
	{
sql_ir.LogGrammarCoverage("DropBindingStmt,GlobalScope")
sql_ir.LogGrammarCoverage("DropBindingStmt,BindableStmt")


		startOffset := parser.startOffset(&yyS[yypt])
		originStmt := $5
		originStmt.SetText(parser.lexer.client, strings.TrimSpace(parser.src[startOffset:]))

		x := &ast.DropBindingStmt{
			OriginNode:  originStmt,
			GlobalScope: $2.(bool),
		}

		$$ = x
	}
|	"DROP" GlobalScope "BINDING" "FOR" BindableStmt "USING" BindableStmt
	{
sql_ir.LogGrammarCoverage("DropBindingStmt,GlobalScope")
sql_ir.LogGrammarCoverage("DropBindingStmt,BindableStmt")
sql_ir.LogGrammarCoverage("DropBindingStmt,BindableStmt")


		startOffset := parser.startOffset(&yyS[yypt-2])
		endOffset := parser.startOffset(&yyS[yypt-1])
		originStmt := $5
		originStmt.SetText(parser.lexer.client, strings.TrimSpace(parser.src[startOffset:endOffset]))

		startOffset = parser.startOffset(&yyS[yypt])
		hintedStmt := $7
		hintedStmt.SetText(parser.lexer.client, strings.TrimSpace(parser.src[startOffset:]))

		x := &ast.DropBindingStmt{
			OriginNode:  originStmt,
			HintedNode:  hintedStmt,
			GlobalScope: $2.(bool),
		}

		$$ = x
	}

SetBindingStmt:
	"SET" "BINDING" BindingStatusType "FOR" BindableStmt
	{
sql_ir.LogGrammarCoverage("SetBindingStmt,BindingStatusType")
sql_ir.LogGrammarCoverage("SetBindingStmt,BindableStmt")


		startOffset := parser.startOffset(&yyS[yypt])
		originStmt := $5
		originStmt.SetText(parser.lexer.client, strings.TrimSpace(parser.src[startOffset:]))

		x := &ast.SetBindingStmt{
			BindingStatusType: $3.(ast.BindingStatusType),
			OriginNode:        originStmt,
		}

		$$ = x
	}
|	"SET" "BINDING" BindingStatusType "FOR" BindableStmt "USING" BindableStmt
	{
sql_ir.LogGrammarCoverage("SetBindingStmt,BindingStatusType")
sql_ir.LogGrammarCoverage("SetBindingStmt,BindableStmt")
sql_ir.LogGrammarCoverage("SetBindingStmt,BindableStmt")


		startOffset := parser.startOffset(&yyS[yypt-2])
		endOffset := parser.startOffset(&yyS[yypt-1])
		originStmt := $5
		originStmt.SetText(parser.lexer.client, strings.TrimSpace(parser.src[startOffset:endOffset]))

		startOffset = parser.startOffset(&yyS[yypt])
		hintedStmt := $7
		hintedStmt.SetText(parser.lexer.client, strings.TrimSpace(parser.src[startOffset:]))

		x := &ast.SetBindingStmt{
			BindingStatusType: $3.(ast.BindingStatusType),
			OriginNode:        originStmt,
			HintedNode:        hintedStmt,
		}

		$$ = x
	}


GrantStmt:
	"GRANT" RoleOrPrivElemList "ON" ObjectType PrivLevel "TO" UserSpecList RequireClauseOpt WithGrantOptionOpt
	{
sql_ir.LogGrammarCoverage("GrantStmt,RoleOrPrivElemList")
sql_ir.LogGrammarCoverage("GrantStmt,ObjectType")
sql_ir.LogGrammarCoverage("GrantStmt,PrivLevel")
sql_ir.LogGrammarCoverage("GrantStmt,UserSpecList")
sql_ir.LogGrammarCoverage("GrantStmt,RequireClauseOpt")
sql_ir.LogGrammarCoverage("GrantStmt,WithGrantOptionOpt")


		p, err := convertToPriv($2.([]*ast.RoleOrPriv))
		if err != nil {
			yylex.AppendError(err)
			return 1
		}
		$$ = &ast.GrantStmt{
			Privs:      p,
			ObjectType: $4.(ast.ObjectTypeType),
			Level:      $5.(*ast.GrantLevel),
			Users:      $7.([]*ast.UserSpec),
			TLSOptions: $8.([]*ast.TLSOption),
			WithGrant:  $9.(bool),
		}
	}

GrantProxyStmt:
	"GRANT" "PROXY" "ON" Username "TO" UsernameList WithGrantOptionOpt
	{
sql_ir.LogGrammarCoverage("GrantProxyStmt,Username")
sql_ir.LogGrammarCoverage("GrantProxyStmt,UsernameList")
sql_ir.LogGrammarCoverage("GrantProxyStmt,WithGrantOptionOpt")


		$$ = &ast.GrantProxyStmt{
			LocalUser:     $4.(*auth.UserIdentity),
			ExternalUsers: $6.([]*auth.UserIdentity),
			WithGrant:     $7.(bool),
		}
	}

GrantRoleStmt:
	"GRANT" RoleOrPrivElemList "TO" UsernameList
	{
sql_ir.LogGrammarCoverage("GrantRoleStmt,RoleOrPrivElemList")
sql_ir.LogGrammarCoverage("GrantRoleStmt,UsernameList")


		r, err := convertToRole($2.([]*ast.RoleOrPriv))
		if err != nil {
			yylex.AppendError(err)
			return 1
		}
		$$ = &ast.GrantRoleStmt{
			Roles: r,
			Users: $4.([]*auth.UserIdentity),
		}
	}

WithGrantOptionOpt:
	{


		$$ = false
	}
|	"WITH" "GRANT" "OPTION"
	{


		$$ = true
	}
|	"WITH" "MAX_QUERIES_PER_HOUR" NUM
	{
sql_ir.LogGrammarCoverage("WithGrantOptionOpt,NUM")


		$$ = false
	}
|	"WITH" "MAX_UPDATES_PER_HOUR" NUM
	{
sql_ir.LogGrammarCoverage("WithGrantOptionOpt,NUM")


		$$ = false
	}
|	"WITH" "MAX_CONNECTIONS_PER_HOUR" NUM
	{
sql_ir.LogGrammarCoverage("WithGrantOptionOpt,NUM")


		$$ = false
	}
|	"WITH" "MAX_USER_CONNECTIONS" NUM
	{
sql_ir.LogGrammarCoverage("WithGrantOptionOpt,NUM")


		$$ = false
	}

ExtendedPriv:
	identifier
	{


		$$ = []string{$1}
	}
|	ExtendedPriv identifier
	{
sql_ir.LogGrammarCoverage("ExtendedPriv,ExtendedPriv")


		$$ = append($1.([]string), $2)
	}

RoleOrPrivElem:
	PrivElem
	{
sql_ir.LogGrammarCoverage("RoleOrPrivElem,PrivElem")


		$$ = &ast.RoleOrPriv{
			Node: $1,
		}
	}
|	RolenameWithoutIdent
	{
sql_ir.LogGrammarCoverage("RoleOrPrivElem,RolenameWithoutIdent")


		$$ = &ast.RoleOrPriv{
			Node: $1,
		}
	}
|	ExtendedPriv
	{
sql_ir.LogGrammarCoverage("RoleOrPrivElem,ExtendedPriv")


		$$ = &ast.RoleOrPriv{
			Symbols: strings.Join($1.([]string), " "),
		}
	}
|	"LOAD" "FROM" "S3"
	{


		$$ = &ast.RoleOrPriv{
			Symbols: "LOAD FROM S3",
		}
	}
|	"SELECT" "INTO" "S3"
	{


		$$ = &ast.RoleOrPriv{
			Symbols: "SELECT INTO S3",
		}
	}

RoleOrPrivElemList:
	RoleOrPrivElem
	{
sql_ir.LogGrammarCoverage("RoleOrPrivElemList,RoleOrPrivElem")


		$$ = []*ast.RoleOrPriv{$1.(*ast.RoleOrPriv)}
	}
|	RoleOrPrivElemList ',' RoleOrPrivElem
	{
sql_ir.LogGrammarCoverage("RoleOrPrivElemList,RoleOrPrivElemList")
sql_ir.LogGrammarCoverage("RoleOrPrivElemList,RoleOrPrivElem")


		$$ = append($1.([]*ast.RoleOrPriv), $3.(*ast.RoleOrPriv))
	}

PrivElem:
	PrivType
	{
sql_ir.LogGrammarCoverage("PrivElem,PrivType")


		$$ = &ast.PrivElem{
			Priv: $1.(mysql.PrivilegeType),
		}
	}
|	PrivType '(' ColumnNameList ')'
	{
sql_ir.LogGrammarCoverage("PrivElem,PrivType")
sql_ir.LogGrammarCoverage("PrivElem,ColumnNameList")


		$$ = &ast.PrivElem{
			Priv: $1.(mysql.PrivilegeType),
			Cols: $3.([]*ast.ColumnName),
		}
	}

PrivType:
	"ALL"
	{


		$$ = mysql.AllPriv
	}
|	"ALL" "PRIVILEGES"
	{


		$$ = mysql.AllPriv
	}
|	"ALTER"
	{


		$$ = mysql.AlterPriv
	}
|	"CREATE"
	{


		$$ = mysql.CreatePriv
	}
|	"CREATE" "USER"
	{


		$$ = mysql.CreateUserPriv
	}
|	"CREATE" "TABLESPACE"
	{


		$$ = mysql.CreateTablespacePriv
	}
|	"TRIGGER"
	{


		$$ = mysql.TriggerPriv
	}
|	"DELETE"
	{


		$$ = mysql.DeletePriv
	}
|	"DROP"
	{


		$$ = mysql.DropPriv
	}
|	"PROCESS"
	{


		$$ = mysql.ProcessPriv
	}
|	"EXECUTE"
	{


		$$ = mysql.ExecutePriv
	}
|	"INDEX"
	{


		$$ = mysql.IndexPriv
	}
|	"INSERT"
	{


		$$ = mysql.InsertPriv
	}
|	"SELECT"
	{


		$$ = mysql.SelectPriv
	}
|	"SUPER"
	{


		$$ = mysql.SuperPriv
	}
|	"SHOW" "DATABASES"
	{


		$$ = mysql.ShowDBPriv
	}
|	"UPDATE"
	{


		$$ = mysql.UpdatePriv
	}
|	"GRANT" "OPTION"
	{


		$$ = mysql.GrantPriv
	}
|	"REFERENCES"
	{


		$$ = mysql.ReferencesPriv
	}
|	"REPLICATION" "SLAVE"
	{


		$$ = mysql.ReplicationSlavePriv
	}
|	"REPLICATION" "CLIENT"
	{


		$$ = mysql.ReplicationClientPriv
	}
|	"USAGE"
	{


		$$ = mysql.UsagePriv
	}
|	"RELOAD"
	{


		$$ = mysql.ReloadPriv
	}
|	"FILE"
	{


		$$ = mysql.FilePriv
	}
|	"CONFIG"
	{


		$$ = mysql.ConfigPriv
	}
|	"CREATE" "TEMPORARY" "TABLES"
	{


		$$ = mysql.CreateTMPTablePriv
	}
|	"LOCK" "TABLES"
	{


		$$ = mysql.LockTablesPriv
	}
|	"CREATE" "VIEW"
	{


		$$ = mysql.CreateViewPriv
	}
|	"SHOW" "VIEW"
	{


		$$ = mysql.ShowViewPriv
	}
|	"CREATE" "ROLE"
	{


		$$ = mysql.CreateRolePriv
	}
|	"DROP" "ROLE"
	{


		$$ = mysql.DropRolePriv
	}
|	"CREATE" "ROUTINE"
	{


		$$ = mysql.CreateRoutinePriv
	}
|	"ALTER" "ROUTINE"
	{


		$$ = mysql.AlterRoutinePriv
	}
|	"EVENT"
	{


		$$ = mysql.EventPriv
	}
|	"SHUTDOWN"
	{


		$$ = mysql.ShutdownPriv
	}

ObjectType:
	%prec lowerThanFunction
	{


		$$ = ast.ObjectTypeNone
	}
|	"TABLE"
	{


		$$ = ast.ObjectTypeTable
	}
|	"FUNCTION"
	{


		$$ = ast.ObjectTypeFunction
	}
|	"PROCEDURE"
	{


		$$ = ast.ObjectTypeProcedure
	}

PrivLevel:
	'*'
	{


		$$ = &ast.GrantLevel{
			Level: ast.GrantLevelDB,
		}
	}
|	'*' '.' '*'
	{


		$$ = &ast.GrantLevel{
			Level: ast.GrantLevelGlobal,
		}
	}
|	Identifier '.' '*'
	{
sql_ir.LogGrammarCoverage("PrivLevel,Identifier")


		$$ = &ast.GrantLevel{
			Level:  ast.GrantLevelDB,
			DBName: $1,
		}
	}
|	Identifier '.' Identifier
	{
sql_ir.LogGrammarCoverage("PrivLevel,Identifier")
sql_ir.LogGrammarCoverage("PrivLevel,Identifier")


		$$ = &ast.GrantLevel{
			Level:     ast.GrantLevelTable,
			DBName:    $1,
			TableName: $3,
		}
	}
|	Identifier
	{
sql_ir.LogGrammarCoverage("PrivLevel,Identifier")


		$$ = &ast.GrantLevel{
			Level:     ast.GrantLevelTable,
			TableName: $1,
		}
	}


RevokeStmt:
	"REVOKE" RoleOrPrivElemList "ON" ObjectType PrivLevel "FROM" UserSpecList
	{
sql_ir.LogGrammarCoverage("RevokeStmt,RoleOrPrivElemList")
sql_ir.LogGrammarCoverage("RevokeStmt,ObjectType")
sql_ir.LogGrammarCoverage("RevokeStmt,PrivLevel")
sql_ir.LogGrammarCoverage("RevokeStmt,UserSpecList")


		p, err := convertToPriv($2.([]*ast.RoleOrPriv))
		if err != nil {
			yylex.AppendError(err)
			return 1
		}
		$$ = &ast.RevokeStmt{
			Privs:      p,
			ObjectType: $4.(ast.ObjectTypeType),
			Level:      $5.(*ast.GrantLevel),
			Users:      $7.([]*ast.UserSpec),
		}
	}

RevokeRoleStmt:
	"REVOKE" RoleOrPrivElemList "FROM" UsernameList
	{
sql_ir.LogGrammarCoverage("RevokeRoleStmt,RoleOrPrivElemList")
sql_ir.LogGrammarCoverage("RevokeRoleStmt,UsernameList")


		// MySQL has special syntax for REVOKE ALL [PRIVILEGES], GRANT OPTION
		// which uses the RevokeRoleStmt syntax but is of type RevokeStmt.
		// It is documented at https://dev.mysql.com/doc/refman/5.7/en/revoke.html
		// as the "second syntax" for REVOKE. It is only valid if *both*
		// ALL PRIVILEGES + GRANT OPTION are specified in that order.
		if isRevokeAllGrant($2.([]*ast.RoleOrPriv)) {
			var users []*ast.UserSpec
			for _, u := range $4.([]*auth.UserIdentity) {
				users = append(users, &ast.UserSpec{
					User: u,
				})
			}
			$$ = &ast.RevokeStmt{
				Privs:      []*ast.PrivElem{{Priv: mysql.AllPriv}, {Priv: mysql.GrantPriv}},
				ObjectType: ast.ObjectTypeNone,
				Level:      &ast.GrantLevel{Level: ast.GrantLevelGlobal},
				Users:      users,
			}
		} else {
			r, err := convertToRole($2.([]*ast.RoleOrPriv))
			if err != nil {
				yylex.AppendError(err)
				return 1
			}
			$$ = &ast.RevokeRoleStmt{
				Roles: r,
				Users: $4.([]*auth.UserIdentity),
			}
		}
	}


LoadDataStmt:
	"LOAD" "DATA" LocalOpt "INFILE" stringLit DuplicateOpt "INTO" "TABLE" TableName CharsetOpt Fields Lines IgnoreLines ColumnNameOrUserVarListOptWithBrackets LoadDataSetSpecOpt
	{
sql_ir.LogGrammarCoverage("LoadDataStmt,LocalOpt")
sql_ir.LogGrammarCoverage("LoadDataStmt,stringLit")
sql_ir.LogGrammarCoverage("LoadDataStmt,DuplicateOpt")
sql_ir.LogGrammarCoverage("LoadDataStmt,TableName")
sql_ir.LogGrammarCoverage("LoadDataStmt,CharsetOpt")
sql_ir.LogGrammarCoverage("LoadDataStmt,Fields")
sql_ir.LogGrammarCoverage("LoadDataStmt,Lines")
sql_ir.LogGrammarCoverage("LoadDataStmt,IgnoreLines")
sql_ir.LogGrammarCoverage("LoadDataStmt,ColumnNameOrUserVarListOptWithBrackets")
sql_ir.LogGrammarCoverage("LoadDataStmt,LoadDataSetSpecOpt")


		x := &ast.LoadDataStmt{
			Path:               $5,
			OnDuplicate:        $6.(ast.OnDuplicateKeyHandlingType),
			Table:              $9.(*ast.TableName),
			ColumnsAndUserVars: $14.([]*ast.ColumnNameOrUserVar),
			IgnoreLines:        $13.(uint64),
		}
		if $3 != nil {
			x.IsLocal = true
			// See https://dev.mysql.com/doc/refman/5.7/en/load-data.html#load-data-duplicate-key-handling
			// If you do not specify IGNORE or REPLACE modifier , then we set default behavior to IGNORE when LOCAL modifier is specified
			if x.OnDuplicate == ast.OnDuplicateKeyHandlingError {
				x.OnDuplicate = ast.OnDuplicateKeyHandlingIgnore
			}
		}
		if $11 != nil {
			x.FieldsInfo = $11.(*ast.FieldsClause)
		}
		if $12 != nil {
			x.LinesInfo = $12.(*ast.LinesClause)
		}
		if $15 != nil {
			x.ColumnAssignments = $15.([]*ast.Assignment)
		}
		columns := []*ast.ColumnName{}
		for _, v := range x.ColumnsAndUserVars {
			if v.ColumnName != nil {
				columns = append(columns, v.ColumnName)
			}
		}
		x.Columns = columns

		$$ = x
	}

IgnoreLines:
	{


		$$ = uint64(0)
	}
|	"IGNORE" NUM "LINES"
	{
sql_ir.LogGrammarCoverage("IgnoreLines,NUM")


		$$ = getUint64FromNUM($2)
	}

CharsetOpt:
	{

}
|	"CHARACTER" "SET" CharsetName

{
sql_ir.LogGrammarCoverage("CharsetOpt,CharsetName")

}
LocalOpt:
	{


		$$ = nil
	}
|	"LOCAL"
	{


		$$ = $1
	}

Fields:
	{


		escape := "\\"
		$$ = &ast.FieldsClause{
			Terminated: "\t",
			Escaped:    escape[0],
		}
	}
|	FieldsOrColumns FieldItemList
	{
sql_ir.LogGrammarCoverage("Fields,FieldsOrColumns")
sql_ir.LogGrammarCoverage("Fields,FieldItemList")


		fieldsClause := &ast.FieldsClause{
			Terminated: "\t",
			Escaped:    []byte("\\")[0],
		}
		fieldItems := $2.([]*ast.FieldItem)
		for _, item := range fieldItems {
			switch item.Type {
			case ast.Terminated:
				fieldsClause.Terminated = item.Value
			case ast.Enclosed:
				var enclosed byte
				if len(item.Value) > 0 {
					enclosed = item.Value[0]
				}
				fieldsClause.Enclosed = enclosed
				if item.OptEnclosed {
					fieldsClause.OptEnclosed = true
				}
			case ast.Escaped:
				var escaped byte
				if len(item.Value) > 0 {
					escaped = item.Value[0]
				}
				fieldsClause.Escaped = escaped
			}
		}
		$$ = fieldsClause
	}

FieldsOrColumns:
	"FIELDS"
{

}
|	"COLUMNS"

{

}
FieldItemList:
	FieldItemList FieldItem
	{
sql_ir.LogGrammarCoverage("FieldItemList,FieldItemList")
sql_ir.LogGrammarCoverage("FieldItemList,FieldItem")


		fieldItems := $1.([]*ast.FieldItem)
		$$ = append(fieldItems, $2.(*ast.FieldItem))
	}
|	FieldItem
	{
sql_ir.LogGrammarCoverage("FieldItemList,FieldItem")


		fieldItems := make([]*ast.FieldItem, 1, 1)
		fieldItems[0] = $1.(*ast.FieldItem)
		$$ = fieldItems
	}

FieldItem:
	"TERMINATED" "BY" FieldTerminator
	{
sql_ir.LogGrammarCoverage("FieldItem,FieldTerminator")


		$$ = &ast.FieldItem{
			Type:  ast.Terminated,
			Value: $3,
		}
	}
|	"OPTIONALLY" "ENCLOSED" "BY" FieldTerminator
	{
sql_ir.LogGrammarCoverage("FieldItem,FieldTerminator")


		str := $4
		if str != "\\" && len(str) > 1 {
			yylex.AppendError(ErrWrongFieldTerminators.GenWithStackByArgs())
			return 1
		}
		$$ = &ast.FieldItem{
			Type:        ast.Enclosed,
			Value:       str,
			OptEnclosed: true,
		}
	}
|	"ENCLOSED" "BY" FieldTerminator
	{
sql_ir.LogGrammarCoverage("FieldItem,FieldTerminator")


		str := $3
		if str != "\\" && len(str) > 1 {
			yylex.AppendError(ErrWrongFieldTerminators.GenWithStackByArgs())
			return 1
		}
		$$ = &ast.FieldItem{
			Type:  ast.Enclosed,
			Value: str,
		}
	}
|	"ESCAPED" "BY" FieldTerminator
	{
sql_ir.LogGrammarCoverage("FieldItem,FieldTerminator")


		str := $3
		if str != "\\" && len(str) > 1 {
			yylex.AppendError(ErrWrongFieldTerminators.GenWithStackByArgs())
			return 1
		}
		$$ = &ast.FieldItem{
			Type:  ast.Escaped,
			Value: str,
		}
	}

FieldTerminator:
	stringLit
{
sql_ir.LogGrammarCoverage("FieldTerminator,stringLit")

}
|	hexLit
	{


		$$ = $1.(ast.BinaryLiteral).ToString()
	}
|	bitLit
	{


		$$ = $1.(ast.BinaryLiteral).ToString()
	}

Lines:
	{


		$$ = &ast.LinesClause{Terminated: "\n"}
	}
|	"LINES" Starting LinesTerminated
	{
sql_ir.LogGrammarCoverage("Lines,Starting")
sql_ir.LogGrammarCoverage("Lines,LinesTerminated")


		$$ = &ast.LinesClause{Starting: $2, Terminated: $3}
	}

Starting:
	{


		$$ = ""
	}
|	"STARTING" "BY" FieldTerminator
	{
sql_ir.LogGrammarCoverage("Starting,FieldTerminator")


		$$ = $3
	}

LinesTerminated:
	{


		$$ = "\n"
	}
|	"TERMINATED" "BY" FieldTerminator
	{
sql_ir.LogGrammarCoverage("LinesTerminated,FieldTerminator")


		$$ = $3
	}

LoadDataSetSpecOpt:
	{


		$$ = nil
	}
|	"SET" LoadDataSetList
	{
sql_ir.LogGrammarCoverage("LoadDataSetSpecOpt,LoadDataSetList")


		$$ = $2
	}

LoadDataSetList:
	LoadDataSetList ',' LoadDataSetItem
	{
sql_ir.LogGrammarCoverage("LoadDataSetList,LoadDataSetList")
sql_ir.LogGrammarCoverage("LoadDataSetList,LoadDataSetItem")


		l := $1.([]*ast.Assignment)
		$$ = append(l, $3.(*ast.Assignment))
	}
|	LoadDataSetItem
	{
sql_ir.LogGrammarCoverage("LoadDataSetList,LoadDataSetItem")


		$$ = []*ast.Assignment{$1.(*ast.Assignment)}
	}

LoadDataSetItem:
	SimpleIdent "=" ExprOrDefault
	{
sql_ir.LogGrammarCoverage("LoadDataSetItem,SimpleIdent")
sql_ir.LogGrammarCoverage("LoadDataSetItem,ExprOrDefault")


		$$ = &ast.Assignment{
			Column: $1.(*ast.ColumnNameExpr).Name,
			Expr:   $3,
		}
	}


UnlockTablesStmt:
	"UNLOCK" TablesTerminalSym
	{
sql_ir.LogGrammarCoverage("UnlockTablesStmt,TablesTerminalSym")


		$$ = &ast.UnlockTablesStmt{}
	}

LockTablesStmt:
	"LOCK" TablesTerminalSym TableLockList
	{
sql_ir.LogGrammarCoverage("LockTablesStmt,TablesTerminalSym")
sql_ir.LogGrammarCoverage("LockTablesStmt,TableLockList")


		$$ = &ast.LockTablesStmt{
			TableLocks: $3.([]ast.TableLock),
		}
	}

TablesTerminalSym:
	"TABLES"
{

}
|	"TABLE"

{

}
TableLock:
	TableName LockType
	{
sql_ir.LogGrammarCoverage("TableLock,TableName")
sql_ir.LogGrammarCoverage("TableLock,LockType")


		$$ = ast.TableLock{
			Table: $1.(*ast.TableName),
			Type:  $2.(model.TableLockType),
		}
	}

LockType:
	"READ"
	{


		$$ = model.TableLockRead
	}
|	"READ" "LOCAL"
	{


		$$ = model.TableLockReadLocal
	}
|	"WRITE"
	{


		$$ = model.TableLockWrite
	}
|	"WRITE" "LOCAL"
	{


		$$ = model.TableLockWriteLocal
	}

TableLockList:
	TableLock
	{
sql_ir.LogGrammarCoverage("TableLockList,TableLock")


		$$ = []ast.TableLock{$1.(ast.TableLock)}
	}
|	TableLockList ',' TableLock
	{
sql_ir.LogGrammarCoverage("TableLockList,TableLockList")
sql_ir.LogGrammarCoverage("TableLockList,TableLock")


		$$ = append($1.([]ast.TableLock), $3.(ast.TableLock))
	}


NonTransactionalDeleteStmt:
	"BATCH" OptionalShardColumn "LIMIT" NUM DryRunOptions DeleteFromStmt
	{
sql_ir.LogGrammarCoverage("NonTransactionalDeleteStmt,OptionalShardColumn")
sql_ir.LogGrammarCoverage("NonTransactionalDeleteStmt,NUM")
sql_ir.LogGrammarCoverage("NonTransactionalDeleteStmt,DryRunOptions")
sql_ir.LogGrammarCoverage("NonTransactionalDeleteStmt,DeleteFromStmt")


		$$ = &ast.NonTransactionalDeleteStmt{
			DryRun:      $5.(int),
			ShardColumn: $2.(*ast.ColumnName),
			Limit:       getUint64FromNUM($4),
			DeleteStmt:  $6.(*ast.DeleteStmt),
		}
	}

DryRunOptions:
	{


		$$ = ast.NoDryRun
	}
|	"DRY" "RUN"
	{


		$$ = ast.DryRunSplitDml
	}
|	"DRY" "RUN" "QUERY"
	{


		$$ = ast.DryRunQuery
	}

OptionalShardColumn:
	{


		$$ = (*ast.ColumnName)(nil)
	}
|	"ON" ColumnName
	{
sql_ir.LogGrammarCoverage("OptionalShardColumn,ColumnName")


		$$ = $2.(*ast.ColumnName)
	}


KillStmt:
	KillOrKillTiDB NUM
	{
sql_ir.LogGrammarCoverage("KillStmt,KillOrKillTiDB")
sql_ir.LogGrammarCoverage("KillStmt,NUM")


		$$ = &ast.KillStmt{
			ConnectionID:  getUint64FromNUM($2),
			TiDBExtension: $1.(bool),
		}
	}
|	KillOrKillTiDB "CONNECTION" NUM
	{
sql_ir.LogGrammarCoverage("KillStmt,KillOrKillTiDB")
sql_ir.LogGrammarCoverage("KillStmt,NUM")


		$$ = &ast.KillStmt{
			ConnectionID:  getUint64FromNUM($3),
			TiDBExtension: $1.(bool),
		}
	}
|	KillOrKillTiDB "QUERY" NUM
	{
sql_ir.LogGrammarCoverage("KillStmt,KillOrKillTiDB")
sql_ir.LogGrammarCoverage("KillStmt,NUM")


		$$ = &ast.KillStmt{
			ConnectionID:  getUint64FromNUM($3),
			Query:         true,
			TiDBExtension: $1.(bool),
		}
	}

KillOrKillTiDB:
	"KILL"
	{


		$$ = false
	}

|	"KILL" "TIDB"
	{


		$$ = true
	}

LoadStatsStmt:
	"LOAD" "STATS" stringLit
	{
sql_ir.LogGrammarCoverage("LoadStatsStmt,stringLit")


		$$ = &ast.LoadStatsStmt{
			Path: $3,
		}
	}

DropPolicyStmt:
	"DROP" "PLACEMENT" "POLICY" IfExists PolicyName
	{
sql_ir.LogGrammarCoverage("DropPolicyStmt,IfExists")
sql_ir.LogGrammarCoverage("DropPolicyStmt,PolicyName")


		$$ = &ast.DropPlacementPolicyStmt{
			IfExists:   $4.(bool),
			PolicyName: model.NewCIStr($5),
		}
	}

CreatePolicyStmt:
	"CREATE" OrReplace "PLACEMENT" "POLICY" IfNotExists PolicyName PlacementOptionList
	{
sql_ir.LogGrammarCoverage("CreatePolicyStmt,OrReplace")
sql_ir.LogGrammarCoverage("CreatePolicyStmt,IfNotExists")
sql_ir.LogGrammarCoverage("CreatePolicyStmt,PolicyName")
sql_ir.LogGrammarCoverage("CreatePolicyStmt,PlacementOptionList")


		$$ = &ast.CreatePlacementPolicyStmt{
			OrReplace:        $2.(bool),
			IfNotExists:      $5.(bool),
			PolicyName:       model.NewCIStr($6),
			PlacementOptions: $7.([]*ast.PlacementOption),
		}
	}

AlterPolicyStmt:
	"ALTER" "PLACEMENT" "POLICY" IfExists PolicyName PlacementOptionList
	{
sql_ir.LogGrammarCoverage("AlterPolicyStmt,IfExists")
sql_ir.LogGrammarCoverage("AlterPolicyStmt,PolicyName")
sql_ir.LogGrammarCoverage("AlterPolicyStmt,PlacementOptionList")


		$$ = &ast.AlterPlacementPolicyStmt{
			IfExists:         $4.(bool),
			PolicyName:       model.NewCIStr($5),
			PlacementOptions: $6.([]*ast.PlacementOption),
		}
	}


CreateSequenceStmt:
	"CREATE" "SEQUENCE" IfNotExists TableName CreateSequenceOptionListOpt CreateTableOptionListOpt
	{
sql_ir.LogGrammarCoverage("CreateSequenceStmt,IfNotExists")
sql_ir.LogGrammarCoverage("CreateSequenceStmt,TableName")
sql_ir.LogGrammarCoverage("CreateSequenceStmt,CreateSequenceOptionListOpt")
sql_ir.LogGrammarCoverage("CreateSequenceStmt,CreateTableOptionListOpt")


		$$ = &ast.CreateSequenceStmt{
			IfNotExists: $3.(bool),
			Name:        $4.(*ast.TableName),
			SeqOptions:  $5.([]*ast.SequenceOption),
			TblOptions:  $6.([]*ast.TableOption),
		}
	}

CreateSequenceOptionListOpt:
	{


		$$ = []*ast.SequenceOption{}
	}
|	SequenceOptionList

{
sql_ir.LogGrammarCoverage("CreateSequenceOptionListOpt,SequenceOptionList")

}
SequenceOptionList:
	SequenceOption
	{
sql_ir.LogGrammarCoverage("SequenceOptionList,SequenceOption")


		$$ = []*ast.SequenceOption{$1.(*ast.SequenceOption)}
	}
|	SequenceOptionList SequenceOption
	{
sql_ir.LogGrammarCoverage("SequenceOptionList,SequenceOptionList")
sql_ir.LogGrammarCoverage("SequenceOptionList,SequenceOption")


		$$ = append($1.([]*ast.SequenceOption), $2.(*ast.SequenceOption))
	}

SequenceOption:
	"INCREMENT" EqOpt SignedNum
	{
sql_ir.LogGrammarCoverage("SequenceOption,EqOpt")
sql_ir.LogGrammarCoverage("SequenceOption,SignedNum")


		$$ = &ast.SequenceOption{Tp: ast.SequenceOptionIncrementBy, IntValue: $3.(int64)}
	}
|	"INCREMENT" "BY" SignedNum
	{
sql_ir.LogGrammarCoverage("SequenceOption,SignedNum")


		$$ = &ast.SequenceOption{Tp: ast.SequenceOptionIncrementBy, IntValue: $3.(int64)}
	}
|	"START" EqOpt SignedNum
	{
sql_ir.LogGrammarCoverage("SequenceOption,EqOpt")
sql_ir.LogGrammarCoverage("SequenceOption,SignedNum")


		$$ = &ast.SequenceOption{Tp: ast.SequenceStartWith, IntValue: $3.(int64)}
	}
|	"START" "WITH" SignedNum
	{
sql_ir.LogGrammarCoverage("SequenceOption,SignedNum")


		$$ = &ast.SequenceOption{Tp: ast.SequenceStartWith, IntValue: $3.(int64)}
	}
|	"MINVALUE" EqOpt SignedNum
	{
sql_ir.LogGrammarCoverage("SequenceOption,EqOpt")
sql_ir.LogGrammarCoverage("SequenceOption,SignedNum")


		$$ = &ast.SequenceOption{Tp: ast.SequenceMinValue, IntValue: $3.(int64)}
	}
|	"NOMINVALUE"
	{


		$$ = &ast.SequenceOption{Tp: ast.SequenceNoMinValue}
	}
|	"NO" "MINVALUE"
	{


		$$ = &ast.SequenceOption{Tp: ast.SequenceNoMinValue}
	}
|	"MAXVALUE" EqOpt SignedNum
	{
sql_ir.LogGrammarCoverage("SequenceOption,EqOpt")
sql_ir.LogGrammarCoverage("SequenceOption,SignedNum")


		$$ = &ast.SequenceOption{Tp: ast.SequenceMaxValue, IntValue: $3.(int64)}
	}
|	"NOMAXVALUE"
	{


		$$ = &ast.SequenceOption{Tp: ast.SequenceNoMaxValue}
	}
|	"NO" "MAXVALUE"
	{


		$$ = &ast.SequenceOption{Tp: ast.SequenceNoMaxValue}
	}
|	"CACHE" EqOpt SignedNum
	{
sql_ir.LogGrammarCoverage("SequenceOption,EqOpt")
sql_ir.LogGrammarCoverage("SequenceOption,SignedNum")


		$$ = &ast.SequenceOption{Tp: ast.SequenceCache, IntValue: $3.(int64)}
	}
|	"NOCACHE"
	{


		$$ = &ast.SequenceOption{Tp: ast.SequenceNoCache}
	}
|	"NO" "CACHE"
	{


		$$ = &ast.SequenceOption{Tp: ast.SequenceNoCache}
	}
|	"CYCLE"
	{


		$$ = &ast.SequenceOption{Tp: ast.SequenceCycle}
	}
|	"NOCYCLE"
	{


		$$ = &ast.SequenceOption{Tp: ast.SequenceNoCycle}
	}
|	"NO" "CYCLE"
	{


		$$ = &ast.SequenceOption{Tp: ast.SequenceNoCycle}
	}

SignedNum:
	Int64Num
{
sql_ir.LogGrammarCoverage("SignedNum,Int64Num")

}
|	'+' Int64Num
	{
sql_ir.LogGrammarCoverage("SignedNum,Int64Num")


		$$ = $2
	}
|	'-' NUM
	{
sql_ir.LogGrammarCoverage("SignedNum,NUM")


		unsigned_num := getUint64FromNUM($2)
		if unsigned_num > 9223372036854775808 {
			yylex.AppendError(yylex.Errorf("the Signed Value should be at the range of [-9223372036854775808, 9223372036854775807]."))
			return 1
		} else if unsigned_num == 9223372036854775808 {
			signed_one := int64(1)
			$$ = signed_one << 63
		} else {
			$$ = -int64(unsigned_num)
		}
	}

DropSequenceStmt:
	"DROP" "SEQUENCE" IfExists TableNameList
	{
sql_ir.LogGrammarCoverage("DropSequenceStmt,IfExists")
sql_ir.LogGrammarCoverage("DropSequenceStmt,TableNameList")


		$$ = &ast.DropSequenceStmt{
			IfExists:  $3.(bool),
			Sequences: $4.([]*ast.TableName),
		}
	}


AlterSequenceStmt:
	"ALTER" "SEQUENCE" IfExists TableName AlterSequenceOptionList
	{
sql_ir.LogGrammarCoverage("AlterSequenceStmt,IfExists")
sql_ir.LogGrammarCoverage("AlterSequenceStmt,TableName")
sql_ir.LogGrammarCoverage("AlterSequenceStmt,AlterSequenceOptionList")


		$$ = &ast.AlterSequenceStmt{
			IfExists:   $3.(bool),
			Name:       $4.(*ast.TableName),
			SeqOptions: $5.([]*ast.SequenceOption),
		}
	}

AlterSequenceOptionList:
	AlterSequenceOption
	{
sql_ir.LogGrammarCoverage("AlterSequenceOptionList,AlterSequenceOption")


		$$ = []*ast.SequenceOption{$1.(*ast.SequenceOption)}
	}
|	AlterSequenceOptionList AlterSequenceOption
	{
sql_ir.LogGrammarCoverage("AlterSequenceOptionList,AlterSequenceOptionList")
sql_ir.LogGrammarCoverage("AlterSequenceOptionList,AlterSequenceOption")


		$$ = append($1.([]*ast.SequenceOption), $2.(*ast.SequenceOption))
	}

AlterSequenceOption:
	SequenceOption
{
sql_ir.LogGrammarCoverage("AlterSequenceOption,SequenceOption")

}
|	"RESTART"
	{


		$$ = &ast.SequenceOption{Tp: ast.SequenceRestart}
	}
|	"RESTART" EqOpt SignedNum
	{
sql_ir.LogGrammarCoverage("AlterSequenceOption,EqOpt")
sql_ir.LogGrammarCoverage("AlterSequenceOption,SignedNum")


		$$ = &ast.SequenceOption{Tp: ast.SequenceRestartWith, IntValue: $3.(int64)}
	}
|	"RESTART" "WITH" SignedNum
	{
sql_ir.LogGrammarCoverage("AlterSequenceOption,SignedNum")


		$$ = &ast.SequenceOption{Tp: ast.SequenceRestartWith, IntValue: $3.(int64)}
	}


IndexAdviseStmt:
	"INDEX" "ADVISE" LocalOpt "INFILE" stringLit MaxMinutesOpt MaxIndexNumOpt Lines
	{
sql_ir.LogGrammarCoverage("IndexAdviseStmt,LocalOpt")
sql_ir.LogGrammarCoverage("IndexAdviseStmt,stringLit")
sql_ir.LogGrammarCoverage("IndexAdviseStmt,MaxMinutesOpt")
sql_ir.LogGrammarCoverage("IndexAdviseStmt,MaxIndexNumOpt")
sql_ir.LogGrammarCoverage("IndexAdviseStmt,Lines")


		x := &ast.IndexAdviseStmt{
			Path:       $5,
			MaxMinutes: $6.(uint64),
		}
		if $3 != nil {
			x.IsLocal = true
		}
		if $7 != nil {
			x.MaxIndexNum = $7.(*ast.MaxIndexNumClause)
		}
		if $8 != nil {
			x.LinesInfo = $8.(*ast.LinesClause)
		}
		$$ = x
	}

MaxMinutesOpt:
	{


		$$ = uint64(ast.UnspecifiedSize)
	}
|	"MAX_MINUTES" NUM
	{
sql_ir.LogGrammarCoverage("MaxMinutesOpt,NUM")


		$$ = getUint64FromNUM($2)
	}

MaxIndexNumOpt:
	{


		$$ = nil
	}
|	"MAX_IDXNUM" PerTable PerDB
	{
sql_ir.LogGrammarCoverage("MaxIndexNumOpt,PerTable")
sql_ir.LogGrammarCoverage("MaxIndexNumOpt,PerDB")


		$$ = &ast.MaxIndexNumClause{
			PerTable: $2.(uint64),
			PerDB:    $3.(uint64),
		}
	}

PerTable:
	{


		$$ = uint64(ast.UnspecifiedSize)
	}
|	"PER_TABLE" NUM
	{
sql_ir.LogGrammarCoverage("PerTable,NUM")


		$$ = getUint64FromNUM($2)
	}

PerDB:
	{


		$$ = uint64(ast.UnspecifiedSize)
	}
|	"PER_DB" NUM
	{
sql_ir.LogGrammarCoverage("PerDB,NUM")


		$$ = getUint64FromNUM($2)
	}

EncryptionOpt:
	stringLit
	{
sql_ir.LogGrammarCoverage("EncryptionOpt,stringLit")


		// Parse it but will ignore it
		switch $1 {
		case "Y", "y":
			yylex.AppendError(yylex.Errorf("The ENCRYPTION clause is parsed but ignored by all storage engines."))
			parser.lastErrorAsWarn()
		case "N", "n":
			break
		default:
			yylex.AppendError(ErrWrongValue.GenWithStackByArgs("argument (should be Y or N)", $1))
			return 1
		}
		$$ = $1
	}

ValuesStmtList:
	RowStmt
	{
sql_ir.LogGrammarCoverage("ValuesStmtList,RowStmt")


		$$ = append([]*ast.RowExpr{}, $1.(*ast.RowExpr))
	}
|	ValuesStmtList ',' RowStmt
	{
sql_ir.LogGrammarCoverage("ValuesStmtList,ValuesStmtList")
sql_ir.LogGrammarCoverage("ValuesStmtList,RowStmt")


		$$ = append($1.([]*ast.RowExpr), $3.(*ast.RowExpr))
	}

RowStmt:
	"ROW" RowValue
	{
sql_ir.LogGrammarCoverage("RowStmt,RowValue")


		$$ = &ast.RowExpr{Values: $2.([]ast.ExprNode)}
	}


PlanReplayerStmt:
	"PLAN" "REPLAYER" "DUMP" "EXPLAIN" ExplainableStmt
	{
sql_ir.LogGrammarCoverage("PlanReplayerStmt,ExplainableStmt")


		x := &ast.PlanReplayerStmt{
			Stmt:    $5,
			Analyze: false,
			Load:    false,
			File:    "",
			Where:   nil,
			OrderBy: nil,
			Limit:   nil,
		}
		startOffset := parser.startOffset(&yyS[yypt])
		x.Stmt.SetText(parser.lexer.client, strings.TrimSpace(parser.src[startOffset:]))

		$$ = x
	}
|	"PLAN" "REPLAYER" "DUMP" "EXPLAIN" "ANALYZE" ExplainableStmt
	{
sql_ir.LogGrammarCoverage("PlanReplayerStmt,ExplainableStmt")


		x := &ast.PlanReplayerStmt{
			Stmt:    $6,
			Analyze: true,
			Load:    false,
			File:    "",
			Where:   nil,
			OrderBy: nil,
			Limit:   nil,
		}
		startOffset := parser.startOffset(&yyS[yypt])
		x.Stmt.SetText(parser.lexer.client, strings.TrimSpace(parser.src[startOffset:]))

		$$ = x
	}
|	"PLAN" "REPLAYER" "DUMP" "EXPLAIN" "SLOW" "QUERY" WhereClauseOptional OrderByOptional SelectStmtLimitOpt
	{
sql_ir.LogGrammarCoverage("PlanReplayerStmt,WhereClauseOptional")
sql_ir.LogGrammarCoverage("PlanReplayerStmt,OrderByOptional")
sql_ir.LogGrammarCoverage("PlanReplayerStmt,SelectStmtLimitOpt")


		x := &ast.PlanReplayerStmt{
			Stmt:    nil,
			Analyze: false,
			Load:    false,
			File:    "",
		}
		if $7 != nil {
			x.Where = $7.(ast.ExprNode)
		}
		if $8 != nil {
			x.OrderBy = $8.(*ast.OrderByClause)
		}
		if $9 != nil {
			x.Limit = $9.(*ast.Limit)
		}

		$$ = x
	}
|	"PLAN" "REPLAYER" "DUMP" "EXPLAIN" "ANALYZE" "SLOW" "QUERY" WhereClauseOptional OrderByOptional SelectStmtLimitOpt
	{
sql_ir.LogGrammarCoverage("PlanReplayerStmt,WhereClauseOptional")
sql_ir.LogGrammarCoverage("PlanReplayerStmt,OrderByOptional")
sql_ir.LogGrammarCoverage("PlanReplayerStmt,SelectStmtLimitOpt")


		x := &ast.PlanReplayerStmt{
			Stmt:    nil,
			Analyze: true,
			Load:    false,
			File:    "",
		}
		if $8 != nil {
			x.Where = $8.(ast.ExprNode)
		}
		if $9 != nil {
			x.OrderBy = $9.(*ast.OrderByClause)
		}
		if $10 != nil {
			x.Limit = $10.(*ast.Limit)
		}

		$$ = x
	}
|	"PLAN" "REPLAYER" "LOAD" stringLit
	{
sql_ir.LogGrammarCoverage("PlanReplayerStmt,stringLit")


		x := &ast.PlanReplayerStmt{
			Stmt:    nil,
			Analyze: false,
			Load:    true,
			File:    $4,
			Where:   nil,
			OrderBy: nil,
			Limit:   nil,
		}

		$$ = x
	}

%%
