EXECUTE test \gdescEXPLAIN EXECUTE test \gdescSELECT 1 + \gdescSELECT \gdescCREATE TABLE bububu(a int) \gdescTABLE bububu;
  SELECT 1 AS x, 'Hello', 2 AS y, true AS "dirty\name"\gdesc\gSELECT 3 AS x, 'Hello', 4 AS y, true AS "dirty\name" \gdesc \gcreate temporary table gexec_test(a int, b text, c date, d float);
  SELECT 1 AS x, 'Hello', 2 AS y, true AS "dirty\name"\gdesc\gSELECT 3 AS x, 'Hello', 4 AS y, true AS "dirty\name" \gdesc \gcreate temporary table gexec_test(a int, b text, c date, d float);
\pset linestyle ascii\pset expanded off\pset columns 40\pset border 0\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 1\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 2\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset expanded on\pset columns 20\pset border 0\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 1\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 2\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset linestyle old-ascii\pset expanded off\pset columns 40\pset border 0\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 1\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 2\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset expanded on\pset columns 20\pset border 0\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 1\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 2\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
deallocate q;
\pset linestyle ascii\pset expanded off\pset columns 40\pset border 0\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 1\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 2\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset expanded on\pset columns 30\pset border 0\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 1\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 2\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset expanded on\pset columns 20\pset border 0\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 1\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 2\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset linestyle old-ascii\pset expanded off\pset columns 40\pset border 0\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 1\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 2\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset expanded on\pset border 0\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 1\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 2\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
deallocate q;
\pset linestyle ascii\pset border 1create table psql_serial_tab (id serial);
\pset format aligned\pset expanded off\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only false\pset expanded on\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only falseselect 1 where false;
\pset format unaligned\pset expanded off\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only false\pset expanded on\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only false\pset format wrapped\pset expanded off\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only false\pset expanded on\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only falseCREATE ACCESS METHOD heap_psql TYPE TABLE HANDLER heap_tableam_handler;
CREATE TABLE tbl_heap_psql(f1 int, f2 char(100)) using heap_psql;
CREATE TABLE tbl_heap(f1 int, f2 char(100)) using heap;
\d+ tbl_heap_psql\d+ tbl_heap\set HIDE_TABLEAM off\d+ tbl_heap_psql\d+ tbl_heap\set HIDE_TABLEAM onDROP TABLE tbl_heap, tbl_heap_psql;
DROP ACCESS METHOD heap_psql;
\pset expanded off\pset border 0execute q;
\pset border 1execute q;
\pset border 2execute q;
\pset expanded on\pset border 0execute q;
\pset border 1execute q;
\pset border 2execute q;
deallocate q;
\pset expanded offexecute q;
\pset expanded onexecute q;
deallocate q;
\pset expanded offselect 'comma,comma' as comma, 'semi;
semi' as semi;
semi' as semi;
\pset csv_fieldsep ';
'select 'comma,comma' as comma, 'semi;
'select 'comma,comma' as comma, 'semi;
semi' as semi;
semi' as semi;
select '\.' as data;
\pset csv_fieldsep '.'select '\' as d1, '' as d2;
\pset expanded off\pset border 0execute q;
\pset border 1execute q;
\pset tableattr foobarexecute q;
\pset tableattr\pset expanded on\pset border 0execute q;
\pset border 1execute q;
\pset tableattr foobarexecute q;
\pset tableattrdeallocate q;
\pset expanded off\pset border 0execute q;
\pset border 1execute q;
\pset border 2execute q;
\pset border 3execute q;
\pset expanded on\pset border 0execute q;
\pset border 1execute q;
\pset border 2execute q;
\pset border 3execute q;
deallocate q;
\pset expanded off\pset border 0execute q;
\pset border 1execute q;
\pset border 2execute q;
\pset border 3execute q;
\pset tableattr lrexecute q;
\pset tableattr\pset expanded on\pset border 0execute q;
\pset border 1execute q;
\pset border 2execute q;
\pset border 3execute q;
\pset tableattr lrexecute q;
\pset tableattrdeallocate q;
\pset expanded off\pset border 0execute q;
\pset border 1execute q;
\pset border 2execute q;
\pset expanded on\pset border 0execute q;
\pset border 1execute q;
\pset border 2execute q;
deallocate q;
\pset format a\pset format ldrop table psql_serial_tab;
\pset format aligned\pset expanded off\pset border 1\echo this is a test\echo -n without newline\echo with -n newline\echo '-n' with newline\set foo bar\echo foo = :foo\qecho this is a test\qecho foo = :foo\warn this is a test\warn foo = :foo\if true  select 'okay';
  select 'still okay';
\else  not okay;
  still not okay\endif\gselect  \if true    42  \else    (bogus  \endif  forty_two;
select \if false \\ (bogus \else \\ 42 \endif \\ forty_two;
\if true	\if 1		\if yes			\if on				\echo 'all true'			\else				\echo 'should not print #1-1'			\endif		\else			\echo 'should not print #1-2'		\endif	\else		\echo 'should not print #1-3'	\endif\else	\echo 'should not print #1-4'\endif\if false	\echo 'should not print #2-1'\elif 0	\echo 'should not print #2-2'\elif no	\echo 'should not print #2-3'\elif off	\echo 'should not print #2-4'\else	\echo 'all false'\endif\if true	\echo 'should print #2-5'\elif true	\echo 'should not print #2-6'\elif false	\echo 'should not print #2-7'\else	\echo 'should not print #2-8'\endif\if true	\echo 'first thing true'\else	\echo 'should not print #3-1'\endif\if false	\echo 'should not print #4-1'\elif true	\echo 'second thing true'\else	\echo 'should not print #5-1'\endif\if invalid boolean expression	\echo 'will not print #6-1'\else	\echo 'will print anyway #6-2'\endif\endif\else\elif\if true\else\else\endif\if false\else\elif\endif\if false    \if false        \echo 'should not print #7-1'    \else        \echo 'should not print #7-2'    \endif    \echo 'should not print #7-3'\else    \echo 'should print #7-4'\endif\set foo bar\echo :foo :'foo' :"foo"\pset fieldsep | `nosuchcommand` :foo :'foo' :"foo"\set try_to_quit '\\q'\if false	:try_to_quit	\echo `nosuchcommand` :foo :'foo' :"foo"	\pset fieldsep | `nosuchcommand` :foo :'foo' :"foo"	\a	\C arg1	\c arg1 arg2 arg3 arg4	\cd arg1	\conninfo	\copy arg1 arg2 arg3 arg4 arg5 arg6	\copyright	SELECT 1 as one, 2, 3 \crosstabview	\dt arg1	\e arg1 arg2	\ef whole_line	\ev whole_line	\echo arg1 arg2 arg3 arg4 arg5	\echo arg1	\encoding arg1	\errverbose	\f arg1	\g arg1	\gx arg1	\gexec	SELECT 1 AS one \gset	\h	\?	\html	\i arg1	\ir arg1	\l arg1	\lo arg1 arg2	\lo_list	\o arg1	\p	\password arg1	\prompt arg1 arg2	\pset arg1 arg2	\q	\reset	\s arg1	\set arg1 arg2 arg3 arg4 arg5 arg6 arg7	\setenv arg1 arg2	\sf whole_line	\sv whole_line	\t arg1	\T arg1	\timing arg1	\unset arg1	\w arg1	\watch arg1	\x arg1		\w |/no/such/file \else		\! whole_line \endif	\z\else	\echo 'should print #8-1'\endif\set i 1\if :{?i}  \echo '#9-1 ok, variable i is defined'\else  \echo 'should not print #9-2'\endif\if :{?no_such_variable}  \echo 'should not print #10-1'\else  \echo '#10-2 ok, variable no_such_variable is not defined'\endifSELECT :{?i} AS i_is_defined;
SELECT NOT :{?no_such_var} AS no_such_var_is_not_defined;
\set SHOW_CONTEXT neverdo begin  raise notice 'foo';
  raise exception 'bar';
end ;
\set SHOW_CONTEXT errorsdo begin  raise notice 'foo';
  raise exception 'bar';
end ;
\set SHOW_CONTEXT alwaysdo begin  raise notice 'foo';
  raise exception 'bar';
end ;
SELECT 1;
\pSELECT 2 \r\pSELECT 3 \pUNION SELECT 4 \pUNION SELECT 5ORDER BY 1;
\r\pSELECT 1 AS stuff UNION SELECT 2;
\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNTSELECT 1 UNION;
\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNT\echo 'last error message:' :LAST_ERROR_MESSAGE\echo 'last error code:' :LAST_ERROR_SQLSTATE;
\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNT\echo 'last error message:' :LAST_ERROR_MESSAGE\echo 'last error code:' :LAST_ERROR_SQLSTATEDROP TABLE this_table_does_not_exist;
\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNT\echo 'last error message:' :LAST_ERROR_MESSAGE\echo 'last error code:' :LAST_ERROR_SQLSTATE\set VERBOSITY terseSELECT 1 UNION;
\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'last error message:' :LAST_ERROR_MESSAGE\set VERBOSITY sqlstateSELECT 1/0;
\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'last error message:' :LAST_ERROR_MESSAGE\set VERBOSITY defaultSELECT 3 AS three, 4 AS four \gdesc\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNTSELECT 4 AS \gdesc\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNT\echo 'last error message:' :LAST_ERROR_MESSAGE\echo 'last error code:' :LAST_ERROR_SQLSTATE\set FETCH_COUNT 10select unique2 from tenk1 order by unique2 limit 19;
\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNTselect 1/(15-unique2) from tenk1 order by unique2 limit 19;
\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNT\echo 'last error message:' :LAST_ERROR_MESSAGE\echo 'last error code:' :LAST_ERROR_SQLSTATE\unset FETCH_COUNTcreate schema testpart;
create role regress_partitioning_role;
alter schema testpart owner to regress_partitioning_role;
set role to regress_partitioning_role;
set search_path to testpart;
create table testtable_apple(logdate date);
create table testtable_orange(logdate date);
create index testtable_apple_index on testtable_apple(logdate);
create index testtable_orange_index on testtable_orange(logdate);
create table testpart_apple(logdate date) partition by range(logdate);
create table testpart_orange(logdate date) partition by range(logdate);
create index testpart_apple_index on testpart_apple(logdate);
create index testpart_orange_index on testpart_orange(logdate);
\dP test*apple*\dPt test*apple*\dPi test*apple*drop table testtable_apple;
drop table testtable_orange;
drop table testpart_apple;
drop table testpart_orange;
create table parent_tab (id int) partition by range (id);
create index parent_index on parent_tab (id);
create table child_0_10 partition of parent_tab  for values from (0) to (10);
create table child_10_20 partition of parent_tab  for values from (10) to (20);
create table child_20_30 partition of parent_tab  for values from (20) to (30);
create table child_30_40 partition of parent_tabfor values from (30) to (40)  partition by range(id);
create table child_30_35 partition of child_30_40  for values from (30) to (35);
create table child_35_40 partition of child_30_40   for values from (35) to (40);
\dPt\dPi\dP testpart.*\dP\dPtn\dPin\dPn\dPn testpart.*drop table parent_tab cascade;
drop schema testpart;
set search_path to default;
set role to default;
drop role regress_partitioning_role;
