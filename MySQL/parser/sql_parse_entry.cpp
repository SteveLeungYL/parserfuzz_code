#include "./sql_parse_entry.h"
// #include "./bison_parser.h"
#include "sql/sql_lex_hash.h"
#include "sql/sql_lex_hints.h"

#include "include/my_config.h"


#include "sql/sql_class.h"
#include "sql/sql_lex.h"
#include "sql/parse_tree_node_base.h"
#include "sql/parse_tree_nodes.h"
#include "sql/table.h"
#include "sql/sql_parse.h"
#include "sql/error_handler.h"
#include "include/mysys_err.h"
#include "sql/sql_locale.h"
#include "sql/derror.h"
#include "sql/sp_head.h"
#include "sql/lex_hash.h"
// #include "sql/lex.h"


/* Helper functions */

// static CODE_STATE *code_state(void) {
//   CODE_STATE *cs, **cs_ptr;

//   if (!init_done) {
//     init_done = true;
//     native_mutex_init(&THR_LOCK_dbug, nullptr);
//     native_mutex_init(&THR_LOCK_gcov, nullptr);
//     native_rw_init(&THR_LOCK_init_settings);
//     memset(&init_settings, 0, sizeof(init_settings));
//     init_settings.out_file = stderr;
//     init_settings.flags = OPEN_APPEND;
//   }

//   if (!(cs_ptr = my_thread_var_dbug()))
//     return nullptr; /* Thread not initialised */
//   if (!(cs = *cs_ptr)) {
//     cs = (CODE_STATE *)DbugMalloc(sizeof(*cs));
//     memset(cs, 0, sizeof(*cs));
//     cs->process = db_process ? db_process : "dbug";
//     cs->func = "?func";
//     cs->file = "?file";
//     cs->stack = &init_settings;
//     cs->m_read_lock_count = 0;
//     *cs_ptr = cs;
//   }
//   return cs;
// }
// struct CODE_STATE {
//   const char *process; /* Pointer to process name; usually argv[0] */
//   const char *func;    /* Name of current user function            */
//   int func_len;        /* How many bytes to print from func        */
//   const char *file;    /* Name of current user file                */
//   struct _db_stack_frame_ *framep; /* Pointer to current frame              */
//   struct settings *stack; /* debugging settings                       */
//   int lineno;             /* Current debugger output line number      */
//   uint level;             /* Current function nesting level           */

//   /*
//    *      The following variables are used to hold the state information
//    *      between the call to _db_pargs_() and _db_doprnt_(), during
//    *      expansion of the DBUG_PRINT macro.  This is the only macro
//    *      that currently uses these variables.
//    *
//    *      These variables are currently used only by _db_pargs_() and
//    *      _db_doprnt_().
//    */

//   uint u_line;           /* User source code line number */
//   int locked;            /* If locked with _db_lock_file_ */
//   const char *u_keyword; /* Keyword for current macro */
//   uint m_read_lock_count;
// };

// #define get_code_state_or_return \
//   if (!((cs = code_state()))) return

// void _db_pargs_(uint _line_, const char *keyword) {
//   CODE_STATE *cs;
//   get_code_state_or_return;
//   cs->u_line = _line_;
//   cs->u_keyword = keyword;
// }

static const char *long_str = "2147483647";
static const uint long_len = 10;
static const char *signed_long_str = "-2147483648";
static const char *longlong_str = "9223372036854775807";
static const uint longlong_len = 19;
static const char *signed_longlong_str = "-9223372036854775808";
static const uint signed_longlong_len = 19;
static const char *unsigned_longlong_str = "18446744073709551615";
static const uint unsigned_longlong_len = 20;

/* Tokens.  */
#define ABORT_SYM 258
#define ACCESSIBLE_SYM 259
#define ACCOUNT_SYM 260
#define ACTION 261
#define ADD 262
#define ADDDATE_SYM 263
#define AFTER_SYM 264
#define AGAINST 265
#define AGGREGATE_SYM 266
#define ALGORITHM_SYM 267
#define ALL 268
#define ALTER 269
#define ALWAYS_SYM 270
#define OBSOLETE_TOKEN_271 271
#define ANALYZE_SYM 272
#define AND_AND_SYM 273
#define AND_SYM 274
#define ANY_SYM 275
#define AS 276
#define ASC 277
#define ASCII_SYM 278
#define ASENSITIVE_SYM 279
#define AT_SYM 280
#define AUTOEXTEND_SIZE_SYM 281
#define AUTO_INC 282
#define AVG_ROW_LENGTH 283
#define AVG_SYM 284
#define BACKUP_SYM 285
#define BEFORE_SYM 286
#define BEGIN_SYM 287
#define BETWEEN_SYM 288
#define BIGINT_SYM 289
#define BINARY_SYM 290
#define BINLOG_SYM 291
#define BIN_NUM 292
#define BIT_AND_SYM 293
#define BIT_OR_SYM 294
#define BIT_SYM 295
#define BIT_XOR_SYM 296
#define BLOB_SYM 297
#define BLOCK_SYM 298
#define BOOLEAN_SYM 299
#define BOOL_SYM 300
#define BOTH 301
#define BTREE_SYM 302
#define BY 303
#define BYTE_SYM 304
#define CACHE_SYM 305
#define CALL_SYM 306
#define CASCADE 307
#define CASCADED 308
#define CASE_SYM 309
#define CAST_SYM 310
#define CATALOG_NAME_SYM 311
#define CHAIN_SYM 312
#define CHANGE 313
#define CHANGED 314
#define CHANNEL_SYM 315
#define CHARSET 316
#define CHAR_SYM 317
#define CHECKSUM_SYM 318
#define CHECK_SYM 319
#define CIPHER_SYM 320
#define CLASS_ORIGIN_SYM 321
#define CLIENT_SYM 322
#define CLOSE_SYM 323
#define COALESCE 324
#define CODE_SYM 325
#define COLLATE_SYM 326
#define COLLATION_SYM 327
#define COLUMNS 328
#define COLUMN_SYM 329
#define COLUMN_FORMAT_SYM 330
#define COLUMN_NAME_SYM 331
#define COMMENT_SYM 332
#define COMMITTED_SYM 333
#define COMMIT_SYM 334
#define COMPACT_SYM 335
#define COMPLETION_SYM 336
#define COMPRESSED_SYM 337
#define COMPRESSION_SYM 338
#define ENCRYPTION_SYM 339
#define CONCURRENT 340
#define CONDITION_SYM 341
#define CONNECTION_SYM 342
#define CONSISTENT_SYM 343
#define CONSTRAINT 344
#define CONSTRAINT_CATALOG_SYM 345
#define CONSTRAINT_NAME_SYM 346
#define CONSTRAINT_SCHEMA_SYM 347
#define CONTAINS_SYM 348
#define CONTEXT_SYM 349
#define CONTINUE_SYM 350
#define CONVERT_SYM 351
#define COUNT_SYM 352
#define CPU_SYM 353
#define CREATE 354
#define CROSS 355
#define CUBE_SYM 356
#define CURDATE 357
#define CURRENT_SYM 358
#define CURRENT_USER 359
#define CURSOR_SYM 360
#define CURSOR_NAME_SYM 361
#define CURTIME 362
#define DATABASE 363
#define DATABASES 364
#define DATAFILE_SYM 365
#define DATA_SYM 366
#define DATETIME_SYM 367
#define DATE_ADD_INTERVAL 368
#define DATE_SUB_INTERVAL 369
#define DATE_SYM 370
#define DAY_HOUR_SYM 371
#define DAY_MICROSECOND_SYM 372
#define DAY_MINUTE_SYM 373
#define DAY_SECOND_SYM 374
#define DAY_SYM 375
#define DEALLOCATE_SYM 376
#define DECIMAL_NUM 377
#define DECIMAL_SYM 378
#define DECLARE_SYM 379
#define DEFAULT_SYM 380
#define DEFAULT_AUTH_SYM 381
#define DEFINER_SYM 382
#define DELAYED_SYM 383
#define DELAY_KEY_WRITE_SYM 384
#define DELETE_SYM 385
#define DESC 386
#define DESCRIBE 387
#define OBSOLETE_TOKEN_388 388
#define DETERMINISTIC_SYM 389
#define DIAGNOSTICS_SYM 390
#define DIRECTORY_SYM 391
#define DISABLE_SYM 392
#define DISCARD_SYM 393
#define DISK_SYM 394
#define DISTINCT 395
#define DIV_SYM 396
#define DOUBLE_SYM 397
#define DO_SYM 398
#define DROP 399
#define DUAL_SYM 400
#define DUMPFILE 401
#define DUPLICATE_SYM 402
#define DYNAMIC_SYM 403
#define EACH_SYM 404
#define ELSE 405
#define ELSEIF_SYM 406
#define ENABLE_SYM 407
#define ENCLOSED 408
#define END 409
#define ENDS_SYM 410
#define END_OF_INPUT 411
#define ENGINES_SYM 412
#define ENGINE_SYM 413
#define ENUM_SYM 414
#define EQ 415
#define EQUAL_SYM 416
#define ERROR_SYM 417
#define ERRORS 418
#define ESCAPED 419
#define ESCAPE_SYM 420
#define EVENTS_SYM 421
#define EVENT_SYM 422
#define EVERY_SYM 423
#define EXCHANGE_SYM 424
#define EXECUTE_SYM 425
#define EXISTS 426
#define EXIT_SYM 427
#define EXPANSION_SYM 428
#define EXPIRE_SYM 429
#define EXPORT_SYM 430
#define EXTENDED_SYM 431
#define EXTENT_SIZE_SYM 432
#define EXTRACT_SYM 433
#define FALSE_SYM 434
#define FAST_SYM 435
#define FAULTS_SYM 436
#define FETCH_SYM 437
#define FILE_SYM 438
#define FILE_BLOCK_SIZE_SYM 439
#define FILTER_SYM 440
#define FIRST_SYM 441
#define FIXED_SYM 442
#define FLOAT_NUM 443
#define FLOAT_SYM 444
#define FLUSH_SYM 445
#define FOLLOWS_SYM 446
#define FORCE_SYM 447
#define FOREIGN 448
#define FOR_SYM 449
#define FORMAT_SYM 450
#define FOUND_SYM 451
#define FROM 452
#define FULL 453
#define FULLTEXT_SYM 454
#define FUNCTION_SYM 455
#define GE 456
#define GENERAL 457
#define GENERATED 458
#define GROUP_REPLICATION 459
#define GEOMETRYCOLLECTION_SYM 460
#define GEOMETRY_SYM 461
#define GET_FORMAT 462
#define GET_SYM 463
#define GLOBAL_SYM 464
#define GRANT 465
#define GRANTS 466
#define GROUP_SYM 467
#define GROUP_CONCAT_SYM 468
#define GT_SYM 469
#define HANDLER_SYM 470
#define HASH_SYM 471
#define HAVING 472
#define HELP_SYM 473
#define HEX_NUM 474
#define HIGH_PRIORITY 475
#define HOST_SYM 476
#define HOSTS_SYM 477
#define HOUR_MICROSECOND_SYM 478
#define HOUR_MINUTE_SYM 479
#define HOUR_SECOND_SYM 480
#define HOUR_SYM 481
#define IDENT 482
#define IDENTIFIED_SYM 483
#define IDENT_QUOTED 484
#define IF 485
#define IGNORE_SYM 486
#define IGNORE_SERVER_IDS_SYM 487
#define IMPORT 488
#define INDEXES 489
#define INDEX_SYM 490
#define INFILE 491
#define INITIAL_SIZE_SYM 492
#define INNER_SYM 493
#define INOUT_SYM 494
#define INSENSITIVE_SYM 495
#define INSERT_SYM 496
#define INSERT_METHOD 497
#define INSTANCE_SYM 498
#define INSTALL_SYM 499
#define INTERVAL_SYM 500
#define INTO 501
#define INT_SYM 502
#define INVOKER_SYM 503
#define IN_SYM 504
#define IO_AFTER_GTIDS 505
#define IO_BEFORE_GTIDS 506
#define IO_SYM 507
#define IPC_SYM 508
#define IS 509
#define ISOLATION 510
#define ISSUER_SYM 511
#define ITERATE_SYM 512
#define JOIN_SYM 513
#define JSON_SEPARATOR_SYM 514
#define JSON_SYM 515
#define KEYS 516
#define KEY_BLOCK_SIZE 517
#define KEY_SYM 518
#define KILL_SYM 519
#define LANGUAGE_SYM 520
#define LAST_SYM 521
#define LE 522
#define LEADING 523
#define LEAVES 524
#define LEAVE_SYM 525
#define LEFT 526
#define LESS_SYM 527
#define LEVEL_SYM 528
#define LEX_HOSTNAME 529
#define LIKE 530
#define LIMIT 531
#define LINEAR_SYM 532
#define LINES 533
#define LINESTRING_SYM 534
#define LIST_SYM 535
#define LOAD 536
#define LOCAL_SYM 537
#define OBSOLETE_TOKEN_538 538
#define LOCKS_SYM 539
#define LOCK_SYM 540
#define LOGFILE_SYM 541
#define LOGS_SYM 542
#define LONGBLOB_SYM 543
#define LONGTEXT_SYM 544
#define LONG_NUM 545
#define LONG_SYM 546
#define LOOP_SYM 547
#define LOW_PRIORITY 548
#define LT 549
#define MASTER_AUTO_POSITION_SYM 550
#define MASTER_BIND_SYM 551
#define MASTER_CONNECT_RETRY_SYM 552
#define MASTER_DELAY_SYM 553
#define MASTER_HOST_SYM 554
#define MASTER_LOG_FILE_SYM 555
#define MASTER_LOG_POS_SYM 556
#define MASTER_PASSWORD_SYM 557
#define MASTER_PORT_SYM 558
#define MASTER_RETRY_COUNT_SYM 559
#define MASTER_SSL_CAPATH_SYM 561
#define MASTER_TLS_VERSION_SYM 562
#define MASTER_SSL_CA_SYM 563
#define MASTER_SSL_CERT_SYM 564
#define MASTER_SSL_CIPHER_SYM 565
#define MASTER_SSL_CRL_SYM 566
#define MASTER_SSL_CRLPATH_SYM 567
#define MASTER_SSL_KEY_SYM 568
#define MASTER_SSL_SYM 569
#define MASTER_SSL_VERIFY_SERVER_CERT_SYM 570
#define MASTER_SYM 571
#define MASTER_USER_SYM 572
#define MASTER_HEARTBEAT_PERIOD_SYM 573
#define MATCH 574
#define MAX_CONNECTIONS_PER_HOUR 575
#define MAX_QUERIES_PER_HOUR 576
#define MAX_ROWS 577
#define MAX_SIZE_SYM 578
#define MAX_SYM 579
#define MAX_UPDATES_PER_HOUR 580
#define MAX_USER_CONNECTIONS_SYM 581
#define MAX_VALUE_SYM 582
#define MEDIUMBLOB_SYM 583
#define MEDIUMINT_SYM 584
#define MEDIUMTEXT_SYM 585
#define MEDIUM_SYM 586
#define MEMORY_SYM 587
#define MERGE_SYM 588
#define MESSAGE_TEXT_SYM 589
#define MICROSECOND_SYM 590
#define MIGRATE_SYM 591
#define MINUTE_MICROSECOND_SYM 592
#define MINUTE_SECOND_SYM 593
#define MINUTE_SYM 594
#define MIN_ROWS 595
#define MIN_SYM 596
#define MODE_SYM 597
#define MODIFIES_SYM 598
#define MODIFY_SYM 599
#define MOD_SYM 600
#define MONTH_SYM 601
#define MULTILINESTRING_SYM 602
#define MULTIPOINT_SYM 603
#define MULTIPOLYGON_SYM 604
#define MUTEX_SYM 605
#define MYSQL_ERRNO_SYM 606
#define NAMES_SYM 607
#define NAME_SYM 608
#define NATIONAL_SYM 609
#define NATURAL 610
#define NCHAR_STRING 611
#define NCHAR_SYM 612
#define NDBCLUSTER_SYM 613
#define NE 614
#define NEG 615
#define NEVER_SYM 616
#define NEW_SYM 617
#define NEXT_SYM 618
#define NODEGROUP_SYM 619
#define NONE_SYM 620
#define NOT2_SYM 621
#define NOT_SYM 622
#define NOW_SYM 623
#define NO_SYM 624
#define NO_WAIT_SYM 625
#define NO_WRITE_TO_BINLOG 626
#define NULL_SYM 627
#define NUM 628
#define NUMBER_SYM 629
#define NUMERIC_SYM 630
#define NVARCHAR_SYM 631
#define OFFSET_SYM 632
#define ON_SYM 633
#define ONE_SYM 634
#define ONLY_SYM 635
#define OPEN_SYM 636
#define OPTIMIZE 637
#define OPTIMIZER_COSTS_SYM 638
#define OPTIONS_SYM 639
#define OPTION 640
#define OPTIONALLY 641
#define OR2_SYM 642
#define ORDER_SYM 643
#define OR_OR_SYM 644
#define OR_SYM 645
#define OUTER_SYM 646
#define OUTFILE 647
#define OUT_SYM 648
#define OWNER_SYM 649
#define PACK_KEYS_SYM 650
#define PAGE_SYM 651
#define PARAM_MARKER 652
#define PARSER_SYM 653
#define OBSOLETE_TOKEN_654 654
#define PARTIAL 655
#define PARTITION_SYM 656
#define PARTITIONS_SYM 657
#define PARTITIONING_SYM 658
#define PASSWORD 659
#define PHASE_SYM 660
#define PLUGIN_DIR_SYM 661
#define PLUGIN_SYM 662
#define PLUGINS_SYM 663
#define POINT_SYM 664
#define POLYGON_SYM 665
#define PORT_SYM 666
#define POSITION_SYM 667
#define PRECEDES_SYM 668
#define PRECISION 669
#define PREPARE_SYM 670
#define PRESERVE_SYM 671
#define PREV_SYM 672
#define PRIMARY_SYM 673
#define PRIVILEGES 674
#define PROCEDURE_SYM 675
#define PROCESS 676
#define PROCESSLIST_SYM 677
#define PROFILE_SYM 678
#define PROFILES_SYM 679
#define PROXY_SYM 680
#define PURGE 681
#define QUARTER_SYM 682
#define QUERY_SYM 683
#define QUICK 684
#define RANGE_SYM 685
#define READS_SYM 686
#define READ_ONLY_SYM 687
#define READ_SYM 688
#define READ_WRITE_SYM 689
#define REAL_SYM 690
#define REBUILD_SYM 691
#define RECOVER_SYM 692
#define OBSOLETE_TOKEN_693 693
#define REDO_BUFFER_SIZE_SYM 694
#define REDUNDANT_SYM 695
#define REFERENCES 696
#define REGEXP 697
#define RELAY 698
#define RELAYLOG_SYM 699
#define RELAY_LOG_FILE_SYM 700
#define RELAY_LOG_POS_SYM 701
#define RELAY_THREAD 702
#define RELEASE_SYM 703
#define RELOAD 704
#define REMOVE_SYM 705
#define RENAME 706
#define REORGANIZE_SYM 707
#define REPAIR 708
#define REPEATABLE_SYM 709
#define REPEAT_SYM 710
#define REPLACE_SYM 711
#define REPLICATION 712
#define REPLICATE_DO_DB 713
#define REPLICATE_IGNORE_DB 714
#define REPLICATE_DO_TABLE 715
#define REPLICATE_IGNORE_TABLE 716
#define REPLICATE_WILD_DO_TABLE 717
#define REPLICATE_WILD_IGNORE_TABLE 718
#define REPLICATE_REWRITE_DB 719
#define REQUIRE_SYM 720
#define RESET_SYM 721
#define RESIGNAL_SYM 722
#define RESOURCES 723
#define RESTORE_SYM 724
#define RESTRICT 725
#define RESUME_SYM 726
#define RETURNED_SQLSTATE_SYM 727
#define RETURNS_SYM 728
#define RETURN_SYM 729
#define REVERSE_SYM 730
#define REVOKE 731
#define RIGHT 732
#define ROLLBACK_SYM 733
#define ROLLUP_SYM 734
#define ROTATE_SYM 735
#define ROUTINE_SYM 736
#define ROWS_SYM 737
#define ROW_FORMAT_SYM 738
#define ROW_SYM 739
#define ROW_COUNT_SYM 740
#define RTREE_SYM 741
#define SAVEPOINT_SYM 742
#define SCHEDULE_SYM 743
#define SCHEMA_NAME_SYM 744
#define SECOND_MICROSECOND_SYM 745
#define SECOND_SYM 746
#define SECURITY_SYM 747
#define SELECT_SYM 748
#define SENSITIVE_SYM 749
#define SEPARATOR_SYM 750
#define SERIALIZABLE_SYM 751
#define SERIAL_SYM 752
#define SESSION_SYM 753
#define SERVER_SYM 754
#define OBSOLETE_TOKEN_755 755
#define SET_SYM 756
#define SET_VAR 757
#define SHARE_SYM 758
#define SHIFT_LEFT 759
#define SHIFT_RIGHT 760
#define SHOW 761
#define SHUTDOWN 762
#define SIGNAL_SYM 763
#define SIGNED_SYM 764
#define SIMPLE_SYM 765
#define SLAVE 766
#define SLOW 767
#define SMALLINT_SYM 768
#define SNAPSHOT_SYM 769
#define SOCKET_SYM 770
#define SONAME_SYM 771
#define SOUNDS_SYM 772
#define SOURCE_SYM 773
#define SPATIAL_SYM 774
#define SPECIFIC_SYM 775
#define SQLEXCEPTION_SYM 776
#define SQLSTATE_SYM 777
#define SQLWARNING_SYM 778
#define SQL_AFTER_GTIDS 779
#define SQL_AFTER_MTS_GAPS 780
#define SQL_BEFORE_GTIDS 781
#define SQL_BIG_RESULT 782
#define SQL_BUFFER_RESULT 783
#define OBSOLETE_TOKEN_784 784
#define SQL_CALC_FOUND_ROWS 785
#define SQL_NO_CACHE_SYM 786
#define SQL_SMALL_RESULT 787
#define SQL_SYM 788
#define SQL_THREAD 789
#define SSL_SYM 790
#define STACKED_SYM 791
#define STARTING 792
#define STARTS_SYM 793
#define START_SYM 794
#define STATS_AUTO_RECALC_SYM 795
#define STATS_PERSISTENT_SYM 796
#define STATS_SAMPLE_PAGES_SYM 797
#define STATUS_SYM 798
#define STDDEV_SAMP_SYM 799
#define STD_SYM 800
#define STOP_SYM 801
#define STORAGE_SYM 802
#define STORED_SYM 803
#define STRAIGHT_JOIN 804
#define STRING_SYM 805
#define SUBCLASS_ORIGIN_SYM 806
#define SUBDATE_SYM 807
#define SUBJECT_SYM 808
#define SUBPARTITIONS_SYM 809
#define SUBPARTITION_SYM 810
#define SUBSTRING 811
#define SUM_SYM 812
#define SUPER_SYM 813
#define SUSPEND_SYM 814
#define SWAPS_SYM 815
#define SWITCHES_SYM 816
#define SYSDATE 817
#define TABLES 818
#define TABLESPACE_SYM 819
#define OBSOLETE_TOKEN_820 820
#define TABLE_SYM 821
#define TABLE_CHECKSUM_SYM 822
#define TABLE_NAME_SYM 823
#define TEMPORARY 824
#define TEMPTABLE_SYM 825
#define TERMINATED 826
#define TEXT_STRING 827
#define TEXT_SYM 828
#define THAN_SYM 829
#define THEN_SYM 830
#define TIMESTAMP_SYM 831
#define TIMESTAMP_ADD 832
#define TIMESTAMP_DIFF 833
#define TIME_SYM 834
#define TINYBLOB_SYM 835
#define TINYINT_SYM 836
#define TINYTEXT_SYN 837
#define TO_SYM 838
#define TRAILING 839
#define TRANSACTION_SYM 840
#define TRIGGERS_SYM 841
#define TRIGGER_SYM 842
#define TRIM 843
#define TRUE_SYM 844
#define TRUNCATE_SYM 845
#define TYPES_SYM 846
#define TYPE_SYM 847
#define OBSOLETE_TOKEN_848 848
#define ULONGLONG_NUM 849
#define UNCOMMITTED_SYM 850
#define UNDEFINED_SYM 851
#define UNDERSCORE_CHARSET 852
#define UNDOFILE_SYM 853
#define UNDO_BUFFER_SIZE_SYM 854
#define UNDO_SYM 855
#define UNICODE_SYM 856
#define UNINSTALL_SYM 857
#define UNION_SYM 858
#define UNIQUE_SYM 859
#define UNKNOWN_SYM 860
#define UNLOCK_SYM 861
#define UNSIGNED_SYM 862
#define UNTIL_SYM 863
#define UPDATE_SYM 864
#define UPGRADE_SYM 865
#define USAGE 866
#define USER 867
#define USE_FRM 868
#define USE_SYM 869
#define USING 870
#define UTC_DATE_SYM 871
#define UTC_TIMESTAMP_SYM 872
#define UTC_TIME_SYM 873
#define VALIDATION_SYM 874
#define VALUES 875
#define VALUE_SYM 876
#define VARBINARY_SYM 877
#define VARCHAR_SYM 878
#define VARIABLES 879
#define VARIANCE_SYM 880
#define VARYING 881
#define VAR_SAMP_SYM 882
#define VIEW_SYM 883
#define VIRTUAL_SYM 884
#define WAIT_SYM 885
#define WARNINGS 886
#define WEEK_SYM 887
#define WEIGHT_STRING_SYM 888
#define WHEN_SYM 889
#define WHERE 890
#define WHILE_SYM 891
#define WITH 892
#define OBSOLETE_TOKEN_893 893
#define WITH_ROLLUP_SYM 894
#define WITHOUT_SYM 895
#define WORK_SYM 896
#define WRAPPER_SYM 897
#define WRITE_SYM 898
#define X509_SYM 899
#define XA_SYM 900
#define XID_SYM 901
#define XML_SYM 902
#define XOR 903
#define YEAR_MONTH_SYM 904
#define YEAR_SYM 905
#define ZEROFILL_SYM 906
#define JSON_UNQUOTED_SEPARATOR_SYM 907
#define PERSIST_SYM 908
#define ROLE_SYM 909
#define ADMIN_SYM 910
#define INVISIBLE_SYM 911
#define VISIBLE_SYM 912
#define EXCEPT_SYM 913
#define COMPONENT_SYM 914
#define RECURSIVE_SYM 915
#define GRAMMAR_SELECTOR_EXPR 916
#define GRAMMAR_SELECTOR_GCOL 917
#define GRAMMAR_SELECTOR_PART 918
#define GRAMMAR_SELECTOR_CTE 919
#define JSON_OBJECTAGG 920
#define JSON_ARRAYAGG 921
#define OF_SYM 922
#define SKIP_SYM 923
#define LOCKED_SYM 924
#define NOWAIT_SYM 925
#define GROUPING_SYM 926
#define PERSIST_ONLY_SYM 927
#define HISTOGRAM_SYM 928
#define BUCKETS_SYM 929
#define OBSOLETE_TOKEN_930 930
#define CLONE_SYM 931
#define CUME_DIST_SYM 932
#define DENSE_RANK_SYM 933
#define EXCLUDE_SYM 934
#define FIRST_VALUE_SYM 935
#define FOLLOWING_SYM 936
#define GROUPS_SYM 937
#define LAG_SYM 938
#define LAST_VALUE_SYM 939
#define LEAD_SYM 940
#define NTH_VALUE_SYM 941
#define NTILE_SYM 942
#define NULLS_SYM 943
#define OTHERS_SYM 944
#define OVER_SYM 945
#define PERCENT_RANK_SYM 946
#define PRECEDING_SYM 947
#define RANK_SYM 948
#define RESPECT_SYM 949
#define ROW_NUMBER_SYM 950
#define TIES_SYM 951
#define UNBOUNDED_SYM 952
#define WINDOW_SYM 953
#define EMPTY_SYM 954
#define JSON_TABLE_SYM 955
#define NESTED_SYM 956
#define ORDINALITY_SYM 957
#define PATH_SYM 958
#define HISTORY_SYM 959
#define REUSE_SYM 960
#define SRID_SYM 961
#define THREAD_PRIORITY_SYM 962
#define RESOURCE_SYM 963
#define SYSTEM_SYM 964
#define VCPU_SYM 965
#define MASTER_PUBLIC_KEY_PATH_SYM 966
#define GET_MASTER_PUBLIC_KEY_SYM 967
#define RESTART_SYM 968
#define DEFINITION_SYM 969
#define DESCRIPTION_SYM 970
#define ORGANIZATION_SYM 971
#define REFERENCE_SYM 972
#define ACTIVE_SYM 973
#define INACTIVE_SYM 974
#define LATERAL_SYM 975
#define ARRAY_SYM 976
#define MEMBER_SYM 977
#define OPTIONAL_SYM 978
#define SECONDARY_SYM 979
#define SECONDARY_ENGINE_SYM 980
#define SECONDARY_LOAD_SYM 981
#define SECONDARY_UNLOAD_SYM 982
#define RETAIN_SYM 983
#define OLD_SYM 984
#define ENFORCED_SYM 985
#define OJ_SYM 986
#define NETWORK_NAMESPACE_SYM 987
#define RANDOM_SYM 988
#define MASTER_COMPRESSION_ALGORITHM_SYM 989
#define MASTER_ZSTD_COMPRESSION_LEVEL_SYM 990
#define PRIVILEGE_CHECKS_USER_SYM 991
#define MASTER_TLS_CIPHERSUITES_SYM 992
#define REQUIRE_ROW_FORMAT_SYM 993
#define PASSWORD_LOCK_TIME_SYM 994
#define FAILED_LOGIN_ATTEMPTS_SYM 995
#define REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYM 996
#define STREAM_SYM 997
#define OFF_SYM 998
#define RETURNING_SYM 999
#define YYUNDEF 1150
#define JSON_VALUE_SYM 1151
#define TLS_SYM 1152
#define ATTRIBUTE_SYM 1153
#define ENGINE_ATTRIBUTE_SYM 1154
#define SECONDARY_ENGINE_ATTRIBUTE_SYM 1155
#define SOURCE_CONNECTION_AUTO_FAILOVER_SYM 1156
#define ZONE_SYM 1157
#define GRAMMAR_SELECTOR_DERIVED_EXPR 1158
#define REPLICA_SYM 1159
#define REPLICAS_SYM 1160
#define ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_SYM 1161
#define GET_SOURCE_PUBLIC_KEY_SYM 1162
#define SOURCE_AUTO_POSITION_SYM 1163
#define SOURCE_BIND_SYM 1164
#define SOURCE_COMPRESSION_ALGORITHM_SYM 1165
#define SOURCE_CONNECT_RETRY_SYM 1166
#define SOURCE_DELAY_SYM 1167
#define SOURCE_HEARTBEAT_PERIOD_SYM 1168
#define SOURCE_HOST_SYM 1169
#define SOURCE_LOG_FILE_SYM 1170
#define SOURCE_LOG_POS_SYM 1171
#define SOURCE_PASSWORD_SYM 1172
#define SOURCE_PORT_SYM 1173
#define SOURCE_PUBLIC_KEY_PATH_SYM 1174
#define SOURCE_RETRY_COUNT_SYM 1175
#define SOURCE_SSL_SYM 1176
#define SOURCE_SSL_CA_SYM 1177
#define SOURCE_SSL_CAPATH_SYM 1178
#define SOURCE_SSL_CERT_SYM 1179
#define SOURCE_SSL_CIPHER_SYM 1180
#define SOURCE_SSL_CRL_SYM 1181
#define SOURCE_SSL_CRLPATH_SYM 1182
#define SOURCE_SSL_KEY_SYM 1183
#define SOURCE_SSL_VERIFY_SERVER_CERT_SYM 1184
#define SOURCE_TLS_CIPHERSUITES_SYM 1185
#define SOURCE_TLS_VERSION_SYM 1186
#define SOURCE_USER_SYM 1187
#define SOURCE_ZSTD_COMPRESSION_LEVEL_SYM 1188
#define ST_COLLECT_SYM 1189
#define KEYRING_SYM 1190
#define AUTHENTICATION_SYM 1191
#define FACTOR_SYM 1192
#define FINISH_SYM 1193
#define INITIATE_SYM 1194
#define REGISTRATION_SYM 1195
#define UNREGISTER_SYM 1196
#define INITIAL_SYM 1197
#define CHALLENGE_RESPONSE_SYM 1198
#define GTID_ONLY_SYM 1199
#define KEYWORD_USED_AS_IDENT 1201
#define KEYWORD_USED_AS_KEYWORD 1202
#define CONDITIONLESS_JOIN 1203
#define SUBQUERY_AS_EXPR 1204
#define EMPTY_FROM_CLAUSE 1205

#define SYM_OR_NULL(A) A

#define SYM(T, A) STRING_WITH_LEN(T), SYM_OR_NULL(A), SG_KEYWORDS
#define SYM_FN(T, A) STRING_WITH_LEN(T), SYM_OR_NULL(A), SG_FUNCTIONS
#define SYM_HK(T, A) STRING_WITH_LEN(T), SYM_OR_NULL(A), SG_HINTABLE_KEYWORDS
#define SYM_H(T, A) STRING_WITH_LEN(T), SYM_OR_NULL(A), SG_HINTS

static const SYMBOL symbols[] = {
    /*
     Insert new SQL keywords after that commentary (by alphabetical order):
    */
    {SYM("&&", AND_AND_SYM)},
    {SYM("<", LT)},
    {SYM("<=", LE)},
    {SYM("<>", NE)},
    {SYM("!=", NE)},
    {SYM("=", EQ)},
    {SYM(">", GT_SYM)},
    {SYM(">=", GE)},
    {SYM("<<", SHIFT_LEFT)},
    {SYM(">>", SHIFT_RIGHT)},
    {SYM("<=>", EQUAL_SYM)},
    {SYM("ACCESSIBLE", ACCESSIBLE_SYM)},
    {SYM("ACCOUNT", ACCOUNT_SYM)},
    {SYM("ACTION", ACTION)},
    {SYM("ACTIVE", ACTIVE_SYM)},
    {SYM("ADD", ADD)},
    {SYM("ADMIN", ADMIN_SYM)},
    {SYM("AFTER", AFTER_SYM)},
    {SYM("AGAINST", AGAINST)},
    {SYM("AGGREGATE", AGGREGATE_SYM)},
    {SYM("ALL", ALL)},
    {SYM("ALGORITHM", ALGORITHM_SYM)},
    {SYM("ALTER", ALTER)},
    {SYM("ALWAYS", ALWAYS_SYM)},
    {SYM("ANALYZE", ANALYZE_SYM)},
    {SYM("AND", AND_SYM)},
    {SYM("ANY", ANY_SYM)},
    {SYM("ARRAY", ARRAY_SYM)},
    {SYM("AS", AS)},
    {SYM("ASC", ASC)},
    {SYM("ASCII", ASCII_SYM)},
    {SYM("ASENSITIVE", ASENSITIVE_SYM)},
    {SYM("AT", AT_SYM)},
    {SYM("ATTRIBUTE", ATTRIBUTE_SYM)},
    {SYM("AUTHENTICATION", AUTHENTICATION_SYM)},
    {SYM("AUTO_INCREMENT", AUTO_INC)},
    {SYM("AUTOEXTEND_SIZE", AUTOEXTEND_SIZE_SYM)},
    {SYM("AVG", AVG_SYM)},
    {SYM("AVG_ROW_LENGTH", AVG_ROW_LENGTH)},
    {SYM("BACKUP", BACKUP_SYM)},
    {SYM("BEFORE", BEFORE_SYM)},
    {SYM("BEGIN", BEGIN_SYM)},
    {SYM("BETWEEN", BETWEEN_SYM)},
    {SYM("BIGINT", BIGINT_SYM)},
    {SYM("BINARY", BINARY_SYM)},
    {SYM("BINLOG", BINLOG_SYM)},
    {SYM("BIT", BIT_SYM)},
    {SYM("BLOB", BLOB_SYM)},
    {SYM("BLOCK", BLOCK_SYM)},
    {SYM("BOOL", BOOL_SYM)},
    {SYM("BOOLEAN", BOOLEAN_SYM)},
    {SYM("BOTH", BOTH)},
    {SYM("BTREE", BTREE_SYM)},
    {SYM("BUCKETS", BUCKETS_SYM)},
    {SYM("BY", BY)},
    {SYM("BYTE", BYTE_SYM)},
    {SYM("CACHE", CACHE_SYM)},
    {SYM("CALL", CALL_SYM)},
    {SYM("CASCADE", CASCADE)},
    {SYM("CASCADED", CASCADED)},
    {SYM("CASE", CASE_SYM)},
    {SYM("CATALOG_NAME", CATALOG_NAME_SYM)},
    {SYM("CHAIN", CHAIN_SYM)},
    {SYM("CHALLENGE_RESPONSE", CHALLENGE_RESPONSE_SYM)},
    {SYM("CHANGE", CHANGE)},
    {SYM("CHANGED", CHANGED)},
    {SYM("CHANNEL", CHANNEL_SYM)},
    {SYM("CHAR", CHAR_SYM)},
    {SYM("CHARACTER", CHAR_SYM)},
    {SYM("CHARSET", CHARSET)},
    {SYM("CHECK", CHECK_SYM)},
    {SYM("CHECKSUM", CHECKSUM_SYM)},
    {SYM("CIPHER", CIPHER_SYM)},
    {SYM("CLASS_ORIGIN", CLASS_ORIGIN_SYM)},
    {SYM("CLIENT", CLIENT_SYM)},
    {SYM("CLONE", CLONE_SYM)},
    {SYM("CLOSE", CLOSE_SYM)},
    {SYM("COALESCE", COALESCE)},
    {SYM("CODE", CODE_SYM)},
    {SYM("COLLATE", COLLATE_SYM)},
    {SYM("COLLATION", COLLATION_SYM)},
    {SYM("COLUMN", COLUMN_SYM)},
    {SYM("COLUMN_FORMAT", COLUMN_FORMAT_SYM)},
    {SYM("COLUMN_NAME", COLUMN_NAME_SYM)},
    {SYM("COLUMNS", COLUMNS)},
    {SYM("COMMENT", COMMENT_SYM)},
    {SYM("COMMIT", COMMIT_SYM)},
    {SYM("COMMITTED", COMMITTED_SYM)},
    {SYM("COMPACT", COMPACT_SYM)},
    {SYM("COMPLETION", COMPLETION_SYM)},
    {SYM("COMPONENT", COMPONENT_SYM)},
    {SYM("COMPRESSION", COMPRESSION_SYM)},
    {SYM("COMPRESSED", COMPRESSED_SYM)},
    {SYM("ENCRYPTION", ENCRYPTION_SYM)},
    {SYM("CONCURRENT", CONCURRENT)},
    {SYM("CONDITION", CONDITION_SYM)},
    {SYM("CONNECTION", CONNECTION_SYM)},
    {SYM("CONSISTENT", CONSISTENT_SYM)},
    {SYM("CONSTRAINT", CONSTRAINT)},
    {SYM("CONSTRAINT_CATALOG", CONSTRAINT_CATALOG_SYM)},
    {SYM("CONSTRAINT_NAME", CONSTRAINT_NAME_SYM)},
    {SYM("CONSTRAINT_SCHEMA", CONSTRAINT_SCHEMA_SYM)},
    {SYM("CONTAINS", CONTAINS_SYM)},
    {SYM("CONTEXT", CONTEXT_SYM)},
    {SYM("CONTINUE", CONTINUE_SYM)},
    {SYM("CONVERT", CONVERT_SYM)},
    {SYM("CPU", CPU_SYM)},
    {SYM("CREATE", CREATE)},
    {SYM("CROSS", CROSS)},
    {SYM("CUBE", CUBE_SYM)},
    {SYM("CUME_DIST", CUME_DIST_SYM)},
    {SYM("CURRENT", CURRENT_SYM)},
    {SYM("CURRENT_DATE", CURDATE)},
    {SYM("CURRENT_TIME", CURTIME)},
    {SYM("CURRENT_TIMESTAMP", NOW_SYM)},
    {SYM("CURRENT_USER", CURRENT_USER)},
    {SYM("CURSOR", CURSOR_SYM)},
    {SYM("CURSOR_NAME", CURSOR_NAME_SYM)},
    {SYM("DATA", DATA_SYM)},
    {SYM("DATABASE", DATABASE)},
    {SYM("DATABASES", DATABASES)},
    {SYM("DATAFILE", DATAFILE_SYM)},
    {SYM("DATE", DATE_SYM)},
    {SYM("DATETIME", DATETIME_SYM)},
    {SYM("DAY", DAY_SYM)},
    {SYM("DAY_HOUR", DAY_HOUR_SYM)},
    {SYM("DAY_MICROSECOND", DAY_MICROSECOND_SYM)},
    {SYM("DAY_MINUTE", DAY_MINUTE_SYM)},
    {SYM("DAY_SECOND", DAY_SECOND_SYM)},
    {SYM("DEALLOCATE", DEALLOCATE_SYM)},
    {SYM("DEC", DECIMAL_SYM)},
    {SYM("DECIMAL", DECIMAL_SYM)},
    {SYM("DECLARE", DECLARE_SYM)},
    {SYM("DEFAULT", DEFAULT_SYM)},
    {SYM("DEFAULT_AUTH", DEFAULT_AUTH_SYM)},
    {SYM("DEFINER", DEFINER_SYM)},
    {SYM("DEFINITION", DEFINITION_SYM)},
    {SYM("DELAYED", DELAYED_SYM)},
    {SYM("DELAY_KEY_WRITE", DELAY_KEY_WRITE_SYM)},
    {SYM("DENSE_RANK", DENSE_RANK_SYM)},
    {SYM("DESC", DESC)},
    {SYM("DESCRIBE", DESCRIBE)},
    {SYM("DESCRIPTION", DESCRIPTION_SYM)},
    {SYM("DETERMINISTIC", DETERMINISTIC_SYM)},
    {SYM("DIAGNOSTICS", DIAGNOSTICS_SYM)},
    {SYM("DIRECTORY", DIRECTORY_SYM)},
    {SYM("DISABLE", DISABLE_SYM)},
    {SYM("DISCARD", DISCARD_SYM)},
    {SYM("DISK", DISK_SYM)},
    {SYM("DISTINCT", DISTINCT)},
    {SYM("DISTINCTROW", DISTINCT)}, /* Access likes this */
    {SYM("DIV", DIV_SYM)},
    {SYM("DO", DO_SYM)},
    {SYM("DOUBLE", DOUBLE_SYM)},
    {SYM("DROP", DROP)},
    {SYM("DUAL", DUAL_SYM)},
    {SYM("DUMPFILE", DUMPFILE)},
    {SYM("DUPLICATE", DUPLICATE_SYM)},
    {SYM("DYNAMIC", DYNAMIC_SYM)},
    {SYM("EACH", EACH_SYM)},
    {SYM("ELSE", ELSE)},
    {SYM("ELSEIF", ELSEIF_SYM)},
    {SYM("EMPTY", EMPTY_SYM)},
    {SYM("ENABLE", ENABLE_SYM)},
    {SYM("ENCLOSED", ENCLOSED)},
    {SYM("END", END)},
    {SYM("ENDS", ENDS_SYM)},
    {SYM("ENFORCED", ENFORCED_SYM)},
    {SYM("ENGINE", ENGINE_SYM)},
    {SYM("ENGINE_ATTRIBUTE", ENGINE_ATTRIBUTE_SYM)},
    {SYM("ENGINES", ENGINES_SYM)},
    {SYM("ENUM", ENUM_SYM)},
    {SYM("ERROR", ERROR_SYM)},
    {SYM("ERRORS", ERRORS)},
    {SYM("ESCAPE", ESCAPE_SYM)},
    {SYM("ESCAPED", ESCAPED)},
    {SYM("EVENT", EVENT_SYM)},
    {SYM("EVENTS", EVENTS_SYM)},
    {SYM("EVERY", EVERY_SYM)},
    {SYM("EXCEPT", EXCEPT_SYM)},
    {SYM("EXCHANGE", EXCHANGE_SYM)},
    {SYM("EXCLUDE", EXCLUDE_SYM)},
    {SYM("EXECUTE", EXECUTE_SYM)},
    {SYM("EXISTS", EXISTS)},
    {SYM("EXIT", EXIT_SYM)},
    {SYM("EXPANSION", EXPANSION_SYM)},
    {SYM("EXPORT", EXPORT_SYM)},
    {SYM("EXPIRE", EXPIRE_SYM)},
    {SYM("EXPLAIN", DESCRIBE)},
    {SYM("EXTENDED", EXTENDED_SYM)},
    {SYM("EXTENT_SIZE", EXTENT_SIZE_SYM)},
    {SYM("FACTOR", FACTOR_SYM)},
    {SYM("FAILED_LOGIN_ATTEMPTS", FAILED_LOGIN_ATTEMPTS_SYM)},
    {SYM("FALSE", FALSE_SYM)},
    {SYM("FAST", FAST_SYM)},
    {SYM("FAULTS", FAULTS_SYM)},
    {SYM("FETCH", FETCH_SYM)},
    {SYM("FIELDS", COLUMNS)},
    {SYM("FILE", FILE_SYM)},
    {SYM("FILE_BLOCK_SIZE", FILE_BLOCK_SIZE_SYM)},
    {SYM("FILTER", FILTER_SYM)},
    {SYM("FINISH", FINISH_SYM)},
    {SYM("FIRST", FIRST_SYM)},
    {SYM("FIRST_VALUE", FIRST_VALUE_SYM)},
    {SYM("FIXED", FIXED_SYM)},
    {SYM("FLOAT", FLOAT_SYM)},
    {SYM("FLOAT4", FLOAT_SYM)},
    {SYM("FLOAT8", DOUBLE_SYM)},
    {SYM("FLUSH", FLUSH_SYM)},
    {SYM("FOLLOWS", FOLLOWS_SYM)},
    {SYM("FOLLOWING", FOLLOWING_SYM)},
    {SYM("FOR", FOR_SYM)},
    {SYM("FORCE", FORCE_SYM)},
    {SYM("FOREIGN", FOREIGN)},
    {SYM("FORMAT", FORMAT_SYM)},
    {SYM("FOUND", FOUND_SYM)},
    {SYM("FROM", FROM)},
    {SYM("FULL", FULL)},
    {SYM("FULLTEXT", FULLTEXT_SYM)},
    {SYM("FUNCTION", FUNCTION_SYM)},
    {SYM("GENERAL", GENERAL)},
    {SYM("GROUP_REPLICATION", GROUP_REPLICATION)},
    {SYM("GEOMCOLLECTION", GEOMETRYCOLLECTION_SYM)},
    {SYM("GEOMETRY", GEOMETRY_SYM)},
    {SYM("GEOMETRYCOLLECTION", GEOMETRYCOLLECTION_SYM)},
    {SYM("GET_FORMAT", GET_FORMAT)},
    {SYM("GET_MASTER_PUBLIC_KEY", GET_MASTER_PUBLIC_KEY_SYM)},
    {SYM("GET_SOURCE_PUBLIC_KEY", GET_SOURCE_PUBLIC_KEY_SYM)},
    {SYM("GET", GET_SYM)},
    {SYM("GENERATED", GENERATED)},
    {SYM("GLOBAL", GLOBAL_SYM)},
    {SYM("GRANT", GRANT)},
    {SYM("GRANTS", GRANTS)},
    {SYM("GROUP", GROUP_SYM)},
    {SYM("GROUPING", GROUPING_SYM)},
    {SYM("GROUPS", GROUPS_SYM)},
    {SYM("GTID_ONLY", GTID_ONLY_SYM)},
    {SYM("HANDLER", HANDLER_SYM)},
    {SYM("HASH", HASH_SYM)},
    {SYM("HAVING", HAVING)},
    {SYM("HELP", HELP_SYM)},
    {SYM("HIGH_PRIORITY", HIGH_PRIORITY)},
    {SYM("HISTOGRAM", HISTOGRAM_SYM)},
    {SYM("HISTORY", HISTORY_SYM)},
    {SYM("HOST", HOST_SYM)},
    {SYM("HOSTS", HOSTS_SYM)},
    {SYM("HOUR", HOUR_SYM)},
    {SYM("HOUR_MICROSECOND", HOUR_MICROSECOND_SYM)},
    {SYM("HOUR_MINUTE", HOUR_MINUTE_SYM)},
    {SYM("HOUR_SECOND", HOUR_SECOND_SYM)},
    {SYM("IDENTIFIED", IDENTIFIED_SYM)},
    {SYM("IF", IF)},
    {SYM("IGNORE", IGNORE_SYM)},
    {SYM("IGNORE_SERVER_IDS", IGNORE_SERVER_IDS_SYM)},
    {SYM("IMPORT", IMPORT)},
    {SYM("IN", IN_SYM)},
    {SYM("INACTIVE", INACTIVE_SYM)},
    {SYM("INDEX", INDEX_SYM)},
    {SYM("INDEXES", INDEXES)},
    {SYM("INFILE", INFILE)},
    {SYM("INITIAL", INITIAL_SYM)},
    {SYM("INITIAL_SIZE", INITIAL_SIZE_SYM)},
    {SYM("INITIATE", INITIATE_SYM)},
    {SYM("INNER", INNER_SYM)},
    {SYM("INOUT", INOUT_SYM)},
    {SYM("INSENSITIVE", INSENSITIVE_SYM)},
    {SYM("INSERT_METHOD", INSERT_METHOD)},
    {SYM("INSTALL", INSTALL_SYM)},
    {SYM("INSTANCE", INSTANCE_SYM)},
    {SYM("INT", INT_SYM)},
    {SYM("INT1", TINYINT_SYM)},
    {SYM("INT2", SMALLINT_SYM)},
    {SYM("INT3", MEDIUMINT_SYM)},
    {SYM("INT4", INT_SYM)},
    {SYM("INT8", BIGINT_SYM)},
    {SYM("INTEGER", INT_SYM)},
    {SYM("INTERVAL", INTERVAL_SYM)},
    {SYM("INTO", INTO)},
    {SYM("IO", IO_SYM)},
    {SYM("IO_AFTER_GTIDS", IO_AFTER_GTIDS)},
    {SYM("IO_BEFORE_GTIDS", IO_BEFORE_GTIDS)},
    {SYM("IO_THREAD", RELAY_THREAD)},
    {SYM("IPC", IPC_SYM)},
    {SYM("IS", IS)},
    {SYM("ISOLATION", ISOLATION)},
    {SYM("ISSUER", ISSUER_SYM)},
    {SYM("ITERATE", ITERATE_SYM)},
    {SYM("INVISIBLE", INVISIBLE_SYM)},
    {SYM("INVOKER", INVOKER_SYM)},
    {SYM("JOIN", JOIN_SYM)},
    {SYM("JSON", JSON_SYM)},
    {SYM("JSON_TABLE", JSON_TABLE_SYM)},
    {SYM("JSON_VALUE", JSON_VALUE_SYM)},
    {SYM("KEY", KEY_SYM)},
    {SYM("KEYRING", KEYRING_SYM)},
    {SYM("KEYS", KEYS)},
    {SYM("KEY_BLOCK_SIZE", KEY_BLOCK_SIZE)},
    {SYM("KILL", KILL_SYM)},
    {SYM("LAG", LAG_SYM)},
    {SYM("LANGUAGE", LANGUAGE_SYM)},
    {SYM("LAST", LAST_SYM)},
    {SYM("LAST_VALUE", LAST_VALUE_SYM)},
    {SYM("LATERAL", LATERAL_SYM)},
    {SYM("LEAD", LEAD_SYM)},
    {SYM("LEADING", LEADING)},
    {SYM("LEAVE", LEAVE_SYM)},
    {SYM("LEAVES", LEAVES)},
    {SYM("LEFT", LEFT)},
    {SYM("LESS", LESS_SYM)},
    {SYM("LEVEL", LEVEL_SYM)},
    {SYM("LIKE", LIKE)},
    {SYM("LIMIT", LIMIT)},
    {SYM("LINEAR", LINEAR_SYM)},
    {SYM("LINES", LINES)},
    {SYM("LINESTRING", LINESTRING_SYM)},
    {SYM("LIST", LIST_SYM)},
    {SYM("LOAD", LOAD)},
    {SYM("LOCAL", LOCAL_SYM)},
    {SYM("LOCALTIME", NOW_SYM)},
    {SYM("LOCALTIMESTAMP", NOW_SYM)},
    {SYM("LOCK", LOCK_SYM)},
    {SYM("LOCKED", LOCKED_SYM)},
    {SYM("LOCKS", LOCKS_SYM)},
    {SYM("LOGFILE", LOGFILE_SYM)},
    {SYM("LOGS", LOGS_SYM)},
    {SYM("LONG", LONG_SYM)},
    {SYM("LONGBLOB", LONGBLOB_SYM)},
    {SYM("LONGTEXT", LONGTEXT_SYM)},
    {SYM("LOOP", LOOP_SYM)},
    {SYM("LOW_PRIORITY", LOW_PRIORITY)},
    {SYM("MASTER", MASTER_SYM)},
    {SYM("MASTER_AUTO_POSITION", MASTER_AUTO_POSITION_SYM)},
    {SYM("MASTER_BIND", MASTER_BIND_SYM)},
    {SYM("MASTER_CONNECT_RETRY", MASTER_CONNECT_RETRY_SYM)},
    {SYM("MASTER_COMPRESSION_ALGORITHMS", MASTER_COMPRESSION_ALGORITHM_SYM)},
    {SYM("MASTER_DELAY", MASTER_DELAY_SYM)},
    {SYM("MASTER_HEARTBEAT_PERIOD", MASTER_HEARTBEAT_PERIOD_SYM)},
    {SYM("MASTER_HOST", MASTER_HOST_SYM)},
    {SYM("MASTER_LOG_FILE", MASTER_LOG_FILE_SYM)},
    {SYM("MASTER_LOG_POS", MASTER_LOG_POS_SYM)},
    {SYM("MASTER_PASSWORD", MASTER_PASSWORD_SYM)},
    {SYM("MASTER_PORT", MASTER_PORT_SYM)},
    {SYM("MASTER_PUBLIC_KEY_PATH", MASTER_PUBLIC_KEY_PATH_SYM)},
    {SYM("MASTER_RETRY_COUNT", MASTER_RETRY_COUNT_SYM)},
    {SYM("MASTER_SSL", MASTER_SSL_SYM)},
    {SYM("MASTER_SSL_CA", MASTER_SSL_CA_SYM)},
    {SYM("MASTER_SSL_CAPATH", MASTER_SSL_CAPATH_SYM)},
    {SYM("MASTER_SSL_CERT", MASTER_SSL_CERT_SYM)},
    {SYM("MASTER_SSL_CIPHER", MASTER_SSL_CIPHER_SYM)},
    {SYM("MASTER_SSL_CRL", MASTER_SSL_CRL_SYM)},
    {SYM("MASTER_SSL_CRLPATH", MASTER_SSL_CRLPATH_SYM)},
    {SYM("MASTER_SSL_KEY", MASTER_SSL_KEY_SYM)},
    {SYM("MASTER_SSL_VERIFY_SERVER_CERT", MASTER_SSL_VERIFY_SERVER_CERT_SYM)},
    {SYM("MASTER_TLS_CIPHERSUITES", MASTER_TLS_CIPHERSUITES_SYM)},
    {SYM("MASTER_TLS_VERSION", MASTER_TLS_VERSION_SYM)},
    {SYM("MASTER_USER", MASTER_USER_SYM)},
    {SYM("MASTER_ZSTD_COMPRESSION_LEVEL", MASTER_ZSTD_COMPRESSION_LEVEL_SYM)},
    {SYM("MATCH", MATCH)},
    {SYM("MAX_CONNECTIONS_PER_HOUR", MAX_CONNECTIONS_PER_HOUR)},
    {SYM("MAX_QUERIES_PER_HOUR", MAX_QUERIES_PER_HOUR)},
    {SYM("MAX_ROWS", MAX_ROWS)},
    {SYM("MAX_SIZE", MAX_SIZE_SYM)},
    {SYM("MAX_UPDATES_PER_HOUR", MAX_UPDATES_PER_HOUR)},
    {SYM("MAX_USER_CONNECTIONS", MAX_USER_CONNECTIONS_SYM)},
    {SYM("MAXVALUE", MAX_VALUE_SYM)},
    {SYM("MEDIUM", MEDIUM_SYM)},
    {SYM("MEDIUMBLOB", MEDIUMBLOB_SYM)},
    {SYM("MEDIUMINT", MEDIUMINT_SYM)},
    {SYM("MEDIUMTEXT", MEDIUMTEXT_SYM)},
    {SYM("MEMBER", MEMBER_SYM)},
    {SYM("MEMORY", MEMORY_SYM)},
    {SYM("MERGE", MERGE_SYM)},
    {SYM("MESSAGE_TEXT", MESSAGE_TEXT_SYM)},
    {SYM("MICROSECOND", MICROSECOND_SYM)},
    {SYM("MIDDLEINT", MEDIUMINT_SYM)}, /* For powerbuilder */
    {SYM("MIGRATE", MIGRATE_SYM)},
    {SYM("MINUTE", MINUTE_SYM)},
    {SYM("MINUTE_MICROSECOND", MINUTE_MICROSECOND_SYM)},
    {SYM("MINUTE_SECOND", MINUTE_SECOND_SYM)},
    {SYM("MIN_ROWS", MIN_ROWS)},
    {SYM("MOD", MOD_SYM)},
    {SYM("MODE", MODE_SYM)},
    {SYM("MODIFIES", MODIFIES_SYM)},
    {SYM("MODIFY", MODIFY_SYM)},
    {SYM("MONTH", MONTH_SYM)},
    {SYM("MULTILINESTRING", MULTILINESTRING_SYM)},
    {SYM("MULTIPOINT", MULTIPOINT_SYM)},
    {SYM("MULTIPOLYGON", MULTIPOLYGON_SYM)},
    {SYM("MUTEX", MUTEX_SYM)},
    {SYM("MYSQL_ERRNO", MYSQL_ERRNO_SYM)},
    {SYM("NAME", NAME_SYM)},
    {SYM("NAMES", NAMES_SYM)},
    {SYM("NATIONAL", NATIONAL_SYM)},
    {SYM("NATURAL", NATURAL)},
    {SYM("NDB", NDBCLUSTER_SYM)},
    {SYM("NDBCLUSTER", NDBCLUSTER_SYM)},
    {SYM("NCHAR", NCHAR_SYM)},
    {SYM("NESTED", NESTED_SYM)},
    {SYM("NETWORK_NAMESPACE", NETWORK_NAMESPACE_SYM)},
    {SYM("NEVER", NEVER_SYM)},
    {SYM("NEW", NEW_SYM)},
    {SYM("NEXT", NEXT_SYM)},
    {SYM("NO", NO_SYM)},
    {SYM("NO_WAIT", NO_WAIT_SYM)},
    {SYM("NOWAIT", NOWAIT_SYM)},
    {SYM("NODEGROUP", NODEGROUP_SYM)},
    {SYM("NONE", NONE_SYM)},
    {SYM("NOT", NOT_SYM)},
    {SYM("NO_WRITE_TO_BINLOG", NO_WRITE_TO_BINLOG)},
    {SYM("NTH_VALUE", NTH_VALUE_SYM)},
    {SYM("NTILE", NTILE_SYM)},
    {SYM("NULL", NULL_SYM)},
    {SYM("NULLS", NULLS_SYM)},
    {SYM("NUMBER", NUMBER_SYM)},
    {SYM("NUMERIC", NUMERIC_SYM)},
    {SYM("NVARCHAR", NVARCHAR_SYM)},
    {SYM("OF", OF_SYM)},
    {SYM("OFF", OFF_SYM)},
    {SYM("OFFSET", OFFSET_SYM)},
    {SYM("OJ", OJ_SYM)},
    {SYM("OLD", OLD_SYM)},
    {SYM("ON", ON_SYM)},
    {SYM("ONE", ONE_SYM)},
    {SYM("ONLY", ONLY_SYM)},
    {SYM("OPEN", OPEN_SYM)},
    {SYM("OPTIMIZE", OPTIMIZE)},
    {SYM("OPTIMIZER_COSTS", OPTIMIZER_COSTS_SYM)},
    {SYM("OPTIONS", OPTIONS_SYM)},
    {SYM("OPTION", OPTION)},
    {SYM("OPTIONAL", OPTIONAL_SYM)},
    {SYM("OPTIONALLY", OPTIONALLY)},
    {SYM("OR", OR_SYM)},
    {SYM("ORGANIZATION", ORGANIZATION_SYM)},
    {SYM("OTHERS", OTHERS_SYM)},
    {SYM("ORDER", ORDER_SYM)},
    {SYM("ORDINALITY", ORDINALITY_SYM)},
    {SYM("OUT", OUT_SYM)},
    {SYM("OUTER", OUTER_SYM)},
    {SYM("OUTFILE", OUTFILE)},
    {SYM("OVER", OVER_SYM)},
    {SYM("OWNER", OWNER_SYM)},
    {SYM("PACK_KEYS", PACK_KEYS_SYM)},
    {SYM("PATH", PATH_SYM)},
    {SYM("PARSER", PARSER_SYM)},
    {SYM("PAGE", PAGE_SYM)},
    {SYM("PARTIAL", PARTIAL)},
    {SYM("PARTITION", PARTITION_SYM)},
    {SYM("PARTITIONING", PARTITIONING_SYM)},
    {SYM("PARTITIONS", PARTITIONS_SYM)},
    {SYM("PASSWORD", PASSWORD)},
    {SYM("PASSWORD_LOCK_TIME", PASSWORD_LOCK_TIME_SYM)},
    {SYM("PERCENT_RANK", PERCENT_RANK_SYM)},
    {SYM("PERSIST", PERSIST_SYM)},
    {SYM("PERSIST_ONLY", PERSIST_ONLY_SYM)},
    {SYM("PHASE", PHASE_SYM)},
    {SYM("PLUGIN", PLUGIN_SYM)},
    {SYM("PLUGINS", PLUGINS_SYM)},
    {SYM("PLUGIN_DIR", PLUGIN_DIR_SYM)},
    {SYM("POINT", POINT_SYM)},
    {SYM("POLYGON", POLYGON_SYM)},
    {SYM("PORT", PORT_SYM)},
    {SYM("PRECEDES", PRECEDES_SYM)},
    {SYM("PRECEDING", PRECEDING_SYM)},
    {SYM("PRECISION", PRECISION)},
    {SYM("PREPARE", PREPARE_SYM)},
    {SYM("PRESERVE", PRESERVE_SYM)},
    {SYM("PREV", PREV_SYM)},
    {SYM("PRIMARY", PRIMARY_SYM)},
    {SYM("PRIVILEGES", PRIVILEGES)},
    {SYM("PRIVILEGE_CHECKS_USER", PRIVILEGE_CHECKS_USER_SYM)},
    {SYM("PROCEDURE", PROCEDURE_SYM)},
    {SYM("PROCESS", PROCESS)},
    {SYM("PROCESSLIST", PROCESSLIST_SYM)},
    {SYM("PROFILE", PROFILE_SYM)},
    {SYM("PROFILES", PROFILES_SYM)},
    {SYM("PROXY", PROXY_SYM)},
    {SYM("PURGE", PURGE)},
    {SYM("QUARTER", QUARTER_SYM)},
    {SYM("QUERY", QUERY_SYM)},
    {SYM("QUICK", QUICK)},
    {SYM("RANDOM", RANDOM_SYM)},
    {SYM("RANK", RANK_SYM)},
    {SYM("RANGE", RANGE_SYM)},
    {SYM("READ", READ_SYM)},
    {SYM("READ_ONLY", READ_ONLY_SYM)},
    {SYM("READ_WRITE", READ_WRITE_SYM)},
    {SYM("READS", READS_SYM)},
    {SYM("REAL", REAL_SYM)},
    {SYM("REBUILD", REBUILD_SYM)},
    {SYM("RECOVER", RECOVER_SYM)},
    {SYM("RECURSIVE", RECURSIVE_SYM)},
    {SYM("REDO_BUFFER_SIZE", REDO_BUFFER_SIZE_SYM)},
    {SYM("REDUNDANT", REDUNDANT_SYM)},
    {SYM("REFERENCE", REFERENCE_SYM)},
    {SYM("REFERENCES", REFERENCES)},
    {SYM("REGEXP", REGEXP)},
    {SYM("REGISTRATION", REGISTRATION_SYM)},
    {SYM("RELAY", RELAY)},
    {SYM("RELAYLOG", RELAYLOG_SYM)},
    {SYM("RELAY_LOG_FILE", RELAY_LOG_FILE_SYM)},
    {SYM("RELAY_LOG_POS", RELAY_LOG_POS_SYM)},
    {SYM("RELAY_THREAD", RELAY_THREAD)},
    {SYM("RELEASE", RELEASE_SYM)},
    {SYM("RELOAD", RELOAD)},
    {SYM("REMOVE", REMOVE_SYM)},
    {SYM("RENAME", RENAME)},
    {SYM("ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS",
         ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_SYM)},
    {SYM("REORGANIZE", REORGANIZE_SYM)},
    {SYM("REPAIR", REPAIR)},
    {SYM("REPEATABLE", REPEATABLE_SYM)},
    {SYM("REPLICA", REPLICA_SYM)},
    {SYM("REPLICAS", REPLICAS_SYM)},
    {SYM("REPLICATION", REPLICATION)},
    {SYM("REPLICATE_DO_DB", REPLICATE_DO_DB)},
    {SYM("REPLICATE_IGNORE_DB", REPLICATE_IGNORE_DB)},
    {SYM("REPLICATE_DO_TABLE", REPLICATE_DO_TABLE)},
    {SYM("REPLICATE_IGNORE_TABLE", REPLICATE_IGNORE_TABLE)},
    {SYM("REPLICATE_WILD_DO_TABLE", REPLICATE_WILD_DO_TABLE)},
    {SYM("REPLICATE_WILD_IGNORE_TABLE", REPLICATE_WILD_IGNORE_TABLE)},
    {SYM("REPLICATE_REWRITE_DB", REPLICATE_REWRITE_DB)},
    {SYM("REPEAT", REPEAT_SYM)},
    {SYM("REQUIRE", REQUIRE_SYM)},
    {SYM("REQUIRE_ROW_FORMAT", REQUIRE_ROW_FORMAT_SYM)},
    {SYM("REQUIRE_TABLE_PRIMARY_KEY_CHECK",
         REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYM)},
    {SYM("RESET", RESET_SYM)},
    {SYM("RESPECT", RESPECT_SYM)},
    {SYM("RESIGNAL", RESIGNAL_SYM)},
    {SYM("RESOURCE", RESOURCE_SYM)},
    {SYM("RESTART", RESTART_SYM)},
    {SYM("RESTORE", RESTORE_SYM)},
    {SYM("RESTRICT", RESTRICT)},
    {SYM("RESUME", RESUME_SYM)},
    {SYM("RETAIN", RETAIN_SYM)},
    {SYM("RETURNED_SQLSTATE", RETURNED_SQLSTATE_SYM)},
    {SYM("RETURN", RETURN_SYM)},
    {SYM("RETURNING", RETURNING_SYM)},
    {SYM("RETURNS", RETURNS_SYM)},
    {SYM("REUSE", REUSE_SYM)},
    {SYM("REVERSE", REVERSE_SYM)},
    {SYM("REVOKE", REVOKE)},
    {SYM("RIGHT", RIGHT)},
    {SYM("RLIKE", REGEXP)}, /* Like in mSQL2 */
    {SYM("ROLE", ROLE_SYM)},
    {SYM("ROLLBACK", ROLLBACK_SYM)},
    {SYM("ROLLUP", ROLLUP_SYM)},
    {SYM("ROUTINE", ROUTINE_SYM)},
    {SYM("ROTATE", ROTATE_SYM)},
    {SYM("ROW", ROW_SYM)},
    {SYM("ROW_COUNT", ROW_COUNT_SYM)},
    {SYM("ROW_NUMBER", ROW_NUMBER_SYM)},
    {SYM("ROWS", ROWS_SYM)},
    {SYM("ROW_FORMAT", ROW_FORMAT_SYM)},
    {SYM("RTREE", RTREE_SYM)},
    {SYM("SAVEPOINT", SAVEPOINT_SYM)},
    {SYM("SCHEDULE", SCHEDULE_SYM)},
    {SYM("SCHEMA", DATABASE)},
    {SYM("SCHEMA_NAME", SCHEMA_NAME_SYM)},
    {SYM("SCHEMAS", DATABASES)},
    {SYM("SECOND", SECOND_SYM)},
    {SYM("SECOND_MICROSECOND", SECOND_MICROSECOND_SYM)},
    {SYM("SECONDARY", SECONDARY_SYM)},
    {SYM("SECONDARY_ENGINE", SECONDARY_ENGINE_SYM)},
    {SYM("SECONDARY_ENGINE_ATTRIBUTE", SECONDARY_ENGINE_ATTRIBUTE_SYM)},
    {SYM("SECONDARY_LOAD", SECONDARY_LOAD_SYM)},
    {SYM("SECONDARY_UNLOAD", SECONDARY_UNLOAD_SYM)},
    {SYM("SECURITY", SECURITY_SYM)},
    {SYM("SENSITIVE", SENSITIVE_SYM)},
    {SYM("SEPARATOR", SEPARATOR_SYM)},
    {SYM("SERIAL", SERIAL_SYM)},
    {SYM("SERIALIZABLE", SERIALIZABLE_SYM)},
    {SYM("SESSION", SESSION_SYM)},
    {SYM("SERVER", SERVER_SYM)},
    {SYM("SET", SET_SYM)},
    {SYM("SHARE", SHARE_SYM)},
    {SYM("SHOW", SHOW)},
    {SYM("SHUTDOWN", SHUTDOWN)},
    {SYM("SIGNAL", SIGNAL_SYM)},
    {SYM("SIGNED", SIGNED_SYM)},
    {SYM("SIMPLE", SIMPLE_SYM)},
    {SYM("SKIP", SKIP_SYM)},
    {SYM("SLAVE", SLAVE)},
    {SYM("SLOW", SLOW)},
    {SYM("SNAPSHOT", SNAPSHOT_SYM)},
    {SYM("SMALLINT", SMALLINT_SYM)},
    {SYM("SOCKET", SOCKET_SYM)},
    {SYM("SOME", ANY_SYM)},
    {SYM("SONAME", SONAME_SYM)},
    {SYM("SOUNDS", SOUNDS_SYM)},
    {SYM("SOURCE", SOURCE_SYM)},
    {SYM("SOURCE_AUTO_POSITION", SOURCE_AUTO_POSITION_SYM)},
    {SYM("SOURCE_BIND", SOURCE_BIND_SYM)},
    {SYM("SOURCE_COMPRESSION_ALGORITHMS", SOURCE_COMPRESSION_ALGORITHM_SYM)},
    {SYM("SOURCE_CONNECT_RETRY", SOURCE_CONNECT_RETRY_SYM)},
    {SYM("SOURCE_CONNECTION_AUTO_FAILOVER",
         SOURCE_CONNECTION_AUTO_FAILOVER_SYM)},
    {SYM("SOURCE_DELAY", SOURCE_DELAY_SYM)},
    {SYM("SOURCE_HEARTBEAT_PERIOD", SOURCE_HEARTBEAT_PERIOD_SYM)},
    {SYM("SOURCE_HOST", SOURCE_HOST_SYM)},
    {SYM("SOURCE_LOG_FILE", SOURCE_LOG_FILE_SYM)},
    {SYM("SOURCE_LOG_POS", SOURCE_LOG_POS_SYM)},
    {SYM("SOURCE_PASSWORD", SOURCE_PASSWORD_SYM)},
    {SYM("SOURCE_PORT", SOURCE_PORT_SYM)},
    {SYM("SOURCE_PUBLIC_KEY_PATH", SOURCE_PUBLIC_KEY_PATH_SYM)},
    {SYM("SOURCE_RETRY_COUNT", SOURCE_RETRY_COUNT_SYM)},
    {SYM("SOURCE_SSL_CAPATH", SOURCE_SSL_CAPATH_SYM)},
    {SYM("SOURCE_SSL_CA", SOURCE_SSL_CA_SYM)},
    {SYM("SOURCE_SSL_CERT", SOURCE_SSL_CERT_SYM)},
    {SYM("SOURCE_SSL_CIPHER", SOURCE_SSL_CIPHER_SYM)},
    {SYM("SOURCE_SSL_CRL", SOURCE_SSL_CRL_SYM)},
    {SYM("SOURCE_SSL_CRLPATH", SOURCE_SSL_CRLPATH_SYM)},
    {SYM("SOURCE_SSL_KEY", SOURCE_SSL_KEY_SYM)},
    {SYM("SOURCE_SSL", SOURCE_SSL_SYM)},
    {SYM("SOURCE_SSL_VERIFY_SERVER_CERT", SOURCE_SSL_VERIFY_SERVER_CERT_SYM)},
    {SYM("SOURCE_TLS_CIPHERSUITES", SOURCE_TLS_CIPHERSUITES_SYM)},
    {SYM("SOURCE_TLS_VERSION", SOURCE_TLS_VERSION_SYM)},
    {SYM("SOURCE_USER", SOURCE_USER_SYM)},
    {SYM("SOURCE_ZSTD_COMPRESSION_LEVEL", SOURCE_ZSTD_COMPRESSION_LEVEL_SYM)},
    {SYM("SPATIAL", SPATIAL_SYM)},
    {SYM("SPECIFIC", SPECIFIC_SYM)},
    {SYM("SQL", SQL_SYM)},
    {SYM("SQLEXCEPTION", SQLEXCEPTION_SYM)},
    {SYM("SQLSTATE", SQLSTATE_SYM)},
    {SYM("SQLWARNING", SQLWARNING_SYM)},
    {SYM("SQL_AFTER_GTIDS", SQL_AFTER_GTIDS)},
    {SYM("SQL_AFTER_MTS_GAPS", SQL_AFTER_MTS_GAPS)},
    {SYM("SQL_BEFORE_GTIDS", SQL_BEFORE_GTIDS)},
    {SYM("SQL_BIG_RESULT", SQL_BIG_RESULT)},
    {SYM("SQL_BUFFER_RESULT", SQL_BUFFER_RESULT)},
    {SYM("SQL_CALC_FOUND_ROWS", SQL_CALC_FOUND_ROWS)},
    {SYM("SQL_NO_CACHE", SQL_NO_CACHE_SYM)},
    {SYM("SQL_SMALL_RESULT", SQL_SMALL_RESULT)},
    {SYM("SQL_THREAD", SQL_THREAD)},
    {SYM("SQL_TSI_SECOND", SECOND_SYM)},
    {SYM("SQL_TSI_MINUTE", MINUTE_SYM)},
    {SYM("SQL_TSI_HOUR", HOUR_SYM)},
    {SYM("SQL_TSI_DAY", DAY_SYM)},
    {SYM("SQL_TSI_WEEK", WEEK_SYM)},
    {SYM("SQL_TSI_MONTH", MONTH_SYM)},
    {SYM("SQL_TSI_QUARTER", QUARTER_SYM)},
    {SYM("SQL_TSI_YEAR", YEAR_SYM)},
    {SYM("SRID", SRID_SYM)},
    {SYM("SSL", SSL_SYM)},
    {SYM("STACKED", STACKED_SYM)},
    {SYM("START", START_SYM)},
    {SYM("STARTING", STARTING)},
    {SYM("STARTS", STARTS_SYM)},
    {SYM("STATS_AUTO_RECALC", STATS_AUTO_RECALC_SYM)},
    {SYM("STATS_PERSISTENT", STATS_PERSISTENT_SYM)},
    {SYM("STATS_SAMPLE_PAGES", STATS_SAMPLE_PAGES_SYM)},
    {SYM("STATUS", STATUS_SYM)},
    {SYM("STOP", STOP_SYM)},
    {SYM("STORAGE", STORAGE_SYM)},
    {SYM("STORED", STORED_SYM)},
    {SYM("STRAIGHT_JOIN", STRAIGHT_JOIN)},
    {SYM("STREAM", STREAM_SYM)},
    {SYM("STRING", STRING_SYM)},
    {SYM("SUBCLASS_ORIGIN", SUBCLASS_ORIGIN_SYM)},
    {SYM("SUBJECT", SUBJECT_SYM)},
    {SYM("SUBPARTITION", SUBPARTITION_SYM)},
    {SYM("SUBPARTITIONS", SUBPARTITIONS_SYM)},
    {SYM("SUPER", SUPER_SYM)},
    {SYM("SUSPEND", SUSPEND_SYM)},
    {SYM("SWAPS", SWAPS_SYM)},
    {SYM("SWITCHES", SWITCHES_SYM)},
    {SYM("SYSTEM", SYSTEM_SYM)},
    {SYM("TABLE", TABLE_SYM)},
    {SYM("TABLE_NAME", TABLE_NAME_SYM)},
    {SYM("TABLES", TABLES)},
    {SYM("TABLESPACE", TABLESPACE_SYM)},
    {SYM("TABLE_CHECKSUM", TABLE_CHECKSUM_SYM)},
    {SYM("TEMPORARY", TEMPORARY)},
    {SYM("TEMPTABLE", TEMPTABLE_SYM)},
    {SYM("TERMINATED", TERMINATED)},
    {SYM("TEXT", TEXT_SYM)},
    {SYM("THAN", THAN_SYM)},
    {SYM("THEN", THEN_SYM)},
    {SYM("THREAD_PRIORITY", THREAD_PRIORITY_SYM)},
    {SYM("TIES", TIES_SYM)},
    {SYM("TIME", TIME_SYM)},
    {SYM("TIMESTAMP", TIMESTAMP_SYM)},
    {SYM("TIMESTAMPADD", TIMESTAMP_ADD)},
    {SYM("TIMESTAMPDIFF", TIMESTAMP_DIFF)},
    {SYM("TINYBLOB", TINYBLOB_SYM)},
    {SYM("TINYINT", TINYINT_SYM)},
    {SYM("TINYTEXT", TINYTEXT_SYN)},
    {SYM("TLS", TLS_SYM)},
    {SYM("TO", TO_SYM)},
    {SYM("TRAILING", TRAILING)},
    {SYM("TRANSACTION", TRANSACTION_SYM)},
    {SYM("TRIGGER", TRIGGER_SYM)},
    {SYM("TRIGGERS", TRIGGERS_SYM)},
    {SYM("TRUE", TRUE_SYM)},
    {SYM("TRUNCATE", TRUNCATE_SYM)},
    {SYM("TYPE", TYPE_SYM)},
    {SYM("TYPES", TYPES_SYM)},
    {SYM("UNBOUNDED", UNBOUNDED_SYM)},
    {SYM("UNCOMMITTED", UNCOMMITTED_SYM)},
    {SYM("UNDEFINED", UNDEFINED_SYM)},
    {SYM("UNDO_BUFFER_SIZE", UNDO_BUFFER_SIZE_SYM)},
    {SYM("UNDOFILE", UNDOFILE_SYM)},
    {SYM("UNDO", UNDO_SYM)},
    {SYM("UNICODE", UNICODE_SYM)},
    {SYM("UNION", UNION_SYM)},
    {SYM("UNIQUE", UNIQUE_SYM)},
    {SYM("UNKNOWN", UNKNOWN_SYM)},
    {SYM("UNLOCK", UNLOCK_SYM)},
    {SYM("UNINSTALL", UNINSTALL_SYM)},
    {SYM("UNREGISTER", UNREGISTER_SYM)},
    {SYM("UNSIGNED", UNSIGNED_SYM)},
    {SYM("UNTIL", UNTIL_SYM)},
    {SYM("UPGRADE", UPGRADE_SYM)},
    {SYM("USAGE", USAGE)},
    {SYM("USE", USE_SYM)},
    {SYM("USER", USER)},
    {SYM("USER_RESOURCES", RESOURCES)},
    {SYM("USE_FRM", USE_FRM)},
    {SYM("USING", USING)},
    {SYM("UTC_DATE", UTC_DATE_SYM)},
    {SYM("UTC_TIME", UTC_TIME_SYM)},
    {SYM("UTC_TIMESTAMP", UTC_TIMESTAMP_SYM)},
    {SYM("VALIDATION", VALIDATION_SYM)},
    {SYM("VALUE", VALUE_SYM)},
    {SYM("VALUES", VALUES)},
    {SYM("VARBINARY", VARBINARY_SYM)},
    {SYM("VARCHAR", VARCHAR_SYM)},
    {SYM("VARCHARACTER", VARCHAR_SYM)},
    {SYM("VARIABLES", VARIABLES)},
    {SYM("VARYING", VARYING)},
    {SYM("WAIT", WAIT_SYM)},
    {SYM("WARNINGS", WARNINGS)},
    {SYM("WEEK", WEEK_SYM)},
    {SYM("WEIGHT_STRING", WEIGHT_STRING_SYM)},
    {SYM("WHEN", WHEN_SYM)},
    {SYM("WHERE", WHERE)},
    {SYM("WHILE", WHILE_SYM)},
    {SYM("WINDOW", WINDOW_SYM)},
    {SYM("VCPU", VCPU_SYM)},
    {SYM("VIEW", VIEW_SYM)},
    {SYM("VIRTUAL", VIRTUAL_SYM)},
    {SYM("VISIBLE", VISIBLE_SYM)},
    {SYM("WITH", WITH)},
    {SYM("WITHOUT", WITHOUT_SYM)},
    {SYM("WORK", WORK_SYM)},
    {SYM("WRAPPER", WRAPPER_SYM)},
    {SYM("WRITE", WRITE_SYM)},
    {SYM("X509", X509_SYM)},
    {SYM("XOR", XOR)},
    {SYM("XA", XA_SYM)},
    {SYM("XID", XID_SYM)},
    {SYM("XML", XML_SYM)}, /* LOAD XML Arnold/Erik */
    {SYM("YEAR", YEAR_SYM)},
    {SYM("YEAR_MONTH", YEAR_MONTH_SYM)},
    {SYM("ZEROFILL", ZEROFILL_SYM)},
    {SYM("ZONE", ZONE_SYM)},
    {SYM("||", OR_OR_SYM)},
    /*
      Place keywords that accept optimizer hints below this comment.
    */
    {SYM_HK("DELETE", DELETE_SYM)},
    {SYM_HK("INSERT", INSERT_SYM)},
    {SYM_HK("REPLACE", REPLACE_SYM)},
    {SYM_HK("SELECT", SELECT_SYM)},
    {SYM_HK("UPDATE", UPDATE_SYM)},
    /*
     Insert new function definitions after that commentary (by alphabetical
     order)
    */
    {SYM_FN("ADDDATE", ADDDATE_SYM)},
    {SYM_FN("BIT_AND", BIT_AND_SYM)},
    {SYM_FN("BIT_OR", BIT_OR_SYM)},
    {SYM_FN("BIT_XOR", BIT_XOR_SYM)},
    {SYM_FN("CAST", CAST_SYM)},
    {SYM_FN("COUNT", COUNT_SYM)},
    {SYM_FN("CURDATE", CURDATE)},
    {SYM_FN("CURTIME", CURTIME)},
    {SYM_FN("DATE_ADD", DATE_ADD_INTERVAL)},
    {SYM_FN("DATE_SUB", DATE_SUB_INTERVAL)},
    {SYM_FN("EXTRACT", EXTRACT_SYM)},
    {SYM_FN("GROUP_CONCAT", GROUP_CONCAT_SYM)},
    {SYM_FN("JSON_OBJECTAGG", JSON_OBJECTAGG)},
    {SYM_FN("JSON_ARRAYAGG", JSON_ARRAYAGG)},
    {SYM_FN("MAX", MAX_SYM)},
    {SYM_FN("MID", SUBSTRING)}, /* unireg function */
    {SYM_FN("MIN", MIN_SYM)},
    {SYM_FN("NOW", NOW_SYM)},
    {SYM_FN("POSITION", POSITION_SYM)},
    {SYM_FN("SESSION_USER", USER)},
    {SYM_FN("STD", STD_SYM)},
    {SYM_FN("STDDEV", STD_SYM)},
    {SYM_FN("STDDEV_POP", STD_SYM)},
    {SYM_FN("STDDEV_SAMP", STDDEV_SAMP_SYM)},
    {SYM_FN("ST_COLLECT", ST_COLLECT_SYM)},
    {SYM_FN("SUBDATE", SUBDATE_SYM)},
    {SYM_FN("SUBSTR", SUBSTRING)},
    {SYM_FN("SUBSTRING", SUBSTRING)},
    {SYM_FN("SUM", SUM_SYM)},
    {SYM_FN("SYSDATE", SYSDATE)},
    {SYM_FN("SYSTEM_USER", USER)},
    {SYM_FN("TRIM", TRIM)},
    {SYM_FN("VARIANCE", VARIANCE_SYM)},
    {SYM_FN("VAR_POP", VARIANCE_SYM)},
    {SYM_FN("VAR_SAMP", VAR_SAMP_SYM)},
    /*
      Insert new optimizer hint keywords after that commentary:
    */
    {SYM_H("BKA", BKA_HINT)},
    {SYM_H("BNL", BNL_HINT)},
    {SYM_H("DUPSWEEDOUT", DUPSWEEDOUT_HINT)},
    {SYM_H("FIRSTMATCH", FIRSTMATCH_HINT)},
    {SYM_H("INTOEXISTS", INTOEXISTS_HINT)},
    {SYM_H("LOOSESCAN", LOOSESCAN_HINT)},
    {SYM_H("MATERIALIZATION", MATERIALIZATION_HINT)},
    {SYM_H("MAX_EXECUTION_TIME", MAX_EXECUTION_TIME_HINT)},
    {SYM_H("NO_BKA", NO_BKA_HINT)},
    {SYM_H("NO_BNL", NO_BNL_HINT)},
    {SYM_H("NO_ICP", NO_ICP_HINT)},
    {SYM_H("NO_MRR", NO_MRR_HINT)},
    {SYM_H("NO_RANGE_OPTIMIZATION", NO_RANGE_OPTIMIZATION_HINT)},
    {SYM_H("NO_SEMIJOIN", NO_SEMIJOIN_HINT)},
    {SYM_H("MRR", MRR_HINT)},
    {SYM_H("QB_NAME", QB_NAME_HINT)},
    {SYM_H("SEMIJOIN", SEMIJOIN_HINT)},
    {SYM_H("SET_VAR", SET_VAR_HINT)},
    {SYM_H("SUBQUERY", SUBQUERY_HINT)},
    {SYM_H("MERGE", DERIVED_MERGE_HINT)},
    {SYM_H("NO_MERGE", NO_DERIVED_MERGE_HINT)},
    {SYM_H("JOIN_PREFIX", JOIN_PREFIX_HINT)},
    {SYM_H("JOIN_SUFFIX", JOIN_SUFFIX_HINT)},
    {SYM_H("JOIN_ORDER", JOIN_ORDER_HINT)},
    {SYM_H("JOIN_FIXED_ORDER", JOIN_FIXED_ORDER_HINT)},
    {SYM_H("INDEX_MERGE", INDEX_MERGE_HINT)},
    {SYM_H("NO_INDEX_MERGE", NO_INDEX_MERGE_HINT)},
    {SYM_H("RESOURCE_GROUP", RESOURCE_GROUP_HINT)},
    {SYM_H("SKIP_SCAN", SKIP_SCAN_HINT)},
    {SYM_H("NO_SKIP_SCAN", NO_SKIP_SCAN_HINT)},
    {SYM_H("HASH_JOIN", HASH_JOIN_HINT)},
    {SYM_H("NO_HASH_JOIN", NO_HASH_JOIN_HINT)},
    {SYM_H("INDEX", INDEX_HINT)},
    {SYM_H("NO_INDEX", NO_INDEX_HINT)},
    {SYM_H("JOIN_INDEX", JOIN_INDEX_HINT)},
    {SYM_H("NO_JOIN_INDEX", NO_JOIN_INDEX_HINT)},
    {SYM_H("GROUP_INDEX", GROUP_INDEX_HINT)},
    {SYM_H("NO_GROUP_INDEX", NO_GROUP_INDEX_HINT)},
    {SYM_H("ORDER_INDEX", ORDER_INDEX_HINT)},
    {SYM_H("NO_ORDER_INDEX", NO_ORDER_INDEX_HINT)},
    {SYM_H("DERIVED_CONDITION_PUSHDOWN", DERIVED_CONDITION_PUSHDOWN_HINT)},
    {SYM_H("NO_DERIVED_CONDITION_PUSHDOWN",
           NO_DERIVED_CONDITION_PUSHDOWN_HINT)}};

static const uchar to_upper_lex[] = {
    0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   10,  11,  12,  13,  14,
    15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
    30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,
    45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
    60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,
    75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,
    90,  91,  92,  93,  94,  95,  96,  65,  66,  67,  68,  69,  70,  71,  72,
    73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,
    88,  89,  90,  123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134,
    135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,
    150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164,
    165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179,
    180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194,
    195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,
    210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 192,
    193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
    208, 209, 210, 211, 212, 213, 214, 247, 216, 217, 218, 219, 220, 221, 222,
    255};

inline int lex_casecmp(const char *s, const char *t, uint len) {
  while (len-- != 0 && to_upper_lex[(uchar)*s++] == to_upper_lex[(uchar)*t++])
    ;
  return (int)len + 1;
}

const SYMBOL *Lex_hash::get_hash_symbol(const char *s, unsigned int len) const {
  const char *cur_str = s;

  if (len == 0) {
    // DBUG_PRINT("warning",
    //            ("get_hash_symbol() received a request for a zero-length symbol,"
    //             " which is probably a mistake."));
    return nullptr;
  }

  if (len > entry_max_len) return nullptr;

  uint32 cur_struct = uint4korr(hash_map + ((len - 1) * 4));

  for (;;) {
    uchar first_char = (uchar)cur_struct;

    if (first_char == 0) {
      uint16 ires = (uint16)(cur_struct >> 16);
      // if (ires == array_elements(symbols)) return nullptr;
      const SYMBOL *res = symbols + ires;
      uint count = (uint)(cur_str - s);
      return lex_casecmp(cur_str, res->name + count, len - count) ? nullptr
                                                                  : res;
    }

    uchar cur_char = (uchar)to_upper_lex[(uchar)*cur_str];
    if (cur_char < first_char) return nullptr;
    cur_struct >>= 8;
    if (cur_char > (uchar)cur_struct) return nullptr;

    cur_struct >>= 8;
    cur_struct = uint4korr(hash_map +
                           (((uint16)cur_struct + cur_char - first_char) * 4));
    cur_str++;
  }
}

const Lex_hash Lex_hash::sql_keywords(sql_keywords_map, sql_keywords_max_len);
const Lex_hash Lex_hash::sql_keywords_and_funcs(sql_keywords_and_funcs_map,
                                                sql_keywords_and_funcs_max_len);

const Lex_hash Lex_hash::hint_keywords(hint_keywords_map,
                                       hint_keywords_max_len);

extern int MYSQLparse(class THD * thd, class Parse_tree_root * *root, vector<IR*>& ir_vec, IR* res);

bool parse_sql_entry(THD *thd, Parser_state *parser_state,
               Object_creation_ctx *creation_ctx, vector<IR*>& ir_vec);

int MYSQLlex(YYSTYPE *yacc_yylval, YYLTYPE *yylloc, THD *thd);

/*
  Return an unescaped text literal without quotes
  Fix sometimes to do only one scan of the string
*/

static bool consume_optimizer_hints(Lex_input_stream *lip) {
  const my_lex_states *state_map = lip->query_charset->state_maps->main_map;
  int whitespace = 0;
  uchar c = lip->yyPeek();
  size_t newlines = 0;

  for (; state_map[c] == MY_LEX_SKIP;
       whitespace++, c = lip->yyPeekn(whitespace)) {
    if (c == '\n') newlines++;
  }

  if (lip->yyPeekn(whitespace) == '/' && lip->yyPeekn(whitespace + 1) == '*' &&
      lip->yyPeekn(whitespace + 2) == '+') {
    lip->yylineno += newlines;
    lip->yySkipn(whitespace);  // skip whitespace

    // Hint_scanner hint_scanner(lip->m_thd, lip->yylineno, lip->get_ptr(),
    //                           lip->get_end_of_query() - lip->get_ptr(),
    //                           lip->m_digest);
    // PT_hint_list *hint_list = nullptr;
    // int rc = HINT_PARSER_parse(lip->m_thd, &hint_scanner, &hint_list);

    /* Yu: Modification to avoid using hint_scanner */
    int rc = 0;
    if (rc == 2)
      return true;  // Bison's internal OOM error
    else if (rc == 1) {
      /*
        This branch is for 2 cases:
        1. YYABORT in the hint parser grammar (we use it to process OOM errors),
        2. open commentary error.
      */
      lip->start_token();  // adjust error message text pointer to "/*+"
      return true;
    } else {
      // lip->yylineno = hint_scanner.get_lineno();
      // lip->yySkipn(hint_scanner.get_ptr() - lip->get_ptr());
      // lip->yylval->optimizer_hints = hint_list;  // NULL in case of syntax error
      // lip->m_digest =
      //     hint_scanner.get_digest();  // NULL is digest buf. is full.
      return false;
    }
    /* End modification from Yu. */
  } else
    return false;
}


static char *get_text(Lex_input_stream *lip, int pre_skip, int post_skip) {
  uchar c, sep;
  uint found_escape = 0;
  const CHARSET_INFO *cs = lip->m_thd->charset();

  lip->tok_bitmap = 0;
  sep = lip->yyGetLast();  // String should end with this
  while (!lip->eof()) {
    c = lip->yyGet();
    lip->tok_bitmap |= c;
    {
      int l;
      if (use_mb(cs) &&
          (l = my_ismbchar(cs, lip->get_ptr() - 1, lip->get_end_of_query()))) {
        lip->skip_binary(l - 1);
        continue;
      }
    }
    if (c == '\\' && !(lip->m_thd->variables.sql_mode &
                       MODE_NO_BACKSLASH_ESCAPES)) {  // Escaped character
      found_escape = 1;
      if (lip->eof()) return nullptr;
      lip->yySkip();
    } else if (c == sep) {
      if (c == lip->yyGet())  // Check if two separators in a row
      {
        found_escape = 1;  // duplicate. Remember for delete
        continue;
      } else
        lip->yyUnget();

      /* Found end. Unescape and return string */
      const char *str, *end;
      char *start;

      str = lip->get_tok_start();
      end = lip->get_ptr();
      /* Extract the text from the token */
      str += pre_skip;
      end -= post_skip;
      assert(end >= str);

      if (!(start =
                static_cast<char *>(lip->m_thd->alloc((uint)(end - str) + 1))))
        return const_cast<char *>("");  // MEM_ROOT has set error flag

      lip->m_cpp_text_start = lip->get_cpp_tok_start() + pre_skip;
      lip->m_cpp_text_end = lip->get_cpp_ptr() - post_skip;

      if (!found_escape) {
        lip->yytoklen = (uint)(end - str);
        memcpy(start, str, lip->yytoklen);
        start[lip->yytoklen] = 0;
      } else {
        char *to;

        for (to = start; str != end; str++) {
          int l;
          if (use_mb(cs) && (l = my_ismbchar(cs, str, end))) {
            while (l--) *to++ = *str++;
            str--;
            continue;
          }
          if (!(lip->m_thd->variables.sql_mode & MODE_NO_BACKSLASH_ESCAPES) &&
              *str == '\\' && str + 1 != end) {
            switch (*++str) {
              case 'n':
                *to++ = '\n';
                break;
              case 't':
                *to++ = '\t';
                break;
              case 'r':
                *to++ = '\r';
                break;
              case 'b':
                *to++ = '\b';
                break;
              case '0':
                *to++ = 0;  // Ascii null
                break;
              case 'Z':  // ^Z must be escaped on Win32
                *to++ = '\032';
                break;
              case '_':
              case '%':
                *to++ = '\\';  // remember prefix for wildcard
                [[fallthrough]];
              default:
                *to++ = *str;
                break;
            }
          } else if (*str == sep)
            *to++ = *str++;  // Two ' or "
          else
            *to++ = *str;
        }
        *to = 0;
        lip->yytoklen = (uint)(to - start);
      }
      return start;
    }
  }
  return nullptr;  // unexpected end of query
}

static int find_keyword(Lex_input_stream *lip, uint len, bool function) {
  const char *tok = lip->get_tok_start();

  const SYMBOL *symbol =
      function ? Lex_hash::sql_keywords_and_funcs.get_hash_symbol(tok, len)
               : Lex_hash::sql_keywords.get_hash_symbol(tok, len);

  if (symbol) {
    lip->yylval->keyword.symbol = symbol;
    lip->yylval->keyword.str = const_cast<char *>(tok);
    lip->yylval->keyword.length = len;

    if ((symbol->tok == 622) &&
        (lip->m_thd->variables.sql_mode & MODE_HIGH_NOT_PRECEDENCE))
      return 621;
    if ((symbol->tok == 644) &&
        !(lip->m_thd->variables.sql_mode & MODE_PIPES_AS_CONCAT)) {
      // push_deprecated_warn(lip->m_thd, "|| as a synonym for OR", "OR");
      return 642;
    }

    lip->yylval->optimizer_hints = nullptr;
    if (symbol->group & SG_HINTABLE_KEYWORDS) {
      // lip->add_digest_token(symbol->tok, lip->yylval);
      if (consume_optimizer_hints(lip)) return 258;
      lip->skip_digest = true;
    }

    return symbol->tok;
  }
  return 0;
}

static LEX_STRING get_token(Lex_input_stream *lip, uint skip, uint length) {
  LEX_STRING tmp;
  lip->yyUnget();  // ptr points now after last token char
  tmp.length = lip->yytoklen = length;
  tmp.str = lip->m_thd->strmake(lip->get_tok_start() + skip, tmp.length);

  lip->m_cpp_text_start = lip->get_cpp_tok_start() + skip;
  lip->m_cpp_text_end = lip->m_cpp_text_start + tmp.length;

  return tmp;
}

/*
 todo:
   There are no dangerous charsets in mysql for function
   get_quoted_token yet. But it should be fixed in the
   future to operate multichar strings (like ucs2)
*/

static LEX_STRING get_quoted_token(Lex_input_stream *lip, uint skip,
                                   uint length, char quote) {
  LEX_STRING tmp;
  const char *from, *end;
  char *to;
  lip->yyUnget();  // ptr points now after last token char
  tmp.length = lip->yytoklen = length;
  tmp.str = (char *)lip->m_thd->alloc(tmp.length + 1);
  from = lip->get_tok_start() + skip;
  to = tmp.str;
  end = to + length;

  lip->m_cpp_text_start = lip->get_cpp_tok_start() + skip;
  lip->m_cpp_text_end = lip->m_cpp_text_start + length;

  for (; to != end;) {
    if ((*to++ = *from++) == quote) {
      from++;  // Skip double quotes
      lip->m_cpp_text_start++;
    }
  }
  *to = 0;  // End null for safety
  return tmp;
}

static inline uint int_token(const char *str, uint length) {
  if (length < long_len)  // quick normal case
    return 628;
  bool neg = false;

  if (*str == '+')  // Remove sign and pre-zeros
  {
    str++;
    length--;
  } else if (*str == '-') {
    str++;
    length--;
    neg = true;
  }
  while (*str == '0' && length) {
    str++;
    length--;
  }
  if (length < long_len) return 628;

  uint smaller, bigger;
  const char *cmp;
  if (neg) {
    if (length == long_len) {
      cmp = signed_long_str + 1;
      smaller = 628;      // If <= signed_long_str
      bigger = 545;  // If >= signed_long_str
    } else if (length < signed_longlong_len)
      return 545;
    else if (length > signed_longlong_len)
      return 377;
    else {
      cmp = signed_longlong_str + 1;
      smaller = 545;  // If <= signed_longlong_str
      bigger = 377;
    }
  } else {
    if (length == long_len) {
      cmp = long_str;
      smaller = 628;
      bigger = 545;
    } else if (length < longlong_len)
      return 545;
    else if (length > longlong_len) {
      if (length > unsigned_longlong_len) return 377;
      cmp = unsigned_longlong_str;
      smaller = 849;
      bigger = 377;
    } else {
      cmp = longlong_str;
      smaller = 545;
      bigger = 849;
    }
  }
  while (*cmp && *cmp++ == *str++)
    ;
  return ((uchar)str[-1] <= (uchar)cmp[-1]) ? smaller : bigger;
}

static bool consume_comment(Lex_input_stream *lip,
                            int remaining_recursions_permitted) {
  // only one level of nested comments are allowed
  assert(remaining_recursions_permitted == 0 ||
         remaining_recursions_permitted == 1);
  uchar c;
  while (!lip->eof()) {
    c = lip->yyGet();

    if (remaining_recursions_permitted == 1) {
      if ((c == '/') && (lip->yyPeek() == '*')) {
        // push_warning(
        //     lip->m_thd, Sql_condition::SL_WARNING,
        //     ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT,
        //     ER_THD(lip->m_thd, ER_WARN_DEPRECATED_NESTED_COMMENT_SYNTAX));
        lip->yyUnput('(');  // Replace nested "/*..." with "(*..."
        lip->yySkip();      // and skip "("
        lip->yySkip();      /* Eat asterisk */
        if (consume_comment(lip, 0)) return true;
        lip->yyUnput(')');  // Replace "...*/" with "...*)"
        lip->yySkip();      // and skip ")"
        continue;
      }
    }

    if (c == '*') {
      if (lip->yyPeek() == '/') {
        lip->yySkip(); /* Eat slash */
        return false;
      }
    }

    if (c == '\n') lip->yylineno++;
  }

  return true;
}

void Lex_input_stream::body_utf8_append(const char *ptr, const char *end_ptr) {
  assert(m_cpp_buf <= ptr && ptr <= m_cpp_buf + m_buf_length);
  assert(m_cpp_buf <= end_ptr && end_ptr <= m_cpp_buf + m_buf_length);

  if (!m_body_utf8) return;

  if (m_cpp_utf8_processed_ptr >= ptr) return;

  size_t bytes_to_copy = ptr - m_cpp_utf8_processed_ptr;

  memcpy(m_body_utf8_ptr, m_cpp_utf8_processed_ptr, bytes_to_copy);
  m_body_utf8_ptr += bytes_to_copy;
  *m_body_utf8_ptr = 0;

  m_cpp_utf8_processed_ptr = end_ptr;
}

void Lex_input_stream::body_utf8_append(const char *ptr) {
  body_utf8_append(ptr, ptr);
}

void Lex_input_stream::body_utf8_append_literal(THD *thd, const LEX_STRING *txt,
                                                const CHARSET_INFO *txt_cs,
                                                const char *end_ptr) {
  // if (!m_cpp_utf8_processed_ptr) return;

  // LEX_STRING utf_txt;

  // if (!my_charset_same(txt_cs, &my_charset_utf8_general_ci)) {
  //   thd->convert_string(&utf_txt, &my_charset_utf8_general_ci, txt->str,
  //                       txt->length, txt_cs);
  // } else {
  //   utf_txt.str = txt->str;
  //   utf_txt.length = txt->length;
  // }

  // /* NOTE: utf_txt.length is in bytes, not in symbols. */

  // memcpy(m_body_utf8_ptr, utf_txt.str, utf_txt.length);
  // m_body_utf8_ptr += utf_txt.length;
  // *m_body_utf8_ptr = 0;

  // m_cpp_utf8_processed_ptr = end_ptr;
}

static int lex_one_token(Lexer_yystype *yylval, THD *thd) {
  uchar c = 0;
  bool comment_closed;
  int tokval, result_state;
  uint length;
  enum my_lex_states state;
  Lex_input_stream *lip = &thd->m_parser_state->m_lip;
  const CHARSET_INFO *cs = thd->charset();
  const my_lex_states *state_map = cs->state_maps->main_map;
  const uchar *ident_map = cs->ident_map;

  lip->yylval = yylval;  // The global state

  lip->start_token();
  state = lip->next_state;
  lip->next_state = MY_LEX_START;
  for (;;) {
    switch (state) {
      case MY_LEX_START:  // Start of token
        // Skip starting whitespace
        while (state_map[c = lip->yyPeek()] == MY_LEX_SKIP) {
          if (c == '\n') lip->yylineno++;

          lip->yySkip();
        }

        /* Start of real token */
        lip->restart_token();
        c = lip->yyGet();
        state = state_map[c];
        break;
      case MY_LEX_CHAR:  // Unknown or single char token
      case MY_LEX_SKIP:  // This should not happen
        if (c == '-' && lip->yyPeek() == '-' &&
            (my_isspace(cs, lip->yyPeekn(1)) ||
             my_iscntrl(cs, lip->yyPeekn(1)))) {
          state = MY_LEX_COMMENT;
          break;
        }

        if (c == '-' && lip->yyPeek() == '>')  // '->'
        {
          lip->yySkip();
          lip->next_state = MY_LEX_START;
          if (lip->yyPeek() == '>') {
            lip->yySkip();
            return 907;
          }
          return 514;
        }

        if (c != ')') lip->next_state = MY_LEX_START;  // Allow signed numbers

        /*
          Check for a placeholder: it should not precede a possible identifier
          because of binlogging: when a placeholder is replaced with its value
          in a query for the binlog, the query must stay grammatically correct.
        */
        if (c == '?' && lip->stmt_prepare_mode && !ident_map[lip->yyPeek()])
          return (652);

        return ((int)c);

      case MY_LEX_IDENT_OR_NCHAR:
        if (lip->yyPeek() != '\'') {
          state = MY_LEX_IDENT;
          break;
        }
        /* Found N'string' */
        lip->yySkip();  // Skip '
        if (!(yylval->lex_str.str = get_text(lip, 2, 1))) {
          state = MY_LEX_CHAR;  // Read char by char
          break;
        }
        yylval->lex_str.length = lip->yytoklen;
        return (611);

      case MY_LEX_IDENT_OR_HEX:
        if (lip->yyPeek() == '\'') {  // Found x'hex-number'
          state = MY_LEX_HEX_NUMBER;
          break;
        }
        [[fallthrough]];
      case MY_LEX_IDENT_OR_BIN:
        if (lip->yyPeek() == '\'') {  // Found b'bin-number'
          state = MY_LEX_BIN_NUMBER;
          break;
        }
        [[fallthrough]];
      case MY_LEX_IDENT:
        const char *start;
        if (use_mb(cs)) {
          result_state = 484;
          switch (my_mbcharlen(cs, lip->yyGetLast())) {
            case 1:
              break;
            case 0:
              if (my_mbmaxlenlen(cs) < 2) break;
              [[fallthrough]];
            default:
              int l =
                  my_ismbchar(cs, lip->get_ptr() - 1, lip->get_end_of_query());
              if (l == 0) {
                state = MY_LEX_CHAR;
                continue;
              }
              lip->skip_binary(l - 1);
          }
          while (ident_map[c = lip->yyGet()]) {
            switch (my_mbcharlen(cs, c)) {
              case 1:
                break;
              case 0:
                if (my_mbmaxlenlen(cs) < 2) break;
                [[fallthrough]];
              default:
                int l;
                if ((l = my_ismbchar(cs, lip->get_ptr() - 1,
                                     lip->get_end_of_query())) == 0)
                  break;
                lip->skip_binary(l - 1);
            }
          }
        } else {
          for (result_state = c; ident_map[c = lip->yyGet()]; result_state |= c)
            ;
          /* If there were non-ASCII characters, mark that we must convert */
          result_state = result_state & 0x80 ? 484 : 482;
        }
        length = lip->yyLength();
        start = lip->get_ptr();
        if (lip->ignore_space) {
          /*
            If we find a space then this can't be an identifier. We notice this
            below by checking start != lex->ptr.
          */
          for (; state_map[c] == MY_LEX_SKIP; c = lip->yyGet()) {
            if (c == '\n') lip->yylineno++;
          }
        }
        if (start == lip->get_ptr() && c == '.' && ident_map[lip->yyPeek()])
          lip->next_state = MY_LEX_IDENT_SEP;
        else {  // '(' must follow directly if function
          lip->yyUnget();
          if ((tokval = find_keyword(lip, length, c == '('))) {
            lip->next_state = MY_LEX_START;  // Allow signed numbers
            return (tokval);                 // Was keyword
          }
          lip->yySkip();  // next state does a unget
        }
        yylval->lex_str = get_token(lip, 0, length);

        /*
           Note: "SELECT _bla AS 'alias'"
           _bla should be considered as a IDENT if charset haven't been found.
           So we don't use MYF(MY_WME) with get_charset_by_csname to avoid
           producing an error.
        */

        // /* Yu: Ignore charset for now.  */

        // if (yylval->lex_str.str[0] == '_') {
        //   auto charset_name = yylval->lex_str.str + 1;
        //   const CHARSET_INFO *underscore_cs =
        //       get_charset_by_csname(charset_name, MY_CS_PRIMARY, MYF(0));
        //   if (underscore_cs) {
        //     lip->warn_on_deprecated_charset(underscore_cs, charset_name);
        //     if (underscore_cs == &my_charset_utf8mb4_0900_ai_ci) {
        //       /*
        //         If underscore_cs is utf8mb4, and the collation of underscore_cs
        //         is the default collation of utf8mb4, then update underscore_cs
        //         with a value of the default_collation_for_utf8mb4 system
        //         variable:
        //       */
        //       underscore_cs = thd->variables.default_collation_for_utf8mb4;
        //     }
        //     yylval->charset = underscore_cs;
        //     lip->m_underscore_cs = underscore_cs;

        //     lip->body_utf8_append(lip->m_cpp_text_start,
        //                           lip->get_cpp_tok_start() + length);
        //     return (852);
        //   }
        // }

        lip->body_utf8_append(lip->m_cpp_text_start);

        lip->body_utf8_append_literal(thd, &yylval->lex_str, cs,
                                      lip->m_cpp_text_end);

        return (result_state);  // IDENT or 484

      case MY_LEX_IDENT_SEP:  // Found ident and now '.'
        yylval->lex_str.str = const_cast<char *>(lip->get_ptr());
        yylval->lex_str.length = 1;
        c = lip->yyGet();  // should be '.'
        lip->next_state =
            MY_LEX_IDENT_START;         // Next is an ident (not a keyword)
        if (!ident_map[lip->yyPeek()])  // Probably ` or "
          lip->next_state = MY_LEX_START;
        return ((int)c);

      case MY_LEX_NUMBER_IDENT:  // number or ident which num-start
        if (lip->yyGetLast() == '0') {
          c = lip->yyGet();
          if (c == 'x') {
            while (my_isxdigit(cs, (c = lip->yyGet())))
              ;
            if ((lip->yyLength() >= 3) && !ident_map[c]) {
              /* skip '0x' */
              yylval->lex_str = get_token(lip, 2, lip->yyLength() - 2);
              return (474);
            }
            lip->yyUnget();
            state = MY_LEX_IDENT_START;
            break;
          } else if (c == 'b') {
            while ((c = lip->yyGet()) == '0' || c == '1')
              ;
            if ((lip->yyLength() >= 3) && !ident_map[c]) {
              /* Skip '0b' */
              yylval->lex_str = get_token(lip, 2, lip->yyLength() - 2);
              return (292);
            }
            lip->yyUnget();
            state = MY_LEX_IDENT_START;
            break;
          }
          lip->yyUnget();
        }

        while (my_isdigit(cs, (c = lip->yyGet())))
          ;
        if (!ident_map[c]) {  // Can't be identifier
          state = MY_LEX_INT_OR_REAL;
          break;
        }
        if (c == 'e' || c == 'E') {
          // The following test is written this way to allow numbers of type 1e1
          if (my_isdigit(cs, lip->yyPeek()) || (c = (lip->yyGet())) == '+' ||
              c == '-') {  // Allow 1E+10
            if (my_isdigit(cs,
                           lip->yyPeek()))  // Number must have digit after sign
            {
              lip->yySkip();
              while (my_isdigit(cs, lip->yyGet()))
                ;
              yylval->lex_str = get_token(lip, 0, lip->yyLength());
              return (443);
            }
          }
          lip->yyUnget();
        }
        [[fallthrough]];
      case MY_LEX_IDENT_START:  // We come here after '.'
        result_state = 482;
        if (use_mb(cs)) {
          result_state = 484;
          while (ident_map[c = lip->yyGet()]) {
            switch (my_mbcharlen(cs, c)) {
              case 1:
                break;
              case 0:
                if (my_mbmaxlenlen(cs) < 2) break;
                [[fallthrough]];
              default:
                int l;
                if ((l = my_ismbchar(cs, lip->get_ptr() - 1,
                                     lip->get_end_of_query())) == 0)
                  break;
                lip->skip_binary(l - 1);
            }
          }
        } else {
          for (result_state = 0; ident_map[c = lip->yyGet()]; result_state |= c)
            ;
          /* If there were non-ASCII characters, mark that we must convert */
          result_state = result_state & 0x80 ? 484 : 482;
        }
        if (c == '.' && ident_map[lip->yyPeek()])
          lip->next_state = MY_LEX_IDENT_SEP;  // Next is '.'

        yylval->lex_str = get_token(lip, 0, lip->yyLength());

        lip->body_utf8_append(lip->m_cpp_text_start);

        lip->body_utf8_append_literal(thd, &yylval->lex_str, cs,
                                      lip->m_cpp_text_end);

        return (result_state);

      case MY_LEX_USER_VARIABLE_DELIMITER:  // Found quote char
      {
        uint double_quotes = 0;
        char quote_char = c;  // Used char
        for (;;) {
          c = lip->yyGet();
          if (c == 0) {
            lip->yyUnget();
            return 258;  // Unmatched quotes
          }

          int var_length;
          if ((var_length = my_mbcharlen(cs, c)) == 1) {
            if (c == quote_char) {
              if (lip->yyPeek() != quote_char) break;
              c = lip->yyGet();
              double_quotes++;
              continue;
            }
          } else if (use_mb(cs)) {
            if ((var_length = my_ismbchar(cs, lip->get_ptr() - 1,
                                          lip->get_end_of_query())))
              lip->skip_binary(var_length - 1);
          }
        }
        if (double_quotes)
          yylval->lex_str = get_quoted_token(
              lip, 1, lip->yyLength() - double_quotes - 1, quote_char);
        else
          yylval->lex_str = get_token(lip, 1, lip->yyLength() - 1);
        if (c == quote_char) lip->yySkip();  // Skip end `
        lip->next_state = MY_LEX_START;

        lip->body_utf8_append(lip->m_cpp_text_start);

        lip->body_utf8_append_literal(thd, &yylval->lex_str, cs,
                                      lip->m_cpp_text_end);

        return (484);
      }
      case MY_LEX_INT_OR_REAL:  // Complete int or incomplete real
        if (c != '.') {         // Found complete integer number.
          yylval->lex_str = get_token(lip, 0, lip->yyLength());
          return int_token(yylval->lex_str.str, (uint)yylval->lex_str.length);
        }
        [[fallthrough]];
      case MY_LEX_REAL:  // Incomplete real number
        while (my_isdigit(cs, c = lip->yyGet()))
          ;

        if (c == 'e' || c == 'E') {
          c = lip->yyGet();
          if (c == '-' || c == '+') c = lip->yyGet();  // Skip sign
          if (!my_isdigit(cs, c)) {                    // No digit after sign
            state = MY_LEX_CHAR;
            break;
          }
          while (my_isdigit(cs, lip->yyGet()))
            ;
          yylval->lex_str = get_token(lip, 0, lip->yyLength());
          return (443);
        }
        yylval->lex_str = get_token(lip, 0, lip->yyLength());
        return (377);

      case MY_LEX_HEX_NUMBER:  // Found x'hexstring'
        lip->yySkip();         // Accept opening '
        while (my_isxdigit(cs, (c = lip->yyGet())))
          ;
        if (c != '\'') return (258);          // Illegal hex constant
        lip->yySkip();                              // Accept closing '
        length = lip->yyLength();                   // Length of hexnum+3
        if ((length % 2) == 0) return (258);  // odd number of hex digits
        yylval->lex_str = get_token(lip,
                                    2,            // skip x'
                                    length - 3);  // don't count x' and last '
        return (474);

      case MY_LEX_BIN_NUMBER:  // Found b'bin-string'
        lip->yySkip();         // Accept opening '
        while ((c = lip->yyGet()) == '0' || c == '1')
          ;
        if (c != '\'') return (258);  // Illegal hex constant
        lip->yySkip();                      // Accept closing '
        length = lip->yyLength();           // Length of bin-num + 3
        yylval->lex_str = get_token(lip,
                                    2,            // skip b'
                                    length - 3);  // don't count b' and last '
        return (292);

      case MY_LEX_CMP_OP:  // Incomplete comparison operator
        if (state_map[lip->yyPeek()] == MY_LEX_CMP_OP ||
            state_map[lip->yyPeek()] == MY_LEX_LONG_CMP_OP)
          lip->yySkip();
        if ((tokval = find_keyword(lip, lip->yyLength() + 1, false))) {
          lip->next_state = MY_LEX_START;  // Allow signed numbers
          return (tokval);
        }
        state = MY_LEX_CHAR;  // Something fishy found
        break;

      case MY_LEX_LONG_CMP_OP:  // Incomplete comparison operator
        if (state_map[lip->yyPeek()] == MY_LEX_CMP_OP ||
            state_map[lip->yyPeek()] == MY_LEX_LONG_CMP_OP) {
          lip->yySkip();
          if (state_map[lip->yyPeek()] == MY_LEX_CMP_OP) lip->yySkip();
        }
        if ((tokval = find_keyword(lip, lip->yyLength() + 1, false))) {
          lip->next_state = MY_LEX_START;  // Found long op
          return (tokval);
        }
        state = MY_LEX_CHAR;  // Something fishy found
        break;

      case MY_LEX_BOOL:
        if (c != lip->yyPeek()) {
          state = MY_LEX_CHAR;
          break;
        }
        lip->yySkip();
        tokval = find_keyword(lip, 2, false);  // Is a bool operator
        lip->next_state = MY_LEX_START;        // Allow signed numbers
        return (tokval);

      case MY_LEX_STRING_OR_DELIMITER:
        if (thd->variables.sql_mode & MODE_ANSI_QUOTES) {
          state = MY_LEX_USER_VARIABLE_DELIMITER;
          break;
        }
        /* " used for strings */
        [[fallthrough]];
      case MY_LEX_STRING:  // Incomplete text string
        if (!(yylval->lex_str.str = get_text(lip, 1, 1))) {
          state = MY_LEX_CHAR;  // Read char by char
          break;
        }
        yylval->lex_str.length = lip->yytoklen;

        lip->body_utf8_append(lip->m_cpp_text_start);

        lip->body_utf8_append_literal(
            thd, &yylval->lex_str,
            lip->m_underscore_cs ? lip->m_underscore_cs : cs,
            lip->m_cpp_text_end);

        lip->m_underscore_cs = nullptr;

        return (827);

      case MY_LEX_COMMENT:  //  Comment
        thd->m_parser_state->add_comment();
        while ((c = lip->yyGet()) != '\n' && c)
          ;
        lip->yyUnget();        // Safety against eof
        state = MY_LEX_START;  // Try again
        break;
      case MY_LEX_LONG_COMMENT: /* Long C comment? */
        if (lip->yyPeek() != '*') {
          state = MY_LEX_CHAR;  // Probable division
          break;
        }
        thd->m_parser_state->add_comment();
        /* Reject '/' '*', since we might need to turn off the echo */
        lip->yyUnget();

        lip->save_in_comment_state();

        if (lip->yyPeekn(2) == '!') {
          lip->in_comment = DISCARD_COMMENT;
          /* Accept '/' '*' '!', but do not keep this marker. */
          lip->set_echo(false);
          lip->yySkip();
          lip->yySkip();
          lip->yySkip();

          /*
            The special comment format is very strict:
            '/' '*' '!', followed by exactly
            1 digit (major), 2 digits (minor), then 2 digits (dot).
            32302 -> 3.23.02
            50032 -> 5.0.32
            50114 -> 5.1.14
          */
          char version_str[6];
          if (my_isdigit(cs, (version_str[0] = lip->yyPeekn(0))) &&
              my_isdigit(cs, (version_str[1] = lip->yyPeekn(1))) &&
              my_isdigit(cs, (version_str[2] = lip->yyPeekn(2))) &&
              my_isdigit(cs, (version_str[3] = lip->yyPeekn(3))) &&
              my_isdigit(cs, (version_str[4] = lip->yyPeekn(4)))) {
            version_str[5] = 0;
            ulong version;
            version = strtol(version_str, nullptr, 10);

            if (version <= MYSQL_VERSION_ID) {
              /* Accept 'M' 'm' 'm' 'd' 'd' */
              lip->yySkipn(5);
              /* Expand the content of the special comment as real code */
              lip->set_echo(true);
              state = MY_LEX_START;
              break; /* Do not treat contents as a comment.  */
            } else {
              /*
                Patch and skip the conditional comment to avoid it
                being propagated infinitely (eg. to a slave).
              */
              char *pcom = lip->yyUnput(' ');
              comment_closed = !consume_comment(lip, 1);
              if (!comment_closed) {
                *pcom = '!';
              }
              /* version allowed to have one level of comment inside. */
            }
          } else {
            /* Not a version comment. */
            state = MY_LEX_START;
            lip->set_echo(true);
            break;
          }
        } else {
          if (lip->in_comment != NO_COMMENT) {
            // push_warning(
            //     lip->m_thd, Sql_condition::SL_WARNING,
            //     ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT,
            //     ER_THD(lip->m_thd, ER_WARN_DEPRECATED_NESTED_COMMENT_SYNTAX));
          }
          lip->in_comment = PRESERVE_COMMENT;
          lip->yySkip();  // Accept /
          lip->yySkip();  // Accept *
          comment_closed = !consume_comment(lip, 0);
          /* regular comments can have zero comments inside. */
        }
        /*
          Discard:
          - regular '/' '*' comments,
          - special comments '/' '*' '!' for a future version,
          by scanning until we find a closing '*' '/' marker.

          Nesting regular comments isn't allowed.  The first
          '*' '/' returns the parser to the previous state.

          /#!VERSI oned containing /# regular #/ is allowed #/

                  Inside one versioned comment, another versioned comment
                  is treated as a regular discardable comment.  It gets
                  no special parsing.
        */

        /* Unbalanced comments with a missing '*' '/' are a syntax error */
        if (!comment_closed) return (258);
        state = MY_LEX_START;  // Try again
        lip->restore_in_comment_state();
        break;
      case MY_LEX_END_LONG_COMMENT:
        if ((lip->in_comment != NO_COMMENT) && lip->yyPeek() == '/') {
          /* Reject '*' '/' */
          lip->yyUnget();
          /* Accept '*' '/', with the proper echo */
          lip->set_echo(lip->in_comment == PRESERVE_COMMENT);
          lip->yySkipn(2);
          /* And start recording the tokens again */
          lip->set_echo(true);

          /*
            C-style comments are replaced with a single space (as it
            is in C and C++).  If there is already a whitespace
            character at this point in the stream, the space is
            not inserted.

            See also ISO/IEC 9899:1999 5.1.1.2
            ("Programming languages  C")
          */
          if (!my_isspace(cs, lip->yyPeek()) &&
              lip->get_cpp_ptr() != lip->get_cpp_buf() &&
              !my_isspace(cs, *(lip->get_cpp_ptr() - 1)))
            lip->cpp_inject(' ');

          lip->in_comment = NO_COMMENT;
          state = MY_LEX_START;
        } else
          state = MY_LEX_CHAR;  // Return '*'
        break;
      case MY_LEX_SET_VAR:  // Check if ':='
        if (lip->yyPeek() != '=') {
          state = MY_LEX_CHAR;  // Return ':'
          break;
        }
        lip->yySkip();
        return (757);
      case MY_LEX_SEMICOLON:  // optional line terminator
        state = MY_LEX_CHAR;  // Return ';'
        break;
      case MY_LEX_EOL:
        if (lip->eof()) {
          lip->yyUnget();  // Reject the last '\0'
          lip->set_echo(false);
          lip->yySkip();
          lip->set_echo(true);
          /* Unbalanced comments with a missing '*' '/' are a syntax error */
          if (lip->in_comment != NO_COMMENT) return (258);
          lip->next_state = MY_LEX_END;  // Mark for next loop
          return (411);
        }
        state = MY_LEX_CHAR;
        break;
      case MY_LEX_END:
        lip->next_state = MY_LEX_END;
        return (0);  // We found end of input last time

        /* Actually real shouldn't start with . but allow them anyhow */
      case MY_LEX_REAL_OR_POINT:
        if (my_isdigit(cs, lip->yyPeek()))
          state = MY_LEX_REAL;  // Real
        else {
          state = MY_LEX_IDENT_SEP;  // return '.'
          lip->yyUnget();            // Put back '.'
        }
        break;
      case MY_LEX_USER_END:  // end '@' of user@hostname
        switch (state_map[lip->yyPeek()]) {
          case MY_LEX_STRING:
          case MY_LEX_USER_VARIABLE_DELIMITER:
          case MY_LEX_STRING_OR_DELIMITER:
            break;
          case MY_LEX_USER_END:
            lip->next_state = MY_LEX_SYSTEM_VAR;
            break;
          default:
            lip->next_state = MY_LEX_HOSTNAME;
            break;
        }
        yylval->lex_str.str = const_cast<char *>(lip->get_ptr());
        yylval->lex_str.length = 1;
        return ((int)'@');
      case MY_LEX_HOSTNAME:  // end '@' of user@hostname
        for (c = lip->yyGet();
             my_isalnum(cs, c) || c == '.' || c == '_' || c == '$';
             c = lip->yyGet())
          ;
        yylval->lex_str = get_token(lip, 0, lip->yyLength());
        return (529);
      case MY_LEX_SYSTEM_VAR:
        yylval->lex_str.str = const_cast<char *>(lip->get_ptr());
        yylval->lex_str.length = 1;
        lip->yySkip();  // Skip '@'
        lip->next_state =
            (state_map[lip->yyPeek()] == MY_LEX_USER_VARIABLE_DELIMITER
                 ? MY_LEX_START
                 : MY_LEX_IDENT_OR_KEYWORD);
        return ((int)'@');
      case MY_LEX_IDENT_OR_KEYWORD:
        /*
          We come here when we have found two '@' in a row.
          We should now be able to handle:
          [(global | local | session) .]variable_name
        */

        for (result_state = 0; ident_map[c = lip->yyGet()]; result_state |= c)
          ;
        /* If there were non-ASCII characters, mark that we must convert */
        result_state = result_state & 0x80 ? 484 : 482;

        if (c == '.') lip->next_state = MY_LEX_IDENT_SEP;
        length = lip->yyLength();
        if (length == 0) return (258);  // Names must be nonempty.
        if ((tokval = find_keyword(lip, length, false))) {
          lip->yyUnget();   // Put back 'c'
          return (tokval);  // Was keyword
        }
        yylval->lex_str = get_token(lip, 0, length);

        lip->body_utf8_append(lip->m_cpp_text_start);

        lip->body_utf8_append_literal(thd, &yylval->lex_str, cs,
                                      lip->m_cpp_text_end);

        return (result_state);
    }
  }
}


/**
  yylex() function implementation for the main parser

  @param [out] yacc_yylval   semantic value of the token being parsed (yylval)
  @param [out] yylloc        "location" of the token being parsed (yylloc)
  @param thd                 THD

  @return                    token number

  @note
  MYSQLlex remember the following states from the following MYSQLlex():

  - MY_LEX_END			Found end of query
*/

int MYSQLlex(YYSTYPE *yacc_yylval, YYLTYPE *yylloc, THD *thd) {
  auto *yylval = reinterpret_cast<Lexer_yystype *>(yacc_yylval);
  Lex_input_stream *lip = &thd->m_parser_state->m_lip;
  int token;

  // if (thd->is_error()) {
  //   if (thd->get_parser_da()->has_sql_condition(ER_CAPACITY_EXCEEDED))
  //     return 258;
  // }

  if (lip->lookahead_token >= 0) {

    /*
      The next token was already parsed in advance,
      return it.
    */
    token = lip->lookahead_token;
    lip->lookahead_token = -1;
    *yylval = *(lip->lookahead_yylval);
    yylloc->cpp.start = lip->get_cpp_tok_start();
    yylloc->cpp.end = lip->get_cpp_ptr();
    yylloc->raw.start = lip->get_tok_start();
    yylloc->raw.end = lip->get_ptr();
    lip->lookahead_yylval = nullptr;
    // lip->add_digest_token(token, yylval);
    return token;
  }

  token = lex_one_token(yylval, thd);
  yylloc->cpp.start = lip->get_cpp_tok_start();
  yylloc->raw.start = lip->get_tok_start();

  switch (token) {
    case 892:
      /*
        Parsing 'WITH' 'ROLLUP' requires 2 look ups,
        which makes the grammar LALR(2).
        Replace by a single 'WITH_ROLLUP' token,
        to transform the grammar into a LALR(1) grammar,
        which sql_yacc.yy can process.
      */
      token = lex_one_token(yylval, thd);
      switch (token) {
        case 734:
          yylloc->cpp.end = lip->get_cpp_ptr();
          yylloc->raw.end = lip->get_ptr();
          // lip->add_digest_token(894, yylval);
          return 894;
        default:
          /*
            Save the token following 'WITH'
          */
          lip->lookahead_yylval = lip->yylval;
          lip->yylval = nullptr;
          lip->lookahead_token = token;
          yylloc->cpp.end = lip->get_cpp_ptr();
          yylloc->raw.end = lip->get_ptr();
          // lip->add_digest_token(892, yylval);
          return 892;
      }
      break;
  }

  yylloc->cpp.end = lip->get_cpp_ptr();
  yylloc->raw.end = lip->get_ptr();
  // if (!lip->skip_digest) lip->add_digest_token(token, yylval);
  lip->skip_digest = false;
  return token;
}



// const char *ER_THD(const THD *thd, int mysql_errno) {
//   return thd->variables.lc_messages->errmsgs->lookup(mysql_errno);
// }

class Parser_oom_handler : public Internal_error_handler {
 public:
  Parser_oom_handler() : m_has_errors(false), m_is_mem_error(false) {}
  bool handle_condition(THD *thd, uint sql_errno, const char *,
                        Sql_condition::enum_severity_level *level,
                        const char *) override {
    if (*level == Sql_condition::SL_ERROR) {
      m_has_errors = true;
      /* Out of memory error is reported only once. Return as handled */
      if (m_is_mem_error &&
          (sql_errno == EE_CAPACITY_EXCEEDED || sql_errno == EE_OUTOFMEMORY))
        return true;
      if (sql_errno == EE_CAPACITY_EXCEEDED || sql_errno == EE_OUTOFMEMORY) {
        m_is_mem_error = true;
        if (sql_errno == EE_CAPACITY_EXCEEDED) {}
          // my_error(ER_CAPACITY_EXCEEDED, MYF(0),
          //          static_cast<ulonglong>(thd->variables.parser_max_mem_size),
          //          "parser_max_mem_size",
          //          ER_THD(thd, ER_CAPACITY_EXCEEDED_IN_PARSER));
        else {}
          // my_error(ER_OUT_OF_RESOURCES, MYF(ME_FATALERROR));
        return true;
      }
    }
    return false;
  }

 private:
  bool m_has_errors;
  bool m_is_mem_error;
};

void sp_parser_data::finish_parsing_sp_body(THD *thd) {
  /*
    In some cases the parser detects a syntax error and calls
    THD::cleanup_after_parse_error() method only after finishing parsing
    the whole routine. In such a situation sp_head::restore_thd_mem_root()
    will be called twice - the first time as part of normal parsing process
    and the second time by cleanup_after_parse_error().

    To avoid ruining active arena/mem_root state in this case we skip
    restoration of old arena/mem_root if this method has been already called
    for this routine.
  */
  if (!is_parsing_sp_body()) return;

  thd->free_items();
  thd->mem_root = m_saved_memroot;
  thd->set_item_list(m_saved_item_list);

  m_saved_memroot = nullptr;
  m_saved_item_list = nullptr;
}

void Query_arena::free_items() {
  Item *next;
  /* This works because items are allocated with (*THR_MALLOC)->Alloc() */
  for (; m_item_list; m_item_list = next) {
    next = m_item_list->next_free;
    m_item_list->delete_self();
  }
  /* Postcondition: free_list is 0 */
}

void sp_head::destroy(sp_head *sp) {
  if (!sp) return;

  /* Pull out main_mem_root as free_root will free the sp */
  MEM_ROOT own_root = std::move(sp->main_mem_root);

  sp->~sp_head();

  own_root.Clear();
}

/**
  Restore session state in case of parse error.

  This is a clean up function that is invoked after the Bison generated
  parser before returning an error from THD::sql_parser(). If your
  semantic actions manipulate with the session state (which
  is a very bad practice and should not normally be employed) and
  need a clean-up in case of error, and you can not use %destructor
  rule in the grammar file itself, this function should be used
  to implement the clean up.
*/

void cleanup_after_parse_error(THD* thd) {
  sp_head *sp = thd->lex->sphead;

  if (sp) {
    sp->m_parser_data.finish_parsing_sp_body(thd);
    //  Do not delete sp_head if is invoked in the context of sp execution.
    if (thd->sp_runtime_ctx == nullptr) {
      sp_head::destroy(sp);
      thd->lex->sphead = nullptr;
    }
  }
}

bool parse_sql_entry(THD *thd, Parser_state *parser_state,
               Object_creation_ctx *creation_ctx, vector<IR*>& ir_vec) {
  DBUG_TRACE;
  bool ret_value;
  assert(thd->m_parser_state == nullptr);
  // TODO fix to allow parsing gcol exprs after main query.
  //  assert(thd->lex->m_sql_cmd == NULL);

  /* Backup creation context. */

  Object_creation_ctx *backup_ctx = nullptr;

  // if (creation_ctx) backup_ctx = creation_ctx->set_n_backup(thd);

  /* Set parser state. */

  thd->m_parser_state = parser_state;

  parser_state->m_digest_psi = nullptr;
  parser_state->m_lip.m_digest = nullptr;

  /*
    Partial parsers (GRAMMAR_SELECTOR_*) are not supposed to compute digests.
  */
  assert(!parser_state->m_lip.is_partial_parser() ||
         !parser_state->m_input.m_has_digest);

  /*
    Only consider statements that are supposed to have a digest,
    like top level queries.
  */
  if (parser_state->m_input.m_has_digest) {
    /*
      For these statements,
      see if the digest computation is required.
    */
    if (thd->m_digest != nullptr) {
      /* Start Digest */
      /* Yu: Have to ignore Digest now, because it is too difficult */
      // parser_state->m_digest_psi = MYSQL_DIGEST_START(thd->m_statement_psi);

      // if (parser_state->m_input.m_compute_digest ||
      //     (parser_state->m_digest_psi != nullptr)) {
      //   /*
      //     If either:
      //     - the caller wants to compute a digest
      //     - the performance schema wants to compute a digest
      //     set the digest listener in the lexer.
      //   */
      //   parser_state->m_lip.m_digest = thd->m_digest;
      //   parser_state->m_lip.m_digest->m_digest_storage.m_charset_number =
      //       thd->charset()->number;
      // }
    }
  }

  /* Parse the query. */

  /*
    Use a temporary DA while parsing. We don't know until after parsing
    whether the current command is a diagnostic statement, in which case
    we'll need to have the previous DA around to answer questions about it.
  */
  Diagnostics_area *parser_da = thd->get_parser_da();
  Diagnostics_area *da = thd->get_stmt_da();

  Parser_oom_handler poomh;
  // Note that we may be called recursively here, on INFORMATION_SCHEMA queries.

  thd->mem_root->set_max_capacity(thd->variables.parser_max_mem_size);
  thd->mem_root->set_error_for_capacity_exceeded(true);
  // thd->push_internal_handler(&poomh);

  // thd->push_diagnostics_area(parser_da, false);

  bool mysql_parse_status = false;

  Parse_tree_root *root = nullptr;
  IR* dummy_res;
  if (MYSQLparse(thd, &root, ir_vec, dummy_res))
  {
      cleanup_after_parse_error(thd);
      mysql_parse_status = true;
  }
  if (root != nullptr 
  // && thd->lex->make_sql_cmd(root)
  ) {
    mysql_parse_status = true;
  }
  mysql_parse_status = false;

  // thd->pop_internal_handler();
  thd->mem_root->set_max_capacity(0);
  thd->mem_root->set_error_for_capacity_exceeded(false);
  /*
    Unwind diagnostics area.

    If any issues occurred during parsing, they will become
    the sole conditions for the current statement.

    Otherwise, if we have a diagnostic statement on our hands,
    we'll preserve the previous diagnostics area here so we
    can answer questions about it.  This specifically means
    that repeatedly asking about a DA won't clear it.

    Otherwise, it's a regular command with no issues during
    parsing, so we'll just clear the DA in preparation for
    the processing of this command.
  */

  if (parser_da->current_statement_cond_count() != 0) {
    /*
      Error/warning during parsing: top DA should contain parse error(s)!  Any
      pre-existing conditions will be replaced. The exception is diagnostics
      statements, in which case we wish to keep the errors so they can be sent
      to the client.
    */
    // if (thd->lex->sql_command != SQLCOM_SHOW_WARNS &&
    //     thd->lex->sql_command != SQLCOM_GET_DIAGNOSTICS)
    //   da->reset_condition_info(thd);

    /*
      We need to put any errors in the DA as well as the condition list.
    */
    // if (parser_da->is_error() && !da->is_error()) {
    //   da->set_error_status(parser_da->mysql_errno(), parser_da->message_text(),
    //                        parser_da->returned_sqlstate());
    // }

    // da->copy_sql_conditions_from_da(thd, parser_da);

    // parser_da->reset_diagnostics_area();
    // parser_da->reset_condition_info(thd);

    /*
      Do not clear the condition list when starting execution as it
      now contains not the results of the previous executions, but
      a non-zero number of errors/warnings thrown during parsing!
    */
    thd->lex->keep_diagnostics = DA_KEEP_PARSE_ERROR;
  }

  thd->pop_diagnostics_area();

  /*
    Check that if THD::sql_parser() failed either thd->is_error() is set, or an
    internal error handler is set.

    The assert will not catch a situation where parsing fails without an
    error reported if an error handler exists. The problem is that the
    error handler might have intercepted the error, so thd->is_error() is
    not set. However, there is no way to be 100% sure here (the error
    handler might be for other errors than parsing one).
  */

  assert(!mysql_parse_status || (mysql_parse_status && thd->is_error()) ||
         (mysql_parse_status && thd->get_internal_handler()));

  /* Reset parser state. */

  thd->m_parser_state = nullptr;

  /* Restore creation context. */

  // if (creation_ctx) creation_ctx->restore_env(thd, backup_ctx);

  /* That's it. */

  ret_value = mysql_parse_status || thd->is_fatal_error();

  if ((ret_value == 0) && (parser_state->m_digest_psi != nullptr)) {
    /*
      On parsing success, record the digest in the performance schema.
    */
    assert(thd->m_digest != nullptr);
    // MYSQL_DIGEST_END(parser_state->m_digest_psi,
                    //  &thd->m_digest->m_digest_storage);
  }

  return ret_value;
}


bool exec_query_command_entry(string input, vector<IR*>& ir_vec) {
    THD *thd = new (std::nothrow) THD;
    thd->get_stmt_da()->reset_diagnostics_area();
    thd->get_stmt_da()->reset_statement_cond_count();

    // Might need a loop
    MYSQL_LEX_CSTRING cmd_mysql_cstring;

    // In stack, will be freed after function exits. 
    cmd_mysql_cstring.str = input.c_str();
    cmd_mysql_cstring.length = input.size();
    thd->set_query(cmd_mysql_cstring);

    Parser_state parser_state;
    parser_state.init(thd, thd->query().str, thd->query().length);

    parser_state.m_input.m_has_digest = true;

    // we produce digest if it's not explicitly turned off
    // by setting maximum digest length to zero
    if (get_max_digest_length() != 0)
        parser_state.m_input.m_compute_digest = true;

    while (!thd->killed && (parser_state.m_lip.found_semicolon != nullptr) &&
           !thd->is_error()) {
        /* in the dispatch_sql_command */
        lex_start(thd);
        mysql_reset_thd_for_next_command(thd);
        thd->m_digest = nullptr;
        thd->m_statement_psi = nullptr;
        // thd->m_parser_state = parser_state;

        bool err;
        err = parse_sql_entry(thd, &parser_state, nullptr, ir_vec);
        thd->end_statement();
    }

    thd->release_resources();
    thd->set_psi(nullptr);
    thd->lex->destroy();
    thd->end_statement();
    thd->cleanup_after_query();

    return true;
}
