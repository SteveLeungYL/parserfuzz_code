    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
SET @old_concurrent_insert = @@global.concurrent_insert;
SET @@global.concurrent_insert = 0;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a DECIMAL(64, 20));
INSERT INTO t1 VALUES ("1234567890123456789012345678901234567890"),("0987654321098765432109876543210987654321");
CREATE TABLE t1 (a DECIMAL(10,5), b FLOAT);
INSERT INTO t1 VALUES (1.2345, 2.3456);
INSERT INTO t1 VALUES ('1.2345', 2.3456);
INSERT INTO t1 VALUES ("1.2345", 2.3456);
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='ANSI_QUOTES';
INSERT INTO t1 VALUES (1.2345, 2.3456);
INSERT INTO t1 VALUES ('1.2345', 2.3456);
INSERT INTO t1 VALUES ("1.2345", 2.3456);
SET SQL_MODE=@OLD_SQL_MODE;
CREATE TABLE t1 (a  VARCHAR(255)) DEFAULT CHARSET koi8r;
INSERT INTO t1  VALUES (_koi8r x'C1C2C3C4C5'), (NULL);
CREATE TABLE t1 (a INT);
CREATE TABLE t2 (a INT);
INSERT INTO t1 VALUES (1),(2),(3);
INSERT INTO t2 VALUES (4),(5),(6);
DROP TABLE t1;
CREATE TABLE t1 (`b` blob);
INSERT INTO `t1` VALUES (0x602010000280100005E71A);
SET @@global.concurrent_insert = @old_concurrent_insert;
    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
SET @old_concurrent_insert = @@global.concurrent_insert;
SET @@global.concurrent_insert = 0;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a DECIMAL(64, 20));
INSERT INTO t1 VALUES ("1234567890123456789012345678901234567890"),("0987654321098765432109876543210987654321");
CREATE TABLE t1 (a DECIMAL(10,5), b FLOAT);
INSERT INTO t1 VALUES (1.2345, 2.3456);
INSERT INTO t1 VALUES ('1.2345', 2.3456);
INSERT INTO t1 VALUES ("1.2345", 2.3456);
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='ANSI_QUOTES';
INSERT INTO t1 VALUES (1.2345, 2.3456);
INSERT INTO t1 VALUES ('1.2345', 2.3456);
INSERT INTO t1 VALUES ("1.2345", 2.3456);
SET SQL_MODE=@OLD_SQL_MODE;
CREATE TABLE t1 (a  VARCHAR(255)) DEFAULT CHARSET koi8r;
INSERT INTO t1  VALUES (_koi8r x'C1C2C3C4C5'), (NULL);
CREATE TABLE t1 (a INT);
CREATE TABLE t2 (a INT);
INSERT INTO t1 VALUES (1),(2),(3);
INSERT INTO t2 VALUES (4),(5),(6);
DROP TABLE t1;
CREATE TABLE t1 (`b` blob);
INSERT INTO `t1` VALUES (0x602010000280100005E71A);
SET @@global.concurrent_insert = @old_concurrent_insert;
    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
SET @old_concurrent_insert = @@global.concurrent_insert;
SET @@global.concurrent_insert = 0;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a DECIMAL(64, 20));
INSERT INTO t1 VALUES ("1234567890123456789012345678901234567890"),("0987654321098765432109876543210987654321");
CREATE TABLE t1 (a DECIMAL(10,5), b FLOAT);
INSERT INTO t1 VALUES (1.2345, 2.3456);
INSERT INTO t1 VALUES ('1.2345', 2.3456);
INSERT INTO t1 VALUES ("1.2345", 2.3456);
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='ANSI_QUOTES';
INSERT INTO t1 VALUES (1.2345, 2.3456);
INSERT INTO t1 VALUES ('1.2345', 2.3456);
INSERT INTO t1 VALUES ("1.2345", 2.3456);
SET SQL_MODE=@OLD_SQL_MODE;
CREATE TABLE t1 (a  VARCHAR(255)) DEFAULT CHARSET koi8r;
INSERT INTO t1  VALUES (_koi8r x'C1C2C3C4C5'), (NULL);
CREATE TABLE t1 (a INT);
CREATE TABLE t2 (a INT);
INSERT INTO t1 VALUES (1),(2),(3);
INSERT INTO t2 VALUES (4),(5),(6);
DROP TABLE t1;
CREATE TABLE t1 (`b` blob);
INSERT INTO `t1` VALUES (0x602010000280100005E71A);
SET @@global.concurrent_insert = @old_concurrent_insert;
    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
SET @old_concurrent_insert = @@global.concurrent_insert;
SET @@global.concurrent_insert = 0;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a DECIMAL(64, 20));
INSERT INTO t1 VALUES ("1234567890123456789012345678901234567890"),("0987654321098765432109876543210987654321");
CREATE TABLE t1 (a DECIMAL(10,5), b FLOAT);
INSERT INTO t1 VALUES (1.2345, 2.3456);
INSERT INTO t1 VALUES ('1.2345', 2.3456);
INSERT INTO t1 VALUES ("1.2345", 2.3456);
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='ANSI_QUOTES';
INSERT INTO t1 VALUES (1.2345, 2.3456);
INSERT INTO t1 VALUES ('1.2345', 2.3456);
INSERT INTO t1 VALUES ("1.2345", 2.3456);
SET SQL_MODE=@OLD_SQL_MODE;
CREATE TABLE t1 (a  VARCHAR(255)) DEFAULT CHARSET koi8r;
INSERT INTO t1  VALUES (_koi8r x'C1C2C3C4C5'), (NULL);
CREATE TABLE t1 (a INT);
CREATE TABLE t2 (a INT);
INSERT INTO t1 VALUES (1),(2),(3);
INSERT INTO t2 VALUES (4),(5),(6);
DROP TABLE t1;
CREATE TABLE t1 (`b` blob);
INSERT INTO `t1` VALUES (0x602010000280100005E71A);
SET @@global.concurrent_insert = @old_concurrent_insert;
    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  eval SET @orig_table_name = CONCAT('$table_name', '_orig');
eval ALTER TABLE $table_name RENAME to $orig_table_name;
eval DROP TABLE $table_name, $orig_table_name;
SET @old_concurrent_insert = @@global.concurrent_insert;
SET @@global.concurrent_insert = 0;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a DECIMAL(64, 20));
INSERT INTO t1 VALUES ("1234567890123456789012345678901234567890"),("0987654321098765432109876543210987654321");
CREATE TABLE t1 (a DECIMAL(10,5), b FLOAT);
INSERT INTO t1 VALUES (1.2345, 2.3456);
INSERT INTO t1 VALUES ('1.2345', 2.3456);
INSERT INTO t1 VALUES ("1.2345", 2.3456);
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='ANSI_QUOTES';
INSERT INTO t1 VALUES (1.2345, 2.3456);
INSERT INTO t1 VALUES ('1.2345', 2.3456);
INSERT INTO t1 VALUES ("1.2345", 2.3456);
SET SQL_MODE=@OLD_SQL_MODE;
CREATE TABLE t1 (a  VARCHAR(255)) DEFAULT CHARSET koi8r;
INSERT INTO t1  VALUES (_koi8r x'C1C2C3C4C5'), (NULL);
CREATE TABLE t1 (a INT);
CREATE TABLE t2 (a INT);
INSERT INTO t1 VALUES (1),(2),(3);
INSERT INTO t2 VALUES (4),(5),(6);
DROP TABLE t1;
CREATE TABLE t1 (`b` blob);
INSERT INTO `t1` VALUES (0x602010000280100005E71A);
SET @@global.concurrent_insert = @old_concurrent_insert;
