eval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $files = $ENV{'DJF_FILES'};
  my $vardir = $ENV{'MYSQLTEST_VARDIR'};
  $files =~ s/^ +//;
  for my $file (split(/ +/, $files)) {    $file =~ m{^$vardir/tmp/}      or die "Error: cannot remove file <$file> outside MYSQLTEST_VARDIR/tmp";
    unlink($file)      or die "Error $? removing file <$file>: $!";
  }END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $files = $ENV{'DJF_FILES'};
  my $vardir = $ENV{'MYSQLTEST_VARDIR'};
  $files =~ s/^ +//;
  for my $file (split(/ +/, $files)) {    $file =~ m{^$vardir/tmp/}      or die "Error: cannot remove file <$file> outside MYSQLTEST_VARDIR/tmp";
    unlink($file)      or die "Error $? removing file <$file>: $!";
  }END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $files = $ENV{'DJF_FILES'};
  my $vardir = $ENV{'MYSQLTEST_VARDIR'};
  $files =~ s/^ +//;
  for my $file (split(/ +/, $files)) {    $file =~ m{^$vardir/tmp/}      or die "Error: cannot remove file <$file> outside MYSQLTEST_VARDIR/tmp";
    unlink($file)      or die "Error $? removing file <$file>: $!";
  }END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $label = $ENV{'CJUI_LABEL'};
  my $prefix = $ENV{'MYSQLTEST_VARDIR'} . "/tmp/json_$label";
  my $next = $prefix . '_next.inc';
  my $unpack = $prefix . '_unpack.inc';
  my $done_var = "json_${label}_done";
  my $value_var = "json_${label}_value";
  open(NEXT, ">> $next")    or die "Error $? opening $next: $!";
  print NEXT (    "if (!\$$done_var) {\n" .    "      "}\n"  ) or die "Error $? writing to $next: $!";
  close(NEXT)    or die "Error $? closing $next: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $label = $ENV{'CJUI_LABEL'};
  my $prefix = $ENV{'MYSQLTEST_VARDIR'} . "/tmp/json_$label";
  my $next = $prefix . '_next.inc';
  my $unpack = $prefix . '_unpack.inc';
  my $done_var = "json_${label}_done";
  my $value_var = "json_${label}_value";
  open(NEXT, ">> $next")    or die "Error $? opening $next: $!";
  print NEXT (    "if (!\$$done_var) {\n" .    "      "}\n"  ) or die "Error $? writing to $next: $!";
  close(NEXT)    or die "Error $? closing $next: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $label = $ENV{'CJUI_LABEL'};
  my $prefix = $ENV{'MYSQLTEST_VARDIR'} . "/tmp/json_$label";
  my $next = $prefix . '_next.inc';
  my $unpack = $prefix . '_unpack.inc';
  my $done_var = "json_${label}_done";
  my $value_var = "json_${label}_value";
  open(NEXT, ">> $next")    or die "Error $? opening $next: $!";
  print NEXT (    "if (!\$$done_var) {\n" .    "      "}\n"  ) or die "Error $? writing to $next: $!";
  close(NEXT)    or die "Error $? closing $next: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $files = $ENV{'DJF_FILES'};
  my $vardir = $ENV{'MYSQLTEST_VARDIR'};
  $files =~ s/^ +//;
  for my $file (split(/ +/, $files)) {    $file =~ m{^$vardir/tmp/}      or die "Error: cannot remove file <$file> outside MYSQLTEST_VARDIR/tmp";
    unlink($file)      or die "Error $? removing file <$file>: $!";
  }END_OF_PERLwhile (!$json_planet_done) {  # Do something useful with the current value.    # Step forward to the next element.  ["Afghanistan", "Bangladesh", "Cambodia"],  ["Albania", "Belgium", "Cyprus"],  ["Argentina", "Bolivia", "Colombia"],  ["Angola", "Burundi", "Cameroon"]];
while (!$json_continent_done) {  # Print the current inner array.    # Reset the inner iterator to the first element of the current inner array.    while (!$json_country_done) {    # Do something useful with the current value.        # Step forward to the next element of the inner array.  }  # Step forward to the next element of the outer array.  {    "author": "Kerstin Ekman",    "title": "Grand final i skojarbranschen"  },  {    "author": "Bjarne Stroustrup",    "title": "The C++ Programming Language"  },  {    "author": "Pelle Holmberg and Hans Marklund",    "title": "Nya svampboken"  }];
while (!$json_book_done) {  # Do something useful with the unpacked values.    # Step forward to the next element.  {    "name": "Apple",    "fruit_color": "red",    "flower_color": "white"  },  {    "name": "Tussilago",    "flower_color": "yellow"  },  {    "name": "Chanterelle",    "fruit_color": "yellow"  }];
while (!$json_plant_done) {  # Do something useful with the unpacked values.  # Non-existing values are empty.  if ($fruit_color) {      }  if (!$fruit_color) {      }  if ($flower_color) {      }  if (!$flower_color) {      }  # Step forward to the next plant.  { "species": "ant", "color": "brown", "legs": 6 },  { "species": "bear", "color": "black" },  { "species": "cat", "color": "orange" }];
while (!$json_animal_done) {  # Do something useful with the unpacked values.    # Step forward to the next animal.  "first": "Ain't Talkin'",  "second": "Don't Think Twice, It's All Right",  "third": "It Ain't Me, Babe",  "fourth": "Rollin' and Tumblin'",  "fifth": "Where are you?"};
while (!$json_vegetable_done) {  while (!$json_vegetable_done) {  while (!$json_vegetable_done) {  eval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $files = $ENV{'DJF_FILES'};
  my $vardir = $ENV{'MYSQLTEST_VARDIR'};
  $files =~ s/^ +//;
  for my $file (split(/ +/, $files)) {    $file =~ m{^$vardir/tmp/}      or die "Error: cannot remove file <$file> outside MYSQLTEST_VARDIR/tmp";
    unlink($file)      or die "Error $? removing file <$file>: $!";
  }END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $files = $ENV{'DJF_FILES'};
  my $vardir = $ENV{'MYSQLTEST_VARDIR'};
  $files =~ s/^ +//;
  for my $file (split(/ +/, $files)) {    $file =~ m{^$vardir/tmp/}      or die "Error: cannot remove file <$file> outside MYSQLTEST_VARDIR/tmp";
    unlink($file)      or die "Error $? removing file <$file>: $!";
  }END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $files = $ENV{'DJF_FILES'};
  my $vardir = $ENV{'MYSQLTEST_VARDIR'};
  $files =~ s/^ +//;
  for my $file (split(/ +/, $files)) {    $file =~ m{^$vardir/tmp/}      or die "Error: cannot remove file <$file> outside MYSQLTEST_VARDIR/tmp";
    unlink($file)      or die "Error $? removing file <$file>: $!";
  }END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $label = $ENV{'CJUI_LABEL'};
  my $prefix = $ENV{'MYSQLTEST_VARDIR'} . "/tmp/json_$label";
  my $next = $prefix . '_next.inc';
  my $unpack = $prefix . '_unpack.inc';
  my $done_var = "json_${label}_done";
  my $value_var = "json_${label}_value";
  open(NEXT, ">> $next")    or die "Error $? opening $next: $!";
  print NEXT (    "if (!\$$done_var) {\n" .    "      "}\n"  ) or die "Error $? writing to $next: $!";
  close(NEXT)    or die "Error $? closing $next: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $label = $ENV{'CJUI_LABEL'};
  my $prefix = $ENV{'MYSQLTEST_VARDIR'} . "/tmp/json_$label";
  my $next = $prefix . '_next.inc';
  my $unpack = $prefix . '_unpack.inc';
  my $done_var = "json_${label}_done";
  my $value_var = "json_${label}_value";
  open(NEXT, ">> $next")    or die "Error $? opening $next: $!";
  print NEXT (    "if (!\$$done_var) {\n" .    "      "}\n"  ) or die "Error $? writing to $next: $!";
  close(NEXT)    or die "Error $? closing $next: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $label = $ENV{'CJUI_LABEL'};
  my $prefix = $ENV{'MYSQLTEST_VARDIR'} . "/tmp/json_$label";
  my $next = $prefix . '_next.inc';
  my $unpack = $prefix . '_unpack.inc';
  my $done_var = "json_${label}_done";
  my $value_var = "json_${label}_value";
  open(NEXT, ">> $next")    or die "Error $? opening $next: $!";
  print NEXT (    "if (!\$$done_var) {\n" .    "      "}\n"  ) or die "Error $? writing to $next: $!";
  close(NEXT)    or die "Error $? closing $next: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $files = $ENV{'DJF_FILES'};
  my $vardir = $ENV{'MYSQLTEST_VARDIR'};
  $files =~ s/^ +//;
  for my $file (split(/ +/, $files)) {    $file =~ m{^$vardir/tmp/}      or die "Error: cannot remove file <$file> outside MYSQLTEST_VARDIR/tmp";
    unlink($file)      or die "Error $? removing file <$file>: $!";
  }END_OF_PERLwhile (!$json_planet_done) {  # Do something useful with the current value.    # Step forward to the next element.  ["Afghanistan", "Bangladesh", "Cambodia"],  ["Albania", "Belgium", "Cyprus"],  ["Argentina", "Bolivia", "Colombia"],  ["Angola", "Burundi", "Cameroon"]];
while (!$json_continent_done) {  # Print the current inner array.    # Reset the inner iterator to the first element of the current inner array.    while (!$json_country_done) {    # Do something useful with the current value.        # Step forward to the next element of the inner array.  }  # Step forward to the next element of the outer array.  {    "author": "Kerstin Ekman",    "title": "Grand final i skojarbranschen"  },  {    "author": "Bjarne Stroustrup",    "title": "The C++ Programming Language"  },  {    "author": "Pelle Holmberg and Hans Marklund",    "title": "Nya svampboken"  }];
while (!$json_book_done) {  # Do something useful with the unpacked values.    # Step forward to the next element.  {    "name": "Apple",    "fruit_color": "red",    "flower_color": "white"  },  {    "name": "Tussilago",    "flower_color": "yellow"  },  {    "name": "Chanterelle",    "fruit_color": "yellow"  }];
while (!$json_plant_done) {  # Do something useful with the unpacked values.  # Non-existing values are empty.  if ($fruit_color) {      }  if (!$fruit_color) {      }  if ($flower_color) {      }  if (!$flower_color) {      }  # Step forward to the next plant.  { "species": "ant", "color": "brown", "legs": 6 },  { "species": "bear", "color": "black" },  { "species": "cat", "color": "orange" }];
while (!$json_animal_done) {  # Do something useful with the unpacked values.    # Step forward to the next animal.  "first": "Ain't Talkin'",  "second": "Don't Think Twice, It's All Right",  "third": "It Ain't Me, Babe",  "fourth": "Rollin' and Tumblin'",  "fifth": "Where are you?"};
while (!$json_vegetable_done) {  while (!$json_vegetable_done) {  while (!$json_vegetable_done) {  eval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $files = $ENV{'DJF_FILES'};
  my $vardir = $ENV{'MYSQLTEST_VARDIR'};
  $files =~ s/^ +//;
  for my $file (split(/ +/, $files)) {    $file =~ m{^$vardir/tmp/}      or die "Error: cannot remove file <$file> outside MYSQLTEST_VARDIR/tmp";
    unlink($file)      or die "Error $? removing file <$file>: $!";
  }END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $files = $ENV{'DJF_FILES'};
  my $vardir = $ENV{'MYSQLTEST_VARDIR'};
  $files =~ s/^ +//;
  for my $file (split(/ +/, $files)) {    $file =~ m{^$vardir/tmp/}      or die "Error: cannot remove file <$file> outside MYSQLTEST_VARDIR/tmp";
    unlink($file)      or die "Error $? removing file <$file>: $!";
  }END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $files = $ENV{'DJF_FILES'};
  my $vardir = $ENV{'MYSQLTEST_VARDIR'};
  $files =~ s/^ +//;
  for my $file (split(/ +/, $files)) {    $file =~ m{^$vardir/tmp/}      or die "Error: cannot remove file <$file> outside MYSQLTEST_VARDIR/tmp";
    unlink($file)      or die "Error $? removing file <$file>: $!";
  }END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $label = $ENV{'CJUI_LABEL'};
  my $prefix = $ENV{'MYSQLTEST_VARDIR'} . "/tmp/json_$label";
  my $next = $prefix . '_next.inc';
  my $unpack = $prefix . '_unpack.inc';
  my $done_var = "json_${label}_done";
  my $value_var = "json_${label}_value";
  open(NEXT, ">> $next")    or die "Error $? opening $next: $!";
  print NEXT (    "if (!\$$done_var) {\n" .    "      "}\n"  ) or die "Error $? writing to $next: $!";
  close(NEXT)    or die "Error $? closing $next: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $label = $ENV{'CJUI_LABEL'};
  my $prefix = $ENV{'MYSQLTEST_VARDIR'} . "/tmp/json_$label";
  my $next = $prefix . '_next.inc';
  my $unpack = $prefix . '_unpack.inc';
  my $done_var = "json_${label}_done";
  my $value_var = "json_${label}_value";
  open(NEXT, ">> $next")    or die "Error $? opening $next: $!";
  print NEXT (    "if (!\$$done_var) {\n" .    "      "}\n"  ) or die "Error $? writing to $next: $!";
  close(NEXT)    or die "Error $? closing $next: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $label = $ENV{'CJUI_LABEL'};
  my $prefix = $ENV{'MYSQLTEST_VARDIR'} . "/tmp/json_$label";
  my $next = $prefix . '_next.inc';
  my $unpack = $prefix . '_unpack.inc';
  my $done_var = "json_${label}_done";
  my $value_var = "json_${label}_value";
  open(NEXT, ">> $next")    or die "Error $? opening $next: $!";
  print NEXT (    "if (!\$$done_var) {\n" .    "      "}\n"  ) or die "Error $? writing to $next: $!";
  close(NEXT)    or die "Error $? closing $next: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $files = $ENV{'DJF_FILES'};
  my $vardir = $ENV{'MYSQLTEST_VARDIR'};
  $files =~ s/^ +//;
  for my $file (split(/ +/, $files)) {    $file =~ m{^$vardir/tmp/}      or die "Error: cannot remove file <$file> outside MYSQLTEST_VARDIR/tmp";
    unlink($file)      or die "Error $? removing file <$file>: $!";
  }END_OF_PERLwhile (!$json_planet_done) {  # Do something useful with the current value.    # Step forward to the next element.  ["Afghanistan", "Bangladesh", "Cambodia"],  ["Albania", "Belgium", "Cyprus"],  ["Argentina", "Bolivia", "Colombia"],  ["Angola", "Burundi", "Cameroon"]];
while (!$json_continent_done) {  # Print the current inner array.    # Reset the inner iterator to the first element of the current inner array.    while (!$json_country_done) {    # Do something useful with the current value.        # Step forward to the next element of the inner array.  }  # Step forward to the next element of the outer array.  {    "author": "Kerstin Ekman",    "title": "Grand final i skojarbranschen"  },  {    "author": "Bjarne Stroustrup",    "title": "The C++ Programming Language"  },  {    "author": "Pelle Holmberg and Hans Marklund",    "title": "Nya svampboken"  }];
while (!$json_book_done) {  # Do something useful with the unpacked values.    # Step forward to the next element.  {    "name": "Apple",    "fruit_color": "red",    "flower_color": "white"  },  {    "name": "Tussilago",    "flower_color": "yellow"  },  {    "name": "Chanterelle",    "fruit_color": "yellow"  }];
while (!$json_plant_done) {  # Do something useful with the unpacked values.  # Non-existing values are empty.  if ($fruit_color) {      }  if (!$fruit_color) {      }  if ($flower_color) {      }  if (!$flower_color) {      }  # Step forward to the next plant.  { "species": "ant", "color": "brown", "legs": 6 },  { "species": "bear", "color": "black" },  { "species": "cat", "color": "orange" }];
while (!$json_animal_done) {  # Do something useful with the unpacked values.    # Step forward to the next animal.  "first": "Ain't Talkin'",  "second": "Don't Think Twice, It's All Right",  "third": "It Ain't Me, Babe",  "fourth": "Rollin' and Tumblin'",  "fifth": "Where are you?"};
while (!$json_vegetable_done) {  while (!$json_vegetable_done) {  while (!$json_vegetable_done) {  eval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $files = $ENV{'DJF_FILES'};
  my $vardir = $ENV{'MYSQLTEST_VARDIR'};
  $files =~ s/^ +//;
  for my $file (split(/ +/, $files)) {    $file =~ m{^$vardir/tmp/}      or die "Error: cannot remove file <$file> outside MYSQLTEST_VARDIR/tmp";
    unlink($file)      or die "Error $? removing file <$file>: $!";
  }END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $files = $ENV{'DJF_FILES'};
  my $vardir = $ENV{'MYSQLTEST_VARDIR'};
  $files =~ s/^ +//;
  for my $file (split(/ +/, $files)) {    $file =~ m{^$vardir/tmp/}      or die "Error: cannot remove file <$file> outside MYSQLTEST_VARDIR/tmp";
    unlink($file)      or die "Error $? removing file <$file>: $!";
  }END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $files = $ENV{'DJF_FILES'};
  my $vardir = $ENV{'MYSQLTEST_VARDIR'};
  $files =~ s/^ +//;
  for my $file (split(/ +/, $files)) {    $file =~ m{^$vardir/tmp/}      or die "Error: cannot remove file <$file> outside MYSQLTEST_VARDIR/tmp";
    unlink($file)      or die "Error $? removing file <$file>: $!";
  }END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $label = $ENV{'CJUI_LABEL'};
  my $prefix = $ENV{'MYSQLTEST_VARDIR'} . "/tmp/json_$label";
  my $next = $prefix . '_next.inc';
  my $unpack = $prefix . '_unpack.inc';
  my $done_var = "json_${label}_done";
  my $value_var = "json_${label}_value";
  open(NEXT, ">> $next")    or die "Error $? opening $next: $!";
  print NEXT (    "if (!\$$done_var) {\n" .    "      "}\n"  ) or die "Error $? writing to $next: $!";
  close(NEXT)    or die "Error $? closing $next: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $label = $ENV{'CJUI_LABEL'};
  my $prefix = $ENV{'MYSQLTEST_VARDIR'} . "/tmp/json_$label";
  my $next = $prefix . '_next.inc';
  my $unpack = $prefix . '_unpack.inc';
  my $done_var = "json_${label}_done";
  my $value_var = "json_${label}_value";
  open(NEXT, ">> $next")    or die "Error $? opening $next: $!";
  print NEXT (    "if (!\$$done_var) {\n" .    "      "}\n"  ) or die "Error $? writing to $next: $!";
  close(NEXT)    or die "Error $? closing $next: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $label = $ENV{'CJUI_LABEL'};
  my $prefix = $ENV{'MYSQLTEST_VARDIR'} . "/tmp/json_$label";
  my $next = $prefix . '_next.inc';
  my $unpack = $prefix . '_unpack.inc';
  my $done_var = "json_${label}_done";
  my $value_var = "json_${label}_value";
  open(NEXT, ">> $next")    or die "Error $? opening $next: $!";
  print NEXT (    "if (!\$$done_var) {\n" .    "      "}\n"  ) or die "Error $? writing to $next: $!";
  close(NEXT)    or die "Error $? closing $next: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $files = $ENV{'DJF_FILES'};
  my $vardir = $ENV{'MYSQLTEST_VARDIR'};
  $files =~ s/^ +//;
  for my $file (split(/ +/, $files)) {    $file =~ m{^$vardir/tmp/}      or die "Error: cannot remove file <$file> outside MYSQLTEST_VARDIR/tmp";
    unlink($file)      or die "Error $? removing file <$file>: $!";
  }END_OF_PERLwhile (!$json_planet_done) {  # Do something useful with the current value.    # Step forward to the next element.  ["Afghanistan", "Bangladesh", "Cambodia"],  ["Albania", "Belgium", "Cyprus"],  ["Argentina", "Bolivia", "Colombia"],  ["Angola", "Burundi", "Cameroon"]];
while (!$json_continent_done) {  # Print the current inner array.    # Reset the inner iterator to the first element of the current inner array.    while (!$json_country_done) {    # Do something useful with the current value.        # Step forward to the next element of the inner array.  }  # Step forward to the next element of the outer array.  {    "author": "Kerstin Ekman",    "title": "Grand final i skojarbranschen"  },  {    "author": "Bjarne Stroustrup",    "title": "The C++ Programming Language"  },  {    "author": "Pelle Holmberg and Hans Marklund",    "title": "Nya svampboken"  }];
while (!$json_book_done) {  # Do something useful with the unpacked values.    # Step forward to the next element.  {    "name": "Apple",    "fruit_color": "red",    "flower_color": "white"  },  {    "name": "Tussilago",    "flower_color": "yellow"  },  {    "name": "Chanterelle",    "fruit_color": "yellow"  }];
while (!$json_plant_done) {  # Do something useful with the unpacked values.  # Non-existing values are empty.  if ($fruit_color) {      }  if (!$fruit_color) {      }  if ($flower_color) {      }  if (!$flower_color) {      }  # Step forward to the next plant.  { "species": "ant", "color": "brown", "legs": 6 },  { "species": "bear", "color": "black" },  { "species": "cat", "color": "orange" }];
while (!$json_animal_done) {  # Do something useful with the unpacked values.    # Step forward to the next animal.  "first": "Ain't Talkin'",  "second": "Don't Think Twice, It's All Right",  "third": "It Ain't Me, Babe",  "fourth": "Rollin' and Tumblin'",  "fifth": "Where are you?"};
while (!$json_vegetable_done) {  while (!$json_vegetable_done) {  while (!$json_vegetable_done) {  eval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $files = $ENV{'DJF_FILES'};
  my $vardir = $ENV{'MYSQLTEST_VARDIR'};
  $files =~ s/^ +//;
  for my $file (split(/ +/, $files)) {    $file =~ m{^$vardir/tmp/}      or die "Error: cannot remove file <$file> outside MYSQLTEST_VARDIR/tmp";
    unlink($file)      or die "Error $? removing file <$file>: $!";
  }END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $files = $ENV{'DJF_FILES'};
  my $vardir = $ENV{'MYSQLTEST_VARDIR'};
  $files =~ s/^ +//;
  for my $file (split(/ +/, $files)) {    $file =~ m{^$vardir/tmp/}      or die "Error: cannot remove file <$file> outside MYSQLTEST_VARDIR/tmp";
    unlink($file)      or die "Error $? removing file <$file>: $!";
  }END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $files = $ENV{'DJF_FILES'};
  my $vardir = $ENV{'MYSQLTEST_VARDIR'};
  $files =~ s/^ +//;
  for my $file (split(/ +/, $files)) {    $file =~ m{^$vardir/tmp/}      or die "Error: cannot remove file <$file> outside MYSQLTEST_VARDIR/tmp";
    unlink($file)      or die "Error $? removing file <$file>: $!";
  }END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $label = $ENV{'CJUI_LABEL'};
  my $prefix = $ENV{'MYSQLTEST_VARDIR'} . "/tmp/json_$label";
  my $next = $prefix . '_next.inc';
  my $unpack = $prefix . '_unpack.inc';
  my $done_var = "json_${label}_done";
  my $value_var = "json_${label}_value";
  open(NEXT, ">> $next")    or die "Error $? opening $next: $!";
  print NEXT (    "if (!\$$done_var) {\n" .    "      "}\n"  ) or die "Error $? writing to $next: $!";
  close(NEXT)    or die "Error $? closing $next: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $label = $ENV{'CJUI_LABEL'};
  my $prefix = $ENV{'MYSQLTEST_VARDIR'} . "/tmp/json_$label";
  my $next = $prefix . '_next.inc';
  my $unpack = $prefix . '_unpack.inc';
  my $done_var = "json_${label}_done";
  my $value_var = "json_${label}_value";
  open(NEXT, ">> $next")    or die "Error $? opening $next: $!";
  print NEXT (    "if (!\$$done_var) {\n" .    "      "}\n"  ) or die "Error $? writing to $next: $!";
  close(NEXT)    or die "Error $? closing $next: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $label = $ENV{'CJUI_LABEL'};
  my $prefix = $ENV{'MYSQLTEST_VARDIR'} . "/tmp/json_$label";
  my $next = $prefix . '_next.inc';
  my $unpack = $prefix . '_unpack.inc';
  my $done_var = "json_${label}_done";
  my $value_var = "json_${label}_value";
  open(NEXT, ">> $next")    or die "Error $? opening $next: $!";
  print NEXT (    "if (!\$$done_var) {\n" .    "      "}\n"  ) or die "Error $? writing to $next: $!";
  close(NEXT)    or die "Error $? closing $next: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJU_LABEL'};
  my $key_text = $ENV{'CJU_KEYS'};
  my $defaults_text = $ENV{'CJU_DEFAULTS'};
  my $required_text = $ENV{'CJU_REQUIRED'};
  my $json_quoted_text = $ENV{'CJU_JSON_QUOTED'};
  my $single_quoted_text = $ENV{'CJU_SINGLE_QUOTED'};
  my $verbose_text = $ENV{'CJU_VERBOSE'};
  my $uuid = $ENV{'CJU_UUID'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_unpacker.inc";
  my $unpack_file = "${file_prefix}_unpack.inc";
  my $var_prefix = 'json_' . $label;
  my $unpack_file_var = $var_prefix . '_unpack';
  my $defaults_var = $var_prefix . '_defaults';
  my $added_var = $var_prefix . '_added_unpacker_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  if (!$key_text) {    die "!!!ERROR IN TEST: Set \$json_keys.";
  }  my @key_list = split / *, */, $key_text;
  my %key_hash = ();
  my $key_check_sql = '';
  for my $key (@key_list) {    $key_hash{$key} = 1;
    $key_check_sql .= ", '\$.\"$key\"'";
  }  my %required_hash = ();
  if ($required_text eq '1') { $required_text = $key_text; }  elsif ($required_text eq '0') { $required_text = ''; }  for my $key (split / *, */, $required_text) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_required contains key <$key> which is not in \$json_keys";
    }    $required_hash{$key} = 1;
  }  my %json_quoted_hash = ();
  if ($json_quoted_text eq '1') { $json_quoted_text = $key_text; }  elsif ($json_quoted_text eq '0') { $json_quoted_text = ''; }  for my $key (split(/ *, */, $json_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_json_quoted contains key <$key> which is not in \$json_keys";
    }    $json_quoted_hash{$key} = 1;
  }  my %single_quoted_hash = ();
  if ($single_quoted_text eq '1') { $single_quoted_text = $key_text; }  if ($single_quoted_text eq '0') { $single_quoted_text = ''; }  for my $key (split(/ *, */, $single_quoted_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_output_single_quoted contains key <$key> which is not in \$json_keys";
    }    $single_quoted_hash{$key} = 1;
  }  my %verbose_hash = ();
  if ($verbose_text eq '1') { $verbose_text = $key_text; }  if ($verbose_text eq '0') { $verbose_text = ''; }  for my $key (split(/ *, */, $verbose_text)) {    if (!defined($key_hash{$key})) {      die "!!!ERROR IN TEST: \$json_verbose contains key <$key> which is not in \$json_keys";
    }    $verbose_hash{$key} = 1;
  }  # INIT_FILE will be sourced at the end of create_json_unpacker.inc  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE (###############################################    "            if (\$rpl_debug) {            # This gives a useful error message for malformed JSON.      if (\$$defaults_var) {        eval SELECT JSON_TYPE('\$$defaults_var') AS JSON_TYPE;
      }    }    if (!\$$added_var) {                }  "###############################################################  ) or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(UNPACK_FILE, "> $unpack_file")    or die "Error $? opening $unpack_file: $!";
  print UNPACK_FILE (############################################    "    # Check JSON syntax and get a reasonable error message.            if (\$rpl_debug) {                }    # Check that no keys other than the expected ones exist in the object.    if (!\$json_allow_extra_keys) {      if (`SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) != CAST('{}' AS JSON)`) {                                eval SELECT JSON_REMOVE('\$json_object_escaped'$key_check_sql) AS unknown_keys;
              }    }    "###########################################################  ) or die "Error $? writing to $unpack_file: $!";
  if (%verbose_hash) {    print UNPACK_FILE (      "    );
  }  for my $key (split(/ *, */, $key_text)) {    if ($key !~ /^[a-zA-Z0-9_]+$/) {      die "!!!ERROR IN TEST: \$json_keys should contain only alphanumeric 7-bit ASCII identifiers";
    }    my $o = "'\$json_object_escaped'";
    my $k = "'\$.\"$key\"'";
    my $func = 'JSON_EXTRACT';
    my $end = '';
    if (!defined($json_quoted_hash{$key})) {      $func = "JSON_UNQUOTE($func";
      $end = ')';
    }    if (defined($required_hash{$key})) {      print UNPACK_FILE (#######################################        "                if (\$$key == '$uuid') {                            }        "#######################################################      ) or die "Error $? writing to $unpack_file: $!";
    } elsif ($defaults_text) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    } else {      print UNPACK_FILE (        "      );
    }    if (defined($single_quoted_hash{$key})) {      print UNPACK_FILE (        "                "      );
    }    if (defined($verbose_hash{$key})) {      print UNPACK_FILE (        "      ) or die "Error $? writing to $unpack_file: $!";
    }  }  close(UNPACK_FILE)    or die "Error $? closing $unpack_file: $!";
END_OF_PERLeval SELECT JSON_TYPE('$_cj_json');
        if (`SELECT '$_cj_message' LIKE '%Invalid JSON text in argument 1 to function json_type:%'`) {                if ($_cj_position < 60) {          }                      }        perl END_OF_PERL;
  my $label = $ENV{'CJI_LABEL'};
  my $unquote = $ENV{'CJI_UNQUOTE'};
  my $function_files = $ENV{'CJI_JSON_FUNCTION_FILES'};
  my $file_infix = "/tmp/json_$label";
  my $file_prefix = $ENV{'MYSQLTEST_VARDIR'} . $file_infix;
  my $file_prefix_generator = '$MYSQLTEST_VARDIR' . $file_infix;
  my $init_file = "${file_prefix}_init_iterator.inc";
  my $start_file = "${file_prefix}_start.inc";
  my $next_file = "${file_prefix}_next.inc";
  my $var_prefix = 'json_' . $label;
  my $array_var = $var_prefix . '_array';
  my $index_var = $var_prefix . '_index';
  my $done_var = $var_prefix . '_done';
  my $length_var = $var_prefix . '_length';
  my $value_var = $var_prefix . '_value';
  my $start_file_var = $var_prefix . '_start';
  my $next_file_var = $var_prefix . '_next';
  my $stride_var = $var_prefix . '_stride';
  my $added_var = $var_prefix . '_added_iterator_to_json_function_files';
  if ($label !~ /^[a-zA-Z0-9_]+$/) {    die "!!!ERROR IN TEST: Set \$json_label an alphanumeric 7-bit ASCII identifier (it was '$label')";
  }  open(INIT_FILE, "> $init_file")    or die "Error $? opening $init_file: $!";
  print INIT_FILE ("            if (!\$$added_var) {                }  ") or die "Error $? writing to $init_file: $!";
  close(INIT_FILE)    or die "Error $? closing $init_file: $!";
  open(START_FILE, "> $start_file")    or die "Error $? opening $start_file: $!";
  print START_FILE (#################################    "    if (!\$json_array) {          }    # Check json syntax and get a reasonable error message                    if (\$$stride_var == '') {          }    if (\$json_start == '') {      if (\$$stride_var > 0) {              }      if (\$$stride_var < 0) {                      }    }    if (\$json_start != '') {          }    if (\$rpl_debug) {                }  "##################################################  ) or die "Error $? writing to $start_file: $!";
  close(START_FILE)    or die "Error $? closing $start_file: $!";
  my $func = 'JSON_EXTRACT';
  my $func_end = '';
  if ($unquote =~ /^1?$/) {    $func = "JSON_UNQUOTE($func";
    $end = ')'  }  open(NEXT_FILE, "> $next_file")    or die "Error $? opening $next_file: $!";
  print NEXT_FILE (##############################################    "    if (\$rpl_debug) {          }        if (\$$index_var >= \$$length_var) {          }    if (\$$index_var < 0) {          }    if (!\$$done_var) {                  if (\$rpl_debug) {              }    }    if (\$rpl_debug) {          }  "#############################################################  ) or die "Error $? writing to $next_file: $!";
  close(NEXT_FILE)    or die "Error $? closing $next_file: $!";
END_OF_PERLperl END_OF_PERL;
  my $files = $ENV{'DJF_FILES'};
  my $vardir = $ENV{'MYSQLTEST_VARDIR'};
  $files =~ s/^ +//;
  for my $file (split(/ +/, $files)) {    $file =~ m{^$vardir/tmp/}      or die "Error: cannot remove file <$file> outside MYSQLTEST_VARDIR/tmp";
    unlink($file)      or die "Error $? removing file <$file>: $!";
  }END_OF_PERLwhile (!$json_planet_done) {  # Do something useful with the current value.    # Step forward to the next element.  ["Afghanistan", "Bangladesh", "Cambodia"],  ["Albania", "Belgium", "Cyprus"],  ["Argentina", "Bolivia", "Colombia"],  ["Angola", "Burundi", "Cameroon"]];
while (!$json_continent_done) {  # Print the current inner array.    # Reset the inner iterator to the first element of the current inner array.    while (!$json_country_done) {    # Do something useful with the current value.        # Step forward to the next element of the inner array.  }  # Step forward to the next element of the outer array.  {    "author": "Kerstin Ekman",    "title": "Grand final i skojarbranschen"  },  {    "author": "Bjarne Stroustrup",    "title": "The C++ Programming Language"  },  {    "author": "Pelle Holmberg and Hans Marklund",    "title": "Nya svampboken"  }];
while (!$json_book_done) {  # Do something useful with the unpacked values.    # Step forward to the next element.  {    "name": "Apple",    "fruit_color": "red",    "flower_color": "white"  },  {    "name": "Tussilago",    "flower_color": "yellow"  },  {    "name": "Chanterelle",    "fruit_color": "yellow"  }];
while (!$json_plant_done) {  # Do something useful with the unpacked values.  # Non-existing values are empty.  if ($fruit_color) {      }  if (!$fruit_color) {      }  if ($flower_color) {      }  if (!$flower_color) {      }  # Step forward to the next plant.  { "species": "ant", "color": "brown", "legs": 6 },  { "species": "bear", "color": "black" },  { "species": "cat", "color": "orange" }];
while (!$json_animal_done) {  # Do something useful with the unpacked values.    # Step forward to the next animal.  "first": "Ain't Talkin'",  "second": "Don't Think Twice, It's All Right",  "third": "It Ain't Me, Babe",  "fourth": "Rollin' and Tumblin'",  "fifth": "Where are you?"};
while (!$json_vegetable_done) {  while (!$json_vegetable_done) {  while (!$json_vegetable_done) {  