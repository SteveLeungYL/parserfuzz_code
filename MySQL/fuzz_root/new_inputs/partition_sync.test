     let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   CREATE TABLE t1 (a int) PARTITION BY RANGE (a)(PARTITION p0 VALUES LESS THAN (1), PARTITION p1 VALUES LESS THAN (2));
INSERT INTO t1 VALUES (0),(1);
connect(con1,localhost,root);
connection con1;
BEGIN;
SELECT * FROM t1;
connection default;
ALTER TABLE t1 DROP PARTITION p3;
connection con1;
SELECT * FROM t1;
connection default;
disconnect con1;
DROP TABLE t1;
DROP TABLE IF EXISTS tbl_with_partitions;
CREATE TABLE tbl_with_partitions ( i INT ) 	PARTITION BY HASH(i);
INSERT INTO tbl_with_partitions VALUES (1);
connect(con2,localhost,root);
connect(con3,localhost,root);
connection con3;
LOCK TABLE tbl_with_partitions READ;
connection default;
SET AUTOCOMMIT = 0;
SELECT * FROM tbl_with_partitions;
connection con2;
set session debug="+d,abort_copy_table";
ALTER TABLE tbl_with_partitions ADD COLUMN f INT, ALGORITHM=COPY;
connection default;
SELECT * FROM tbl_with_partitions;
connection con3;
UNLOCK TABLES;
connection default;
disconnect con2;
disconnect con3;
DROP TABLE tbl_with_partitions;
     let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   CREATE TABLE t1 (a int) PARTITION BY RANGE (a)(PARTITION p0 VALUES LESS THAN (1), PARTITION p1 VALUES LESS THAN (2));
INSERT INTO t1 VALUES (0),(1);
connect(con1,localhost,root);
connection con1;
BEGIN;
SELECT * FROM t1;
connection default;
ALTER TABLE t1 DROP PARTITION p3;
connection con1;
SELECT * FROM t1;
connection default;
disconnect con1;
DROP TABLE t1;
DROP TABLE IF EXISTS tbl_with_partitions;
CREATE TABLE tbl_with_partitions ( i INT ) 	PARTITION BY HASH(i);
INSERT INTO tbl_with_partitions VALUES (1);
connect(con2,localhost,root);
connect(con3,localhost,root);
connection con3;
LOCK TABLE tbl_with_partitions READ;
connection default;
SET AUTOCOMMIT = 0;
SELECT * FROM tbl_with_partitions;
connection con2;
set session debug="+d,abort_copy_table";
ALTER TABLE tbl_with_partitions ADD COLUMN f INT, ALGORITHM=COPY;
connection default;
SELECT * FROM tbl_with_partitions;
connection con3;
UNLOCK TABLES;
connection default;
disconnect con2;
disconnect con3;
DROP TABLE tbl_with_partitions;
     let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   CREATE TABLE t1 (a int) PARTITION BY RANGE (a)(PARTITION p0 VALUES LESS THAN (1), PARTITION p1 VALUES LESS THAN (2));
INSERT INTO t1 VALUES (0),(1);
connect(con1,localhost,root);
connection con1;
BEGIN;
SELECT * FROM t1;
connection default;
ALTER TABLE t1 DROP PARTITION p3;
connection con1;
SELECT * FROM t1;
connection default;
disconnect con1;
DROP TABLE t1;
DROP TABLE IF EXISTS tbl_with_partitions;
CREATE TABLE tbl_with_partitions ( i INT ) 	PARTITION BY HASH(i);
INSERT INTO tbl_with_partitions VALUES (1);
connect(con2,localhost,root);
connect(con3,localhost,root);
connection con3;
LOCK TABLE tbl_with_partitions READ;
connection default;
SET AUTOCOMMIT = 0;
SELECT * FROM tbl_with_partitions;
connection con2;
set session debug="+d,abort_copy_table";
ALTER TABLE tbl_with_partitions ADD COLUMN f INT, ALGORITHM=COPY;
connection default;
SELECT * FROM tbl_with_partitions;
connection con3;
UNLOCK TABLES;
connection default;
disconnect con2;
disconnect con3;
DROP TABLE tbl_with_partitions;
     let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   CREATE TABLE t1 (a int) PARTITION BY RANGE (a)(PARTITION p0 VALUES LESS THAN (1), PARTITION p1 VALUES LESS THAN (2));
INSERT INTO t1 VALUES (0),(1);
connect(con1,localhost,root);
connection con1;
BEGIN;
SELECT * FROM t1;
connection default;
ALTER TABLE t1 DROP PARTITION p3;
connection con1;
SELECT * FROM t1;
connection default;
disconnect con1;
DROP TABLE t1;
DROP TABLE IF EXISTS tbl_with_partitions;
CREATE TABLE tbl_with_partitions ( i INT ) 	PARTITION BY HASH(i);
INSERT INTO tbl_with_partitions VALUES (1);
connect(con2,localhost,root);
connect(con3,localhost,root);
connection con3;
LOCK TABLE tbl_with_partitions READ;
connection default;
SET AUTOCOMMIT = 0;
SELECT * FROM tbl_with_partitions;
connection con2;
set session debug="+d,abort_copy_table";
ALTER TABLE tbl_with_partitions ADD COLUMN f INT, ALGORITHM=COPY;
connection default;
SELECT * FROM tbl_with_partitions;
connection con3;
UNLOCK TABLES;
connection default;
disconnect con2;
disconnect con3;
DROP TABLE tbl_with_partitions;
     let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   CREATE TABLE t1 (a int) PARTITION BY RANGE (a)(PARTITION p0 VALUES LESS THAN (1), PARTITION p1 VALUES LESS THAN (2));
INSERT INTO t1 VALUES (0),(1);
connect(con1,localhost,root);
connection con1;
BEGIN;
SELECT * FROM t1;
connection default;
ALTER TABLE t1 DROP PARTITION p3;
connection con1;
SELECT * FROM t1;
connection default;
disconnect con1;
DROP TABLE t1;
DROP TABLE IF EXISTS tbl_with_partitions;
CREATE TABLE tbl_with_partitions ( i INT ) 	PARTITION BY HASH(i);
INSERT INTO tbl_with_partitions VALUES (1);
connect(con2,localhost,root);
connect(con3,localhost,root);
connection con3;
LOCK TABLE tbl_with_partitions READ;
connection default;
SET AUTOCOMMIT = 0;
SELECT * FROM tbl_with_partitions;
connection con2;
set session debug="+d,abort_copy_table";
ALTER TABLE tbl_with_partitions ADD COLUMN f INT, ALGORITHM=COPY;
connection default;
SELECT * FROM tbl_with_partitions;
connection con3;
UNLOCK TABLES;
connection default;
disconnect con2;
disconnect con3;
DROP TABLE tbl_with_partitions;
