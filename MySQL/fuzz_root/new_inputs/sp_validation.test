  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
CREATE TABLE t1 (a INT, b INT);
CREATE TABLE t2 (a INT, b INT);
CREATE TABLE t3 (a INT);
INSERT INTO t2 VALUES (11, 12), (21, 22);
CREATE TRIGGER t3_ai AFTER INSERT ON t3 FOR EACH ROW  INSERT INTO t1 SELECT * FROM t2;
INSERT INTO t3 (a) VALUES (1);
SELECT * FROM t1;
SELECT * FROM t2;
ALTER TABLE t1 ADD COLUMN c INT;
ALTER TABLE t2 ADD COLUMN c INT;
INSERT INTO t2 VALUES (31, 32, 33);
INSERT INTO t3 (a) VALUES (2);
SELECT * FROM t1;
SELECT * FROM t2;
DROP TABLE t1;
DROP TABLE t2;
DROP TABLE t3;
CREATE TABLE t1 (a INT);
INSERT INTO t1(a) VALUES (1);
delimiter |;
CREATE TRIGGER t1_bu BEFORE UPDATE ON t1 FOR EACH ROWBEGIN  SET @a = OLD.a;
  SET @b = NEW.a;
  SELECT OLD.a INTO @c;
  SELECT NEW.a INTO @d;
  SET NEW.a = NEW.a * 2;
END|delimiter ;|UPDATE t1 SET a = a * 10;
SELECT @a, @c, @b, @d;
SELECT a FROM t1;
DROP TABLE t1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE PROCEDURE p1()  SELECT * FROM t1;
CALL p1();
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 0;
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
ALTER TABLE t1 CHANGE COLUMN b b VARCHAR(255) DEFAULT 'n/a';
DELETE FROM t1;
INSERT INTO t1 VALUES (b), ('hello');
CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE PROCEDURE p1()  SELECT * FROM t1;
CALL p1();
DROP TABLE t1;
CALL p1();
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE PROCEDURE p1()  SELECT * FROM t1;
CALL p1();
DROP TABLE t1;
CALL p1();
CREATE TABLE t1 (b VARCHAR(10), c VARCHAR(10));
INSERT INTO t1 VALUES ('a', 'b'), ('c', 'd');
CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE VIEW v1 AS SELECT 1, 2, 3;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER VIEW v1 AS SELECT 1, 2, 3, 4, 5;
CALL p1();
ALTER VIEW v1 AS SELECT 1, 5;
CALL p1();
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
DROP VIEW v1;
CREATE VIEW v1 AS SELECT * FROM t1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER TABLE t1 ADD COLUMN c INT DEFAULT 3;
CALL p1();
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT, c INT);
INSERT INTO t1 VALUES (1, 2, 3);
DROP VIEW v1;
CREATE VIEW v1 AS SELECT b, c FROM t1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
ALTER TABLE t1 DROP COLUMN b;
CALL p1();
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT, c INT);
INSERT INTO t1 VALUES (1, 2, 3);
DROP VIEW v1;
CREATE VIEW v1 AS SELECT b, c FROM t1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER TABLE t1 CHANGE COLUMN b b VARCHAR(255) DEFAULT 'n/a';
DELETE FROM t1;
INSERT INTO t1(a, c) VALUES (10, 30);
CALL p1();
DROP VIEW v1;
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE VIEW v1 AS SELECT 1, 2, 3;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
DROP VIEW v1;
CALL p1();
CREATE VIEW v1 AS SELECT 4, 5, 6;
CALL p1();
DROP VIEW v1;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE VIEW v1 AS SELECT * FROM t1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
DROP TABLE t1;
CALL p1();
CREATE TABLE t1(a VARCHAR(255), b VARCHAR(255));
INSERT INTO t1 VALUES ('a', 'b'), ('c', 'd');
CALL p1();
DROP VIEW v1;
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
ALTER TABLE t1 ADD COLUMN c INT DEFAULT 3;
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
ALTER TABLE t1 CHANGE COLUMN b b VARCHAR(255) DEFAULT 'n/a';
INSERT INTO t1(c) VALUES (4);
CALL p1();
DROP TEMPORARY TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP TEMPORARY TABLE t1;
CREATE TEMPORARY TABLE t1(a VARCHAR(255), b VARCHAR(255), c VARCHAR(255));
INSERT INTO t1 VALUES ('aa', 'bb', 'cc');
CALL p1();
DROP TEMPORARY TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT a, b FROM t1;
CALL p1();
ALTER TABLE t1 DROP COLUMN b;
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT a, b FROM t1;
CALL p1();
ALTER TABLE t1 DROP COLUMN b;
CALL p1();
DROP PROCEDURE p1;
DROP TEMPORARY TABLE t1;
CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
CREATE PROCEDURE p1() SELECT a, b FROM v1;
CALL p1();
ALTER VIEW v1 AS SELECT 1 AS a;
CALL p1();
DROP PROCEDURE p1;
DROP VIEW v1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT a, b FROM t1;
CALL p1();
DROP TABLE t1;
CALL p1();
DROP PROCEDURE p1;
CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
CREATE PROCEDURE p1() SELECT a, b FROM v1;
CALL p1();
DROP VIEW v1;
CALL p1();
DROP PROCEDURE p1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT a, b FROM t1;
CALL p1();
DROP TABLE t1;
CALL p1();
DROP PROCEDURE p1;
CREATE TABLE t1(a INT);
CREATE TABLE t2(a INT);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE CONTINUE HANDLER FOR 1146    SELECT 'Table t1 does not exist anymore' as msg;
  SELECT * FROM t1;
  INSERT INTO t2 VALUES (1);
  SELECT GET_LOCK('m1', 10000);
    SELECT * FROM t1;
END|delimiter ;|SELECT GET_LOCK('m1', 0);
DROP TABLE t1;
SELECT RELEASE_LOCK('m1');
DROP TABLE t2;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP TABLE t1;
CREATE VIEW t1 AS SELECT 1 AS a, 2 AS b;
CALL p1();
DROP PROCEDURE p1;
DROP VIEW t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP PROCEDURE p1;
DROP TEMPORARY TABLE t1;
CREATE VIEW t1 AS SELECT 1 AS a, 2 AS b;
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP VIEW t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE VIEW t1 AS SELECT 1 AS a, 2 AS b;
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP VIEW t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP PROCEDURE p1;
DROP TEMPORARY TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP TEMPORARY TABLE t1;
CREATE VIEW t1 AS SELECT 1 AS a, 2 AS b;
CALL p1();
DROP PROCEDURE p1;
DROP VIEW t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP TEMPORARY TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE TRIGGER t1_bu BEFORE UPDATE ON t1 FOR EACH ROWBEGIN  SET @x = OLD.a;
  SET @y = NEW.a;
END|delimiter ;|SET @x = 0, @y = 0;
UPDATE t1 SET a = 3, b = 4;
SELECT @x, @y;
ALTER TABLE t1 ADD COLUMN c INT DEFAULT -1;
SET @x = 0, @y = 0;
UPDATE t1 SET a = 5, b = 6;
SELECT @x, @y;
ALTER TABLE t1 CHANGE COLUMN a a VARCHAR(255);
SET @x = 0, @y = 0;
UPDATE t1 SET a = CONCAT('xxx_', a), b = 7;
SELECT @x, @y;
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE TRIGGER t1_bu BEFORE UPDATE ON t1 FOR EACH ROWBEGIN  SET @x = OLD.a;
  SET @y = NEW.b;
END|delimiter ;|UPDATE t1 SET a = 3, b = 4;
ALTER TABLE t1 CHANGE COLUMN a a2 INT;
UPDATE t1 SET a2 = 5, b = 6;
ALTER TABLE t1 CHANGE COLUMN a2 a INT;
ALTER TABLE t1 CHANGE COLUMN b b2 INT;
UPDATE t1 SET a = 5, b2 = 6;
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()  ALTER TABLE t1 ADD COLUMN c INT DEFAULT 3|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()  ALTER TABLE t1 ADD COLUMN c INT DEFAULT 3|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TEMPORARY TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP TABLE t1;
  CREATE TABLE t1(a INT, b INT, c INT);
  INSERT INTO t1 VALUES (1, 2, 3);
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP TEMPORARY TABLE t1;
  CREATE TEMPORARY TABLE t1(a INT, b INT, c INT);
  INSERT INTO t1 VALUES (1, 2, 3);
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TEMPORARY TABLE t1;
CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP VIEW v1;
  CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b, 3 AS c;
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM v1;
  CALL p1();
  SELECT a, b FROM v1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP VIEW v1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()  ALTER TABLE t1 DROP COLUMN a|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()  ALTER TABLE t1 DROP COLUMN a|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TEMPORARY TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP TABLE t1;
  CREATE TABLE t1(b INT, c INT);
  INSERT INTO t1 VALUES (2, 3);
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP TEMPORARY TABLE t1;
  CREATE TEMPORARY TABLE t1(b INT, c INT);
  INSERT INTO t1 VALUES (2, 3);
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TEMPORARY TABLE t1;
CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP VIEW v1;
  CREATE VIEW v1 AS SELECT 2 AS b, 3 AS c;
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM v1;
  CALL p1();
  SELECT a, b FROM v1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP VIEW v1;
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION  BEGIN    SELECT 'SQLEXCEPTION caught' AS msg;
    CREATE TABLE t1(a INT, b INT);
    INSERT INTO t1 VALUES (1, 2);
  END;
  SELECT * FROM t1;
  SELECT * FROM t1;
  DROP TABLE t1;
END|CREATE PROCEDURE p2()BEGIN  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION  BEGIN    SELECT 'SQLEXCEPTION caught' AS msg;
    CREATE TEMPORARY TABLE t1(a INT, b INT);
    INSERT INTO t1 VALUES (1, 2);
  END;
  SELECT * FROM t1;
  SELECT * FROM t1;
  DROP TEMPORARY TABLE t1;
END|CREATE PROCEDURE p3()BEGIN  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION  BEGIN    SELECT 'SQLEXCEPTION caught' AS msg;
    CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
  END;
  SELECT * FROM v1;
  SELECT * FROM v1;
  DROP VIEW v1;
END|delimiter ;|CALL p1();
CALL p2();
CALL p3();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP PROCEDURE p3;
delimiter |;
CREATE PROCEDURE p1()BEGIN  IF(SELECT * FROM t1)THEN    SELECT 1;
  ELSE    SELECT 2;
  END IF;
END|CREATE PROCEDURE p2()BEGIN  DECLARE v INT DEFAULT 1;
  IF v * (SELECT * FROM t1) THEN    SELECT 1;
  ELSE    SELECT 2;
  END IF;
END|CREATE FUNCTION f1() RETURNS INTBEGIN  IF (SELECT * FROM t1) THEN    RETURN 1;
  ELSE    RETURN 2;
  END IF;
  RETURN 3;
END|CREATE FUNCTION f2() RETURNS INTBEGIN  DECLARE v INT DEFAULT 1;
  IF v * (SELECT * FROM t1) THEN    RETURN 1;
  ELSE    RETURN 2;
  END IF;
  RETURN 3;
END|delimiter ;|CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
CALL p1();
CALL p2();
SELECT f1();
SELECT f2();
UPDATE t1 SET a = 0;
CALL p1();
CALL p2();
SELECT f1();
SELECT f2();
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 1;
CALL p1();
CALL p2();
SELECT f1();
SELECT f2();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
CALL p2();
SELECT f1();
SELECT f2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP FUNCTION f1;
DROP FUNCTION f2;
DROP TABLE t1;
delimiter |;
CREATE PROCEDURE p1(x INT)BEGIN  WHILE(SELECT * FROM t1)DO    SELECT x;
    UPDATE t1 SET a = x;
    SET x = x - 1;
  END WHILE;
END|delimiter ;|CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (0);
CALL p1(3);
UPDATE t1 SET a = 1;
CALL p1(3);
UPDATE t1 SET a = 1;
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 1;
CALL p1(3);
ALTER TABLE t1 DROP COLUMN a;
CALL p1(3);
DROP PROCEDURE p1;
DROP TABLE t1;
delimiter |;
CREATE PROCEDURE p1(x INT)BEGIN  REPEAT    SELECT x;
    UPDATE t1 SET a = x;
    SET x = x - 1;
  UNTIL(NOT (SELECT * FROM t1))END REPEAT;
END|delimiter ;|CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (0);
CALL p1(3);
UPDATE t1 SET a = 1;
CALL p1(3);
UPDATE t1 SET a = 1;
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 1;
CALL p1(3);
ALTER TABLE t1 DROP COLUMN a;
CALL p1(3);
DROP PROCEDURE p1;
DROP TABLE t1;
delimiter |;
CREATE PROCEDURE p1()BEGIN  CASE    WHEN (SELECT * FROM t1) = 1 THEN SELECT 'a1';
    WHEN (SELECT * FROM t1) = 2 THEN SELECT 'a2';
    WHEN (SELECT * FROM t1) = 3 THEN SELECT 'a3';
    ELSE SELECT 'a4';
  END CASE;
END|CREATE PROCEDURE p2()BEGIN  CASE (SELECT * FROM t1)    WHEN 1 THEN SELECT 'a1';
    WHEN 2 THEN SELECT 'a2';
    WHEN 3 THEN SELECT 'a3';
    ELSE SELECT 'a4';
  END CASE;
END|delimiter ;|CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (0);
CALL p1();
CALL p2();
UPDATE t1 SET a = 3;
CALL p1();
CALL p2();
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
CALL p1();
CALL p2();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TABLE t1(a INT);
CREATE TABLE t2(a INT);
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (1);
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  SET @x = @x + 1;
  RETURN (SELECT a FROM t1);
END|CREATE PROCEDURE p1()BEGIN  CASE f1()    WHEN 1 THEN SELECT 'a1';
    WHEN 2 THEN SELECT 'a2';
    WHEN (SELECT * FROM t2) THEN SELECT 'subselect';
    ELSE SELECT 'else';
  END CASE;
END|delimiter ;|SET @x = 0;
CALL p1();
SELECT @x;
UPDATE t1 SET a = 3;
ALTER TABLE t2 ADD COLUMN b INT DEFAULT 3;
SET @x = 0;
CALL p1();
SELECT @x;
ALTER TABLE t2 DROP COLUMN a;
SET @x = 0;
CALL p1();
SELECT @x;
DROP PROCEDURE p1;
DROP FUNCTION f1;
DROP TABLE t1;
DROP TABLE t2;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE v INT DEFAULT (SELECT * FROM t1);
  SELECT v;
END|delimiter ;|CALL p1();
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2(a INT);
INSERT INTO t2 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE x INT;
  SET x = (SELECT * FROM t1);
  SELECT x;
END|CREATE PROCEDURE p2()BEGIN  SET @x = NULL;
  SET @x = (SELECT * FROM t1);
  SELECT @x;
END|CREATE TRIGGER t2_bu BEFORE UPDATE ON t2 FOR EACH ROWBEGIN  SET NEW.a = (SELECT * FROM t1) * 2;
END|delimiter ;|CALL p1();
CALL p2();
UPDATE t2 SET a = 10;
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
CALL p1();
CALL p2();
UPDATE t2 SET a = 20;
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
CALL p2();
UPDATE t2 SET a = 30;
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
DROP TABLE t2;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE v INT;
  DECLARE c CURSOR FOR SELECT * FROM t1;
  ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
  ALTER TABLE t1 DROP COLUMN a;
  OPEN c;
  FETCH c INTO v;
  CLOSE c;
  SELECT v;
END|delimiter ;|CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TEMPORARY TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE v INT;
  DECLARE c CURSOR FOR SELECT * FROM t1;
  ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
  ALTER TABLE t1 DROP COLUMN a;
  OPEN c;
  FETCH c INTO v;
  CLOSE c;
  SELECT v;
END|delimiter ;|CALL p1();
DROP TEMPORARY TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE v INT;
  DECLARE c CURSOR FOR SELECT * FROM t1;
  OPEN c;
  ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
  ALTER TABLE t1 DROP COLUMN a;
  FETCH c INTO v;
  CLOSE c;
  SELECT v;
END|delimiter ;|CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE f1 INT;
  DECLARE f2 INT;
  DECLARE f3 INT;
  DECLARE x INT DEFAULT 1;
  DECLARE y INT DEFAULT 2;
  DECLARE c CURSOR FOR SELECT x, y, t1.a FROM t1;
  ALTER TABLE t1 ADD COLUMN b INT;
  BEGIN    DECLARE x INT DEFAULT 10;
    DECLARE y INT DEFAULT 20;
    OPEN c;
    FETCH c INTO f1, f2, f3;
    SELECT f1, f2, f3;
    CLOSE c;
  END;
END|delimiter ;|CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE VIEW v1 AS SELECT * FROM t1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER TABLE t1 ADD COLUMN (b INT);
ALTER VIEW v1 AS SELECT * FROM t1;
CALL p1();
DROP VIEW v1;
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TEMPORARY TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE PROCEDURE p1()  SELECT * FROM t1;
CALL p1();
ALTER TABLE t1 ADD COLUMN (b INT);
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  CREATE TEMPORARY TABLE t1_result_set AS SELECT * FROM t1;
  RETURN 0;
END|delimiter ;|SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
ALTER TABLE t1 ADD COLUMN (b INT);
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
ALTER TABLE t1 DROP COLUMN a;
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
DROP FUNCTION f1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  CREATE TEMPORARY TABLE t1_result_set AS SELECT * FROM t1;
  RETURN 0;
END|delimiter ;|SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP FUNCTION f1;
DROP TABLE t1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE VIEW v1 AS SELECT * FROM t1;
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  CREATE TEMPORARY TABLE t1_result_set AS SELECT * FROM v1;
  RETURN 0;
END|delimiter ;|SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
ALTER TABLE t1 ADD COLUMN (b INT);
ALTER VIEW v1 AS SELECT * FROM t1;
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
DROP VIEW v1;
DROP FUNCTION f1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  CREATE TEMPORARY TABLE t1_result_set AS SELECT * FROM t1;
  RETURN 0;
END|CREATE PROCEDURE p1()  SELECT * FROM t1|delimiter ;|CALL p1();
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CALL p1;
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
CREATE TABLE t2 (a INT);
INSERT INTO t2 VALUES (1), (2);
CREATE VIEW t1 AS SELECT * FROM t2;
CALL p1;
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t2;
DROP VIEW t1;
DROP FUNCTION f1;
DROP PROCEDURE p1;
CREATE TABLE t1 (a INT);
CREATE TRIGGER trg1 BEFORE INSERT ON t1 FOR EACH ROW  SET new.a = new.a + 100;
INSERT INTO t1 VALUES (1), (2);
SELECT * FROM t1;
ALTER TABLE t1 ADD COLUMN (b INT);
INSERT INTO t1 VALUES (3, 4);
SELECT * FROM t1;
DROP TRIGGER trg1;
DROP TABLE t1;
CREATE TABLE t1 (a INT, b INT);
CREATE TRIGGER trg1 BEFORE INSERT ON t1 FOR EACH ROW  SET new.a = new.a + 100;
INSERT INTO t1 VALUES (1, 2), (3, 4);
SELECT * FROM t1;
ALTER TABLE t1 DROP COLUMN b;
INSERT INTO t1 VALUES (5);
SELECT * FROM t1;
DROP TRIGGER trg1;
DROP TABLE t1;
CREATE TABLE t1 (a INT, b INT);
CREATE TRIGGER trg1 BEFORE INSERT ON t1 FOR EACH ROW  SET new.a = new.a + 100;
INSERT INTO t1 VALUES (1, 2), (3, 4);
SELECT * FROM t1;
ALTER TABLE t1 DROP COLUMN a;
INSERT INTO t1 VALUES (5);
DROP TRIGGER trg1;
DROP TABLE t1;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2(a INT);
INSERT INTO t2 VALUES (1);
CREATE VIEW v1 AS SELECT a FROM t1;
delimiter |;
CREATE TRIGGER t2_bu BEFORE UPDATE ON t2 FOR EACH ROWBEGIN  INSERT INTO v1 VALUES (NEW.a);
  SET @x = (SELECT CHARSET(a) FROM v1 LIMIT 1);
END|delimiter ;|SET @x = NULL;
UPDATE t2 SET a = 10;
SELECT * FROM v1;
SELECT @x;
ALTER TABLE t1 CHANGE COLUMN a a CHAR(2);
SET @x = NULL;
UPDATE t2 SET a = 20;
SELECT * FROM v1;
SELECT @x;
DROP TABLE t1;
DROP TABLE t2;
DROP VIEW v1;
SET sql_mode = default;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
CREATE TABLE t1 (a INT, b INT);
CREATE TABLE t2 (a INT, b INT);
CREATE TABLE t3 (a INT);
INSERT INTO t2 VALUES (11, 12), (21, 22);
CREATE TRIGGER t3_ai AFTER INSERT ON t3 FOR EACH ROW  INSERT INTO t1 SELECT * FROM t2;
INSERT INTO t3 (a) VALUES (1);
SELECT * FROM t1;
SELECT * FROM t2;
ALTER TABLE t1 ADD COLUMN c INT;
ALTER TABLE t2 ADD COLUMN c INT;
INSERT INTO t2 VALUES (31, 32, 33);
INSERT INTO t3 (a) VALUES (2);
SELECT * FROM t1;
SELECT * FROM t2;
DROP TABLE t1;
DROP TABLE t2;
DROP TABLE t3;
CREATE TABLE t1 (a INT);
INSERT INTO t1(a) VALUES (1);
delimiter |;
CREATE TRIGGER t1_bu BEFORE UPDATE ON t1 FOR EACH ROWBEGIN  SET @a = OLD.a;
  SET @b = NEW.a;
  SELECT OLD.a INTO @c;
  SELECT NEW.a INTO @d;
  SET NEW.a = NEW.a * 2;
END|delimiter ;|UPDATE t1 SET a = a * 10;
SELECT @a, @c, @b, @d;
SELECT a FROM t1;
DROP TABLE t1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE PROCEDURE p1()  SELECT * FROM t1;
CALL p1();
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 0;
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
ALTER TABLE t1 CHANGE COLUMN b b VARCHAR(255) DEFAULT 'n/a';
DELETE FROM t1;
INSERT INTO t1 VALUES (b), ('hello');
CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE PROCEDURE p1()  SELECT * FROM t1;
CALL p1();
DROP TABLE t1;
CALL p1();
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE PROCEDURE p1()  SELECT * FROM t1;
CALL p1();
DROP TABLE t1;
CALL p1();
CREATE TABLE t1 (b VARCHAR(10), c VARCHAR(10));
INSERT INTO t1 VALUES ('a', 'b'), ('c', 'd');
CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE VIEW v1 AS SELECT 1, 2, 3;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER VIEW v1 AS SELECT 1, 2, 3, 4, 5;
CALL p1();
ALTER VIEW v1 AS SELECT 1, 5;
CALL p1();
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
DROP VIEW v1;
CREATE VIEW v1 AS SELECT * FROM t1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER TABLE t1 ADD COLUMN c INT DEFAULT 3;
CALL p1();
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT, c INT);
INSERT INTO t1 VALUES (1, 2, 3);
DROP VIEW v1;
CREATE VIEW v1 AS SELECT b, c FROM t1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
ALTER TABLE t1 DROP COLUMN b;
CALL p1();
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT, c INT);
INSERT INTO t1 VALUES (1, 2, 3);
DROP VIEW v1;
CREATE VIEW v1 AS SELECT b, c FROM t1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER TABLE t1 CHANGE COLUMN b b VARCHAR(255) DEFAULT 'n/a';
DELETE FROM t1;
INSERT INTO t1(a, c) VALUES (10, 30);
CALL p1();
DROP VIEW v1;
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE VIEW v1 AS SELECT 1, 2, 3;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
DROP VIEW v1;
CALL p1();
CREATE VIEW v1 AS SELECT 4, 5, 6;
CALL p1();
DROP VIEW v1;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE VIEW v1 AS SELECT * FROM t1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
DROP TABLE t1;
CALL p1();
CREATE TABLE t1(a VARCHAR(255), b VARCHAR(255));
INSERT INTO t1 VALUES ('a', 'b'), ('c', 'd');
CALL p1();
DROP VIEW v1;
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
ALTER TABLE t1 ADD COLUMN c INT DEFAULT 3;
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
ALTER TABLE t1 CHANGE COLUMN b b VARCHAR(255) DEFAULT 'n/a';
INSERT INTO t1(c) VALUES (4);
CALL p1();
DROP TEMPORARY TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP TEMPORARY TABLE t1;
CREATE TEMPORARY TABLE t1(a VARCHAR(255), b VARCHAR(255), c VARCHAR(255));
INSERT INTO t1 VALUES ('aa', 'bb', 'cc');
CALL p1();
DROP TEMPORARY TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT a, b FROM t1;
CALL p1();
ALTER TABLE t1 DROP COLUMN b;
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT a, b FROM t1;
CALL p1();
ALTER TABLE t1 DROP COLUMN b;
CALL p1();
DROP PROCEDURE p1;
DROP TEMPORARY TABLE t1;
CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
CREATE PROCEDURE p1() SELECT a, b FROM v1;
CALL p1();
ALTER VIEW v1 AS SELECT 1 AS a;
CALL p1();
DROP PROCEDURE p1;
DROP VIEW v1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT a, b FROM t1;
CALL p1();
DROP TABLE t1;
CALL p1();
DROP PROCEDURE p1;
CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
CREATE PROCEDURE p1() SELECT a, b FROM v1;
CALL p1();
DROP VIEW v1;
CALL p1();
DROP PROCEDURE p1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT a, b FROM t1;
CALL p1();
DROP TABLE t1;
CALL p1();
DROP PROCEDURE p1;
CREATE TABLE t1(a INT);
CREATE TABLE t2(a INT);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE CONTINUE HANDLER FOR 1146    SELECT 'Table t1 does not exist anymore' as msg;
  SELECT * FROM t1;
  INSERT INTO t2 VALUES (1);
  SELECT GET_LOCK('m1', 10000);
    SELECT * FROM t1;
END|delimiter ;|SELECT GET_LOCK('m1', 0);
DROP TABLE t1;
SELECT RELEASE_LOCK('m1');
DROP TABLE t2;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP TABLE t1;
CREATE VIEW t1 AS SELECT 1 AS a, 2 AS b;
CALL p1();
DROP PROCEDURE p1;
DROP VIEW t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP PROCEDURE p1;
DROP TEMPORARY TABLE t1;
CREATE VIEW t1 AS SELECT 1 AS a, 2 AS b;
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP VIEW t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE VIEW t1 AS SELECT 1 AS a, 2 AS b;
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP VIEW t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP PROCEDURE p1;
DROP TEMPORARY TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP TEMPORARY TABLE t1;
CREATE VIEW t1 AS SELECT 1 AS a, 2 AS b;
CALL p1();
DROP PROCEDURE p1;
DROP VIEW t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP TEMPORARY TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE TRIGGER t1_bu BEFORE UPDATE ON t1 FOR EACH ROWBEGIN  SET @x = OLD.a;
  SET @y = NEW.a;
END|delimiter ;|SET @x = 0, @y = 0;
UPDATE t1 SET a = 3, b = 4;
SELECT @x, @y;
ALTER TABLE t1 ADD COLUMN c INT DEFAULT -1;
SET @x = 0, @y = 0;
UPDATE t1 SET a = 5, b = 6;
SELECT @x, @y;
ALTER TABLE t1 CHANGE COLUMN a a VARCHAR(255);
SET @x = 0, @y = 0;
UPDATE t1 SET a = CONCAT('xxx_', a), b = 7;
SELECT @x, @y;
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE TRIGGER t1_bu BEFORE UPDATE ON t1 FOR EACH ROWBEGIN  SET @x = OLD.a;
  SET @y = NEW.b;
END|delimiter ;|UPDATE t1 SET a = 3, b = 4;
ALTER TABLE t1 CHANGE COLUMN a a2 INT;
UPDATE t1 SET a2 = 5, b = 6;
ALTER TABLE t1 CHANGE COLUMN a2 a INT;
ALTER TABLE t1 CHANGE COLUMN b b2 INT;
UPDATE t1 SET a = 5, b2 = 6;
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()  ALTER TABLE t1 ADD COLUMN c INT DEFAULT 3|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()  ALTER TABLE t1 ADD COLUMN c INT DEFAULT 3|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TEMPORARY TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP TABLE t1;
  CREATE TABLE t1(a INT, b INT, c INT);
  INSERT INTO t1 VALUES (1, 2, 3);
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP TEMPORARY TABLE t1;
  CREATE TEMPORARY TABLE t1(a INT, b INT, c INT);
  INSERT INTO t1 VALUES (1, 2, 3);
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TEMPORARY TABLE t1;
CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP VIEW v1;
  CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b, 3 AS c;
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM v1;
  CALL p1();
  SELECT a, b FROM v1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP VIEW v1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()  ALTER TABLE t1 DROP COLUMN a|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()  ALTER TABLE t1 DROP COLUMN a|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TEMPORARY TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP TABLE t1;
  CREATE TABLE t1(b INT, c INT);
  INSERT INTO t1 VALUES (2, 3);
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP TEMPORARY TABLE t1;
  CREATE TEMPORARY TABLE t1(b INT, c INT);
  INSERT INTO t1 VALUES (2, 3);
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TEMPORARY TABLE t1;
CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP VIEW v1;
  CREATE VIEW v1 AS SELECT 2 AS b, 3 AS c;
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM v1;
  CALL p1();
  SELECT a, b FROM v1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP VIEW v1;
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION  BEGIN    SELECT 'SQLEXCEPTION caught' AS msg;
    CREATE TABLE t1(a INT, b INT);
    INSERT INTO t1 VALUES (1, 2);
  END;
  SELECT * FROM t1;
  SELECT * FROM t1;
  DROP TABLE t1;
END|CREATE PROCEDURE p2()BEGIN  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION  BEGIN    SELECT 'SQLEXCEPTION caught' AS msg;
    CREATE TEMPORARY TABLE t1(a INT, b INT);
    INSERT INTO t1 VALUES (1, 2);
  END;
  SELECT * FROM t1;
  SELECT * FROM t1;
  DROP TEMPORARY TABLE t1;
END|CREATE PROCEDURE p3()BEGIN  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION  BEGIN    SELECT 'SQLEXCEPTION caught' AS msg;
    CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
  END;
  SELECT * FROM v1;
  SELECT * FROM v1;
  DROP VIEW v1;
END|delimiter ;|CALL p1();
CALL p2();
CALL p3();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP PROCEDURE p3;
delimiter |;
CREATE PROCEDURE p1()BEGIN  IF(SELECT * FROM t1)THEN    SELECT 1;
  ELSE    SELECT 2;
  END IF;
END|CREATE PROCEDURE p2()BEGIN  DECLARE v INT DEFAULT 1;
  IF v * (SELECT * FROM t1) THEN    SELECT 1;
  ELSE    SELECT 2;
  END IF;
END|CREATE FUNCTION f1() RETURNS INTBEGIN  IF (SELECT * FROM t1) THEN    RETURN 1;
  ELSE    RETURN 2;
  END IF;
  RETURN 3;
END|CREATE FUNCTION f2() RETURNS INTBEGIN  DECLARE v INT DEFAULT 1;
  IF v * (SELECT * FROM t1) THEN    RETURN 1;
  ELSE    RETURN 2;
  END IF;
  RETURN 3;
END|delimiter ;|CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
CALL p1();
CALL p2();
SELECT f1();
SELECT f2();
UPDATE t1 SET a = 0;
CALL p1();
CALL p2();
SELECT f1();
SELECT f2();
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 1;
CALL p1();
CALL p2();
SELECT f1();
SELECT f2();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
CALL p2();
SELECT f1();
SELECT f2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP FUNCTION f1;
DROP FUNCTION f2;
DROP TABLE t1;
delimiter |;
CREATE PROCEDURE p1(x INT)BEGIN  WHILE(SELECT * FROM t1)DO    SELECT x;
    UPDATE t1 SET a = x;
    SET x = x - 1;
  END WHILE;
END|delimiter ;|CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (0);
CALL p1(3);
UPDATE t1 SET a = 1;
CALL p1(3);
UPDATE t1 SET a = 1;
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 1;
CALL p1(3);
ALTER TABLE t1 DROP COLUMN a;
CALL p1(3);
DROP PROCEDURE p1;
DROP TABLE t1;
delimiter |;
CREATE PROCEDURE p1(x INT)BEGIN  REPEAT    SELECT x;
    UPDATE t1 SET a = x;
    SET x = x - 1;
  UNTIL(NOT (SELECT * FROM t1))END REPEAT;
END|delimiter ;|CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (0);
CALL p1(3);
UPDATE t1 SET a = 1;
CALL p1(3);
UPDATE t1 SET a = 1;
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 1;
CALL p1(3);
ALTER TABLE t1 DROP COLUMN a;
CALL p1(3);
DROP PROCEDURE p1;
DROP TABLE t1;
delimiter |;
CREATE PROCEDURE p1()BEGIN  CASE    WHEN (SELECT * FROM t1) = 1 THEN SELECT 'a1';
    WHEN (SELECT * FROM t1) = 2 THEN SELECT 'a2';
    WHEN (SELECT * FROM t1) = 3 THEN SELECT 'a3';
    ELSE SELECT 'a4';
  END CASE;
END|CREATE PROCEDURE p2()BEGIN  CASE (SELECT * FROM t1)    WHEN 1 THEN SELECT 'a1';
    WHEN 2 THEN SELECT 'a2';
    WHEN 3 THEN SELECT 'a3';
    ELSE SELECT 'a4';
  END CASE;
END|delimiter ;|CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (0);
CALL p1();
CALL p2();
UPDATE t1 SET a = 3;
CALL p1();
CALL p2();
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
CALL p1();
CALL p2();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TABLE t1(a INT);
CREATE TABLE t2(a INT);
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (1);
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  SET @x = @x + 1;
  RETURN (SELECT a FROM t1);
END|CREATE PROCEDURE p1()BEGIN  CASE f1()    WHEN 1 THEN SELECT 'a1';
    WHEN 2 THEN SELECT 'a2';
    WHEN (SELECT * FROM t2) THEN SELECT 'subselect';
    ELSE SELECT 'else';
  END CASE;
END|delimiter ;|SET @x = 0;
CALL p1();
SELECT @x;
UPDATE t1 SET a = 3;
ALTER TABLE t2 ADD COLUMN b INT DEFAULT 3;
SET @x = 0;
CALL p1();
SELECT @x;
ALTER TABLE t2 DROP COLUMN a;
SET @x = 0;
CALL p1();
SELECT @x;
DROP PROCEDURE p1;
DROP FUNCTION f1;
DROP TABLE t1;
DROP TABLE t2;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE v INT DEFAULT (SELECT * FROM t1);
  SELECT v;
END|delimiter ;|CALL p1();
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2(a INT);
INSERT INTO t2 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE x INT;
  SET x = (SELECT * FROM t1);
  SELECT x;
END|CREATE PROCEDURE p2()BEGIN  SET @x = NULL;
  SET @x = (SELECT * FROM t1);
  SELECT @x;
END|CREATE TRIGGER t2_bu BEFORE UPDATE ON t2 FOR EACH ROWBEGIN  SET NEW.a = (SELECT * FROM t1) * 2;
END|delimiter ;|CALL p1();
CALL p2();
UPDATE t2 SET a = 10;
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
CALL p1();
CALL p2();
UPDATE t2 SET a = 20;
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
CALL p2();
UPDATE t2 SET a = 30;
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
DROP TABLE t2;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE v INT;
  DECLARE c CURSOR FOR SELECT * FROM t1;
  ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
  ALTER TABLE t1 DROP COLUMN a;
  OPEN c;
  FETCH c INTO v;
  CLOSE c;
  SELECT v;
END|delimiter ;|CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TEMPORARY TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE v INT;
  DECLARE c CURSOR FOR SELECT * FROM t1;
  ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
  ALTER TABLE t1 DROP COLUMN a;
  OPEN c;
  FETCH c INTO v;
  CLOSE c;
  SELECT v;
END|delimiter ;|CALL p1();
DROP TEMPORARY TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE v INT;
  DECLARE c CURSOR FOR SELECT * FROM t1;
  OPEN c;
  ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
  ALTER TABLE t1 DROP COLUMN a;
  FETCH c INTO v;
  CLOSE c;
  SELECT v;
END|delimiter ;|CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE f1 INT;
  DECLARE f2 INT;
  DECLARE f3 INT;
  DECLARE x INT DEFAULT 1;
  DECLARE y INT DEFAULT 2;
  DECLARE c CURSOR FOR SELECT x, y, t1.a FROM t1;
  ALTER TABLE t1 ADD COLUMN b INT;
  BEGIN    DECLARE x INT DEFAULT 10;
    DECLARE y INT DEFAULT 20;
    OPEN c;
    FETCH c INTO f1, f2, f3;
    SELECT f1, f2, f3;
    CLOSE c;
  END;
END|delimiter ;|CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE VIEW v1 AS SELECT * FROM t1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER TABLE t1 ADD COLUMN (b INT);
ALTER VIEW v1 AS SELECT * FROM t1;
CALL p1();
DROP VIEW v1;
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TEMPORARY TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE PROCEDURE p1()  SELECT * FROM t1;
CALL p1();
ALTER TABLE t1 ADD COLUMN (b INT);
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  CREATE TEMPORARY TABLE t1_result_set AS SELECT * FROM t1;
  RETURN 0;
END|delimiter ;|SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
ALTER TABLE t1 ADD COLUMN (b INT);
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
ALTER TABLE t1 DROP COLUMN a;
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
DROP FUNCTION f1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  CREATE TEMPORARY TABLE t1_result_set AS SELECT * FROM t1;
  RETURN 0;
END|delimiter ;|SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP FUNCTION f1;
DROP TABLE t1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE VIEW v1 AS SELECT * FROM t1;
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  CREATE TEMPORARY TABLE t1_result_set AS SELECT * FROM v1;
  RETURN 0;
END|delimiter ;|SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
ALTER TABLE t1 ADD COLUMN (b INT);
ALTER VIEW v1 AS SELECT * FROM t1;
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
DROP VIEW v1;
DROP FUNCTION f1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  CREATE TEMPORARY TABLE t1_result_set AS SELECT * FROM t1;
  RETURN 0;
END|CREATE PROCEDURE p1()  SELECT * FROM t1|delimiter ;|CALL p1();
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CALL p1;
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
CREATE TABLE t2 (a INT);
INSERT INTO t2 VALUES (1), (2);
CREATE VIEW t1 AS SELECT * FROM t2;
CALL p1;
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t2;
DROP VIEW t1;
DROP FUNCTION f1;
DROP PROCEDURE p1;
CREATE TABLE t1 (a INT);
CREATE TRIGGER trg1 BEFORE INSERT ON t1 FOR EACH ROW  SET new.a = new.a + 100;
INSERT INTO t1 VALUES (1), (2);
SELECT * FROM t1;
ALTER TABLE t1 ADD COLUMN (b INT);
INSERT INTO t1 VALUES (3, 4);
SELECT * FROM t1;
DROP TRIGGER trg1;
DROP TABLE t1;
CREATE TABLE t1 (a INT, b INT);
CREATE TRIGGER trg1 BEFORE INSERT ON t1 FOR EACH ROW  SET new.a = new.a + 100;
INSERT INTO t1 VALUES (1, 2), (3, 4);
SELECT * FROM t1;
ALTER TABLE t1 DROP COLUMN b;
INSERT INTO t1 VALUES (5);
SELECT * FROM t1;
DROP TRIGGER trg1;
DROP TABLE t1;
CREATE TABLE t1 (a INT, b INT);
CREATE TRIGGER trg1 BEFORE INSERT ON t1 FOR EACH ROW  SET new.a = new.a + 100;
INSERT INTO t1 VALUES (1, 2), (3, 4);
SELECT * FROM t1;
ALTER TABLE t1 DROP COLUMN a;
INSERT INTO t1 VALUES (5);
DROP TRIGGER trg1;
DROP TABLE t1;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2(a INT);
INSERT INTO t2 VALUES (1);
CREATE VIEW v1 AS SELECT a FROM t1;
delimiter |;
CREATE TRIGGER t2_bu BEFORE UPDATE ON t2 FOR EACH ROWBEGIN  INSERT INTO v1 VALUES (NEW.a);
  SET @x = (SELECT CHARSET(a) FROM v1 LIMIT 1);
END|delimiter ;|SET @x = NULL;
UPDATE t2 SET a = 10;
SELECT * FROM v1;
SELECT @x;
ALTER TABLE t1 CHANGE COLUMN a a CHAR(2);
SET @x = NULL;
UPDATE t2 SET a = 20;
SELECT * FROM v1;
SELECT @x;
DROP TABLE t1;
DROP TABLE t2;
DROP VIEW v1;
SET sql_mode = default;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
CREATE TABLE t1 (a INT, b INT);
CREATE TABLE t2 (a INT, b INT);
CREATE TABLE t3 (a INT);
INSERT INTO t2 VALUES (11, 12), (21, 22);
CREATE TRIGGER t3_ai AFTER INSERT ON t3 FOR EACH ROW  INSERT INTO t1 SELECT * FROM t2;
INSERT INTO t3 (a) VALUES (1);
SELECT * FROM t1;
SELECT * FROM t2;
ALTER TABLE t1 ADD COLUMN c INT;
ALTER TABLE t2 ADD COLUMN c INT;
INSERT INTO t2 VALUES (31, 32, 33);
INSERT INTO t3 (a) VALUES (2);
SELECT * FROM t1;
SELECT * FROM t2;
DROP TABLE t1;
DROP TABLE t2;
DROP TABLE t3;
CREATE TABLE t1 (a INT);
INSERT INTO t1(a) VALUES (1);
delimiter |;
CREATE TRIGGER t1_bu BEFORE UPDATE ON t1 FOR EACH ROWBEGIN  SET @a = OLD.a;
  SET @b = NEW.a;
  SELECT OLD.a INTO @c;
  SELECT NEW.a INTO @d;
  SET NEW.a = NEW.a * 2;
END|delimiter ;|UPDATE t1 SET a = a * 10;
SELECT @a, @c, @b, @d;
SELECT a FROM t1;
DROP TABLE t1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE PROCEDURE p1()  SELECT * FROM t1;
CALL p1();
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 0;
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
ALTER TABLE t1 CHANGE COLUMN b b VARCHAR(255) DEFAULT 'n/a';
DELETE FROM t1;
INSERT INTO t1 VALUES (b), ('hello');
CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE PROCEDURE p1()  SELECT * FROM t1;
CALL p1();
DROP TABLE t1;
CALL p1();
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE PROCEDURE p1()  SELECT * FROM t1;
CALL p1();
DROP TABLE t1;
CALL p1();
CREATE TABLE t1 (b VARCHAR(10), c VARCHAR(10));
INSERT INTO t1 VALUES ('a', 'b'), ('c', 'd');
CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE VIEW v1 AS SELECT 1, 2, 3;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER VIEW v1 AS SELECT 1, 2, 3, 4, 5;
CALL p1();
ALTER VIEW v1 AS SELECT 1, 5;
CALL p1();
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
DROP VIEW v1;
CREATE VIEW v1 AS SELECT * FROM t1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER TABLE t1 ADD COLUMN c INT DEFAULT 3;
CALL p1();
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT, c INT);
INSERT INTO t1 VALUES (1, 2, 3);
DROP VIEW v1;
CREATE VIEW v1 AS SELECT b, c FROM t1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
ALTER TABLE t1 DROP COLUMN b;
CALL p1();
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT, c INT);
INSERT INTO t1 VALUES (1, 2, 3);
DROP VIEW v1;
CREATE VIEW v1 AS SELECT b, c FROM t1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER TABLE t1 CHANGE COLUMN b b VARCHAR(255) DEFAULT 'n/a';
DELETE FROM t1;
INSERT INTO t1(a, c) VALUES (10, 30);
CALL p1();
DROP VIEW v1;
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE VIEW v1 AS SELECT 1, 2, 3;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
DROP VIEW v1;
CALL p1();
CREATE VIEW v1 AS SELECT 4, 5, 6;
CALL p1();
DROP VIEW v1;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE VIEW v1 AS SELECT * FROM t1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
DROP TABLE t1;
CALL p1();
CREATE TABLE t1(a VARCHAR(255), b VARCHAR(255));
INSERT INTO t1 VALUES ('a', 'b'), ('c', 'd');
CALL p1();
DROP VIEW v1;
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
ALTER TABLE t1 ADD COLUMN c INT DEFAULT 3;
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
ALTER TABLE t1 CHANGE COLUMN b b VARCHAR(255) DEFAULT 'n/a';
INSERT INTO t1(c) VALUES (4);
CALL p1();
DROP TEMPORARY TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP TEMPORARY TABLE t1;
CREATE TEMPORARY TABLE t1(a VARCHAR(255), b VARCHAR(255), c VARCHAR(255));
INSERT INTO t1 VALUES ('aa', 'bb', 'cc');
CALL p1();
DROP TEMPORARY TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT a, b FROM t1;
CALL p1();
ALTER TABLE t1 DROP COLUMN b;
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT a, b FROM t1;
CALL p1();
ALTER TABLE t1 DROP COLUMN b;
CALL p1();
DROP PROCEDURE p1;
DROP TEMPORARY TABLE t1;
CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
CREATE PROCEDURE p1() SELECT a, b FROM v1;
CALL p1();
ALTER VIEW v1 AS SELECT 1 AS a;
CALL p1();
DROP PROCEDURE p1;
DROP VIEW v1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT a, b FROM t1;
CALL p1();
DROP TABLE t1;
CALL p1();
DROP PROCEDURE p1;
CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
CREATE PROCEDURE p1() SELECT a, b FROM v1;
CALL p1();
DROP VIEW v1;
CALL p1();
DROP PROCEDURE p1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT a, b FROM t1;
CALL p1();
DROP TABLE t1;
CALL p1();
DROP PROCEDURE p1;
CREATE TABLE t1(a INT);
CREATE TABLE t2(a INT);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE CONTINUE HANDLER FOR 1146    SELECT 'Table t1 does not exist anymore' as msg;
  SELECT * FROM t1;
  INSERT INTO t2 VALUES (1);
  SELECT GET_LOCK('m1', 10000);
    SELECT * FROM t1;
END|delimiter ;|SELECT GET_LOCK('m1', 0);
DROP TABLE t1;
SELECT RELEASE_LOCK('m1');
DROP TABLE t2;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP TABLE t1;
CREATE VIEW t1 AS SELECT 1 AS a, 2 AS b;
CALL p1();
DROP PROCEDURE p1;
DROP VIEW t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP PROCEDURE p1;
DROP TEMPORARY TABLE t1;
CREATE VIEW t1 AS SELECT 1 AS a, 2 AS b;
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP VIEW t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE VIEW t1 AS SELECT 1 AS a, 2 AS b;
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP VIEW t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP PROCEDURE p1;
DROP TEMPORARY TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP TEMPORARY TABLE t1;
CREATE VIEW t1 AS SELECT 1 AS a, 2 AS b;
CALL p1();
DROP PROCEDURE p1;
DROP VIEW t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP TEMPORARY TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE TRIGGER t1_bu BEFORE UPDATE ON t1 FOR EACH ROWBEGIN  SET @x = OLD.a;
  SET @y = NEW.a;
END|delimiter ;|SET @x = 0, @y = 0;
UPDATE t1 SET a = 3, b = 4;
SELECT @x, @y;
ALTER TABLE t1 ADD COLUMN c INT DEFAULT -1;
SET @x = 0, @y = 0;
UPDATE t1 SET a = 5, b = 6;
SELECT @x, @y;
ALTER TABLE t1 CHANGE COLUMN a a VARCHAR(255);
SET @x = 0, @y = 0;
UPDATE t1 SET a = CONCAT('xxx_', a), b = 7;
SELECT @x, @y;
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE TRIGGER t1_bu BEFORE UPDATE ON t1 FOR EACH ROWBEGIN  SET @x = OLD.a;
  SET @y = NEW.b;
END|delimiter ;|UPDATE t1 SET a = 3, b = 4;
ALTER TABLE t1 CHANGE COLUMN a a2 INT;
UPDATE t1 SET a2 = 5, b = 6;
ALTER TABLE t1 CHANGE COLUMN a2 a INT;
ALTER TABLE t1 CHANGE COLUMN b b2 INT;
UPDATE t1 SET a = 5, b2 = 6;
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()  ALTER TABLE t1 ADD COLUMN c INT DEFAULT 3|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()  ALTER TABLE t1 ADD COLUMN c INT DEFAULT 3|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TEMPORARY TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP TABLE t1;
  CREATE TABLE t1(a INT, b INT, c INT);
  INSERT INTO t1 VALUES (1, 2, 3);
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP TEMPORARY TABLE t1;
  CREATE TEMPORARY TABLE t1(a INT, b INT, c INT);
  INSERT INTO t1 VALUES (1, 2, 3);
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TEMPORARY TABLE t1;
CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP VIEW v1;
  CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b, 3 AS c;
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM v1;
  CALL p1();
  SELECT a, b FROM v1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP VIEW v1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()  ALTER TABLE t1 DROP COLUMN a|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()  ALTER TABLE t1 DROP COLUMN a|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TEMPORARY TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP TABLE t1;
  CREATE TABLE t1(b INT, c INT);
  INSERT INTO t1 VALUES (2, 3);
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP TEMPORARY TABLE t1;
  CREATE TEMPORARY TABLE t1(b INT, c INT);
  INSERT INTO t1 VALUES (2, 3);
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TEMPORARY TABLE t1;
CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP VIEW v1;
  CREATE VIEW v1 AS SELECT 2 AS b, 3 AS c;
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM v1;
  CALL p1();
  SELECT a, b FROM v1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP VIEW v1;
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION  BEGIN    SELECT 'SQLEXCEPTION caught' AS msg;
    CREATE TABLE t1(a INT, b INT);
    INSERT INTO t1 VALUES (1, 2);
  END;
  SELECT * FROM t1;
  SELECT * FROM t1;
  DROP TABLE t1;
END|CREATE PROCEDURE p2()BEGIN  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION  BEGIN    SELECT 'SQLEXCEPTION caught' AS msg;
    CREATE TEMPORARY TABLE t1(a INT, b INT);
    INSERT INTO t1 VALUES (1, 2);
  END;
  SELECT * FROM t1;
  SELECT * FROM t1;
  DROP TEMPORARY TABLE t1;
END|CREATE PROCEDURE p3()BEGIN  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION  BEGIN    SELECT 'SQLEXCEPTION caught' AS msg;
    CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
  END;
  SELECT * FROM v1;
  SELECT * FROM v1;
  DROP VIEW v1;
END|delimiter ;|CALL p1();
CALL p2();
CALL p3();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP PROCEDURE p3;
delimiter |;
CREATE PROCEDURE p1()BEGIN  IF(SELECT * FROM t1)THEN    SELECT 1;
  ELSE    SELECT 2;
  END IF;
END|CREATE PROCEDURE p2()BEGIN  DECLARE v INT DEFAULT 1;
  IF v * (SELECT * FROM t1) THEN    SELECT 1;
  ELSE    SELECT 2;
  END IF;
END|CREATE FUNCTION f1() RETURNS INTBEGIN  IF (SELECT * FROM t1) THEN    RETURN 1;
  ELSE    RETURN 2;
  END IF;
  RETURN 3;
END|CREATE FUNCTION f2() RETURNS INTBEGIN  DECLARE v INT DEFAULT 1;
  IF v * (SELECT * FROM t1) THEN    RETURN 1;
  ELSE    RETURN 2;
  END IF;
  RETURN 3;
END|delimiter ;|CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
CALL p1();
CALL p2();
SELECT f1();
SELECT f2();
UPDATE t1 SET a = 0;
CALL p1();
CALL p2();
SELECT f1();
SELECT f2();
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 1;
CALL p1();
CALL p2();
SELECT f1();
SELECT f2();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
CALL p2();
SELECT f1();
SELECT f2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP FUNCTION f1;
DROP FUNCTION f2;
DROP TABLE t1;
delimiter |;
CREATE PROCEDURE p1(x INT)BEGIN  WHILE(SELECT * FROM t1)DO    SELECT x;
    UPDATE t1 SET a = x;
    SET x = x - 1;
  END WHILE;
END|delimiter ;|CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (0);
CALL p1(3);
UPDATE t1 SET a = 1;
CALL p1(3);
UPDATE t1 SET a = 1;
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 1;
CALL p1(3);
ALTER TABLE t1 DROP COLUMN a;
CALL p1(3);
DROP PROCEDURE p1;
DROP TABLE t1;
delimiter |;
CREATE PROCEDURE p1(x INT)BEGIN  REPEAT    SELECT x;
    UPDATE t1 SET a = x;
    SET x = x - 1;
  UNTIL(NOT (SELECT * FROM t1))END REPEAT;
END|delimiter ;|CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (0);
CALL p1(3);
UPDATE t1 SET a = 1;
CALL p1(3);
UPDATE t1 SET a = 1;
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 1;
CALL p1(3);
ALTER TABLE t1 DROP COLUMN a;
CALL p1(3);
DROP PROCEDURE p1;
DROP TABLE t1;
delimiter |;
CREATE PROCEDURE p1()BEGIN  CASE    WHEN (SELECT * FROM t1) = 1 THEN SELECT 'a1';
    WHEN (SELECT * FROM t1) = 2 THEN SELECT 'a2';
    WHEN (SELECT * FROM t1) = 3 THEN SELECT 'a3';
    ELSE SELECT 'a4';
  END CASE;
END|CREATE PROCEDURE p2()BEGIN  CASE (SELECT * FROM t1)    WHEN 1 THEN SELECT 'a1';
    WHEN 2 THEN SELECT 'a2';
    WHEN 3 THEN SELECT 'a3';
    ELSE SELECT 'a4';
  END CASE;
END|delimiter ;|CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (0);
CALL p1();
CALL p2();
UPDATE t1 SET a = 3;
CALL p1();
CALL p2();
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
CALL p1();
CALL p2();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TABLE t1(a INT);
CREATE TABLE t2(a INT);
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (1);
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  SET @x = @x + 1;
  RETURN (SELECT a FROM t1);
END|CREATE PROCEDURE p1()BEGIN  CASE f1()    WHEN 1 THEN SELECT 'a1';
    WHEN 2 THEN SELECT 'a2';
    WHEN (SELECT * FROM t2) THEN SELECT 'subselect';
    ELSE SELECT 'else';
  END CASE;
END|delimiter ;|SET @x = 0;
CALL p1();
SELECT @x;
UPDATE t1 SET a = 3;
ALTER TABLE t2 ADD COLUMN b INT DEFAULT 3;
SET @x = 0;
CALL p1();
SELECT @x;
ALTER TABLE t2 DROP COLUMN a;
SET @x = 0;
CALL p1();
SELECT @x;
DROP PROCEDURE p1;
DROP FUNCTION f1;
DROP TABLE t1;
DROP TABLE t2;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE v INT DEFAULT (SELECT * FROM t1);
  SELECT v;
END|delimiter ;|CALL p1();
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2(a INT);
INSERT INTO t2 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE x INT;
  SET x = (SELECT * FROM t1);
  SELECT x;
END|CREATE PROCEDURE p2()BEGIN  SET @x = NULL;
  SET @x = (SELECT * FROM t1);
  SELECT @x;
END|CREATE TRIGGER t2_bu BEFORE UPDATE ON t2 FOR EACH ROWBEGIN  SET NEW.a = (SELECT * FROM t1) * 2;
END|delimiter ;|CALL p1();
CALL p2();
UPDATE t2 SET a = 10;
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
CALL p1();
CALL p2();
UPDATE t2 SET a = 20;
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
CALL p2();
UPDATE t2 SET a = 30;
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
DROP TABLE t2;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE v INT;
  DECLARE c CURSOR FOR SELECT * FROM t1;
  ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
  ALTER TABLE t1 DROP COLUMN a;
  OPEN c;
  FETCH c INTO v;
  CLOSE c;
  SELECT v;
END|delimiter ;|CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TEMPORARY TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE v INT;
  DECLARE c CURSOR FOR SELECT * FROM t1;
  ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
  ALTER TABLE t1 DROP COLUMN a;
  OPEN c;
  FETCH c INTO v;
  CLOSE c;
  SELECT v;
END|delimiter ;|CALL p1();
DROP TEMPORARY TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE v INT;
  DECLARE c CURSOR FOR SELECT * FROM t1;
  OPEN c;
  ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
  ALTER TABLE t1 DROP COLUMN a;
  FETCH c INTO v;
  CLOSE c;
  SELECT v;
END|delimiter ;|CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE f1 INT;
  DECLARE f2 INT;
  DECLARE f3 INT;
  DECLARE x INT DEFAULT 1;
  DECLARE y INT DEFAULT 2;
  DECLARE c CURSOR FOR SELECT x, y, t1.a FROM t1;
  ALTER TABLE t1 ADD COLUMN b INT;
  BEGIN    DECLARE x INT DEFAULT 10;
    DECLARE y INT DEFAULT 20;
    OPEN c;
    FETCH c INTO f1, f2, f3;
    SELECT f1, f2, f3;
    CLOSE c;
  END;
END|delimiter ;|CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE VIEW v1 AS SELECT * FROM t1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER TABLE t1 ADD COLUMN (b INT);
ALTER VIEW v1 AS SELECT * FROM t1;
CALL p1();
DROP VIEW v1;
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TEMPORARY TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE PROCEDURE p1()  SELECT * FROM t1;
CALL p1();
ALTER TABLE t1 ADD COLUMN (b INT);
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  CREATE TEMPORARY TABLE t1_result_set AS SELECT * FROM t1;
  RETURN 0;
END|delimiter ;|SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
ALTER TABLE t1 ADD COLUMN (b INT);
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
ALTER TABLE t1 DROP COLUMN a;
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
DROP FUNCTION f1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  CREATE TEMPORARY TABLE t1_result_set AS SELECT * FROM t1;
  RETURN 0;
END|delimiter ;|SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP FUNCTION f1;
DROP TABLE t1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE VIEW v1 AS SELECT * FROM t1;
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  CREATE TEMPORARY TABLE t1_result_set AS SELECT * FROM v1;
  RETURN 0;
END|delimiter ;|SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
ALTER TABLE t1 ADD COLUMN (b INT);
ALTER VIEW v1 AS SELECT * FROM t1;
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
DROP VIEW v1;
DROP FUNCTION f1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  CREATE TEMPORARY TABLE t1_result_set AS SELECT * FROM t1;
  RETURN 0;
END|CREATE PROCEDURE p1()  SELECT * FROM t1|delimiter ;|CALL p1();
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CALL p1;
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
CREATE TABLE t2 (a INT);
INSERT INTO t2 VALUES (1), (2);
CREATE VIEW t1 AS SELECT * FROM t2;
CALL p1;
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t2;
DROP VIEW t1;
DROP FUNCTION f1;
DROP PROCEDURE p1;
CREATE TABLE t1 (a INT);
CREATE TRIGGER trg1 BEFORE INSERT ON t1 FOR EACH ROW  SET new.a = new.a + 100;
INSERT INTO t1 VALUES (1), (2);
SELECT * FROM t1;
ALTER TABLE t1 ADD COLUMN (b INT);
INSERT INTO t1 VALUES (3, 4);
SELECT * FROM t1;
DROP TRIGGER trg1;
DROP TABLE t1;
CREATE TABLE t1 (a INT, b INT);
CREATE TRIGGER trg1 BEFORE INSERT ON t1 FOR EACH ROW  SET new.a = new.a + 100;
INSERT INTO t1 VALUES (1, 2), (3, 4);
SELECT * FROM t1;
ALTER TABLE t1 DROP COLUMN b;
INSERT INTO t1 VALUES (5);
SELECT * FROM t1;
DROP TRIGGER trg1;
DROP TABLE t1;
CREATE TABLE t1 (a INT, b INT);
CREATE TRIGGER trg1 BEFORE INSERT ON t1 FOR EACH ROW  SET new.a = new.a + 100;
INSERT INTO t1 VALUES (1, 2), (3, 4);
SELECT * FROM t1;
ALTER TABLE t1 DROP COLUMN a;
INSERT INTO t1 VALUES (5);
DROP TRIGGER trg1;
DROP TABLE t1;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2(a INT);
INSERT INTO t2 VALUES (1);
CREATE VIEW v1 AS SELECT a FROM t1;
delimiter |;
CREATE TRIGGER t2_bu BEFORE UPDATE ON t2 FOR EACH ROWBEGIN  INSERT INTO v1 VALUES (NEW.a);
  SET @x = (SELECT CHARSET(a) FROM v1 LIMIT 1);
END|delimiter ;|SET @x = NULL;
UPDATE t2 SET a = 10;
SELECT * FROM v1;
SELECT @x;
ALTER TABLE t1 CHANGE COLUMN a a CHAR(2);
SET @x = NULL;
UPDATE t2 SET a = 20;
SELECT * FROM v1;
SELECT @x;
DROP TABLE t1;
DROP TABLE t2;
DROP VIEW v1;
SET sql_mode = default;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
CREATE TABLE t1 (a INT, b INT);
CREATE TABLE t2 (a INT, b INT);
CREATE TABLE t3 (a INT);
INSERT INTO t2 VALUES (11, 12), (21, 22);
CREATE TRIGGER t3_ai AFTER INSERT ON t3 FOR EACH ROW  INSERT INTO t1 SELECT * FROM t2;
INSERT INTO t3 (a) VALUES (1);
SELECT * FROM t1;
SELECT * FROM t2;
ALTER TABLE t1 ADD COLUMN c INT;
ALTER TABLE t2 ADD COLUMN c INT;
INSERT INTO t2 VALUES (31, 32, 33);
INSERT INTO t3 (a) VALUES (2);
SELECT * FROM t1;
SELECT * FROM t2;
DROP TABLE t1;
DROP TABLE t2;
DROP TABLE t3;
CREATE TABLE t1 (a INT);
INSERT INTO t1(a) VALUES (1);
delimiter |;
CREATE TRIGGER t1_bu BEFORE UPDATE ON t1 FOR EACH ROWBEGIN  SET @a = OLD.a;
  SET @b = NEW.a;
  SELECT OLD.a INTO @c;
  SELECT NEW.a INTO @d;
  SET NEW.a = NEW.a * 2;
END|delimiter ;|UPDATE t1 SET a = a * 10;
SELECT @a, @c, @b, @d;
SELECT a FROM t1;
DROP TABLE t1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE PROCEDURE p1()  SELECT * FROM t1;
CALL p1();
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 0;
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
ALTER TABLE t1 CHANGE COLUMN b b VARCHAR(255) DEFAULT 'n/a';
DELETE FROM t1;
INSERT INTO t1 VALUES (b), ('hello');
CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE PROCEDURE p1()  SELECT * FROM t1;
CALL p1();
DROP TABLE t1;
CALL p1();
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE PROCEDURE p1()  SELECT * FROM t1;
CALL p1();
DROP TABLE t1;
CALL p1();
CREATE TABLE t1 (b VARCHAR(10), c VARCHAR(10));
INSERT INTO t1 VALUES ('a', 'b'), ('c', 'd');
CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE VIEW v1 AS SELECT 1, 2, 3;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER VIEW v1 AS SELECT 1, 2, 3, 4, 5;
CALL p1();
ALTER VIEW v1 AS SELECT 1, 5;
CALL p1();
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
DROP VIEW v1;
CREATE VIEW v1 AS SELECT * FROM t1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER TABLE t1 ADD COLUMN c INT DEFAULT 3;
CALL p1();
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT, c INT);
INSERT INTO t1 VALUES (1, 2, 3);
DROP VIEW v1;
CREATE VIEW v1 AS SELECT b, c FROM t1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
ALTER TABLE t1 DROP COLUMN b;
CALL p1();
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT, c INT);
INSERT INTO t1 VALUES (1, 2, 3);
DROP VIEW v1;
CREATE VIEW v1 AS SELECT b, c FROM t1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER TABLE t1 CHANGE COLUMN b b VARCHAR(255) DEFAULT 'n/a';
DELETE FROM t1;
INSERT INTO t1(a, c) VALUES (10, 30);
CALL p1();
DROP VIEW v1;
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE VIEW v1 AS SELECT 1, 2, 3;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
DROP VIEW v1;
CALL p1();
CREATE VIEW v1 AS SELECT 4, 5, 6;
CALL p1();
DROP VIEW v1;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE VIEW v1 AS SELECT * FROM t1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
DROP TABLE t1;
CALL p1();
CREATE TABLE t1(a VARCHAR(255), b VARCHAR(255));
INSERT INTO t1 VALUES ('a', 'b'), ('c', 'd');
CALL p1();
DROP VIEW v1;
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
ALTER TABLE t1 ADD COLUMN c INT DEFAULT 3;
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
ALTER TABLE t1 CHANGE COLUMN b b VARCHAR(255) DEFAULT 'n/a';
INSERT INTO t1(c) VALUES (4);
CALL p1();
DROP TEMPORARY TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP TEMPORARY TABLE t1;
CREATE TEMPORARY TABLE t1(a VARCHAR(255), b VARCHAR(255), c VARCHAR(255));
INSERT INTO t1 VALUES ('aa', 'bb', 'cc');
CALL p1();
DROP TEMPORARY TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT a, b FROM t1;
CALL p1();
ALTER TABLE t1 DROP COLUMN b;
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT a, b FROM t1;
CALL p1();
ALTER TABLE t1 DROP COLUMN b;
CALL p1();
DROP PROCEDURE p1;
DROP TEMPORARY TABLE t1;
CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
CREATE PROCEDURE p1() SELECT a, b FROM v1;
CALL p1();
ALTER VIEW v1 AS SELECT 1 AS a;
CALL p1();
DROP PROCEDURE p1;
DROP VIEW v1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT a, b FROM t1;
CALL p1();
DROP TABLE t1;
CALL p1();
DROP PROCEDURE p1;
CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
CREATE PROCEDURE p1() SELECT a, b FROM v1;
CALL p1();
DROP VIEW v1;
CALL p1();
DROP PROCEDURE p1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT a, b FROM t1;
CALL p1();
DROP TABLE t1;
CALL p1();
DROP PROCEDURE p1;
CREATE TABLE t1(a INT);
CREATE TABLE t2(a INT);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE CONTINUE HANDLER FOR 1146    SELECT 'Table t1 does not exist anymore' as msg;
  SELECT * FROM t1;
  INSERT INTO t2 VALUES (1);
  SELECT GET_LOCK('m1', 10000);
    SELECT * FROM t1;
END|delimiter ;|SELECT GET_LOCK('m1', 0);
DROP TABLE t1;
SELECT RELEASE_LOCK('m1');
DROP TABLE t2;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP TABLE t1;
CREATE VIEW t1 AS SELECT 1 AS a, 2 AS b;
CALL p1();
DROP PROCEDURE p1;
DROP VIEW t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP PROCEDURE p1;
DROP TEMPORARY TABLE t1;
CREATE VIEW t1 AS SELECT 1 AS a, 2 AS b;
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP VIEW t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE VIEW t1 AS SELECT 1 AS a, 2 AS b;
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP VIEW t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP PROCEDURE p1;
DROP TEMPORARY TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP TEMPORARY TABLE t1;
CREATE VIEW t1 AS SELECT 1 AS a, 2 AS b;
CALL p1();
DROP PROCEDURE p1;
DROP VIEW t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP TEMPORARY TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE TRIGGER t1_bu BEFORE UPDATE ON t1 FOR EACH ROWBEGIN  SET @x = OLD.a;
  SET @y = NEW.a;
END|delimiter ;|SET @x = 0, @y = 0;
UPDATE t1 SET a = 3, b = 4;
SELECT @x, @y;
ALTER TABLE t1 ADD COLUMN c INT DEFAULT -1;
SET @x = 0, @y = 0;
UPDATE t1 SET a = 5, b = 6;
SELECT @x, @y;
ALTER TABLE t1 CHANGE COLUMN a a VARCHAR(255);
SET @x = 0, @y = 0;
UPDATE t1 SET a = CONCAT('xxx_', a), b = 7;
SELECT @x, @y;
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE TRIGGER t1_bu BEFORE UPDATE ON t1 FOR EACH ROWBEGIN  SET @x = OLD.a;
  SET @y = NEW.b;
END|delimiter ;|UPDATE t1 SET a = 3, b = 4;
ALTER TABLE t1 CHANGE COLUMN a a2 INT;
UPDATE t1 SET a2 = 5, b = 6;
ALTER TABLE t1 CHANGE COLUMN a2 a INT;
ALTER TABLE t1 CHANGE COLUMN b b2 INT;
UPDATE t1 SET a = 5, b2 = 6;
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()  ALTER TABLE t1 ADD COLUMN c INT DEFAULT 3|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()  ALTER TABLE t1 ADD COLUMN c INT DEFAULT 3|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TEMPORARY TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP TABLE t1;
  CREATE TABLE t1(a INT, b INT, c INT);
  INSERT INTO t1 VALUES (1, 2, 3);
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP TEMPORARY TABLE t1;
  CREATE TEMPORARY TABLE t1(a INT, b INT, c INT);
  INSERT INTO t1 VALUES (1, 2, 3);
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TEMPORARY TABLE t1;
CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP VIEW v1;
  CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b, 3 AS c;
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM v1;
  CALL p1();
  SELECT a, b FROM v1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP VIEW v1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()  ALTER TABLE t1 DROP COLUMN a|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()  ALTER TABLE t1 DROP COLUMN a|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TEMPORARY TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP TABLE t1;
  CREATE TABLE t1(b INT, c INT);
  INSERT INTO t1 VALUES (2, 3);
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP TEMPORARY TABLE t1;
  CREATE TEMPORARY TABLE t1(b INT, c INT);
  INSERT INTO t1 VALUES (2, 3);
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TEMPORARY TABLE t1;
CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP VIEW v1;
  CREATE VIEW v1 AS SELECT 2 AS b, 3 AS c;
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM v1;
  CALL p1();
  SELECT a, b FROM v1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP VIEW v1;
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION  BEGIN    SELECT 'SQLEXCEPTION caught' AS msg;
    CREATE TABLE t1(a INT, b INT);
    INSERT INTO t1 VALUES (1, 2);
  END;
  SELECT * FROM t1;
  SELECT * FROM t1;
  DROP TABLE t1;
END|CREATE PROCEDURE p2()BEGIN  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION  BEGIN    SELECT 'SQLEXCEPTION caught' AS msg;
    CREATE TEMPORARY TABLE t1(a INT, b INT);
    INSERT INTO t1 VALUES (1, 2);
  END;
  SELECT * FROM t1;
  SELECT * FROM t1;
  DROP TEMPORARY TABLE t1;
END|CREATE PROCEDURE p3()BEGIN  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION  BEGIN    SELECT 'SQLEXCEPTION caught' AS msg;
    CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
  END;
  SELECT * FROM v1;
  SELECT * FROM v1;
  DROP VIEW v1;
END|delimiter ;|CALL p1();
CALL p2();
CALL p3();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP PROCEDURE p3;
delimiter |;
CREATE PROCEDURE p1()BEGIN  IF(SELECT * FROM t1)THEN    SELECT 1;
  ELSE    SELECT 2;
  END IF;
END|CREATE PROCEDURE p2()BEGIN  DECLARE v INT DEFAULT 1;
  IF v * (SELECT * FROM t1) THEN    SELECT 1;
  ELSE    SELECT 2;
  END IF;
END|CREATE FUNCTION f1() RETURNS INTBEGIN  IF (SELECT * FROM t1) THEN    RETURN 1;
  ELSE    RETURN 2;
  END IF;
  RETURN 3;
END|CREATE FUNCTION f2() RETURNS INTBEGIN  DECLARE v INT DEFAULT 1;
  IF v * (SELECT * FROM t1) THEN    RETURN 1;
  ELSE    RETURN 2;
  END IF;
  RETURN 3;
END|delimiter ;|CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
CALL p1();
CALL p2();
SELECT f1();
SELECT f2();
UPDATE t1 SET a = 0;
CALL p1();
CALL p2();
SELECT f1();
SELECT f2();
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 1;
CALL p1();
CALL p2();
SELECT f1();
SELECT f2();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
CALL p2();
SELECT f1();
SELECT f2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP FUNCTION f1;
DROP FUNCTION f2;
DROP TABLE t1;
delimiter |;
CREATE PROCEDURE p1(x INT)BEGIN  WHILE(SELECT * FROM t1)DO    SELECT x;
    UPDATE t1 SET a = x;
    SET x = x - 1;
  END WHILE;
END|delimiter ;|CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (0);
CALL p1(3);
UPDATE t1 SET a = 1;
CALL p1(3);
UPDATE t1 SET a = 1;
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 1;
CALL p1(3);
ALTER TABLE t1 DROP COLUMN a;
CALL p1(3);
DROP PROCEDURE p1;
DROP TABLE t1;
delimiter |;
CREATE PROCEDURE p1(x INT)BEGIN  REPEAT    SELECT x;
    UPDATE t1 SET a = x;
    SET x = x - 1;
  UNTIL(NOT (SELECT * FROM t1))END REPEAT;
END|delimiter ;|CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (0);
CALL p1(3);
UPDATE t1 SET a = 1;
CALL p1(3);
UPDATE t1 SET a = 1;
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 1;
CALL p1(3);
ALTER TABLE t1 DROP COLUMN a;
CALL p1(3);
DROP PROCEDURE p1;
DROP TABLE t1;
delimiter |;
CREATE PROCEDURE p1()BEGIN  CASE    WHEN (SELECT * FROM t1) = 1 THEN SELECT 'a1';
    WHEN (SELECT * FROM t1) = 2 THEN SELECT 'a2';
    WHEN (SELECT * FROM t1) = 3 THEN SELECT 'a3';
    ELSE SELECT 'a4';
  END CASE;
END|CREATE PROCEDURE p2()BEGIN  CASE (SELECT * FROM t1)    WHEN 1 THEN SELECT 'a1';
    WHEN 2 THEN SELECT 'a2';
    WHEN 3 THEN SELECT 'a3';
    ELSE SELECT 'a4';
  END CASE;
END|delimiter ;|CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (0);
CALL p1();
CALL p2();
UPDATE t1 SET a = 3;
CALL p1();
CALL p2();
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
CALL p1();
CALL p2();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TABLE t1(a INT);
CREATE TABLE t2(a INT);
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (1);
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  SET @x = @x + 1;
  RETURN (SELECT a FROM t1);
END|CREATE PROCEDURE p1()BEGIN  CASE f1()    WHEN 1 THEN SELECT 'a1';
    WHEN 2 THEN SELECT 'a2';
    WHEN (SELECT * FROM t2) THEN SELECT 'subselect';
    ELSE SELECT 'else';
  END CASE;
END|delimiter ;|SET @x = 0;
CALL p1();
SELECT @x;
UPDATE t1 SET a = 3;
ALTER TABLE t2 ADD COLUMN b INT DEFAULT 3;
SET @x = 0;
CALL p1();
SELECT @x;
ALTER TABLE t2 DROP COLUMN a;
SET @x = 0;
CALL p1();
SELECT @x;
DROP PROCEDURE p1;
DROP FUNCTION f1;
DROP TABLE t1;
DROP TABLE t2;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE v INT DEFAULT (SELECT * FROM t1);
  SELECT v;
END|delimiter ;|CALL p1();
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2(a INT);
INSERT INTO t2 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE x INT;
  SET x = (SELECT * FROM t1);
  SELECT x;
END|CREATE PROCEDURE p2()BEGIN  SET @x = NULL;
  SET @x = (SELECT * FROM t1);
  SELECT @x;
END|CREATE TRIGGER t2_bu BEFORE UPDATE ON t2 FOR EACH ROWBEGIN  SET NEW.a = (SELECT * FROM t1) * 2;
END|delimiter ;|CALL p1();
CALL p2();
UPDATE t2 SET a = 10;
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
CALL p1();
CALL p2();
UPDATE t2 SET a = 20;
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
CALL p2();
UPDATE t2 SET a = 30;
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
DROP TABLE t2;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE v INT;
  DECLARE c CURSOR FOR SELECT * FROM t1;
  ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
  ALTER TABLE t1 DROP COLUMN a;
  OPEN c;
  FETCH c INTO v;
  CLOSE c;
  SELECT v;
END|delimiter ;|CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TEMPORARY TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE v INT;
  DECLARE c CURSOR FOR SELECT * FROM t1;
  ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
  ALTER TABLE t1 DROP COLUMN a;
  OPEN c;
  FETCH c INTO v;
  CLOSE c;
  SELECT v;
END|delimiter ;|CALL p1();
DROP TEMPORARY TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE v INT;
  DECLARE c CURSOR FOR SELECT * FROM t1;
  OPEN c;
  ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
  ALTER TABLE t1 DROP COLUMN a;
  FETCH c INTO v;
  CLOSE c;
  SELECT v;
END|delimiter ;|CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE f1 INT;
  DECLARE f2 INT;
  DECLARE f3 INT;
  DECLARE x INT DEFAULT 1;
  DECLARE y INT DEFAULT 2;
  DECLARE c CURSOR FOR SELECT x, y, t1.a FROM t1;
  ALTER TABLE t1 ADD COLUMN b INT;
  BEGIN    DECLARE x INT DEFAULT 10;
    DECLARE y INT DEFAULT 20;
    OPEN c;
    FETCH c INTO f1, f2, f3;
    SELECT f1, f2, f3;
    CLOSE c;
  END;
END|delimiter ;|CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE VIEW v1 AS SELECT * FROM t1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER TABLE t1 ADD COLUMN (b INT);
ALTER VIEW v1 AS SELECT * FROM t1;
CALL p1();
DROP VIEW v1;
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TEMPORARY TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE PROCEDURE p1()  SELECT * FROM t1;
CALL p1();
ALTER TABLE t1 ADD COLUMN (b INT);
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  CREATE TEMPORARY TABLE t1_result_set AS SELECT * FROM t1;
  RETURN 0;
END|delimiter ;|SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
ALTER TABLE t1 ADD COLUMN (b INT);
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
ALTER TABLE t1 DROP COLUMN a;
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
DROP FUNCTION f1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  CREATE TEMPORARY TABLE t1_result_set AS SELECT * FROM t1;
  RETURN 0;
END|delimiter ;|SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP FUNCTION f1;
DROP TABLE t1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE VIEW v1 AS SELECT * FROM t1;
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  CREATE TEMPORARY TABLE t1_result_set AS SELECT * FROM v1;
  RETURN 0;
END|delimiter ;|SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
ALTER TABLE t1 ADD COLUMN (b INT);
ALTER VIEW v1 AS SELECT * FROM t1;
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
DROP VIEW v1;
DROP FUNCTION f1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  CREATE TEMPORARY TABLE t1_result_set AS SELECT * FROM t1;
  RETURN 0;
END|CREATE PROCEDURE p1()  SELECT * FROM t1|delimiter ;|CALL p1();
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CALL p1;
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
CREATE TABLE t2 (a INT);
INSERT INTO t2 VALUES (1), (2);
CREATE VIEW t1 AS SELECT * FROM t2;
CALL p1;
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t2;
DROP VIEW t1;
DROP FUNCTION f1;
DROP PROCEDURE p1;
CREATE TABLE t1 (a INT);
CREATE TRIGGER trg1 BEFORE INSERT ON t1 FOR EACH ROW  SET new.a = new.a + 100;
INSERT INTO t1 VALUES (1), (2);
SELECT * FROM t1;
ALTER TABLE t1 ADD COLUMN (b INT);
INSERT INTO t1 VALUES (3, 4);
SELECT * FROM t1;
DROP TRIGGER trg1;
DROP TABLE t1;
CREATE TABLE t1 (a INT, b INT);
CREATE TRIGGER trg1 BEFORE INSERT ON t1 FOR EACH ROW  SET new.a = new.a + 100;
INSERT INTO t1 VALUES (1, 2), (3, 4);
SELECT * FROM t1;
ALTER TABLE t1 DROP COLUMN b;
INSERT INTO t1 VALUES (5);
SELECT * FROM t1;
DROP TRIGGER trg1;
DROP TABLE t1;
CREATE TABLE t1 (a INT, b INT);
CREATE TRIGGER trg1 BEFORE INSERT ON t1 FOR EACH ROW  SET new.a = new.a + 100;
INSERT INTO t1 VALUES (1, 2), (3, 4);
SELECT * FROM t1;
ALTER TABLE t1 DROP COLUMN a;
INSERT INTO t1 VALUES (5);
DROP TRIGGER trg1;
DROP TABLE t1;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2(a INT);
INSERT INTO t2 VALUES (1);
CREATE VIEW v1 AS SELECT a FROM t1;
delimiter |;
CREATE TRIGGER t2_bu BEFORE UPDATE ON t2 FOR EACH ROWBEGIN  INSERT INTO v1 VALUES (NEW.a);
  SET @x = (SELECT CHARSET(a) FROM v1 LIMIT 1);
END|delimiter ;|SET @x = NULL;
UPDATE t2 SET a = 10;
SELECT * FROM v1;
SELECT @x;
ALTER TABLE t1 CHANGE COLUMN a a CHAR(2);
SET @x = NULL;
UPDATE t2 SET a = 20;
SELECT * FROM v1;
SELECT @x;
DROP TABLE t1;
DROP TABLE t2;
DROP VIEW v1;
SET sql_mode = default;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
CREATE TABLE t1 (a INT, b INT);
CREATE TABLE t2 (a INT, b INT);
CREATE TABLE t3 (a INT);
INSERT INTO t2 VALUES (11, 12), (21, 22);
CREATE TRIGGER t3_ai AFTER INSERT ON t3 FOR EACH ROW  INSERT INTO t1 SELECT * FROM t2;
INSERT INTO t3 (a) VALUES (1);
SELECT * FROM t1;
SELECT * FROM t2;
ALTER TABLE t1 ADD COLUMN c INT;
ALTER TABLE t2 ADD COLUMN c INT;
INSERT INTO t2 VALUES (31, 32, 33);
INSERT INTO t3 (a) VALUES (2);
SELECT * FROM t1;
SELECT * FROM t2;
DROP TABLE t1;
DROP TABLE t2;
DROP TABLE t3;
CREATE TABLE t1 (a INT);
INSERT INTO t1(a) VALUES (1);
delimiter |;
CREATE TRIGGER t1_bu BEFORE UPDATE ON t1 FOR EACH ROWBEGIN  SET @a = OLD.a;
  SET @b = NEW.a;
  SELECT OLD.a INTO @c;
  SELECT NEW.a INTO @d;
  SET NEW.a = NEW.a * 2;
END|delimiter ;|UPDATE t1 SET a = a * 10;
SELECT @a, @c, @b, @d;
SELECT a FROM t1;
DROP TABLE t1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE PROCEDURE p1()  SELECT * FROM t1;
CALL p1();
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 0;
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
ALTER TABLE t1 CHANGE COLUMN b b VARCHAR(255) DEFAULT 'n/a';
DELETE FROM t1;
INSERT INTO t1 VALUES (b), ('hello');
CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE PROCEDURE p1()  SELECT * FROM t1;
CALL p1();
DROP TABLE t1;
CALL p1();
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE PROCEDURE p1()  SELECT * FROM t1;
CALL p1();
DROP TABLE t1;
CALL p1();
CREATE TABLE t1 (b VARCHAR(10), c VARCHAR(10));
INSERT INTO t1 VALUES ('a', 'b'), ('c', 'd');
CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE VIEW v1 AS SELECT 1, 2, 3;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER VIEW v1 AS SELECT 1, 2, 3, 4, 5;
CALL p1();
ALTER VIEW v1 AS SELECT 1, 5;
CALL p1();
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
DROP VIEW v1;
CREATE VIEW v1 AS SELECT * FROM t1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER TABLE t1 ADD COLUMN c INT DEFAULT 3;
CALL p1();
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT, c INT);
INSERT INTO t1 VALUES (1, 2, 3);
DROP VIEW v1;
CREATE VIEW v1 AS SELECT b, c FROM t1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
ALTER TABLE t1 DROP COLUMN b;
CALL p1();
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT, c INT);
INSERT INTO t1 VALUES (1, 2, 3);
DROP VIEW v1;
CREATE VIEW v1 AS SELECT b, c FROM t1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER TABLE t1 CHANGE COLUMN b b VARCHAR(255) DEFAULT 'n/a';
DELETE FROM t1;
INSERT INTO t1(a, c) VALUES (10, 30);
CALL p1();
DROP VIEW v1;
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE VIEW v1 AS SELECT 1, 2, 3;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
DROP VIEW v1;
CALL p1();
CREATE VIEW v1 AS SELECT 4, 5, 6;
CALL p1();
DROP VIEW v1;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE VIEW v1 AS SELECT * FROM t1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
DROP TABLE t1;
CALL p1();
CREATE TABLE t1(a VARCHAR(255), b VARCHAR(255));
INSERT INTO t1 VALUES ('a', 'b'), ('c', 'd');
CALL p1();
DROP VIEW v1;
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
ALTER TABLE t1 ADD COLUMN c INT DEFAULT 3;
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
ALTER TABLE t1 CHANGE COLUMN b b VARCHAR(255) DEFAULT 'n/a';
INSERT INTO t1(c) VALUES (4);
CALL p1();
DROP TEMPORARY TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP TEMPORARY TABLE t1;
CREATE TEMPORARY TABLE t1(a VARCHAR(255), b VARCHAR(255), c VARCHAR(255));
INSERT INTO t1 VALUES ('aa', 'bb', 'cc');
CALL p1();
DROP TEMPORARY TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT a, b FROM t1;
CALL p1();
ALTER TABLE t1 DROP COLUMN b;
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT a, b FROM t1;
CALL p1();
ALTER TABLE t1 DROP COLUMN b;
CALL p1();
DROP PROCEDURE p1;
DROP TEMPORARY TABLE t1;
CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
CREATE PROCEDURE p1() SELECT a, b FROM v1;
CALL p1();
ALTER VIEW v1 AS SELECT 1 AS a;
CALL p1();
DROP PROCEDURE p1;
DROP VIEW v1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT a, b FROM t1;
CALL p1();
DROP TABLE t1;
CALL p1();
DROP PROCEDURE p1;
CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
CREATE PROCEDURE p1() SELECT a, b FROM v1;
CALL p1();
DROP VIEW v1;
CALL p1();
DROP PROCEDURE p1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT a, b FROM t1;
CALL p1();
DROP TABLE t1;
CALL p1();
DROP PROCEDURE p1;
CREATE TABLE t1(a INT);
CREATE TABLE t2(a INT);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE CONTINUE HANDLER FOR 1146    SELECT 'Table t1 does not exist anymore' as msg;
  SELECT * FROM t1;
  INSERT INTO t2 VALUES (1);
  SELECT GET_LOCK('m1', 10000);
    SELECT * FROM t1;
END|delimiter ;|SELECT GET_LOCK('m1', 0);
DROP TABLE t1;
SELECT RELEASE_LOCK('m1');
DROP TABLE t2;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP TABLE t1;
CREATE VIEW t1 AS SELECT 1 AS a, 2 AS b;
CALL p1();
DROP PROCEDURE p1;
DROP VIEW t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP PROCEDURE p1;
DROP TEMPORARY TABLE t1;
CREATE VIEW t1 AS SELECT 1 AS a, 2 AS b;
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP VIEW t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE VIEW t1 AS SELECT 1 AS a, 2 AS b;
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP VIEW t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP PROCEDURE p1;
DROP TEMPORARY TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP TEMPORARY TABLE t1;
CREATE VIEW t1 AS SELECT 1 AS a, 2 AS b;
CALL p1();
DROP PROCEDURE p1;
DROP VIEW t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE PROCEDURE p1() SELECT * FROM t1;
CALL p1();
DROP TEMPORARY TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE TRIGGER t1_bu BEFORE UPDATE ON t1 FOR EACH ROWBEGIN  SET @x = OLD.a;
  SET @y = NEW.a;
END|delimiter ;|SET @x = 0, @y = 0;
UPDATE t1 SET a = 3, b = 4;
SELECT @x, @y;
ALTER TABLE t1 ADD COLUMN c INT DEFAULT -1;
SET @x = 0, @y = 0;
UPDATE t1 SET a = 5, b = 6;
SELECT @x, @y;
ALTER TABLE t1 CHANGE COLUMN a a VARCHAR(255);
SET @x = 0, @y = 0;
UPDATE t1 SET a = CONCAT('xxx_', a), b = 7;
SELECT @x, @y;
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE TRIGGER t1_bu BEFORE UPDATE ON t1 FOR EACH ROWBEGIN  SET @x = OLD.a;
  SET @y = NEW.b;
END|delimiter ;|UPDATE t1 SET a = 3, b = 4;
ALTER TABLE t1 CHANGE COLUMN a a2 INT;
UPDATE t1 SET a2 = 5, b = 6;
ALTER TABLE t1 CHANGE COLUMN a2 a INT;
ALTER TABLE t1 CHANGE COLUMN b b2 INT;
UPDATE t1 SET a = 5, b2 = 6;
DROP TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()  ALTER TABLE t1 ADD COLUMN c INT DEFAULT 3|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()  ALTER TABLE t1 ADD COLUMN c INT DEFAULT 3|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TEMPORARY TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP TABLE t1;
  CREATE TABLE t1(a INT, b INT, c INT);
  INSERT INTO t1 VALUES (1, 2, 3);
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP TEMPORARY TABLE t1;
  CREATE TEMPORARY TABLE t1(a INT, b INT, c INT);
  INSERT INTO t1 VALUES (1, 2, 3);
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TEMPORARY TABLE t1;
CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP VIEW v1;
  CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b, 3 AS c;
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM v1;
  CALL p1();
  SELECT a, b FROM v1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP VIEW v1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()  ALTER TABLE t1 DROP COLUMN a|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()  ALTER TABLE t1 DROP COLUMN a|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TEMPORARY TABLE t1;
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP TABLE t1;
  CREATE TABLE t1(b INT, c INT);
  INSERT INTO t1 VALUES (2, 3);
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP TEMPORARY TABLE t1;
  CREATE TEMPORARY TABLE t1(b INT, c INT);
  INSERT INTO t1 VALUES (2, 3);
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM t1;
  CALL p1();
  SELECT a, b FROM t1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TEMPORARY TABLE t1;
CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
delimiter |;
CREATE PROCEDURE p1()BEGIN  DROP VIEW v1;
  CREATE VIEW v1 AS SELECT 2 AS b, 3 AS c;
END|CREATE PROCEDURE p2()BEGIN  SELECT a, b FROM v1;
  CALL p1();
  SELECT a, b FROM v1;
END|delimiter ;|CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP VIEW v1;
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION  BEGIN    SELECT 'SQLEXCEPTION caught' AS msg;
    CREATE TABLE t1(a INT, b INT);
    INSERT INTO t1 VALUES (1, 2);
  END;
  SELECT * FROM t1;
  SELECT * FROM t1;
  DROP TABLE t1;
END|CREATE PROCEDURE p2()BEGIN  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION  BEGIN    SELECT 'SQLEXCEPTION caught' AS msg;
    CREATE TEMPORARY TABLE t1(a INT, b INT);
    INSERT INTO t1 VALUES (1, 2);
  END;
  SELECT * FROM t1;
  SELECT * FROM t1;
  DROP TEMPORARY TABLE t1;
END|CREATE PROCEDURE p3()BEGIN  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION  BEGIN    SELECT 'SQLEXCEPTION caught' AS msg;
    CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b;
  END;
  SELECT * FROM v1;
  SELECT * FROM v1;
  DROP VIEW v1;
END|delimiter ;|CALL p1();
CALL p2();
CALL p3();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP PROCEDURE p3;
delimiter |;
CREATE PROCEDURE p1()BEGIN  IF(SELECT * FROM t1)THEN    SELECT 1;
  ELSE    SELECT 2;
  END IF;
END|CREATE PROCEDURE p2()BEGIN  DECLARE v INT DEFAULT 1;
  IF v * (SELECT * FROM t1) THEN    SELECT 1;
  ELSE    SELECT 2;
  END IF;
END|CREATE FUNCTION f1() RETURNS INTBEGIN  IF (SELECT * FROM t1) THEN    RETURN 1;
  ELSE    RETURN 2;
  END IF;
  RETURN 3;
END|CREATE FUNCTION f2() RETURNS INTBEGIN  DECLARE v INT DEFAULT 1;
  IF v * (SELECT * FROM t1) THEN    RETURN 1;
  ELSE    RETURN 2;
  END IF;
  RETURN 3;
END|delimiter ;|CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
CALL p1();
CALL p2();
SELECT f1();
SELECT f2();
UPDATE t1 SET a = 0;
CALL p1();
CALL p2();
SELECT f1();
SELECT f2();
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 1;
CALL p1();
CALL p2();
SELECT f1();
SELECT f2();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
CALL p2();
SELECT f1();
SELECT f2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP FUNCTION f1;
DROP FUNCTION f2;
DROP TABLE t1;
delimiter |;
CREATE PROCEDURE p1(x INT)BEGIN  WHILE(SELECT * FROM t1)DO    SELECT x;
    UPDATE t1 SET a = x;
    SET x = x - 1;
  END WHILE;
END|delimiter ;|CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (0);
CALL p1(3);
UPDATE t1 SET a = 1;
CALL p1(3);
UPDATE t1 SET a = 1;
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 1;
CALL p1(3);
ALTER TABLE t1 DROP COLUMN a;
CALL p1(3);
DROP PROCEDURE p1;
DROP TABLE t1;
delimiter |;
CREATE PROCEDURE p1(x INT)BEGIN  REPEAT    SELECT x;
    UPDATE t1 SET a = x;
    SET x = x - 1;
  UNTIL(NOT (SELECT * FROM t1))END REPEAT;
END|delimiter ;|CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (0);
CALL p1(3);
UPDATE t1 SET a = 1;
CALL p1(3);
UPDATE t1 SET a = 1;
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 1;
CALL p1(3);
ALTER TABLE t1 DROP COLUMN a;
CALL p1(3);
DROP PROCEDURE p1;
DROP TABLE t1;
delimiter |;
CREATE PROCEDURE p1()BEGIN  CASE    WHEN (SELECT * FROM t1) = 1 THEN SELECT 'a1';
    WHEN (SELECT * FROM t1) = 2 THEN SELECT 'a2';
    WHEN (SELECT * FROM t1) = 3 THEN SELECT 'a3';
    ELSE SELECT 'a4';
  END CASE;
END|CREATE PROCEDURE p2()BEGIN  CASE (SELECT * FROM t1)    WHEN 1 THEN SELECT 'a1';
    WHEN 2 THEN SELECT 'a2';
    WHEN 3 THEN SELECT 'a3';
    ELSE SELECT 'a4';
  END CASE;
END|delimiter ;|CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (0);
CALL p1();
CALL p2();
UPDATE t1 SET a = 3;
CALL p1();
CALL p2();
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
CALL p1();
CALL p2();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
CREATE TABLE t1(a INT);
CREATE TABLE t2(a INT);
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (1);
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  SET @x = @x + 1;
  RETURN (SELECT a FROM t1);
END|CREATE PROCEDURE p1()BEGIN  CASE f1()    WHEN 1 THEN SELECT 'a1';
    WHEN 2 THEN SELECT 'a2';
    WHEN (SELECT * FROM t2) THEN SELECT 'subselect';
    ELSE SELECT 'else';
  END CASE;
END|delimiter ;|SET @x = 0;
CALL p1();
SELECT @x;
UPDATE t1 SET a = 3;
ALTER TABLE t2 ADD COLUMN b INT DEFAULT 3;
SET @x = 0;
CALL p1();
SELECT @x;
ALTER TABLE t2 DROP COLUMN a;
SET @x = 0;
CALL p1();
SELECT @x;
DROP PROCEDURE p1;
DROP FUNCTION f1;
DROP TABLE t1;
DROP TABLE t2;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE v INT DEFAULT (SELECT * FROM t1);
  SELECT v;
END|delimiter ;|CALL p1();
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2(a INT);
INSERT INTO t2 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE x INT;
  SET x = (SELECT * FROM t1);
  SELECT x;
END|CREATE PROCEDURE p2()BEGIN  SET @x = NULL;
  SET @x = (SELECT * FROM t1);
  SELECT @x;
END|CREATE TRIGGER t2_bu BEFORE UPDATE ON t2 FOR EACH ROWBEGIN  SET NEW.a = (SELECT * FROM t1) * 2;
END|delimiter ;|CALL p1();
CALL p2();
UPDATE t2 SET a = 10;
ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
CALL p1();
CALL p2();
UPDATE t2 SET a = 20;
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
CALL p2();
UPDATE t2 SET a = 30;
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
DROP TABLE t2;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE v INT;
  DECLARE c CURSOR FOR SELECT * FROM t1;
  ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
  ALTER TABLE t1 DROP COLUMN a;
  OPEN c;
  FETCH c INTO v;
  CLOSE c;
  SELECT v;
END|delimiter ;|CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TEMPORARY TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE v INT;
  DECLARE c CURSOR FOR SELECT * FROM t1;
  ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
  ALTER TABLE t1 DROP COLUMN a;
  OPEN c;
  FETCH c INTO v;
  CLOSE c;
  SELECT v;
END|delimiter ;|CALL p1();
DROP TEMPORARY TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE v INT;
  DECLARE c CURSOR FOR SELECT * FROM t1;
  OPEN c;
  ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2;
  ALTER TABLE t1 DROP COLUMN a;
  FETCH c INTO v;
  CLOSE c;
  SELECT v;
END|delimiter ;|CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
delimiter |;
CREATE PROCEDURE p1()BEGIN  DECLARE f1 INT;
  DECLARE f2 INT;
  DECLARE f3 INT;
  DECLARE x INT DEFAULT 1;
  DECLARE y INT DEFAULT 2;
  DECLARE c CURSOR FOR SELECT x, y, t1.a FROM t1;
  ALTER TABLE t1 ADD COLUMN b INT;
  BEGIN    DECLARE x INT DEFAULT 10;
    DECLARE y INT DEFAULT 20;
    OPEN c;
    FETCH c INTO f1, f2, f3;
    SELECT f1, f2, f3;
    CLOSE c;
  END;
END|delimiter ;|CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE VIEW v1 AS SELECT * FROM t1;
CREATE PROCEDURE p1()  SELECT * FROM v1;
CALL p1();
ALTER TABLE t1 ADD COLUMN (b INT);
ALTER VIEW v1 AS SELECT * FROM t1;
CALL p1();
DROP VIEW v1;
DROP TABLE t1;
DROP PROCEDURE p1;
CREATE TEMPORARY TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE PROCEDURE p1()  SELECT * FROM t1;
CALL p1();
ALTER TABLE t1 ADD COLUMN (b INT);
CALL p1();
ALTER TABLE t1 DROP COLUMN a;
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  CREATE TEMPORARY TABLE t1_result_set AS SELECT * FROM t1;
  RETURN 0;
END|delimiter ;|SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
ALTER TABLE t1 ADD COLUMN (b INT);
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
ALTER TABLE t1 DROP COLUMN a;
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
DROP FUNCTION f1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  CREATE TEMPORARY TABLE t1_result_set AS SELECT * FROM t1;
  RETURN 0;
END|delimiter ;|SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP FUNCTION f1;
DROP TABLE t1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CREATE VIEW v1 AS SELECT * FROM t1;
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  CREATE TEMPORARY TABLE t1_result_set AS SELECT * FROM v1;
  RETURN 0;
END|delimiter ;|SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
ALTER TABLE t1 ADD COLUMN (b INT);
ALTER VIEW v1 AS SELECT * FROM t1;
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
DROP VIEW v1;
DROP FUNCTION f1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
delimiter |;
CREATE FUNCTION f1() RETURNS INTBEGIN  CREATE TEMPORARY TABLE t1_result_set AS SELECT * FROM t1;
  RETURN 0;
END|CREATE PROCEDURE p1()  SELECT * FROM t1|delimiter ;|CALL p1();
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
CREATE TEMPORARY TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);
CALL p1;
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t1;
CREATE TABLE t2 (a INT);
INSERT INTO t2 VALUES (1), (2);
CREATE VIEW t1 AS SELECT * FROM t2;
CALL p1;
SELECT f1();
SELECT * FROM t1_result_set;
DROP TABLE t1_result_set;
DROP TABLE t2;
DROP VIEW t1;
DROP FUNCTION f1;
DROP PROCEDURE p1;
CREATE TABLE t1 (a INT);
CREATE TRIGGER trg1 BEFORE INSERT ON t1 FOR EACH ROW  SET new.a = new.a + 100;
INSERT INTO t1 VALUES (1), (2);
SELECT * FROM t1;
ALTER TABLE t1 ADD COLUMN (b INT);
INSERT INTO t1 VALUES (3, 4);
SELECT * FROM t1;
DROP TRIGGER trg1;
DROP TABLE t1;
CREATE TABLE t1 (a INT, b INT);
CREATE TRIGGER trg1 BEFORE INSERT ON t1 FOR EACH ROW  SET new.a = new.a + 100;
INSERT INTO t1 VALUES (1, 2), (3, 4);
SELECT * FROM t1;
ALTER TABLE t1 DROP COLUMN b;
INSERT INTO t1 VALUES (5);
SELECT * FROM t1;
DROP TRIGGER trg1;
DROP TABLE t1;
CREATE TABLE t1 (a INT, b INT);
CREATE TRIGGER trg1 BEFORE INSERT ON t1 FOR EACH ROW  SET new.a = new.a + 100;
INSERT INTO t1 VALUES (1, 2), (3, 4);
SELECT * FROM t1;
ALTER TABLE t1 DROP COLUMN a;
INSERT INTO t1 VALUES (5);
DROP TRIGGER trg1;
DROP TABLE t1;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2(a INT);
INSERT INTO t2 VALUES (1);
CREATE VIEW v1 AS SELECT a FROM t1;
delimiter |;
CREATE TRIGGER t2_bu BEFORE UPDATE ON t2 FOR EACH ROWBEGIN  INSERT INTO v1 VALUES (NEW.a);
  SET @x = (SELECT CHARSET(a) FROM v1 LIMIT 1);
END|delimiter ;|SET @x = NULL;
UPDATE t2 SET a = 10;
SELECT * FROM v1;
SELECT @x;
ALTER TABLE t1 CHANGE COLUMN a a CHAR(2);
SET @x = NULL;
UPDATE t2 SET a = 20;
SELECT * FROM v1;
SELECT @x;
DROP TABLE t1;
DROP TABLE t2;
DROP VIEW v1;
SET sql_mode = default;
