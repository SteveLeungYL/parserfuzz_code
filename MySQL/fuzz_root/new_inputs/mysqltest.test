echo $mysql_errno before test;
echo $mysql_errname before test;
select otto from (select 1 as otto) as t1;
select otto from (select 1 as otto) as t1;
select friedrich from (select 1 as otto) as t1;
select otto from (select 1 as otto) as t1;
select friedrich from (select 1 as otto) as t1;
select otto from (select 1 as otto) as t1;
echo $mysql_errname;
eval select $mysql_errno as "after_successful_stmt_errno" ;
garbage ;
echo $mysql_errname;
eval select $mysql_errno as "after_wrong_syntax_errno" ;
garbage ;
echo $mysql_errname;
eval select $mysql_errno as "after_let_var_equal_value" ;
garbage ;
set @my_var= 'abc' ;
echo $mysql_errname;
eval select $mysql_errno as "after_set_var_equal_value" ;
garbage ;
echo $mysql_errname;
eval select $mysql_errno as "after_disable_warnings_command" ;
drop table if exists t1 ;
garbage ;
drop table if exists t1 ;
echo $mysql_errname;
eval select $mysql_errno as "after_disable_warnings" ;
garbage ;
select 3 from t1 ;
echo $mysql_errname;
eval select $mysql_errno as "after_minus_masked" ;
garbage ;
select 3 from t1 ;
echo $mysql_errname;
eval select $mysql_errno as "after_!_masked" ;
garbage ;
eval select $mysql_errno as "after_let_errno_equal_value" ;
garbage ;
prepare stmt from "select 3 from t1" ;
echo $mysql_errname;
eval select $mysql_errno as "after_failing_prepare" ;
create table t1 ( f1 char(10));
garbage ;
prepare stmt from "select 3 from t1" ;
echo $mysql_errname;
eval select $mysql_errno as "after_successful_prepare" ;
garbage ;
execute stmt;
echo $mysql_errname;
eval select $mysql_errno as "after_successful_execute" ;
drop table t1;
garbage ;
execute stmt;
echo $mysql_errname;
eval select $mysql_errno as "after_failing_execute" ;
garbage ;
execute __stmt_;
echo $mysql_errname;
eval select $mysql_errno as "after_failing_execute" ;
garbage ;
deallocate prepare stmt;
echo $mysql_errname;
eval select $mysql_errno as "after_successful_deallocate" ;
garbage ;
deallocate prepare __stmt_;
echo $mysql_errname;
eval select $mysql_errno as "after_failing_deallocate" ;
garbage ;
echo $mysql_errname;
eval select $mysql_errno as "after_select 3 from t1 ;
select 3 from t1 ;
select 3 from t1 ;
echo $mysql_errname;
eval select $mysql_errno as "after_!errno_masked_error" ;
  exit(2);
EOFecho $empty is empty;
echo $empty is empty;
garbage ;
echo $mysql_errname;
eval select $mysql_errno as "after_select 3 from t1 ;
garbage;
select 2;
select 3;
select 5;
select 3 from t1;
select 7;
connect (con1,localhost,root,,);
connection default;
disconnect con1;
select 5 from t1;
select "CASE" as "LOWER";
select "xyz" as name union select "abc" as name order by name desc;
echo $empty is empty;
echo $empty is empty;
  echo "Yes it's empty";
echo $var2;
echo $var2;
echo $var;
echo $var;
echo $var;
echo $var;
echo $var1;
sleep 4show status;
EOFremove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;
sleep 7EOFremove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;
disconnect defaultdisable_query_log;
EOFremove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;
disconnect defaultdisable_query_log;
EOFremove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;
disconnect defaultEOFremove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;
disconnect default # commentEOFremove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;
EOFremove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;
EOFremove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;
echo $x;
EOFremove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;
  DROP TABLE table_does_not_exist;
  DROP TABLE table_does_not_exist;
  if(1)  {      }DROP TABLE table_does_not_exist;
  if(1)  {    DROP TABLE table_does_not_exist;
  }while ($i < 3)    CREATE TABLE t1 (a INT);
    DROP TABLE t1;
echo MySQL;
echo "MySQL";
echo MySQL: The world''s most popular open source database;
echo "MySQL: The world's most popular open source database";
echo MySQL: The world''s     most popular open     source database;
echo # MySQL: The world''secho - MySQL: The world''s- most popular open- source database;
echo - MySQL: The world''secho # MySQL: The- source database;
echo "MySQL: The world's most popular; open source database";
echo "MySQL: The world's most popular ; open source database";
echo "MySQL: The world's most popular ;open source database";
echo echo message echo message;
echo ;
exec $MYSQL    test -e "select 1";
exec $MYSQL test -e "select    2";
    as X;
exec $MYSQL test -e "$query";
echo $message;
echo $message;
 world''s most popular open source database;
echo $message;
echo $message;
echo $message;
- world''s mostecho $message;
echo '$message';
echo "$message";
echo $1;
echo $1;
echo $1;
echo $2;
echo $5;
echo $6;
echo $where;
echo $where2;
echo $where3;
echo $where3;
echo $novar1;
echo banana = $cat;
echo Not a banana: $cat;
echo $escape;
echo $escape;
echo $tick;
echo # <whatever> success: $success ;
echo $success ;
echo var2: $var2;
echo var3: $var3;
  echo length of var3 is longer than 0;
echo var1;
echo $var1;
echo var2;
echo $var2;
echo var2 again;
echo $var2;
echo var3 two columns with same name;
echo $var3;
echo var4 from query that returns NULL;
echo var5 from query that returns no row;
echo failing query in let;
echo $var2;
EOFcreate table t1 (a varchar(100)) charset utf8mb4;
insert into t1 values ('`select 42`');
echo $a;
insert into t1 values ('$dollar');
echo $a;
echo $a;
drop table t1;
remove_file $MYSQLTEST_VARDIR/tmp/let.sql;
remove_file $MYSQLTEST_VARDIR/tmp/recursive.sql;
remove_file $MYSQLTEST_VARDIR/tmp/error.sql;
echo here is the sourced script;
EOFwhile ($outer)  eval SELECT '$outer = outer loop variable after while' AS "";
  eval SELECT '$outer = outer loop variable before dec' AS "";
  dec $outer;
  eval SELECT '$outer = outer loop variable after dec' AS "";
while ($outer)  echo outer=$outer ifval=$ifval;
  if ($ifval) {        SELECT * from nowhere;
        SELECT * FROM nowhere else;
  }  dec $outer;
  inc $ifval;
while ($num)   SELECT 'In loop' AS "";
   dec $num;
echo "hello";
EOFsource $MYSQLTEST_VARDIR/tmp/$x.inc;
source $x/tmp/sourced.inc;
sleep 0.5;
sleep 1;
sleep $sleep_var;
EOFinc $i;
echo $i;
inc $i;
echo $i;
inc $i;
echo $i;
inc $i; inc $i; inc $i; echo $i;
dec $d;
echo $d;
dec $d;
echo $d;
delimiter stop;
echo teststopdelimiter ;stopecho test2;
echo test3stopecho test4;
  delimiter ||;
  echo false-inner||  if (0)  {    delimiter *||    echo false-innerer*    delimiter ||*  }  echo false-inner again||echo outer;
  delimiter /;
  echo true-inner/  if (0)  {    delimiter %/    echo true-innerer%  }  echo true-inner again/echo true-outer/delimiter ;/  echo Counter is greater than 0, (counter=10);
  echo Counter is not 0, (counter=10);
  let $counter=5;
echo Counter should still be 10, is $counter;
  echo Counter is greater than 0, (counter=0);
  echo Counter is not 0, (counter=0);
  echo Not space var works;
  echo Counter is true, (counter=alpha);
  echo oops, space is true;
  echo oops, -0 is true;
while ($counter)  echo while with string, only once;
  let $counter=000;
  echo 5<7;
  echo 5<7 again;
  echo 5<7 still;
  echo 5<6;
  echo 5<=4;
  echo 5>=5;
  echo 5>=5 again;
  echo 5>3;
  echo 5==4;
  echo 5==5;
  echo 5!=8;
  echo 5!=five;
  echo 5==3+2;
  echo 5   ==   5;
  echo hello == hello there;
  echo hello == hello;
  echo hello == hell;
  echo hello   ==   hello;
  echo hello != goodbye;
  echo 'quoted' == ''quoted'';
  echo two words;
  echo 'two words';
  echo "two words";
  echo two words are two words;
  echo right answer;
  echo wrong answer;
  echo anything goes;
  echo 0 == string;
  echo 0 != string;
 echo 5>=four;
EOFremove_file $MYSQL_TMP_DIR/mysqltest.sql;
 echo 5~=6;
EOFremove_file $MYSQL_TMP_DIR/mysqltest.sql;
 echo Oops I forgot the $;
EOFremove_file $MYSQL_TMP_DIR/mysqltest.sql;
while ($counter < 5)  echo counter is $counter;
  inc $counter;
while ($ifvar != stop)  if ($counter >= 7)  {    let $ifvar= stop;
  }  echo counter is $counter;
  inc $counter;
while ($i)  echo $i;
  dec $i;
while (!$i)  echo Testing while with not;
  inc $i;
while ($1)while ($1)while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1)eval SET @utf8_message = CONVERT('$message' using utf8);
select @utf8_message as ""unionselect repeat(CONVERT('-' using utf8),char_length(@utf8_message));
eval SET @utf8_message = CONVERT('$message' using utf8);
select @utf8_message as ""unionselect repeat(CONVERT('-' using utf8),char_length(@utf8_message));
eval SET @utf8_message = CONVERT('$message' using utf8);
select @utf8_message as ""unionselect repeat(CONVERT('-' using utf8),80);
eval SET @utf8_message = CONVERT('$message' using utf8);
select @utf8_message as ""unionselect repeat(CONVERT('-' using utf8),80);
 while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1) while ($1)  echo $1;
  dec $1;
EOFwhile (0)echo hej;
EOFremove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;
while (0){echo hej;
EOFremove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;
while (0){ echo hej;
EOFremove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;
select "a" as col1, "c" as col2;
select "a" as col1, "c" as col2;
select "a" as col1, "c" as col2;
select "a" as col1, "c" as col2;
eval select "$long_rep" as x;
while ($i) connect (test_con1,localhost,root,,);
 disconnect test_con1;
 dec $i;
echo 200 connects succeeded;
EOFremove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;
connect (test_con1,localhost,root,,);
disconnect test_con1;
connection test_con1;
EOFremove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;
connect (test_con1,localhost,root,,);
connect (test_con1,localhost,root,,);
EOFremove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;
connect (con1,localhost,root,,);
connection default;
connection con1;
disconnect con1;
connect (con2,localhost,root,,*NO-ONE*);
show tables;
disconnect con2;
connection default;
connect (con1,localhost,root,,);
connection default;
connection con1;
connect (con2,localhost,root,,*NO-ONE*);
connection con2;
disconnect con2;
connection con1;
disconnect con1;
connection default;
while ($num)      failing_statement;
   dec $num;
SELECT 1 as a;
select 1 as `a'b`, 2 as `a"b`;
select 'aaa\\','aa''a',"aa""a";
"Here comes a very very long message that    - is longer then 80 characters    and    - consists of several lines";
              .      - is longer then 80 characters    and              .      - consists of several lines;
remove_file $MYSQLTEST_VARDIR/tmp/zero_length_file.result;
remove_file $MYSQLTEST_VARDIR/tmp/zero_length_file.reject;
remove_file $MYSQLTEST_VARDIR/tmp/zero_length_file.log;
remove_file $MYSQL_TEST_DIR/r/zero_length_file.reject;
remove_file $MYSQLTEST_VARDIR/tmp/query.sql;
echo Failing multi statement query;
drop table t1;
drop table t1;
echo Multi statement using expected error;
drop table t1;
drop table t1;
remove_file $MYSQLTEST_VARDIR/tmp/bug11731.out;
remove_file $MYSQLTEST_VARDIR/log/bug11731.log;
remove_file $MYSQLTEST_VARDIR/tmp/bug11731.sql;
query sleep;
query ;
select "at" as col1, "c" as col2;
select "at" as col1, "AT" as col2, "c" as col3;
select "a" as col1, "ct" as col2;
select "strawberry","blueberry","potato";
create table t1 (a int, b int);
insert into t1 values (1,3);
insert into t1 values (2,4);
select * from t1;
drop table t1;
select "a is a and less is more" as txt;
select "a is a and less is more" as txt;
create table t2 ( a char(10));
garbage;
garbage;
garbage;
insert into t1 values ("Abcd");
garbage;
drop table t2;
create table t1 ( f1 char(10));
insert into t1 values ("Abcd");
send select * from t1;
reap;
select * from t1;
select 1;
EOF  my $dir= $ENV{'MYSQL_TMP_DIR'};
  open (FILE, "$dir/mysqltest.out");
  while (<FILE>) {    print unless /Note: net_clear/; # This shows up on rare occations  }EOFremove_file $MYSQL_TMP_DIR/mysqltest.out;
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.in;
drop table t1;
remove_file non_existing_file;
remove_files_wildcard non_existing_dir *;
remove_files_wildcard non_existing_dir non_existing_file;
write_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
Content for test_file1EOFfile_exists $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
cat_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
remove_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
write_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp END_DELIMITER;
Content for test_file1 contains EOFEND_DELIMITERfile_exists $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
remove_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
write_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
Content for test_file1EOFfile_exists $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
append_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
Appended textEOFfile_exists $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
remove_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
append_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
Appended text on nonexisting fileEOFremove_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
while ($outer)  append_file $MYSQLTEST_VARDIR/tmp/app_while.tmp;
These lines should be repeated,EOF  dec $outer;
cat_file $MYSQLTEST_VARDIR/tmp/app_while.tmp;
remove_file $MYSQLTEST_VARDIR/tmp/app_while.tmp;
Some datafor cat_file commandof mysqltestEOFcat_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
remove_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
Some datafor diff_file commandof mysqltestEOFSome datafor diff_file commandof mysqltestEOFSome other datafor diff_file commandof mysqltestEOFSome datafor diff_file commandof musqltestEOFremove_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
file_exists $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
write_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
Content for test_file1EOFfile_exists $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
remove_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
file_exists $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
file1EOFcopy_file $MYSQLTEST_VARDIR/tmp/file1.tmp $MYSQLTEST_VARDIR/tmp/file2.tmp;
file_exists $MYSQLTEST_VARDIR/tmp/file2.tmp;
remove_file $MYSQLTEST_VARDIR/tmp/file1.tmp;
remove_file $MYSQLTEST_VARDIR/tmp/file2.tmp;
file_exists $MYSQLTEST_VARDIR/tmp/file1.tmp;
file_exists $MYSQLTEST_VARDIR/tmp/file2.tmp;
move_file $MYSQLTEST_VARDIR/tmp/file1.tmp $MYSQLTEST_VARDIR/tmp/file2.tmp;
file_exists $MYSQLTEST_VARDIR/tmp/file1.tmp;
file_exists $MYSQLTEST_VARDIR/tmp/file2.tmp;
file1EOFmove_file $MYSQLTEST_VARDIR/tmp/file1.tmp $MYSQLTEST_VARDIR/tmp/file2.tmp;
file_exists $MYSQLTEST_VARDIR/tmp/file1.tmp;
file_exists $MYSQLTEST_VARDIR/tmp/file2.tmp;
file1EOFmove_file $MYSQLTEST_VARDIR/tmp/file1.tmp $MYSQLTEST_VARDIR/tmp/file2.tmp;
file_exists $MYSQLTEST_VARDIR/tmp/file1.tmp;
file_exists $MYSQLTEST_VARDIR/tmp/file2.tmp;
remove_file $MYSQLTEST_VARDIR/tmp/file2.tmp;
file1EOFchmod 0000 $MYSQLTEST_VARDIR/tmp/file1.tmp;
chmod 0777 $MYSQLTEST_VARDIR/tmp/file1.tmp;
remove_file $MYSQLTEST_VARDIR/tmp/file1.tmp;
test2EOFremove_file $MYSQLTEST_VARDIR/tmp/file1.tmp;
print "hello\n";
EOFprint "hello\n";
EOFprint "hello\n";
DELIMITERperl;
print "hello\n";
EOFperl;
  # Print "hello"  print "hello\n";
EOFwhile ($outer) {  if ($ifval) {    perl UNTIL;
      my $val= 5;
      print "val is $val\n";
UNTIL  }  inc $ifval;
  dec $outer;
create table t1( a int, b char(255), c timestamp);
insert into t1 values(1, 'Line 1', '2007-04-05'), (2, "Part 2", '2007-04-05');
insert into t1 values(1, 'Line 1', '2007-04-05'), (2, "Part 3", '2007-04-05');
select * from t1;
select * from t1;
select * from t1;
disable_result_log;
sorted_result;
select * from t1;
enable_result_log;
select '';
sorted_result;
select "h";
select "he";
select "hep";
select "hepp";
drop table t1;
sorted_result;
 SELECT 2 as "my_col"UNIONSELECT 1;
SELECT 2 as "my_col" UNION SELECT 1;
SELECT 2 as "my_col"UNIONSELECT 1;
SELECT '2' as "3"UNIONSELECT '1';
CREATE TABLE t1( a CHAR);
SELECT * FROM t1;
DROP TABLE t1;
SELECT NULL as "my_col1",2 AS "my_col2"UNIONSELECT NULL,1;
SELECT NULL as "my_col1",2 AS "my_col2"UNIONSELECT NULL,1;
SELECT 2 as "my_col1",NULL AS "my_col2"UNIONSELECT 1,NULL;
SELECT 2 as "my_col1",NULL AS "my_col2"UNIONSELECT 1,NULL;
sorted_result;
 SET @a = 17;
SELECT 2 as "my_col"UNIONSELECT 1;
UNIONSELECT 1;
eval $my_stmt;
SELECT '2' as "my_col1",2 as "my_col2"UNIONSELECT '1',1 from t2;
SELECT '1' as "my_col1",2 as "my_col2"UNIONSELECT '2',1;
CREATE TABLE t1 (f1 INT);
INSERT INTO t1 SET f1 = 1024;
INSERT INTO t1 SELECT f1 - 1 FROM t1;
INSERT INTO t1 SELECT f1 - 2 FROM t1;
INSERT INTO t1 SELECT f1 - 4 FROM t1;
INSERT INTO t1 SELECT f1 - 8 FROM t1;
INSERT INTO t1 SELECT f1 - 16 FROM t1;
INSERT INTO t1 SELECT f1 - 32 FROM t1;
INSERT INTO t1 SELECT f1 - 64 FROM t1;
INSERT INTO t1 SELECT f1 - 128 FROM t1;
INSERT INTO t1 SELECT f1 - 256 FROM t1;
INSERT INTO t1 SELECT f1 - 512 FROM t1;
SELECT * FROM t1;
DROP TABLE t1;
CREATE TABLE t1(a BINARY(32), b BINARY(32));
INSERT INTO t1 VALUES('1abc', 'abc2'), ('\0', '\0'), ('1a', 'ba');
SELECT * FROM t1;
DROP TABLE t1;
   let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   perl;
    use strict;
    my $search_file =           $ENV{'SEARCH_FILE'}           or die "SEARCH_FILE not set";
    my $search_pattern =        $ENV{'SEARCH_PATTERN'}        or die "SEARCH_PATTERN not set";
    my $search_echo =           $ENV{'SEARCH_ECHO'}     || "NONE";
    my $ignore_pattern =        $ENV{'IGNORE_PATTERN'}  || "";
    my $search_echo_ctx =       $ENV{'SEARCH_ECHO_CTX'} || 0;
    open(FILE, "< $search_file") or die("Unable to open '$search_file': $!\n");
    # We include the current line and 'n' previous lines in its context    # as a FIFO queue i.e., oldest entries in the queue are removed when    # new lines are read from the file.    my @context = (undef) x ($search_echo_ctx + 1);
    my $line;
    my $flag = 0;
    my $output = "";
    # Read the file line by line    while ($line = <FILE>)    {        my $cur_lineno = $.;
        my $file_pos = tell(FILE);
        if ($line =~ /^CURRENT_TEST: /)        {            $output = "";
            $flag = 0;
            @context = (undef) x ($search_echo_ctx + 1);
        }        # Context stored as a sliding window of size 'n' lines        shift @context;
        push  @context, $line;
        if ($line =~ /$search_pattern/)        {            if (!(length $ignore_pattern) or !($line =~ /$ignore_pattern/))            {                # Line matches the specified pattern                $flag = 1;
                if ($search_echo eq 'FIRST')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    print_succeeding_n_lines($search_echo_ctx, $cur_lineno)                      if ($search_echo_ctx > 0);
                    last;
                }                elsif ($search_echo eq 'ALL')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    if ($search_echo_ctx > 0)                    {                        print_succeeding_n_lines($search_echo_ctx, $cur_lineno);
                        # Return to current file position after reading 'n'                        # succeeding lines                        seek(FILE, $file_pos, 0);
                        $. = $cur_lineno;
                        # Separate each matching line                        $output .= "                    }                }            }        }    }    print $output;
    if ($flag == 1)    {        print "Pattern \"$search_pattern\" found\n";
    }    else    {        print "Pattern \"$search_pattern\" not found\n";
    }    close(FILE);
    sub print_current_and_previous_n_lines()    {        my ($search_echo_ctx, $cur_lineno)= @_;
        my $start_lineno= $cur_lineno - $search_echo_ctx;
        $cur_lineno= $start_lineno > 0 ? $start_lineno: 1;
        for my $ctx_line (@context)        {            next if not defined $ctx_line;
            $output .= "$cur_lineno: $ctx_line";
            $cur_lineno++;
        }    }    sub print_succeeding_n_lines()    {        # Read the next 'n' lines from the file (excluding the current        # line) and print them        my ($search_echo_ctx, $cur_lineno)= @_;
        my $end_lineno= $cur_lineno + $search_echo_ctx;
        while ($line= <FILE>)        {            last if ($. > $end_lineno);
            $output .= "$.: $line";
        }    }EOFperl;
    use strict;
    my $search_file =           $ENV{'SEARCH_FILE'}           or die "SEARCH_FILE not set";
    my $search_pattern =        $ENV{'SEARCH_PATTERN'}        or die "SEARCH_PATTERN not set";
    my $search_echo =           $ENV{'SEARCH_ECHO'}     || "NONE";
    my $ignore_pattern =        $ENV{'IGNORE_PATTERN'}  || "";
    my $search_echo_ctx =       $ENV{'SEARCH_ECHO_CTX'} || 0;
    open(FILE, "< $search_file") or die("Unable to open '$search_file': $!\n");
    # We include the current line and 'n' previous lines in its context    # as a FIFO queue i.e., oldest entries in the queue are removed when    # new lines are read from the file.    my @context = (undef) x ($search_echo_ctx + 1);
    my $line;
    my $flag = 0;
    my $output = "";
    # Read the file line by line    while ($line = <FILE>)    {        my $cur_lineno = $.;
        my $file_pos = tell(FILE);
        if ($line =~ /^CURRENT_TEST: /)        {            $output = "";
            $flag = 0;
            @context = (undef) x ($search_echo_ctx + 1);
        }        # Context stored as a sliding window of size 'n' lines        shift @context;
        push  @context, $line;
        if ($line =~ /$search_pattern/)        {            if (!(length $ignore_pattern) or !($line =~ /$ignore_pattern/))            {                # Line matches the specified pattern                $flag = 1;
                if ($search_echo eq 'FIRST')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    print_succeeding_n_lines($search_echo_ctx, $cur_lineno)                      if ($search_echo_ctx > 0);
                    last;
                }                elsif ($search_echo eq 'ALL')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    if ($search_echo_ctx > 0)                    {                        print_succeeding_n_lines($search_echo_ctx, $cur_lineno);
                        # Return to current file position after reading 'n'                        # succeeding lines                        seek(FILE, $file_pos, 0);
                        $. = $cur_lineno;
                        # Separate each matching line                        $output .= "                    }                }            }        }    }    print $output;
    if ($flag == 1)    {        print "Pattern \"$search_pattern\" found\n";
    }    else    {        print "Pattern \"$search_pattern\" not found\n";
    }    close(FILE);
    sub print_current_and_previous_n_lines()    {        my ($search_echo_ctx, $cur_lineno)= @_;
        my $start_lineno= $cur_lineno - $search_echo_ctx;
        $cur_lineno= $start_lineno > 0 ? $start_lineno: 1;
        for my $ctx_line (@context)        {            next if not defined $ctx_line;
            $output .= "$cur_lineno: $ctx_line";
            $cur_lineno++;
        }    }    sub print_succeeding_n_lines()    {        # Read the next 'n' lines from the file (excluding the current        # line) and print them        my ($search_echo_ctx, $cur_lineno)= @_;
        my $end_lineno= $cur_lineno + $search_echo_ctx;
        while ($line= <FILE>)        {            last if ($. > $end_lineno);
            $output .= "$.: $line";
        }    }EOFperl;
    use strict;
    my $search_file =           $ENV{'SEARCH_FILE'}           or die "SEARCH_FILE not set";
    my $search_pattern =        $ENV{'SEARCH_PATTERN'}        or die "SEARCH_PATTERN not set";
    my $search_echo =           $ENV{'SEARCH_ECHO'}     || "NONE";
    my $ignore_pattern =        $ENV{'IGNORE_PATTERN'}  || "";
    my $search_echo_ctx =       $ENV{'SEARCH_ECHO_CTX'} || 0;
    open(FILE, "< $search_file") or die("Unable to open '$search_file': $!\n");
    # We include the current line and 'n' previous lines in its context    # as a FIFO queue i.e., oldest entries in the queue are removed when    # new lines are read from the file.    my @context = (undef) x ($search_echo_ctx + 1);
    my $line;
    my $flag = 0;
    my $output = "";
    # Read the file line by line    while ($line = <FILE>)    {        my $cur_lineno = $.;
        my $file_pos = tell(FILE);
        if ($line =~ /^CURRENT_TEST: /)        {            $output = "";
            $flag = 0;
            @context = (undef) x ($search_echo_ctx + 1);
        }        # Context stored as a sliding window of size 'n' lines        shift @context;
        push  @context, $line;
        if ($line =~ /$search_pattern/)        {            if (!(length $ignore_pattern) or !($line =~ /$ignore_pattern/))            {                # Line matches the specified pattern                $flag = 1;
                if ($search_echo eq 'FIRST')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    print_succeeding_n_lines($search_echo_ctx, $cur_lineno)                      if ($search_echo_ctx > 0);
                    last;
                }                elsif ($search_echo eq 'ALL')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    if ($search_echo_ctx > 0)                    {                        print_succeeding_n_lines($search_echo_ctx, $cur_lineno);
                        # Return to current file position after reading 'n'                        # succeeding lines                        seek(FILE, $file_pos, 0);
                        $. = $cur_lineno;
                        # Separate each matching line                        $output .= "                    }                }            }        }    }    print $output;
    if ($flag == 1)    {        print "Pattern \"$search_pattern\" found\n";
    }    else    {        print "Pattern \"$search_pattern\" not found\n";
    }    close(FILE);
    sub print_current_and_previous_n_lines()    {        my ($search_echo_ctx, $cur_lineno)= @_;
        my $start_lineno= $cur_lineno - $search_echo_ctx;
        $cur_lineno= $start_lineno > 0 ? $start_lineno: 1;
        for my $ctx_line (@context)        {            next if not defined $ctx_line;
            $output .= "$cur_lineno: $ctx_line";
            $cur_lineno++;
        }    }    sub print_succeeding_n_lines()    {        # Read the next 'n' lines from the file (excluding the current        # line) and print them        my ($search_echo_ctx, $cur_lineno)= @_;
        my $end_lineno= $cur_lineno + $search_echo_ctx;
        while ($line= <FILE>)        {            last if ($. > $end_lineno);
            $output .= "$.: $line";
        }    }EOFperl;
    use strict;
    my $search_file =           $ENV{'SEARCH_FILE'}           or die "SEARCH_FILE not set";
    my $search_pattern =        $ENV{'SEARCH_PATTERN'}        or die "SEARCH_PATTERN not set";
    my $search_echo =           $ENV{'SEARCH_ECHO'}     || "NONE";
    my $ignore_pattern =        $ENV{'IGNORE_PATTERN'}  || "";
    my $search_echo_ctx =       $ENV{'SEARCH_ECHO_CTX'} || 0;
    open(FILE, "< $search_file") or die("Unable to open '$search_file': $!\n");
    # We include the current line and 'n' previous lines in its context    # as a FIFO queue i.e., oldest entries in the queue are removed when    # new lines are read from the file.    my @context = (undef) x ($search_echo_ctx + 1);
    my $line;
    my $flag = 0;
    my $output = "";
    # Read the file line by line    while ($line = <FILE>)    {        my $cur_lineno = $.;
        my $file_pos = tell(FILE);
        if ($line =~ /^CURRENT_TEST: /)        {            $output = "";
            $flag = 0;
            @context = (undef) x ($search_echo_ctx + 1);
        }        # Context stored as a sliding window of size 'n' lines        shift @context;
        push  @context, $line;
        if ($line =~ /$search_pattern/)        {            if (!(length $ignore_pattern) or !($line =~ /$ignore_pattern/))            {                # Line matches the specified pattern                $flag = 1;
                if ($search_echo eq 'FIRST')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    print_succeeding_n_lines($search_echo_ctx, $cur_lineno)                      if ($search_echo_ctx > 0);
                    last;
                }                elsif ($search_echo eq 'ALL')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    if ($search_echo_ctx > 0)                    {                        print_succeeding_n_lines($search_echo_ctx, $cur_lineno);
                        # Return to current file position after reading 'n'                        # succeeding lines                        seek(FILE, $file_pos, 0);
                        $. = $cur_lineno;
                        # Separate each matching line                        $output .= "                    }                }            }        }    }    print $output;
    if ($flag == 1)    {        print "Pattern \"$search_pattern\" found\n";
    }    else    {        print "Pattern \"$search_pattern\" not found\n";
    }    close(FILE);
    sub print_current_and_previous_n_lines()    {        my ($search_echo_ctx, $cur_lineno)= @_;
        my $start_lineno= $cur_lineno - $search_echo_ctx;
        $cur_lineno= $start_lineno > 0 ? $start_lineno: 1;
        for my $ctx_line (@context)        {            next if not defined $ctx_line;
            $output .= "$cur_lineno: $ctx_line";
            $cur_lineno++;
        }    }    sub print_succeeding_n_lines()    {        # Read the next 'n' lines from the file (excluding the current        # line) and print them        my ($search_echo_ctx, $cur_lineno)= @_;
        my $end_lineno= $cur_lineno + $search_echo_ctx;
        while ($line= <FILE>)        {            last if ($. > $end_lineno);
            $output .= "$.: $line";
        }    }EOFperl;
    use strict;
    my $search_file =           $ENV{'SEARCH_FILE'}           or die "SEARCH_FILE not set";
    my $search_pattern =        $ENV{'SEARCH_PATTERN'}        or die "SEARCH_PATTERN not set";
    my $search_echo =           $ENV{'SEARCH_ECHO'}     || "NONE";
    my $ignore_pattern =        $ENV{'IGNORE_PATTERN'}  || "";
    my $search_echo_ctx =       $ENV{'SEARCH_ECHO_CTX'} || 0;
    open(FILE, "< $search_file") or die("Unable to open '$search_file': $!\n");
    # We include the current line and 'n' previous lines in its context    # as a FIFO queue i.e., oldest entries in the queue are removed when    # new lines are read from the file.    my @context = (undef) x ($search_echo_ctx + 1);
    my $line;
    my $flag = 0;
    my $output = "";
    # Read the file line by line    while ($line = <FILE>)    {        my $cur_lineno = $.;
        my $file_pos = tell(FILE);
        if ($line =~ /^CURRENT_TEST: /)        {            $output = "";
            $flag = 0;
            @context = (undef) x ($search_echo_ctx + 1);
        }        # Context stored as a sliding window of size 'n' lines        shift @context;
        push  @context, $line;
        if ($line =~ /$search_pattern/)        {            if (!(length $ignore_pattern) or !($line =~ /$ignore_pattern/))            {                # Line matches the specified pattern                $flag = 1;
                if ($search_echo eq 'FIRST')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    print_succeeding_n_lines($search_echo_ctx, $cur_lineno)                      if ($search_echo_ctx > 0);
                    last;
                }                elsif ($search_echo eq 'ALL')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    if ($search_echo_ctx > 0)                    {                        print_succeeding_n_lines($search_echo_ctx, $cur_lineno);
                        # Return to current file position after reading 'n'                        # succeeding lines                        seek(FILE, $file_pos, 0);
                        $. = $cur_lineno;
                        # Separate each matching line                        $output .= "                    }                }            }        }    }    print $output;
    if ($flag == 1)    {        print "Pattern \"$search_pattern\" found\n";
    }    else    {        print "Pattern \"$search_pattern\" not found\n";
    }    close(FILE);
    sub print_current_and_previous_n_lines()    {        my ($search_echo_ctx, $cur_lineno)= @_;
        my $start_lineno= $cur_lineno - $search_echo_ctx;
        $cur_lineno= $start_lineno > 0 ? $start_lineno: 1;
        for my $ctx_line (@context)        {            next if not defined $ctx_line;
            $output .= "$cur_lineno: $ctx_line";
            $cur_lineno++;
        }    }    sub print_succeeding_n_lines()    {        # Read the next 'n' lines from the file (excluding the current        # line) and print them        my ($search_echo_ctx, $cur_lineno)= @_;
        my $end_lineno= $cur_lineno + $search_echo_ctx;
        while ($line= <FILE>)        {            last if ($. > $end_lineno);
            $output .= "$.: $line";
        }    }EOFperl;
    use strict;
    my $search_file =           $ENV{'SEARCH_FILE'}           or die "SEARCH_FILE not set";
    my $search_pattern =        $ENV{'SEARCH_PATTERN'}        or die "SEARCH_PATTERN not set";
    my $search_echo =           $ENV{'SEARCH_ECHO'}     || "NONE";
    my $ignore_pattern =        $ENV{'IGNORE_PATTERN'}  || "";
    my $search_echo_ctx =       $ENV{'SEARCH_ECHO_CTX'} || 0;
    open(FILE, "< $search_file") or die("Unable to open '$search_file': $!\n");
    # We include the current line and 'n' previous lines in its context    # as a FIFO queue i.e., oldest entries in the queue are removed when    # new lines are read from the file.    my @context = (undef) x ($search_echo_ctx + 1);
    my $line;
    my $flag = 0;
    my $output = "";
    # Read the file line by line    while ($line = <FILE>)    {        my $cur_lineno = $.;
        my $file_pos = tell(FILE);
        if ($line =~ /^CURRENT_TEST: /)        {            $output = "";
            $flag = 0;
            @context = (undef) x ($search_echo_ctx + 1);
        }        # Context stored as a sliding window of size 'n' lines        shift @context;
        push  @context, $line;
        if ($line =~ /$search_pattern/)        {            if (!(length $ignore_pattern) or !($line =~ /$ignore_pattern/))            {                # Line matches the specified pattern                $flag = 1;
                if ($search_echo eq 'FIRST')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    print_succeeding_n_lines($search_echo_ctx, $cur_lineno)                      if ($search_echo_ctx > 0);
                    last;
                }                elsif ($search_echo eq 'ALL')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    if ($search_echo_ctx > 0)                    {                        print_succeeding_n_lines($search_echo_ctx, $cur_lineno);
                        # Return to current file position after reading 'n'                        # succeeding lines                        seek(FILE, $file_pos, 0);
                        $. = $cur_lineno;
                        # Separate each matching line                        $output .= "                    }                }            }        }    }    print $output;
    if ($flag == 1)    {        print "Pattern \"$search_pattern\" found\n";
    }    else    {        print "Pattern \"$search_pattern\" not found\n";
    }    close(FILE);
    sub print_current_and_previous_n_lines()    {        my ($search_echo_ctx, $cur_lineno)= @_;
        my $start_lineno= $cur_lineno - $search_echo_ctx;
        $cur_lineno= $start_lineno > 0 ? $start_lineno: 1;
        for my $ctx_line (@context)        {            next if not defined $ctx_line;
            $output .= "$cur_lineno: $ctx_line";
            $cur_lineno++;
        }    }    sub print_succeeding_n_lines()    {        # Read the next 'n' lines from the file (excluding the current        # line) and print them        my ($search_echo_ctx, $cur_lineno)= @_;
        my $end_lineno= $cur_lineno + $search_echo_ctx;
        while ($line= <FILE>)        {            last if ($. > $end_lineno);
            $output .= "$.: $line";
        }    }EOFperl;
    use strict;
    my $search_file =           $ENV{'SEARCH_FILE'}           or die "SEARCH_FILE not set";
    my $search_pattern =        $ENV{'SEARCH_PATTERN'}        or die "SEARCH_PATTERN not set";
    my $search_echo =           $ENV{'SEARCH_ECHO'}     || "NONE";
    my $ignore_pattern =        $ENV{'IGNORE_PATTERN'}  || "";
    my $search_echo_ctx =       $ENV{'SEARCH_ECHO_CTX'} || 0;
    open(FILE, "< $search_file") or die("Unable to open '$search_file': $!\n");
    # We include the current line and 'n' previous lines in its context    # as a FIFO queue i.e., oldest entries in the queue are removed when    # new lines are read from the file.    my @context = (undef) x ($search_echo_ctx + 1);
    my $line;
    my $flag = 0;
    my $output = "";
    # Read the file line by line    while ($line = <FILE>)    {        my $cur_lineno = $.;
        my $file_pos = tell(FILE);
        if ($line =~ /^CURRENT_TEST: /)        {            $output = "";
            $flag = 0;
            @context = (undef) x ($search_echo_ctx + 1);
        }        # Context stored as a sliding window of size 'n' lines        shift @context;
        push  @context, $line;
        if ($line =~ /$search_pattern/)        {            if (!(length $ignore_pattern) or !($line =~ /$ignore_pattern/))            {                # Line matches the specified pattern                $flag = 1;
                if ($search_echo eq 'FIRST')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    print_succeeding_n_lines($search_echo_ctx, $cur_lineno)                      if ($search_echo_ctx > 0);
                    last;
                }                elsif ($search_echo eq 'ALL')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    if ($search_echo_ctx > 0)                    {                        print_succeeding_n_lines($search_echo_ctx, $cur_lineno);
                        # Return to current file position after reading 'n'                        # succeeding lines                        seek(FILE, $file_pos, 0);
                        $. = $cur_lineno;
                        # Separate each matching line                        $output .= "                    }                }            }        }    }    print $output;
    if ($flag == 1)    {        print "Pattern \"$search_pattern\" found\n";
    }    else    {        print "Pattern \"$search_pattern\" not found\n";
    }    close(FILE);
    sub print_current_and_previous_n_lines()    {        my ($search_echo_ctx, $cur_lineno)= @_;
        my $start_lineno= $cur_lineno - $search_echo_ctx;
        $cur_lineno= $start_lineno > 0 ? $start_lineno: 1;
        for my $ctx_line (@context)        {            next if not defined $ctx_line;
            $output .= "$cur_lineno: $ctx_line";
            $cur_lineno++;
        }    }    sub print_succeeding_n_lines()    {        # Read the next 'n' lines from the file (excluding the current        # line) and print them        my ($search_echo_ctx, $cur_lineno)= @_;
        my $end_lineno= $cur_lineno + $search_echo_ctx;
        while ($line= <FILE>)        {            last if ($. > $end_lineno);
            $output .= "$.: $line";
        }    }EOFperl;
    use strict;
    my $search_file =           $ENV{'SEARCH_FILE'}           or die "SEARCH_FILE not set";
    my $search_pattern =        $ENV{'SEARCH_PATTERN'}        or die "SEARCH_PATTERN not set";
    my $search_echo =           $ENV{'SEARCH_ECHO'}     || "NONE";
    my $ignore_pattern =        $ENV{'IGNORE_PATTERN'}  || "";
    my $search_echo_ctx =       $ENV{'SEARCH_ECHO_CTX'} || 0;
    open(FILE, "< $search_file") or die("Unable to open '$search_file': $!\n");
    # We include the current line and 'n' previous lines in its context    # as a FIFO queue i.e., oldest entries in the queue are removed when    # new lines are read from the file.    my @context = (undef) x ($search_echo_ctx + 1);
    my $line;
    my $flag = 0;
    my $output = "";
    # Read the file line by line    while ($line = <FILE>)    {        my $cur_lineno = $.;
        my $file_pos = tell(FILE);
        if ($line =~ /^CURRENT_TEST: /)        {            $output = "";
            $flag = 0;
            @context = (undef) x ($search_echo_ctx + 1);
        }        # Context stored as a sliding window of size 'n' lines        shift @context;
        push  @context, $line;
        if ($line =~ /$search_pattern/)        {            if (!(length $ignore_pattern) or !($line =~ /$ignore_pattern/))            {                # Line matches the specified pattern                $flag = 1;
                if ($search_echo eq 'FIRST')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    print_succeeding_n_lines($search_echo_ctx, $cur_lineno)                      if ($search_echo_ctx > 0);
                    last;
                }                elsif ($search_echo eq 'ALL')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    if ($search_echo_ctx > 0)                    {                        print_succeeding_n_lines($search_echo_ctx, $cur_lineno);
                        # Return to current file position after reading 'n'                        # succeeding lines                        seek(FILE, $file_pos, 0);
                        $. = $cur_lineno;
                        # Separate each matching line                        $output .= "                    }                }            }        }    }    print $output;
    if ($flag == 1)    {        print "Pattern \"$search_pattern\" found\n";
    }    else    {        print "Pattern \"$search_pattern\" not found\n";
    }    close(FILE);
    sub print_current_and_previous_n_lines()    {        my ($search_echo_ctx, $cur_lineno)= @_;
        my $start_lineno= $cur_lineno - $search_echo_ctx;
        $cur_lineno= $start_lineno > 0 ? $start_lineno: 1;
        for my $ctx_line (@context)        {            next if not defined $ctx_line;
            $output .= "$cur_lineno: $ctx_line";
            $cur_lineno++;
        }    }    sub print_succeeding_n_lines()    {        # Read the next 'n' lines from the file (excluding the current        # line) and print them        my ($search_echo_ctx, $cur_lineno)= @_;
        my $end_lineno= $cur_lineno + $search_echo_ctx;
        while ($line= <FILE>)        {            last if ($. > $end_lineno);
            $output .= "$.: $line";
        }    }EOFperl;
    use strict;
    my $search_file =           $ENV{'SEARCH_FILE'}           or die "SEARCH_FILE not set";
    my $search_pattern =        $ENV{'SEARCH_PATTERN'}        or die "SEARCH_PATTERN not set";
    my $search_echo =           $ENV{'SEARCH_ECHO'}     || "NONE";
    my $ignore_pattern =        $ENV{'IGNORE_PATTERN'}  || "";
    my $search_echo_ctx =       $ENV{'SEARCH_ECHO_CTX'} || 0;
    open(FILE, "< $search_file") or die("Unable to open '$search_file': $!\n");
    # We include the current line and 'n' previous lines in its context    # as a FIFO queue i.e., oldest entries in the queue are removed when    # new lines are read from the file.    my @context = (undef) x ($search_echo_ctx + 1);
    my $line;
    my $flag = 0;
    my $output = "";
    # Read the file line by line    while ($line = <FILE>)    {        my $cur_lineno = $.;
        my $file_pos = tell(FILE);
        if ($line =~ /^CURRENT_TEST: /)        {            $output = "";
            $flag = 0;
            @context = (undef) x ($search_echo_ctx + 1);
        }        # Context stored as a sliding window of size 'n' lines        shift @context;
        push  @context, $line;
        if ($line =~ /$search_pattern/)        {            if (!(length $ignore_pattern) or !($line =~ /$ignore_pattern/))            {                # Line matches the specified pattern                $flag = 1;
                if ($search_echo eq 'FIRST')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    print_succeeding_n_lines($search_echo_ctx, $cur_lineno)                      if ($search_echo_ctx > 0);
                    last;
                }                elsif ($search_echo eq 'ALL')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    if ($search_echo_ctx > 0)                    {                        print_succeeding_n_lines($search_echo_ctx, $cur_lineno);
                        # Return to current file position after reading 'n'                        # succeeding lines                        seek(FILE, $file_pos, 0);
                        $. = $cur_lineno;
                        # Separate each matching line                        $output .= "                    }                }            }        }    }    print $output;
    if ($flag == 1)    {        print "Pattern \"$search_pattern\" found\n";
    }    else    {        print "Pattern \"$search_pattern\" not found\n";
    }    close(FILE);
    sub print_current_and_previous_n_lines()    {        my ($search_echo_ctx, $cur_lineno)= @_;
        my $start_lineno= $cur_lineno - $search_echo_ctx;
        $cur_lineno= $start_lineno > 0 ? $start_lineno: 1;
        for my $ctx_line (@context)        {            next if not defined $ctx_line;
            $output .= "$cur_lineno: $ctx_line";
            $cur_lineno++;
        }    }    sub print_succeeding_n_lines()    {        # Read the next 'n' lines from the file (excluding the current        # line) and print them        my ($search_echo_ctx, $cur_lineno)= @_;
        my $end_lineno= $cur_lineno + $search_echo_ctx;
        while ($line= <FILE>)        {            last if ($. > $end_lineno);
            $output .= "$.: $line";
        }    }EOFperl;
    use strict;
    my $search_file =           $ENV{'SEARCH_FILE'}           or die "SEARCH_FILE not set";
    my $search_pattern =        $ENV{'SEARCH_PATTERN'}        or die "SEARCH_PATTERN not set";
    my $search_echo =           $ENV{'SEARCH_ECHO'}     || "NONE";
    my $ignore_pattern =        $ENV{'IGNORE_PATTERN'}  || "";
    my $search_echo_ctx =       $ENV{'SEARCH_ECHO_CTX'} || 0;
    open(FILE, "< $search_file") or die("Unable to open '$search_file': $!\n");
    # We include the current line and 'n' previous lines in its context    # as a FIFO queue i.e., oldest entries in the queue are removed when    # new lines are read from the file.    my @context = (undef) x ($search_echo_ctx + 1);
    my $line;
    my $flag = 0;
    my $output = "";
    # Read the file line by line    while ($line = <FILE>)    {        my $cur_lineno = $.;
        my $file_pos = tell(FILE);
        if ($line =~ /^CURRENT_TEST: /)        {            $output = "";
            $flag = 0;
            @context = (undef) x ($search_echo_ctx + 1);
        }        # Context stored as a sliding window of size 'n' lines        shift @context;
        push  @context, $line;
        if ($line =~ /$search_pattern/)        {            if (!(length $ignore_pattern) or !($line =~ /$ignore_pattern/))            {                # Line matches the specified pattern                $flag = 1;
                if ($search_echo eq 'FIRST')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    print_succeeding_n_lines($search_echo_ctx, $cur_lineno)                      if ($search_echo_ctx > 0);
                    last;
                }                elsif ($search_echo eq 'ALL')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    if ($search_echo_ctx > 0)                    {                        print_succeeding_n_lines($search_echo_ctx, $cur_lineno);
                        # Return to current file position after reading 'n'                        # succeeding lines                        seek(FILE, $file_pos, 0);
                        $. = $cur_lineno;
                        # Separate each matching line                        $output .= "                    }                }            }        }    }    print $output;
    if ($flag == 1)    {        print "Pattern \"$search_pattern\" found\n";
    }    else    {        print "Pattern \"$search_pattern\" not found\n";
    }    close(FILE);
    sub print_current_and_previous_n_lines()    {        my ($search_echo_ctx, $cur_lineno)= @_;
        my $start_lineno= $cur_lineno - $search_echo_ctx;
        $cur_lineno= $start_lineno > 0 ? $start_lineno: 1;
        for my $ctx_line (@context)        {            next if not defined $ctx_line;
            $output .= "$cur_lineno: $ctx_line";
            $cur_lineno++;
        }    }    sub print_succeeding_n_lines()    {        # Read the next 'n' lines from the file (excluding the current        # line) and print them        my ($search_echo_ctx, $cur_lineno)= @_;
        my $end_lineno= $cur_lineno + $search_echo_ctx;
        while ($line= <FILE>)        {            last if ($. > $end_lineno);
            $output .= "$.: $line";
        }    }EOFperl;
    use strict;
    my $search_file =           $ENV{'SEARCH_FILE'}           or die "SEARCH_FILE not set";
    my $search_pattern =        $ENV{'SEARCH_PATTERN'}        or die "SEARCH_PATTERN not set";
    my $search_echo =           $ENV{'SEARCH_ECHO'}     || "NONE";
    my $ignore_pattern =        $ENV{'IGNORE_PATTERN'}  || "";
    my $search_echo_ctx =       $ENV{'SEARCH_ECHO_CTX'} || 0;
    open(FILE, "< $search_file") or die("Unable to open '$search_file': $!\n");
    # We include the current line and 'n' previous lines in its context    # as a FIFO queue i.e., oldest entries in the queue are removed when    # new lines are read from the file.    my @context = (undef) x ($search_echo_ctx + 1);
    my $line;
    my $flag = 0;
    my $output = "";
    # Read the file line by line    while ($line = <FILE>)    {        my $cur_lineno = $.;
        my $file_pos = tell(FILE);
        if ($line =~ /^CURRENT_TEST: /)        {            $output = "";
            $flag = 0;
            @context = (undef) x ($search_echo_ctx + 1);
        }        # Context stored as a sliding window of size 'n' lines        shift @context;
        push  @context, $line;
        if ($line =~ /$search_pattern/)        {            if (!(length $ignore_pattern) or !($line =~ /$ignore_pattern/))            {                # Line matches the specified pattern                $flag = 1;
                if ($search_echo eq 'FIRST')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    print_succeeding_n_lines($search_echo_ctx, $cur_lineno)                      if ($search_echo_ctx > 0);
                    last;
                }                elsif ($search_echo eq 'ALL')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    if ($search_echo_ctx > 0)                    {                        print_succeeding_n_lines($search_echo_ctx, $cur_lineno);
                        # Return to current file position after reading 'n'                        # succeeding lines                        seek(FILE, $file_pos, 0);
                        $. = $cur_lineno;
                        # Separate each matching line                        $output .= "                    }                }            }        }    }    print $output;
    if ($flag == 1)    {        print "Pattern \"$search_pattern\" found\n";
    }    else    {        print "Pattern \"$search_pattern\" not found\n";
    }    close(FILE);
    sub print_current_and_previous_n_lines()    {        my ($search_echo_ctx, $cur_lineno)= @_;
        my $start_lineno= $cur_lineno - $search_echo_ctx;
        $cur_lineno= $start_lineno > 0 ? $start_lineno: 1;
        for my $ctx_line (@context)        {            next if not defined $ctx_line;
            $output .= "$cur_lineno: $ctx_line";
            $cur_lineno++;
        }    }    sub print_succeeding_n_lines()    {        # Read the next 'n' lines from the file (excluding the current        # line) and print them        my ($search_echo_ctx, $cur_lineno)= @_;
        my $end_lineno= $cur_lineno + $search_echo_ctx;
        while ($line= <FILE>)        {            last if ($. > $end_lineno);
            $output .= "$.: $line";
        }    }EOFperl;
    use strict;
    my $search_file =           $ENV{'SEARCH_FILE'}           or die "SEARCH_FILE not set";
    my $search_pattern =        $ENV{'SEARCH_PATTERN'}        or die "SEARCH_PATTERN not set";
    my $search_echo =           $ENV{'SEARCH_ECHO'}     || "NONE";
    my $ignore_pattern =        $ENV{'IGNORE_PATTERN'}  || "";
    my $search_echo_ctx =       $ENV{'SEARCH_ECHO_CTX'} || 0;
    open(FILE, "< $search_file") or die("Unable to open '$search_file': $!\n");
    # We include the current line and 'n' previous lines in its context    # as a FIFO queue i.e., oldest entries in the queue are removed when    # new lines are read from the file.    my @context = (undef) x ($search_echo_ctx + 1);
    my $line;
    my $flag = 0;
    my $output = "";
    # Read the file line by line    while ($line = <FILE>)    {        my $cur_lineno = $.;
        my $file_pos = tell(FILE);
        if ($line =~ /^CURRENT_TEST: /)        {            $output = "";
            $flag = 0;
            @context = (undef) x ($search_echo_ctx + 1);
        }        # Context stored as a sliding window of size 'n' lines        shift @context;
        push  @context, $line;
        if ($line =~ /$search_pattern/)        {            if (!(length $ignore_pattern) or !($line =~ /$ignore_pattern/))            {                # Line matches the specified pattern                $flag = 1;
                if ($search_echo eq 'FIRST')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    print_succeeding_n_lines($search_echo_ctx, $cur_lineno)                      if ($search_echo_ctx > 0);
                    last;
                }                elsif ($search_echo eq 'ALL')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    if ($search_echo_ctx > 0)                    {                        print_succeeding_n_lines($search_echo_ctx, $cur_lineno);
                        # Return to current file position after reading 'n'                        # succeeding lines                        seek(FILE, $file_pos, 0);
                        $. = $cur_lineno;
                        # Separate each matching line                        $output .= "                    }                }            }        }    }    print $output;
    if ($flag == 1)    {        print "Pattern \"$search_pattern\" found\n";
    }    else    {        print "Pattern \"$search_pattern\" not found\n";
    }    close(FILE);
    sub print_current_and_previous_n_lines()    {        my ($search_echo_ctx, $cur_lineno)= @_;
        my $start_lineno= $cur_lineno - $search_echo_ctx;
        $cur_lineno= $start_lineno > 0 ? $start_lineno: 1;
        for my $ctx_line (@context)        {            next if not defined $ctx_line;
            $output .= "$cur_lineno: $ctx_line";
            $cur_lineno++;
        }    }    sub print_succeeding_n_lines()    {        # Read the next 'n' lines from the file (excluding the current        # line) and print them        my ($search_echo_ctx, $cur_lineno)= @_;
        my $end_lineno= $cur_lineno + $search_echo_ctx;
        while ($line= <FILE>)        {            last if ($. > $end_lineno);
            $output .= "$.: $line";
        }    }EOFperl;
    use strict;
    my $search_file =           $ENV{'SEARCH_FILE'}           or die "SEARCH_FILE not set";
    my $search_pattern =        $ENV{'SEARCH_PATTERN'}        or die "SEARCH_PATTERN not set";
    my $search_echo =           $ENV{'SEARCH_ECHO'}     || "NONE";
    my $ignore_pattern =        $ENV{'IGNORE_PATTERN'}  || "";
    my $search_echo_ctx =       $ENV{'SEARCH_ECHO_CTX'} || 0;
    open(FILE, "< $search_file") or die("Unable to open '$search_file': $!\n");
    # We include the current line and 'n' previous lines in its context    # as a FIFO queue i.e., oldest entries in the queue are removed when    # new lines are read from the file.    my @context = (undef) x ($search_echo_ctx + 1);
    my $line;
    my $flag = 0;
    my $output = "";
    # Read the file line by line    while ($line = <FILE>)    {        my $cur_lineno = $.;
        my $file_pos = tell(FILE);
        if ($line =~ /^CURRENT_TEST: /)        {            $output = "";
            $flag = 0;
            @context = (undef) x ($search_echo_ctx + 1);
        }        # Context stored as a sliding window of size 'n' lines        shift @context;
        push  @context, $line;
        if ($line =~ /$search_pattern/)        {            if (!(length $ignore_pattern) or !($line =~ /$ignore_pattern/))            {                # Line matches the specified pattern                $flag = 1;
                if ($search_echo eq 'FIRST')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    print_succeeding_n_lines($search_echo_ctx, $cur_lineno)                      if ($search_echo_ctx > 0);
                    last;
                }                elsif ($search_echo eq 'ALL')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    if ($search_echo_ctx > 0)                    {                        print_succeeding_n_lines($search_echo_ctx, $cur_lineno);
                        # Return to current file position after reading 'n'                        # succeeding lines                        seek(FILE, $file_pos, 0);
                        $. = $cur_lineno;
                        # Separate each matching line                        $output .= "                    }                }            }        }    }    print $output;
    if ($flag == 1)    {        print "Pattern \"$search_pattern\" found\n";
    }    else    {        print "Pattern \"$search_pattern\" not found\n";
    }    close(FILE);
    sub print_current_and_previous_n_lines()    {        my ($search_echo_ctx, $cur_lineno)= @_;
        my $start_lineno= $cur_lineno - $search_echo_ctx;
        $cur_lineno= $start_lineno > 0 ? $start_lineno: 1;
        for my $ctx_line (@context)        {            next if not defined $ctx_line;
            $output .= "$cur_lineno: $ctx_line";
            $cur_lineno++;
        }    }    sub print_succeeding_n_lines()    {        # Read the next 'n' lines from the file (excluding the current        # line) and print them        my ($search_echo_ctx, $cur_lineno)= @_;
        my $end_lineno= $cur_lineno + $search_echo_ctx;
        while ($line= <FILE>)        {            last if ($. > $end_lineno);
            $output .= "$.: $line";
        }    }EOF  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $counter = `SELECT $disconnect_timeout * 10`;
while (!$mysql_errno)    show session status;
  dec $counter;
  if (!$counter)  {    if ($show_rpl_debug_info)    {          }      }  CREATE TABLE t1(a CHAR(32), b CHAR(32));
INSERT INTO t1 VALUES('\0', 'abc2'), ('abcd', '\0'), ('1a', 'ba');
SELECT * FROM t1;
DROP TABLE t1;
CREATE TABLE t1(a CHAR(32), b CHAR(32), c CHAR(32));
INSERT INTO t1 VALUES('abc', '1a', '2a'), ('abc', 'west', 'east'), ('\0', '1a', 'north'),('\0', 'west', 'south'), ('abc', 'sun', 'moon');
SELECT a, b, c FROM t1 ORDER by a;
SELECT a, b, c FROM t1 ORDER by a, b;
DROP TABLE t1;
CREATE TABLE t1(i INT, j INT, k INT);
INSERT INTO t1 VALUES(1, 2, 1),(1, 2, 4),(1, 2, 3),(2, 3, 1),(3, 4, 1),(2, 5, 0),(1, 6, 0),(1, 7, 1);
SELECT i, j, k FROM t1 ORDER by i;
SELECT i, j, k FROM t1 ORDER by i, j;
DROP TABLE t1;
SELECT "500g BLBRSYLTETY" AS "WILL BE lower cased";
SELECT "UPPER" AS "WILL NOT BE lower cased";
SELECT 0 as "UP AGAIN";
eval $lower_stmt;
sorted_result;
lowercase_result;
SELECT "Xyz" AS Name UNION SELECT "Abc" as Name ORDER BY Name DESC;
SELECT 1 as "SOME OLD TEXT";
set names latin1;
SELECT 0 as "WILL Lower CASE ";
set names utf8mb4;
CREATE TABLE t1( a int, b varchar(255), c datetime);
SHOW COLUMNS FROM t1;
while ($run)   let $Field=   query_get_value($show_statement, Field,   $rowno);
   if ($Field == No such row)   {      let $run= 0;
   }   if ($Field != No such row)   {      let $Type=    query_get_value($show_statement, Type,    $rowno);
      let $Null=    query_get_value($show_statement, Null,    $rowno);
      if ($Null == YES)      {         inc $count;
      }      let $Key=     query_get_value($show_statement, Key,     $rowno);
      let $Default= query_get_value($show_statement, Default, $rowno);
      let $Extra=   query_get_value($show_statement, Extra,   $rowno);
            inc $rowno;
   }eval $show_statement;
drop table t1;
mkdir $MYSQLTEST_VARDIR/tmp/testdir;
rmdir $MYSQLTEST_VARDIR/tmp/testdir;
mkdir $MYSQLTEST_VARDIR/tmp/testdir;
mkdir $MYSQLTEST_VARDIR/tmp/testdir;
write_file $MYSQLTEST_VARDIR/tmp/testdir/file1.txt;
helloEOFlist_files $MYSQLTEST_VARDIR/tmp/testdir;
list_files_write_file $MYSQLTEST_VARDIR/tmp/testdir/file2.txt $MYSQLTEST_VARDIR/tmp/testdir *;
list_files_append_file $MYSQLTEST_VARDIR/tmp/testdir/file2.txt $MYSQLTEST_VARDIR/tmp/testdir *2*;
list_files_write_file $MYSQLTEST_VARDIR/tmp/testdir/file2.txt $MYSQLTEST_VARDIR/tmp/testdir file?.txt;
list_files_append_file $MYSQLTEST_VARDIR/tmp/testdir/file3.txt $MYSQLTEST_VARDIR/tmp/testdir file*.txt;
diff_files $MYSQLTEST_VARDIR/tmp/testdir/file2.txt $MYSQLTEST_VARDIR/tmp/testdir/file3.txt;
rmdir $MYSQLTEST_VARDIR/tmp/testdir;
cat_file $MYSQLTEST_VARDIR/tmp/testdir/file3.txt;
replace_result file prefix;
list_files $MYSQLTEST_VARDIR/tmp/testdir;
SELECT "bla bla file" as x;
list_files_write_file $MYSQLTEST_VARDIR/tmp/testdir/file11.txt $MYSQLTEST_VARDIR/tmp/testdir file?.txt;
remove_files_wildcard $MYSQLTEST_VARDIR/tmp/testdir file?.txt;
list_files_write_file $MYSQLTEST_VARDIR/tmp/testdir/dir-list.txt $MYSQLTEST_VARDIR/tmp/testdir file*.txt;
cat_file $MYSQLTEST_VARDIR/tmp/testdir/dir-list.txt;
remove_files_wildcard $MYSQLTEST_VARDIR/tmp/testdir file*.txt;
list_files $MYSQLTEST_VARDIR/tmp/testdir;
remove_files_wildcard $MYSQLTEST_VARDIR/tmp/testdir *;
list_files $MYSQLTEST_VARDIR/tmp/testdir;
rmdir $MYSQLTEST_VARDIR/tmp/testdir;
SELECT 'c:\\a.txt' AS col;
select 1;
connect (con1,localhost,root,,);
connect (con2,localhost,root,,);
connection default;
connection con1;
connection con2;
connection $x;
connection $y;
disconnect $x;
disconnect $y;
connection default;
select "a" as a;
select "a" as a;
select "a" as a;
jan feb marapr may junjul aug septoct nov decjan feb marapr may junjul aug septoct nov decjan feb marapr may junjul aug septoct nov decjan feb marapr may junjul aug septoct nov decjan feb octEOF    # True block  print "True block\n";
  EOF    # False block  print "False block\n";
  EOFwhile($i) {    if (!$i) {        print "Hello\n";
    EOF  }SELECT 100 + /* Shouldn't fail */ 1 AS result;
SELECT 100 /* Shouldn't fail */ + 1 AS result;
SELECT 100 +/*Shouldn'tfail*/1 AS result;
SELECT 100/*Shouldn'tfail*/+ 1 AS result;
SELECT 100 /* shouldn't / fail */ + 1 AS result;
SELECT 100 /* shouldn't * fail */ + 1 AS result;
SELECT 100 /* shouldn't /* fail */ + 1 AS result;
SELECT 100 /* shouldn't /* fail */ + 1 AS res1, 'ABC' AS res2;
SELECT 100 + /* "shouldnt fail */ 1 AS result;
SELECT 100 + /* "shouldn't fail" */ 1 AS result;
SELECT 100 + /* `shouldn't fail */ 1 AS result;
SELECT 100 + /* `shouldn't fail` */ 1 AS result;
SELECT 100 + /*  + shouldn't fail */ 1 AS result;
SELECT 100 + /*  ! shouldn't fail */ 1 AS result;
SELECT 1 /*!,"\'" */;
SELECT 100 + /***/ 1 AS result;
SELECT 100 + /**'*/ 1 AS result;
SELECT 100 + /*/*/ 1 AS result;
SELECT 100 + /*/'*/ 1 AS result;
SELECT 100 + /* should */ fail */ 1 AS result;
SELECT 100 + /* shoul'd */ fail */ 1 AS result;
CREATE TABLE t1(a INT PRIMARY KEY);
INSERT INTO t1 values (1),(5),(10) /* doesn't throw error */;
SELECT * FROM t1 /* shouldn't throw error */;
DROP TABLE t1;
SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_TEMP_TABLE_INFO;
CREATE /*! TEMPORARY */ TABLE t1 /* shouldn't fail */ (a INT) CHARSET utf8mb4;
SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_TEMP_TABLE_INFO;
SHOW CREATE TABLE t1;
DROP TEMPORARY TABLE t1;
connect (con1, localhost, root,,);
SELECT 1 AS res;
disconnect con1;
SELECT 1 AS res;
connection default;
                Test case for "force-cpdir <source> <destination>" commandEOFTest case for "force-cpdir <source> <destination>" commandEOFSELECT 100 AS res;
EOFSELECT 100 AS res;
EOFSELECT 100;
EOFSELECT 100;
EOFSELECT 100;
EOFSELECT 100;
EOFSELECT 100;
EOFCREATE TABLE t1(f FLOAT, k DOUBLE);
INSERT INTO t1 VALUES(124.7892,1.23456e200);
INSERT INTO t1 VALUES(6.9999999,1.000000000);
INSERT INTO t1 VALUES(12900.019,37489e-12);
SELECT * FROM t1;
DROP TABLE t1;
SELECT 'aaaa(12.123484502750487)';
SELECT 19.955934879;
    Hello  EOFwhile (0)    Hello  EOFHelloEOF  if (1)  {        Hello    EOF  }while (0)  if (1)  {        Hello    EOF  }while ($counter)    if (!$counter)  {    execute this invalid query;
  }EOFwhile ($counter <= 1)  if ($counter == 0)  {      }  DROP TABLE t1;
  CREATE TABLE t1(c1 INT);
  DROP TABLE t1;
while ($counter <= 1)  if ($counter == 1)  {      }  CREATE TABLE t1(c1 INT);
  DROP TABLE t1;
EOFEOFbug fixes in MTREOFTest invalid values of retry parameterEOFSELECT "this will not be executed" AS not_executed;
SELECT "this will be executed" AS executed;
SELECT "this will not be executed" AS not_executed;
SELECT "this will be executed" AS executed;
SELECT "this will not be executed" AS not_executed;
SELECT "this will be executed" AS executed;
SELECT 1 AS res;
EOFSELECT 1 AS res;
EOFSELECT 1 AS res;
EOFSELECT 1 AS res;
EOFSELECT 1 AS res;
EOFSELECT 1 AS res;
EOFSELECT 1 AS res;
BUG#28358835EOFSET @old_sql_mode = @@sql_mode;
SET @@sql_mode = 'NO_ENGINE_SUBSTITUTION';
CREATE TABLE t1 (  c1 DOUBLE NOT NULL AUTO_INCREMENT,  c2 INT,  c3 DECIMAL(2) UNSIGNED,  c4 DECIMAL,  PRIMARY KEY (c1));
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 1, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 2, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 3, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 4, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 5, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 6, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 7, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 8, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 9, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 10, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 11, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 12, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 13, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 14, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 15, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 16, -500, "aaa");
DELETE FROM t1;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 17, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 18, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 19, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 20, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 21, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 22, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 23, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 24, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 25, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 26, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 27, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 28, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 29, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 30, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 31, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 32, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 33, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 34, -500, "aaa");
SET @@sql_mode = @old_sql_mode;
DROP TABLE t1;
DROP TABLE IF EXISTS t1;
DROP TABLE IF EXISTS t1;
EOFDROP TABLE IF EXISTS t1;
DROP TABLE IF EXISTS t1;
DROP TABLE IF EXISTS t1;
EOFDROP TABLE IF EXISTS t1;
DROP TABLE IF EXISTS t1;
EOFDROP TABLE IF EXISTS t1;
DROP TABLE IF EXISTS t1;
DROP TABLE IF EXISTS t1;
EOFDROP TABLE IF EXISTS t1;
DROP TABLE IF EXISTS t1;
EOFSET @old_sql_mode = @@sql_mode;
SET @@sql_mode = 'NO_ENGINE_SUBSTITUTION';
CREATE TABLE t1 (  c1 DOUBLE NOT NULL AUTO_INCREMENT,  c2 INT,  c3 DECIMAL(2) UNSIGNED,  c4 DECIMAL,  PRIMARY KEY (c1));
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 35, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 36, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 37, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 38, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 39, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 40, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 41, -500, "aaa");
DELETE FROM t1;
INSERT INTO t1 VALUES (0x7FFFFFFFFFFFFFFD, 42, -500, "aaa");
DELETE FROM t1;
SET @@sql_mode = @old_sql_mode;
DROP TABLE t1;
SELECT 'b-','ab';
SELECT "$,*,." as escape_chars;
SELECT "(";
SELECT "[";
SELECT 0x00, 0xff;
SELECT 0x00, 0xff;
SELECT 0x00;
SELECT "[ MY-012345 ]" as err;
SELECT CONCAT('winpath','\\');
SELECT "mtr";
SELECT "mtr";
SELECT "mtr";
SELECT "mtr";
SELECT "abc", "abd";
SELECT "abc", "abd";
SELECT "many words form a sentence" as text;
SELECT "many words form a sentence" as text;
SELECT "absolute", "accent";
SELECT 1 as num, "abc" as lc, "ABC" as uc;
SELECT 'a' as letter, 0x00 as nullchar, 0xff as nonprintable;
$my_stmt;
$my_stmt;
SELECT $val AS res;
SELECT $val AS res;
CREATE TABLE t1(col1 INT, col2 INT, col3 INT);
INSERT INTO t1 VALUES(1, RAND(), 4);
INSERT INTO t1 VALUES(2, RAND(), 5);
INSERT INTO t1 VALUES(3, RAND(), 6);
CREATE TABLE t2(col1 INT, col2 INT, col3 INT);
INSERT INTO t2 VALUES(1, RAND(), 4);
INSERT INTO t2 VALUES(2, RAND(), 5);
INSERT INTO t2 VALUES(3, RAND(), 6);
DROP TABLE t1, t2;
abc 456.27EOFSELECT "abc 456.27" as c1;
SELECT "abc 456.27" as c1;
  my $vardir= $ENV{'MYSQLTEST_VARDIR'};
  open(FILE, ">", "$vardir/tmp/600chars.txt");
  print FILE "a"x600 . "\n";
  close(FILE)EOFassert(1);
assert($x);
assert(! $y);
CREATE TABLE t1 (i int primary key not null);
INSERT INTO t1 values(3);
assert(`select count(*) from t1`);
assert(! `select count(*) from t1 where i = 4`);
DROP TABLE t1;
  assert(3);
while(0)    assert(0);
while ($myvar)  assert(0);
  assert(0);
while ($myvar)  assert(0);
  while ($myvar)    EOF  EOFwhile($myvar)      EOFwhile ($counter)      if ($counter)  {    # Should not assert      }  if (!$counter)  {    # Asserts here      }EOF