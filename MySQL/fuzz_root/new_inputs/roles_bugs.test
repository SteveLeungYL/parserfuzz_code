   let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   SELECT CHARSET(CURRENT_ROLE()) = @@character_set_system;
SELECT CHARSET(ROLES_GRAPHML()) = @@character_set_system;
CREATE TABLE t1 AS  SELECT CURRENT_ROLE() AS CURRENT_ROLE, ROLES_GRAPHML() AS ROLES_GRAPHML;
SHOW CREATE TABLE t1;
DROP TABLE t1;
CREATE ROLE r1;
GRANT r1 TO root@localhost;
SET ROLE r1;
SELECT CHARSET(CURRENT_ROLE()) = @@character_set_system;
SELECT CHARSET(ROLES_GRAPHML()) = @@character_set_system;
SET ROLE DEFAULT;
REVOKE r1 FROM root@localhost;
DROP ROLE r1;
CREATE USER uu@localhost, u1@localhost;
CREATE ROLE r1;
GRANT CREATE ROLE, DROP ROLE ON *.* TO uu@localhost;
connect(con1,localhost,uu,,);
SHOW GRANTS;
DROP USER u1@localhost;
DROP ROLE u1@localhost;
DROP ROLE r1;
connection default;
DROP USER uu@localhost, u1@localhost;
disconnect con1;
CREATE DATABASE my_db;
CREATE table my_db.t1 (id int primary key);
CREATE ROLE my_role;
CREATE USER my_user, foo@localhost, baz@localhost;
GRANT ALL ON *.* to my_role, foo@localhost;
GRANT EXECUTE ON *.* TO my_user, baz@localhost;
GRANT my_role TO my_user, baz@localhost;
SET DEFAULT ROLE my_role TO my_user;
DELIMITER $$;
CREATE DEFINER=foo@localhost PROCEDURE my_db.foo_proc()BEGININSERT into my_db.t1 values(2) on duplicate key UPDATE id = values(id) + 200;
END $$DELIMITER ;$$DELIMITER $$;
CREATE DEFINER=baz@localhost PROCEDURE my_db.baz_proc()BEGINset ROLE all;
INSERT into my_db.t1 values(4) on duplicate key UPDATE id = values(id) + 400;
END $$DELIMITER ;$$INSERT into my_db.t1 values(5);
INSERT into my_db.t1 values(8) on duplicate key UPDATE id = values(id) + 800;
CALL my_db.foo_proc();
CALL my_db.baz_proc();
connection default;
REVOKE ALL ON *.* FROM my_role;
REVOKE ALL ON *.* FROM foo@localhost;
GRANT EXECUTE ON *.* TO foo@localhost;
connection my_user_con;
INSERT into my_db.t1 values(10);
CALL my_db.baz_proc();
CALL my_db.foo_proc();
connection default;
disconnect my_user_con;
DROP DATABASE my_db;
DROP USER my_user;
DROP USER foo@localhost, baz@localhost;
DROP ROLE my_role;
CREATE USER u1, u2;
CREATE ROLE r1, r2;
GRANT r2 TO r1 WITH ADMIN OPTION;
GRANT r1 TO u1 WITH ADMIN OPTION;
connect(conn_u1,localhost, u1,,,,);
GRANT r1 TO u2;
REVOKE r1 FROM u2;
GRANT r2 TO u2;
REVOKE r2 FROM u2;
SET ROLE r1;
GRANT r1 TO u2;
REVOKE r1 FROM u2;
GRANT r2 TO u2;
REVOKE r2 FROM u2;
connection default;
disconnect conn_u1;
DROP ROLE r1, r2;
DROP USER u1, u2;
CREATE USER u1;
CREATE ROLE r1, r2;
GRANT CREATE USER ON *.* TO u1;
GRANT r1 TO u1 WITH ADMIN OPTION;
connect(conn_u1, localhost, u1,,,,);
CREATE USER u2 DEFAULT ROLE r1;
CREATE USER u3 DEFAULT ROLE r2;
connection default;
disconnect conn_u1;
DROP ROLE r1, r2;
DROP USER u1, u2;
CREATE DATABASE bug_test;
CREATE TABLE bug_test.test_table (test_id int, test_data varchar(50),row_is_verified bool);
INSERT INTO bug_test.test_table VALUES(1, 'valueA', FALSE);
CREATE ROLE `r_verifier`@`localhost`;
CREATE USER `TestUserFails`@`localhost` IDENTIFIED BY 'test';
CREATE USER `TestUserWorks`@`localhost` IDENTIFIED BY 'test';
GRANT SELECT ON bug_test.* TO `r_verifier`@`localhost`;
GRANT UPDATE (row_is_verified) ON bug_test.test_table TO `r_verifier`@`localhost`;
GRANT SELECT ON bug_test.* TO `TestUserWorks`@`localhost`;
GRANT UPDATE (row_is_verified) ON bug_test.test_table TO `TestUserWorks`@`localhost`;
GRANT `r_verifier`@`localhost` TO `TestUserFails`@`localhost`;
SET DEFAULT ROLE `r_verifier`@`localhost` TO `TestUserFails`@`localhost`;
SHOW GRANTS FOR `r_verifier`@`localhost`;
SHOW GRANTS FOR `TestUserFails`@`localhost`;
connect(con1, localhost, TestUserWorks, test, bug_test);
SELECT CURRENT_USER(), CURRENT_ROLE();
SELECT test_id, test_data, row_is_verified FROM bug_test.test_table;
UPDATE bug_test.test_table SET row_is_verified = TRUE WHERE test_id=1;
SELECT test_id, test_data, row_is_verified FROM bug_test.test_table;
connect(con2, localhost, TestUserFails, test, bug_test);
SELECT CURRENT_USER(), CURRENT_ROLE();
SELECT test_id, test_data, row_is_verified FROM bug_test.test_table;
UPDATE bug_test.test_table SET row_is_verified = TRUE WHERE test_id=1;
connection default;
disconnect con1;
disconnect con2;
DROP USER `TestUserFails`@`localhost`, `TestUserWorks`@`localhost`;
DROP ROLE `r_verifier`@`localhost`;
DROP DATABASE bug_test;
CREATE ROLE r1,r2,r3,r4;
GRANT r1 TO r2;
GRANT r2 TO r3;
GRANT r4 TO r3;
GRANT r1 TO r1;
GRANT r2 TO r1;
GRANT r3 TO r1;
SET @save_mandatory_roles = @@global.mandatory_roles;
SET GLOBAL mandatory_roles = 'r4';
GRANT r3 TO r4;
SET GLOBAL mandatory_roles = @save_mandatory_roles;
DROP ROLE r1,r2,r3,r4;
   let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   SELECT CHARSET(CURRENT_ROLE()) = @@character_set_system;
SELECT CHARSET(ROLES_GRAPHML()) = @@character_set_system;
CREATE TABLE t1 AS  SELECT CURRENT_ROLE() AS CURRENT_ROLE, ROLES_GRAPHML() AS ROLES_GRAPHML;
SHOW CREATE TABLE t1;
DROP TABLE t1;
CREATE ROLE r1;
GRANT r1 TO root@localhost;
SET ROLE r1;
SELECT CHARSET(CURRENT_ROLE()) = @@character_set_system;
SELECT CHARSET(ROLES_GRAPHML()) = @@character_set_system;
SET ROLE DEFAULT;
REVOKE r1 FROM root@localhost;
DROP ROLE r1;
CREATE USER uu@localhost, u1@localhost;
CREATE ROLE r1;
GRANT CREATE ROLE, DROP ROLE ON *.* TO uu@localhost;
connect(con1,localhost,uu,,);
SHOW GRANTS;
DROP USER u1@localhost;
DROP ROLE u1@localhost;
DROP ROLE r1;
connection default;
DROP USER uu@localhost, u1@localhost;
disconnect con1;
CREATE DATABASE my_db;
CREATE table my_db.t1 (id int primary key);
CREATE ROLE my_role;
CREATE USER my_user, foo@localhost, baz@localhost;
GRANT ALL ON *.* to my_role, foo@localhost;
GRANT EXECUTE ON *.* TO my_user, baz@localhost;
GRANT my_role TO my_user, baz@localhost;
SET DEFAULT ROLE my_role TO my_user;
DELIMITER $$;
CREATE DEFINER=foo@localhost PROCEDURE my_db.foo_proc()BEGININSERT into my_db.t1 values(2) on duplicate key UPDATE id = values(id) + 200;
END $$DELIMITER ;$$DELIMITER $$;
CREATE DEFINER=baz@localhost PROCEDURE my_db.baz_proc()BEGINset ROLE all;
INSERT into my_db.t1 values(4) on duplicate key UPDATE id = values(id) + 400;
END $$DELIMITER ;$$INSERT into my_db.t1 values(5);
INSERT into my_db.t1 values(8) on duplicate key UPDATE id = values(id) + 800;
CALL my_db.foo_proc();
CALL my_db.baz_proc();
connection default;
REVOKE ALL ON *.* FROM my_role;
REVOKE ALL ON *.* FROM foo@localhost;
GRANT EXECUTE ON *.* TO foo@localhost;
connection my_user_con;
INSERT into my_db.t1 values(10);
CALL my_db.baz_proc();
CALL my_db.foo_proc();
connection default;
disconnect my_user_con;
DROP DATABASE my_db;
DROP USER my_user;
DROP USER foo@localhost, baz@localhost;
DROP ROLE my_role;
CREATE USER u1, u2;
CREATE ROLE r1, r2;
GRANT r2 TO r1 WITH ADMIN OPTION;
GRANT r1 TO u1 WITH ADMIN OPTION;
connect(conn_u1,localhost, u1,,,,);
GRANT r1 TO u2;
REVOKE r1 FROM u2;
GRANT r2 TO u2;
REVOKE r2 FROM u2;
SET ROLE r1;
GRANT r1 TO u2;
REVOKE r1 FROM u2;
GRANT r2 TO u2;
REVOKE r2 FROM u2;
connection default;
disconnect conn_u1;
DROP ROLE r1, r2;
DROP USER u1, u2;
CREATE USER u1;
CREATE ROLE r1, r2;
GRANT CREATE USER ON *.* TO u1;
GRANT r1 TO u1 WITH ADMIN OPTION;
connect(conn_u1, localhost, u1,,,,);
CREATE USER u2 DEFAULT ROLE r1;
CREATE USER u3 DEFAULT ROLE r2;
connection default;
disconnect conn_u1;
DROP ROLE r1, r2;
DROP USER u1, u2;
CREATE DATABASE bug_test;
CREATE TABLE bug_test.test_table (test_id int, test_data varchar(50),row_is_verified bool);
INSERT INTO bug_test.test_table VALUES(1, 'valueA', FALSE);
CREATE ROLE `r_verifier`@`localhost`;
CREATE USER `TestUserFails`@`localhost` IDENTIFIED BY 'test';
CREATE USER `TestUserWorks`@`localhost` IDENTIFIED BY 'test';
GRANT SELECT ON bug_test.* TO `r_verifier`@`localhost`;
GRANT UPDATE (row_is_verified) ON bug_test.test_table TO `r_verifier`@`localhost`;
GRANT SELECT ON bug_test.* TO `TestUserWorks`@`localhost`;
GRANT UPDATE (row_is_verified) ON bug_test.test_table TO `TestUserWorks`@`localhost`;
GRANT `r_verifier`@`localhost` TO `TestUserFails`@`localhost`;
SET DEFAULT ROLE `r_verifier`@`localhost` TO `TestUserFails`@`localhost`;
SHOW GRANTS FOR `r_verifier`@`localhost`;
SHOW GRANTS FOR `TestUserFails`@`localhost`;
connect(con1, localhost, TestUserWorks, test, bug_test);
SELECT CURRENT_USER(), CURRENT_ROLE();
SELECT test_id, test_data, row_is_verified FROM bug_test.test_table;
UPDATE bug_test.test_table SET row_is_verified = TRUE WHERE test_id=1;
SELECT test_id, test_data, row_is_verified FROM bug_test.test_table;
connect(con2, localhost, TestUserFails, test, bug_test);
SELECT CURRENT_USER(), CURRENT_ROLE();
SELECT test_id, test_data, row_is_verified FROM bug_test.test_table;
UPDATE bug_test.test_table SET row_is_verified = TRUE WHERE test_id=1;
connection default;
disconnect con1;
disconnect con2;
DROP USER `TestUserFails`@`localhost`, `TestUserWorks`@`localhost`;
DROP ROLE `r_verifier`@`localhost`;
DROP DATABASE bug_test;
CREATE ROLE r1,r2,r3,r4;
GRANT r1 TO r2;
GRANT r2 TO r3;
GRANT r4 TO r3;
GRANT r1 TO r1;
GRANT r2 TO r1;
GRANT r3 TO r1;
SET @save_mandatory_roles = @@global.mandatory_roles;
SET GLOBAL mandatory_roles = 'r4';
GRANT r3 TO r4;
SET GLOBAL mandatory_roles = @save_mandatory_roles;
DROP ROLE r1,r2,r3,r4;
   let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   SELECT CHARSET(CURRENT_ROLE()) = @@character_set_system;
SELECT CHARSET(ROLES_GRAPHML()) = @@character_set_system;
CREATE TABLE t1 AS  SELECT CURRENT_ROLE() AS CURRENT_ROLE, ROLES_GRAPHML() AS ROLES_GRAPHML;
SHOW CREATE TABLE t1;
DROP TABLE t1;
CREATE ROLE r1;
GRANT r1 TO root@localhost;
SET ROLE r1;
SELECT CHARSET(CURRENT_ROLE()) = @@character_set_system;
SELECT CHARSET(ROLES_GRAPHML()) = @@character_set_system;
SET ROLE DEFAULT;
REVOKE r1 FROM root@localhost;
DROP ROLE r1;
CREATE USER uu@localhost, u1@localhost;
CREATE ROLE r1;
GRANT CREATE ROLE, DROP ROLE ON *.* TO uu@localhost;
connect(con1,localhost,uu,,);
SHOW GRANTS;
DROP USER u1@localhost;
DROP ROLE u1@localhost;
DROP ROLE r1;
connection default;
DROP USER uu@localhost, u1@localhost;
disconnect con1;
CREATE DATABASE my_db;
CREATE table my_db.t1 (id int primary key);
CREATE ROLE my_role;
CREATE USER my_user, foo@localhost, baz@localhost;
GRANT ALL ON *.* to my_role, foo@localhost;
GRANT EXECUTE ON *.* TO my_user, baz@localhost;
GRANT my_role TO my_user, baz@localhost;
SET DEFAULT ROLE my_role TO my_user;
DELIMITER $$;
CREATE DEFINER=foo@localhost PROCEDURE my_db.foo_proc()BEGININSERT into my_db.t1 values(2) on duplicate key UPDATE id = values(id) + 200;
END $$DELIMITER ;$$DELIMITER $$;
CREATE DEFINER=baz@localhost PROCEDURE my_db.baz_proc()BEGINset ROLE all;
INSERT into my_db.t1 values(4) on duplicate key UPDATE id = values(id) + 400;
END $$DELIMITER ;$$INSERT into my_db.t1 values(5);
INSERT into my_db.t1 values(8) on duplicate key UPDATE id = values(id) + 800;
CALL my_db.foo_proc();
CALL my_db.baz_proc();
connection default;
REVOKE ALL ON *.* FROM my_role;
REVOKE ALL ON *.* FROM foo@localhost;
GRANT EXECUTE ON *.* TO foo@localhost;
connection my_user_con;
INSERT into my_db.t1 values(10);
CALL my_db.baz_proc();
CALL my_db.foo_proc();
connection default;
disconnect my_user_con;
DROP DATABASE my_db;
DROP USER my_user;
DROP USER foo@localhost, baz@localhost;
DROP ROLE my_role;
CREATE USER u1, u2;
CREATE ROLE r1, r2;
GRANT r2 TO r1 WITH ADMIN OPTION;
GRANT r1 TO u1 WITH ADMIN OPTION;
connect(conn_u1,localhost, u1,,,,);
GRANT r1 TO u2;
REVOKE r1 FROM u2;
GRANT r2 TO u2;
REVOKE r2 FROM u2;
SET ROLE r1;
GRANT r1 TO u2;
REVOKE r1 FROM u2;
GRANT r2 TO u2;
REVOKE r2 FROM u2;
connection default;
disconnect conn_u1;
DROP ROLE r1, r2;
DROP USER u1, u2;
CREATE USER u1;
CREATE ROLE r1, r2;
GRANT CREATE USER ON *.* TO u1;
GRANT r1 TO u1 WITH ADMIN OPTION;
connect(conn_u1, localhost, u1,,,,);
CREATE USER u2 DEFAULT ROLE r1;
CREATE USER u3 DEFAULT ROLE r2;
connection default;
disconnect conn_u1;
DROP ROLE r1, r2;
DROP USER u1, u2;
CREATE DATABASE bug_test;
CREATE TABLE bug_test.test_table (test_id int, test_data varchar(50),row_is_verified bool);
INSERT INTO bug_test.test_table VALUES(1, 'valueA', FALSE);
CREATE ROLE `r_verifier`@`localhost`;
CREATE USER `TestUserFails`@`localhost` IDENTIFIED BY 'test';
CREATE USER `TestUserWorks`@`localhost` IDENTIFIED BY 'test';
GRANT SELECT ON bug_test.* TO `r_verifier`@`localhost`;
GRANT UPDATE (row_is_verified) ON bug_test.test_table TO `r_verifier`@`localhost`;
GRANT SELECT ON bug_test.* TO `TestUserWorks`@`localhost`;
GRANT UPDATE (row_is_verified) ON bug_test.test_table TO `TestUserWorks`@`localhost`;
GRANT `r_verifier`@`localhost` TO `TestUserFails`@`localhost`;
SET DEFAULT ROLE `r_verifier`@`localhost` TO `TestUserFails`@`localhost`;
SHOW GRANTS FOR `r_verifier`@`localhost`;
SHOW GRANTS FOR `TestUserFails`@`localhost`;
connect(con1, localhost, TestUserWorks, test, bug_test);
SELECT CURRENT_USER(), CURRENT_ROLE();
SELECT test_id, test_data, row_is_verified FROM bug_test.test_table;
UPDATE bug_test.test_table SET row_is_verified = TRUE WHERE test_id=1;
SELECT test_id, test_data, row_is_verified FROM bug_test.test_table;
connect(con2, localhost, TestUserFails, test, bug_test);
SELECT CURRENT_USER(), CURRENT_ROLE();
SELECT test_id, test_data, row_is_verified FROM bug_test.test_table;
UPDATE bug_test.test_table SET row_is_verified = TRUE WHERE test_id=1;
connection default;
disconnect con1;
disconnect con2;
DROP USER `TestUserFails`@`localhost`, `TestUserWorks`@`localhost`;
DROP ROLE `r_verifier`@`localhost`;
DROP DATABASE bug_test;
CREATE ROLE r1,r2,r3,r4;
GRANT r1 TO r2;
GRANT r2 TO r3;
GRANT r4 TO r3;
GRANT r1 TO r1;
GRANT r2 TO r1;
GRANT r3 TO r1;
SET @save_mandatory_roles = @@global.mandatory_roles;
SET GLOBAL mandatory_roles = 'r4';
GRANT r3 TO r4;
SET GLOBAL mandatory_roles = @save_mandatory_roles;
DROP ROLE r1,r2,r3,r4;
   let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   SELECT CHARSET(CURRENT_ROLE()) = @@character_set_system;
SELECT CHARSET(ROLES_GRAPHML()) = @@character_set_system;
CREATE TABLE t1 AS  SELECT CURRENT_ROLE() AS CURRENT_ROLE, ROLES_GRAPHML() AS ROLES_GRAPHML;
SHOW CREATE TABLE t1;
DROP TABLE t1;
CREATE ROLE r1;
GRANT r1 TO root@localhost;
SET ROLE r1;
SELECT CHARSET(CURRENT_ROLE()) = @@character_set_system;
SELECT CHARSET(ROLES_GRAPHML()) = @@character_set_system;
SET ROLE DEFAULT;
REVOKE r1 FROM root@localhost;
DROP ROLE r1;
CREATE USER uu@localhost, u1@localhost;
CREATE ROLE r1;
GRANT CREATE ROLE, DROP ROLE ON *.* TO uu@localhost;
connect(con1,localhost,uu,,);
SHOW GRANTS;
DROP USER u1@localhost;
DROP ROLE u1@localhost;
DROP ROLE r1;
connection default;
DROP USER uu@localhost, u1@localhost;
disconnect con1;
CREATE DATABASE my_db;
CREATE table my_db.t1 (id int primary key);
CREATE ROLE my_role;
CREATE USER my_user, foo@localhost, baz@localhost;
GRANT ALL ON *.* to my_role, foo@localhost;
GRANT EXECUTE ON *.* TO my_user, baz@localhost;
GRANT my_role TO my_user, baz@localhost;
SET DEFAULT ROLE my_role TO my_user;
DELIMITER $$;
CREATE DEFINER=foo@localhost PROCEDURE my_db.foo_proc()BEGININSERT into my_db.t1 values(2) on duplicate key UPDATE id = values(id) + 200;
END $$DELIMITER ;$$DELIMITER $$;
CREATE DEFINER=baz@localhost PROCEDURE my_db.baz_proc()BEGINset ROLE all;
INSERT into my_db.t1 values(4) on duplicate key UPDATE id = values(id) + 400;
END $$DELIMITER ;$$INSERT into my_db.t1 values(5);
INSERT into my_db.t1 values(8) on duplicate key UPDATE id = values(id) + 800;
CALL my_db.foo_proc();
CALL my_db.baz_proc();
connection default;
REVOKE ALL ON *.* FROM my_role;
REVOKE ALL ON *.* FROM foo@localhost;
GRANT EXECUTE ON *.* TO foo@localhost;
connection my_user_con;
INSERT into my_db.t1 values(10);
CALL my_db.baz_proc();
CALL my_db.foo_proc();
connection default;
disconnect my_user_con;
DROP DATABASE my_db;
DROP USER my_user;
DROP USER foo@localhost, baz@localhost;
DROP ROLE my_role;
CREATE USER u1, u2;
CREATE ROLE r1, r2;
GRANT r2 TO r1 WITH ADMIN OPTION;
GRANT r1 TO u1 WITH ADMIN OPTION;
connect(conn_u1,localhost, u1,,,,);
GRANT r1 TO u2;
REVOKE r1 FROM u2;
GRANT r2 TO u2;
REVOKE r2 FROM u2;
SET ROLE r1;
GRANT r1 TO u2;
REVOKE r1 FROM u2;
GRANT r2 TO u2;
REVOKE r2 FROM u2;
connection default;
disconnect conn_u1;
DROP ROLE r1, r2;
DROP USER u1, u2;
CREATE USER u1;
CREATE ROLE r1, r2;
GRANT CREATE USER ON *.* TO u1;
GRANT r1 TO u1 WITH ADMIN OPTION;
connect(conn_u1, localhost, u1,,,,);
CREATE USER u2 DEFAULT ROLE r1;
CREATE USER u3 DEFAULT ROLE r2;
connection default;
disconnect conn_u1;
DROP ROLE r1, r2;
DROP USER u1, u2;
CREATE DATABASE bug_test;
CREATE TABLE bug_test.test_table (test_id int, test_data varchar(50),row_is_verified bool);
INSERT INTO bug_test.test_table VALUES(1, 'valueA', FALSE);
CREATE ROLE `r_verifier`@`localhost`;
CREATE USER `TestUserFails`@`localhost` IDENTIFIED BY 'test';
CREATE USER `TestUserWorks`@`localhost` IDENTIFIED BY 'test';
GRANT SELECT ON bug_test.* TO `r_verifier`@`localhost`;
GRANT UPDATE (row_is_verified) ON bug_test.test_table TO `r_verifier`@`localhost`;
GRANT SELECT ON bug_test.* TO `TestUserWorks`@`localhost`;
GRANT UPDATE (row_is_verified) ON bug_test.test_table TO `TestUserWorks`@`localhost`;
GRANT `r_verifier`@`localhost` TO `TestUserFails`@`localhost`;
SET DEFAULT ROLE `r_verifier`@`localhost` TO `TestUserFails`@`localhost`;
SHOW GRANTS FOR `r_verifier`@`localhost`;
SHOW GRANTS FOR `TestUserFails`@`localhost`;
connect(con1, localhost, TestUserWorks, test, bug_test);
SELECT CURRENT_USER(), CURRENT_ROLE();
SELECT test_id, test_data, row_is_verified FROM bug_test.test_table;
UPDATE bug_test.test_table SET row_is_verified = TRUE WHERE test_id=1;
SELECT test_id, test_data, row_is_verified FROM bug_test.test_table;
connect(con2, localhost, TestUserFails, test, bug_test);
SELECT CURRENT_USER(), CURRENT_ROLE();
SELECT test_id, test_data, row_is_verified FROM bug_test.test_table;
UPDATE bug_test.test_table SET row_is_verified = TRUE WHERE test_id=1;
connection default;
disconnect con1;
disconnect con2;
DROP USER `TestUserFails`@`localhost`, `TestUserWorks`@`localhost`;
DROP ROLE `r_verifier`@`localhost`;
DROP DATABASE bug_test;
CREATE ROLE r1,r2,r3,r4;
GRANT r1 TO r2;
GRANT r2 TO r3;
GRANT r4 TO r3;
GRANT r1 TO r1;
GRANT r2 TO r1;
GRANT r3 TO r1;
SET @save_mandatory_roles = @@global.mandatory_roles;
SET GLOBAL mandatory_roles = 'r4';
GRANT r3 TO r4;
SET GLOBAL mandatory_roles = @save_mandatory_roles;
DROP ROLE r1,r2,r3,r4;
   let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   SELECT CHARSET(CURRENT_ROLE()) = @@character_set_system;
SELECT CHARSET(ROLES_GRAPHML()) = @@character_set_system;
CREATE TABLE t1 AS  SELECT CURRENT_ROLE() AS CURRENT_ROLE, ROLES_GRAPHML() AS ROLES_GRAPHML;
SHOW CREATE TABLE t1;
DROP TABLE t1;
CREATE ROLE r1;
GRANT r1 TO root@localhost;
SET ROLE r1;
SELECT CHARSET(CURRENT_ROLE()) = @@character_set_system;
SELECT CHARSET(ROLES_GRAPHML()) = @@character_set_system;
SET ROLE DEFAULT;
REVOKE r1 FROM root@localhost;
DROP ROLE r1;
CREATE USER uu@localhost, u1@localhost;
CREATE ROLE r1;
GRANT CREATE ROLE, DROP ROLE ON *.* TO uu@localhost;
connect(con1,localhost,uu,,);
SHOW GRANTS;
DROP USER u1@localhost;
DROP ROLE u1@localhost;
DROP ROLE r1;
connection default;
DROP USER uu@localhost, u1@localhost;
disconnect con1;
CREATE DATABASE my_db;
CREATE table my_db.t1 (id int primary key);
CREATE ROLE my_role;
CREATE USER my_user, foo@localhost, baz@localhost;
GRANT ALL ON *.* to my_role, foo@localhost;
GRANT EXECUTE ON *.* TO my_user, baz@localhost;
GRANT my_role TO my_user, baz@localhost;
SET DEFAULT ROLE my_role TO my_user;
DELIMITER $$;
CREATE DEFINER=foo@localhost PROCEDURE my_db.foo_proc()BEGININSERT into my_db.t1 values(2) on duplicate key UPDATE id = values(id) + 200;
END $$DELIMITER ;$$DELIMITER $$;
CREATE DEFINER=baz@localhost PROCEDURE my_db.baz_proc()BEGINset ROLE all;
INSERT into my_db.t1 values(4) on duplicate key UPDATE id = values(id) + 400;
END $$DELIMITER ;$$INSERT into my_db.t1 values(5);
INSERT into my_db.t1 values(8) on duplicate key UPDATE id = values(id) + 800;
CALL my_db.foo_proc();
CALL my_db.baz_proc();
connection default;
REVOKE ALL ON *.* FROM my_role;
REVOKE ALL ON *.* FROM foo@localhost;
GRANT EXECUTE ON *.* TO foo@localhost;
connection my_user_con;
INSERT into my_db.t1 values(10);
CALL my_db.baz_proc();
CALL my_db.foo_proc();
connection default;
disconnect my_user_con;
DROP DATABASE my_db;
DROP USER my_user;
DROP USER foo@localhost, baz@localhost;
DROP ROLE my_role;
CREATE USER u1, u2;
CREATE ROLE r1, r2;
GRANT r2 TO r1 WITH ADMIN OPTION;
GRANT r1 TO u1 WITH ADMIN OPTION;
connect(conn_u1,localhost, u1,,,,);
GRANT r1 TO u2;
REVOKE r1 FROM u2;
GRANT r2 TO u2;
REVOKE r2 FROM u2;
SET ROLE r1;
GRANT r1 TO u2;
REVOKE r1 FROM u2;
GRANT r2 TO u2;
REVOKE r2 FROM u2;
connection default;
disconnect conn_u1;
DROP ROLE r1, r2;
DROP USER u1, u2;
CREATE USER u1;
CREATE ROLE r1, r2;
GRANT CREATE USER ON *.* TO u1;
GRANT r1 TO u1 WITH ADMIN OPTION;
connect(conn_u1, localhost, u1,,,,);
CREATE USER u2 DEFAULT ROLE r1;
CREATE USER u3 DEFAULT ROLE r2;
connection default;
disconnect conn_u1;
DROP ROLE r1, r2;
DROP USER u1, u2;
CREATE DATABASE bug_test;
CREATE TABLE bug_test.test_table (test_id int, test_data varchar(50),row_is_verified bool);
INSERT INTO bug_test.test_table VALUES(1, 'valueA', FALSE);
CREATE ROLE `r_verifier`@`localhost`;
CREATE USER `TestUserFails`@`localhost` IDENTIFIED BY 'test';
CREATE USER `TestUserWorks`@`localhost` IDENTIFIED BY 'test';
GRANT SELECT ON bug_test.* TO `r_verifier`@`localhost`;
GRANT UPDATE (row_is_verified) ON bug_test.test_table TO `r_verifier`@`localhost`;
GRANT SELECT ON bug_test.* TO `TestUserWorks`@`localhost`;
GRANT UPDATE (row_is_verified) ON bug_test.test_table TO `TestUserWorks`@`localhost`;
GRANT `r_verifier`@`localhost` TO `TestUserFails`@`localhost`;
SET DEFAULT ROLE `r_verifier`@`localhost` TO `TestUserFails`@`localhost`;
SHOW GRANTS FOR `r_verifier`@`localhost`;
SHOW GRANTS FOR `TestUserFails`@`localhost`;
connect(con1, localhost, TestUserWorks, test, bug_test);
SELECT CURRENT_USER(), CURRENT_ROLE();
SELECT test_id, test_data, row_is_verified FROM bug_test.test_table;
UPDATE bug_test.test_table SET row_is_verified = TRUE WHERE test_id=1;
SELECT test_id, test_data, row_is_verified FROM bug_test.test_table;
connect(con2, localhost, TestUserFails, test, bug_test);
SELECT CURRENT_USER(), CURRENT_ROLE();
SELECT test_id, test_data, row_is_verified FROM bug_test.test_table;
UPDATE bug_test.test_table SET row_is_verified = TRUE WHERE test_id=1;
connection default;
disconnect con1;
disconnect con2;
DROP USER `TestUserFails`@`localhost`, `TestUserWorks`@`localhost`;
DROP ROLE `r_verifier`@`localhost`;
DROP DATABASE bug_test;
CREATE ROLE r1,r2,r3,r4;
GRANT r1 TO r2;
GRANT r2 TO r3;
GRANT r4 TO r3;
GRANT r1 TO r1;
GRANT r2 TO r1;
GRANT r3 TO r1;
SET @save_mandatory_roles = @@global.mandatory_roles;
SET GLOBAL mandatory_roles = 'r4';
GRANT r3 TO r4;
SET GLOBAL mandatory_roles = @save_mandatory_roles;
DROP ROLE r1,r2,r3,r4;
