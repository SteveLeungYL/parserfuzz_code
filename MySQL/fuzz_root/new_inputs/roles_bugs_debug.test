     let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   CREATE DATABASE my_db;
CREATE table my_db.t1 (id int primary key);
CREATE ROLE foo_role;
CREATE USER foo, bar;
GRANT INSERT(id), UPDATE(id), SELECT(id) ON my_db.t1 to foo_role, bar;
GRANT EXECUTE, SYSTEM_VARIABLES_ADMIN ON *.* TO foo, bar;
GRANT foo_role TO foo;
SET DEFAULT ROLE foo_role TO foo;
SET DEBUG_SYNC='in_check_grant_all_columns SIGNAL s1 WAIT_FOR s2';
send INSERT into my_db.t1 values(8) on duplicate key UPDATE id = values(id) + 80;
connection default;
SET DEBUG_SYNC='now WAIT_FOR s1';
SET DEBUG_SYNC='after_table_grant_revoke SIGNAL s2';
REVOKE ALL ON my_db.t1 FROM foo_role;
connection foo_con;
reap;
SET DEBUG_SYNC= 'RESET';
INSERT into my_db.t1 values(9) on duplicate key UPDATE id = values(id) + 90;
SET DEBUG_SYNC='in_check_grant_all_columns SIGNAL s1 WAIT_FOR s2';
send INSERT into my_db.t1 values(6) on duplicate key UPDATE id = values(id) + 60;
connection default;
SET DEBUG_SYNC='now WAIT_FOR s1';
SET DEBUG_SYNC='after_table_grant_revoke SIGNAL s2';
REVOKE ALL ON my_db.t1 FROM bar;
connection bar_con;
reap;
INSERT into my_db.t1 values(9) on duplicate key UPDATE id = values(id) + 90;
connection default;
SET DEBUG_SYNC= 'RESET';
disconnect foo_con;
disconnect bar_con;
DROP DATABASE my_db;
DROP USER foo, bar;
DROP ROLE foo_role;
     let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   CREATE DATABASE my_db;
CREATE table my_db.t1 (id int primary key);
CREATE ROLE foo_role;
CREATE USER foo, bar;
GRANT INSERT(id), UPDATE(id), SELECT(id) ON my_db.t1 to foo_role, bar;
GRANT EXECUTE, SYSTEM_VARIABLES_ADMIN ON *.* TO foo, bar;
GRANT foo_role TO foo;
SET DEFAULT ROLE foo_role TO foo;
SET DEBUG_SYNC='in_check_grant_all_columns SIGNAL s1 WAIT_FOR s2';
send INSERT into my_db.t1 values(8) on duplicate key UPDATE id = values(id) + 80;
connection default;
SET DEBUG_SYNC='now WAIT_FOR s1';
SET DEBUG_SYNC='after_table_grant_revoke SIGNAL s2';
REVOKE ALL ON my_db.t1 FROM foo_role;
connection foo_con;
reap;
SET DEBUG_SYNC= 'RESET';
INSERT into my_db.t1 values(9) on duplicate key UPDATE id = values(id) + 90;
SET DEBUG_SYNC='in_check_grant_all_columns SIGNAL s1 WAIT_FOR s2';
send INSERT into my_db.t1 values(6) on duplicate key UPDATE id = values(id) + 60;
connection default;
SET DEBUG_SYNC='now WAIT_FOR s1';
SET DEBUG_SYNC='after_table_grant_revoke SIGNAL s2';
REVOKE ALL ON my_db.t1 FROM bar;
connection bar_con;
reap;
INSERT into my_db.t1 values(9) on duplicate key UPDATE id = values(id) + 90;
connection default;
SET DEBUG_SYNC= 'RESET';
disconnect foo_con;
disconnect bar_con;
DROP DATABASE my_db;
DROP USER foo, bar;
DROP ROLE foo_role;
     let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   CREATE DATABASE my_db;
CREATE table my_db.t1 (id int primary key);
CREATE ROLE foo_role;
CREATE USER foo, bar;
GRANT INSERT(id), UPDATE(id), SELECT(id) ON my_db.t1 to foo_role, bar;
GRANT EXECUTE, SYSTEM_VARIABLES_ADMIN ON *.* TO foo, bar;
GRANT foo_role TO foo;
SET DEFAULT ROLE foo_role TO foo;
SET DEBUG_SYNC='in_check_grant_all_columns SIGNAL s1 WAIT_FOR s2';
send INSERT into my_db.t1 values(8) on duplicate key UPDATE id = values(id) + 80;
connection default;
SET DEBUG_SYNC='now WAIT_FOR s1';
SET DEBUG_SYNC='after_table_grant_revoke SIGNAL s2';
REVOKE ALL ON my_db.t1 FROM foo_role;
connection foo_con;
reap;
SET DEBUG_SYNC= 'RESET';
INSERT into my_db.t1 values(9) on duplicate key UPDATE id = values(id) + 90;
SET DEBUG_SYNC='in_check_grant_all_columns SIGNAL s1 WAIT_FOR s2';
send INSERT into my_db.t1 values(6) on duplicate key UPDATE id = values(id) + 60;
connection default;
SET DEBUG_SYNC='now WAIT_FOR s1';
SET DEBUG_SYNC='after_table_grant_revoke SIGNAL s2';
REVOKE ALL ON my_db.t1 FROM bar;
connection bar_con;
reap;
INSERT into my_db.t1 values(9) on duplicate key UPDATE id = values(id) + 90;
connection default;
SET DEBUG_SYNC= 'RESET';
disconnect foo_con;
disconnect bar_con;
DROP DATABASE my_db;
DROP USER foo, bar;
DROP ROLE foo_role;
     let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   CREATE DATABASE my_db;
CREATE table my_db.t1 (id int primary key);
CREATE ROLE foo_role;
CREATE USER foo, bar;
GRANT INSERT(id), UPDATE(id), SELECT(id) ON my_db.t1 to foo_role, bar;
GRANT EXECUTE, SYSTEM_VARIABLES_ADMIN ON *.* TO foo, bar;
GRANT foo_role TO foo;
SET DEFAULT ROLE foo_role TO foo;
SET DEBUG_SYNC='in_check_grant_all_columns SIGNAL s1 WAIT_FOR s2';
send INSERT into my_db.t1 values(8) on duplicate key UPDATE id = values(id) + 80;
connection default;
SET DEBUG_SYNC='now WAIT_FOR s1';
SET DEBUG_SYNC='after_table_grant_revoke SIGNAL s2';
REVOKE ALL ON my_db.t1 FROM foo_role;
connection foo_con;
reap;
SET DEBUG_SYNC= 'RESET';
INSERT into my_db.t1 values(9) on duplicate key UPDATE id = values(id) + 90;
SET DEBUG_SYNC='in_check_grant_all_columns SIGNAL s1 WAIT_FOR s2';
send INSERT into my_db.t1 values(6) on duplicate key UPDATE id = values(id) + 60;
connection default;
SET DEBUG_SYNC='now WAIT_FOR s1';
SET DEBUG_SYNC='after_table_grant_revoke SIGNAL s2';
REVOKE ALL ON my_db.t1 FROM bar;
connection bar_con;
reap;
INSERT into my_db.t1 values(9) on duplicate key UPDATE id = values(id) + 90;
connection default;
SET DEBUG_SYNC= 'RESET';
disconnect foo_con;
disconnect bar_con;
DROP DATABASE my_db;
DROP USER foo, bar;
DROP ROLE foo_role;
     let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   CREATE DATABASE my_db;
CREATE table my_db.t1 (id int primary key);
CREATE ROLE foo_role;
CREATE USER foo, bar;
GRANT INSERT(id), UPDATE(id), SELECT(id) ON my_db.t1 to foo_role, bar;
GRANT EXECUTE, SYSTEM_VARIABLES_ADMIN ON *.* TO foo, bar;
GRANT foo_role TO foo;
SET DEFAULT ROLE foo_role TO foo;
SET DEBUG_SYNC='in_check_grant_all_columns SIGNAL s1 WAIT_FOR s2';
send INSERT into my_db.t1 values(8) on duplicate key UPDATE id = values(id) + 80;
connection default;
SET DEBUG_SYNC='now WAIT_FOR s1';
SET DEBUG_SYNC='after_table_grant_revoke SIGNAL s2';
REVOKE ALL ON my_db.t1 FROM foo_role;
connection foo_con;
reap;
SET DEBUG_SYNC= 'RESET';
INSERT into my_db.t1 values(9) on duplicate key UPDATE id = values(id) + 90;
SET DEBUG_SYNC='in_check_grant_all_columns SIGNAL s1 WAIT_FOR s2';
send INSERT into my_db.t1 values(6) on duplicate key UPDATE id = values(id) + 60;
connection default;
SET DEBUG_SYNC='now WAIT_FOR s1';
SET DEBUG_SYNC='after_table_grant_revoke SIGNAL s2';
REVOKE ALL ON my_db.t1 FROM bar;
connection bar_con;
reap;
INSERT into my_db.t1 values(9) on duplicate key UPDATE id = values(id) + 90;
connection default;
SET DEBUG_SYNC= 'RESET';
disconnect foo_con;
disconnect bar_con;
DROP DATABASE my_db;
DROP USER foo, bar;
DROP ROLE foo_role;
