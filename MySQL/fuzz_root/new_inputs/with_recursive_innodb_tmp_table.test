SET @@session.myisam_sort_buffer_size = 4294967296;
eval SET @@session.myisam_sort_buffer_size = $_c64m_myisam_sort_buffer_size_save;
    if (!$BIG_TEST)  {      }set cte_max_recursion_depth=5000;
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q, q as q1;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q right join q as q1 on 1;
show status like 'Created_tmp_disk_tables';
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q where b=300;
eval explain $query;
show status like 'Created_tmp_disk_tables';
eval $query;
show status like 'Created_tmp_disk_tables';
set @c:=1;
flush status;
with recursive q (b, c) as(select 1, 1 union all select (1+b), (@c:=(@c+1)) from q where b<2000)select sum(b*c) from q;
show status like 'Created_tmp_disk_tables';
set cte_max_recursion_depth=5000;
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q, q as q1;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q right join q as q1 on 1;
show status like 'Created_tmp_disk_tables';
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q where b=300;
eval explain $query;
show status like 'Created_tmp_disk_tables';
eval $query;
show status like 'Created_tmp_disk_tables';
set @c:=1;
flush status;
with recursive q (b, c) as(select 1, 1 union all select (1+b), (@c:=(@c+1)) from q where b<2000)select sum(b*c) from q;
show status like 'Created_tmp_disk_tables';
set cte_max_recursion_depth=5000;
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q, q as q1;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q right join q as q1 on 1;
show status like 'Created_tmp_disk_tables';
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q where b=300;
eval explain $query;
show status like 'Created_tmp_disk_tables';
eval $query;
show status like 'Created_tmp_disk_tables';
set @c:=1;
flush status;
with recursive q (b, c) as(select 1, 1 union all select (1+b), (@c:=(@c+1)) from q where b<2000)select sum(b*c) from q;
show status like 'Created_tmp_disk_tables';
set cte_max_recursion_depth=5000;
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q, q as q1;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q right join q as q1 on 1;
show status like 'Created_tmp_disk_tables';
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q where b=300;
eval explain $query;
show status like 'Created_tmp_disk_tables';
eval $query;
show status like 'Created_tmp_disk_tables';
set @c:=1;
flush status;
with recursive q (b, c) as(select 1, 1 union all select (1+b), (@c:=(@c+1)) from q where b<2000)select sum(b*c) from q;
show status like 'Created_tmp_disk_tables';
set session internal_tmp_mem_storage_engine='memory';
create table t1(a int);
insert into t1 values(1),(2),(3);
set big_tables=1;
set optimizer_switch='block_nested_loop=off';
with qn as (select * from t1 limit 3) select * from qn;
with qn as (select * from t1 limit 3) select * from qn, qn qn1;
with recursive qn as (select 0 as nunion allselect n+1 from qn where n<10)select * from qn;
with recursive qn as (select 0 as nunion allselect 2*n+2 from qn where n<50union allselect 2*n+1 from qn where n<50select count(n),max(n) from qn;
set optimizer_switch=default;
set big_tables=1;
set big_tables=0;
set @@tmp_table_size=1024,@@max_heap_table_size=16384;
set @@tmp_table_size=30000,@@max_heap_table_size=30000;
set @@tmp_table_size=60000,@@max_heap_table_size=60000;
drop table t1;
set session internal_tmp_mem_storage_engine=default;
SET @@session.myisam_sort_buffer_size = 4294967296;
eval SET @@session.myisam_sort_buffer_size = $_c64m_myisam_sort_buffer_size_save;
    if (!$BIG_TEST)  {      }set cte_max_recursion_depth=5000;
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q, q as q1;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q right join q as q1 on 1;
show status like 'Created_tmp_disk_tables';
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q where b=300;
eval explain $query;
show status like 'Created_tmp_disk_tables';
eval $query;
show status like 'Created_tmp_disk_tables';
set @c:=1;
flush status;
with recursive q (b, c) as(select 1, 1 union all select (1+b), (@c:=(@c+1)) from q where b<2000)select sum(b*c) from q;
show status like 'Created_tmp_disk_tables';
set cte_max_recursion_depth=5000;
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q, q as q1;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q right join q as q1 on 1;
show status like 'Created_tmp_disk_tables';
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q where b=300;
eval explain $query;
show status like 'Created_tmp_disk_tables';
eval $query;
show status like 'Created_tmp_disk_tables';
set @c:=1;
flush status;
with recursive q (b, c) as(select 1, 1 union all select (1+b), (@c:=(@c+1)) from q where b<2000)select sum(b*c) from q;
show status like 'Created_tmp_disk_tables';
set cte_max_recursion_depth=5000;
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q, q as q1;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q right join q as q1 on 1;
show status like 'Created_tmp_disk_tables';
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q where b=300;
eval explain $query;
show status like 'Created_tmp_disk_tables';
eval $query;
show status like 'Created_tmp_disk_tables';
set @c:=1;
flush status;
with recursive q (b, c) as(select 1, 1 union all select (1+b), (@c:=(@c+1)) from q where b<2000)select sum(b*c) from q;
show status like 'Created_tmp_disk_tables';
set cte_max_recursion_depth=5000;
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q, q as q1;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q right join q as q1 on 1;
show status like 'Created_tmp_disk_tables';
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q where b=300;
eval explain $query;
show status like 'Created_tmp_disk_tables';
eval $query;
show status like 'Created_tmp_disk_tables';
set @c:=1;
flush status;
with recursive q (b, c) as(select 1, 1 union all select (1+b), (@c:=(@c+1)) from q where b<2000)select sum(b*c) from q;
show status like 'Created_tmp_disk_tables';
set session internal_tmp_mem_storage_engine='memory';
create table t1(a int);
insert into t1 values(1),(2),(3);
set big_tables=1;
set optimizer_switch='block_nested_loop=off';
with qn as (select * from t1 limit 3) select * from qn;
with qn as (select * from t1 limit 3) select * from qn, qn qn1;
with recursive qn as (select 0 as nunion allselect n+1 from qn where n<10)select * from qn;
with recursive qn as (select 0 as nunion allselect 2*n+2 from qn where n<50union allselect 2*n+1 from qn where n<50select count(n),max(n) from qn;
set optimizer_switch=default;
set big_tables=1;
set big_tables=0;
set @@tmp_table_size=1024,@@max_heap_table_size=16384;
set @@tmp_table_size=30000,@@max_heap_table_size=30000;
set @@tmp_table_size=60000,@@max_heap_table_size=60000;
drop table t1;
set session internal_tmp_mem_storage_engine=default;
SET @@session.myisam_sort_buffer_size = 4294967296;
eval SET @@session.myisam_sort_buffer_size = $_c64m_myisam_sort_buffer_size_save;
    if (!$BIG_TEST)  {      }set cte_max_recursion_depth=5000;
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q, q as q1;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q right join q as q1 on 1;
show status like 'Created_tmp_disk_tables';
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q where b=300;
eval explain $query;
show status like 'Created_tmp_disk_tables';
eval $query;
show status like 'Created_tmp_disk_tables';
set @c:=1;
flush status;
with recursive q (b, c) as(select 1, 1 union all select (1+b), (@c:=(@c+1)) from q where b<2000)select sum(b*c) from q;
show status like 'Created_tmp_disk_tables';
set cte_max_recursion_depth=5000;
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q, q as q1;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q right join q as q1 on 1;
show status like 'Created_tmp_disk_tables';
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q where b=300;
eval explain $query;
show status like 'Created_tmp_disk_tables';
eval $query;
show status like 'Created_tmp_disk_tables';
set @c:=1;
flush status;
with recursive q (b, c) as(select 1, 1 union all select (1+b), (@c:=(@c+1)) from q where b<2000)select sum(b*c) from q;
show status like 'Created_tmp_disk_tables';
set cte_max_recursion_depth=5000;
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q, q as q1;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q right join q as q1 on 1;
show status like 'Created_tmp_disk_tables';
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q where b=300;
eval explain $query;
show status like 'Created_tmp_disk_tables';
eval $query;
show status like 'Created_tmp_disk_tables';
set @c:=1;
flush status;
with recursive q (b, c) as(select 1, 1 union all select (1+b), (@c:=(@c+1)) from q where b<2000)select sum(b*c) from q;
show status like 'Created_tmp_disk_tables';
set cte_max_recursion_depth=5000;
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q, q as q1;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q right join q as q1 on 1;
show status like 'Created_tmp_disk_tables';
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q where b=300;
eval explain $query;
show status like 'Created_tmp_disk_tables';
eval $query;
show status like 'Created_tmp_disk_tables';
set @c:=1;
flush status;
with recursive q (b, c) as(select 1, 1 union all select (1+b), (@c:=(@c+1)) from q where b<2000)select sum(b*c) from q;
show status like 'Created_tmp_disk_tables';
set session internal_tmp_mem_storage_engine='memory';
create table t1(a int);
insert into t1 values(1),(2),(3);
set big_tables=1;
set optimizer_switch='block_nested_loop=off';
with qn as (select * from t1 limit 3) select * from qn;
with qn as (select * from t1 limit 3) select * from qn, qn qn1;
with recursive qn as (select 0 as nunion allselect n+1 from qn where n<10)select * from qn;
with recursive qn as (select 0 as nunion allselect 2*n+2 from qn where n<50union allselect 2*n+1 from qn where n<50select count(n),max(n) from qn;
set optimizer_switch=default;
set big_tables=1;
set big_tables=0;
set @@tmp_table_size=1024,@@max_heap_table_size=16384;
set @@tmp_table_size=30000,@@max_heap_table_size=30000;
set @@tmp_table_size=60000,@@max_heap_table_size=60000;
drop table t1;
set session internal_tmp_mem_storage_engine=default;
SET @@session.myisam_sort_buffer_size = 4294967296;
eval SET @@session.myisam_sort_buffer_size = $_c64m_myisam_sort_buffer_size_save;
    if (!$BIG_TEST)  {      }set cte_max_recursion_depth=5000;
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q, q as q1;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q right join q as q1 on 1;
show status like 'Created_tmp_disk_tables';
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q where b=300;
eval explain $query;
show status like 'Created_tmp_disk_tables';
eval $query;
show status like 'Created_tmp_disk_tables';
set @c:=1;
flush status;
with recursive q (b, c) as(select 1, 1 union all select (1+b), (@c:=(@c+1)) from q where b<2000)select sum(b*c) from q;
show status like 'Created_tmp_disk_tables';
set cte_max_recursion_depth=5000;
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q, q as q1;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q right join q as q1 on 1;
show status like 'Created_tmp_disk_tables';
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q where b=300;
eval explain $query;
show status like 'Created_tmp_disk_tables';
eval $query;
show status like 'Created_tmp_disk_tables';
set @c:=1;
flush status;
with recursive q (b, c) as(select 1, 1 union all select (1+b), (@c:=(@c+1)) from q where b<2000)select sum(b*c) from q;
show status like 'Created_tmp_disk_tables';
set cte_max_recursion_depth=5000;
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q, q as q1;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q right join q as q1 on 1;
show status like 'Created_tmp_disk_tables';
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q where b=300;
eval explain $query;
show status like 'Created_tmp_disk_tables';
eval $query;
show status like 'Created_tmp_disk_tables';
set @c:=1;
flush status;
with recursive q (b, c) as(select 1, 1 union all select (1+b), (@c:=(@c+1)) from q where b<2000)select sum(b*c) from q;
show status like 'Created_tmp_disk_tables';
set cte_max_recursion_depth=5000;
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q, q as q1;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q right join q as q1 on 1;
show status like 'Created_tmp_disk_tables';
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q where b=300;
eval explain $query;
show status like 'Created_tmp_disk_tables';
eval $query;
show status like 'Created_tmp_disk_tables';
set @c:=1;
flush status;
with recursive q (b, c) as(select 1, 1 union all select (1+b), (@c:=(@c+1)) from q where b<2000)select sum(b*c) from q;
show status like 'Created_tmp_disk_tables';
set session internal_tmp_mem_storage_engine='memory';
create table t1(a int);
insert into t1 values(1),(2),(3);
set big_tables=1;
set optimizer_switch='block_nested_loop=off';
with qn as (select * from t1 limit 3) select * from qn;
with qn as (select * from t1 limit 3) select * from qn, qn qn1;
with recursive qn as (select 0 as nunion allselect n+1 from qn where n<10)select * from qn;
with recursive qn as (select 0 as nunion allselect 2*n+2 from qn where n<50union allselect 2*n+1 from qn where n<50select count(n),max(n) from qn;
set optimizer_switch=default;
set big_tables=1;
set big_tables=0;
set @@tmp_table_size=1024,@@max_heap_table_size=16384;
set @@tmp_table_size=30000,@@max_heap_table_size=30000;
set @@tmp_table_size=60000,@@max_heap_table_size=60000;
drop table t1;
set session internal_tmp_mem_storage_engine=default;
SET @@session.myisam_sort_buffer_size = 4294967296;
eval SET @@session.myisam_sort_buffer_size = $_c64m_myisam_sort_buffer_size_save;
    if (!$BIG_TEST)  {      }set cte_max_recursion_depth=5000;
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q, q as q1;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q right join q as q1 on 1;
show status like 'Created_tmp_disk_tables';
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q where b=300;
eval explain $query;
show status like 'Created_tmp_disk_tables';
eval $query;
show status like 'Created_tmp_disk_tables';
set @c:=1;
flush status;
with recursive q (b, c) as(select 1, 1 union all select (1+b), (@c:=(@c+1)) from q where b<2000)select sum(b*c) from q;
show status like 'Created_tmp_disk_tables';
set cte_max_recursion_depth=5000;
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q, q as q1;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q right join q as q1 on 1;
show status like 'Created_tmp_disk_tables';
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q where b=300;
eval explain $query;
show status like 'Created_tmp_disk_tables';
eval $query;
show status like 'Created_tmp_disk_tables';
set @c:=1;
flush status;
with recursive q (b, c) as(select 1, 1 union all select (1+b), (@c:=(@c+1)) from q where b<2000)select sum(b*c) from q;
show status like 'Created_tmp_disk_tables';
set cte_max_recursion_depth=5000;
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q, q as q1;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q right join q as q1 on 1;
show status like 'Created_tmp_disk_tables';
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q where b=300;
eval explain $query;
show status like 'Created_tmp_disk_tables';
eval $query;
show status like 'Created_tmp_disk_tables';
set @c:=1;
flush status;
with recursive q (b, c) as(select 1, 1 union all select (1+b), (@c:=(@c+1)) from q where b<2000)select sum(b*c) from q;
show status like 'Created_tmp_disk_tables';
set cte_max_recursion_depth=5000;
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q, q as q1;
show status like 'Created_tmp_disk_tables';
flush status;
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(q.b),max(q.b),avg(q.b) from q right join q as q1 on 1;
show status like 'Created_tmp_disk_tables';
with recursive q (b) as(select 1 union all select 1+b from q where b<2000)select min(b),max(b),avg(b) from q where b=300;
eval explain $query;
show status like 'Created_tmp_disk_tables';
eval $query;
show status like 'Created_tmp_disk_tables';
set @c:=1;
flush status;
with recursive q (b, c) as(select 1, 1 union all select (1+b), (@c:=(@c+1)) from q where b<2000)select sum(b*c) from q;
show status like 'Created_tmp_disk_tables';
set session internal_tmp_mem_storage_engine='memory';
create table t1(a int);
insert into t1 values(1),(2),(3);
set big_tables=1;
set optimizer_switch='block_nested_loop=off';
with qn as (select * from t1 limit 3) select * from qn;
with qn as (select * from t1 limit 3) select * from qn, qn qn1;
with recursive qn as (select 0 as nunion allselect n+1 from qn where n<10)select * from qn;
with recursive qn as (select 0 as nunion allselect 2*n+2 from qn where n<50union allselect 2*n+1 from qn where n<50select count(n),max(n) from qn;
set optimizer_switch=default;
set big_tables=1;
set big_tables=0;
set @@tmp_table_size=1024,@@max_heap_table_size=16384;
set @@tmp_table_size=30000,@@max_heap_table_size=30000;
set @@tmp_table_size=60000,@@max_heap_table_size=60000;
drop table t1;
set session internal_tmp_mem_storage_engine=default;
