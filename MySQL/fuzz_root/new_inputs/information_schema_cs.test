    if (!$BIG_TEST)  {      }      VARIABLE_NAME = 'THREAD_HANDLING' AND      VARIABLE_VALUE = 'loaded-dynamically'`){  skip Test requires: 'not_threadpool';
set @orig_sql_mode= @@sql_mode;
DROP TABLE IF EXISTS t0,t1,t2,t3,t4,t5;
DROP VIEW IF EXISTS v1;
SET SESSION information_schema_stats_expiry=0;
select table_name, data_type, column_type from information_schema.columns  where column_name = 'numeric_precision' and table_schema = 'information_schema';
show variables where variable_name like "skip_show_database";
create user mysqltest_1@localhost, mysqltest_2@localhost;
grant select, update, execute on test.* to mysqltest_2@localhost;
grant select, update on test.* to mysqltest_1@localhost;
create user mysqltest_3@localhost;
create user mysqltest_3;
select * from information_schema.SCHEMATA where schema_name > 'm' ORDER BY SCHEMA_NAME;
select schema_name from information_schema.schemata ORDER BY schema_name;
show databases like 't%';
show databases;
show databases where `database` = 't%';
create database mysqltest;
create table mysqltest.t1(a int, b VARCHAR(30), KEY string_data (b));
create table test.t2(a int);
create table t3(a int, KEY a_data (a));
create table mysqltest.t4(a int);
create table t5 (id int auto_increment primary key);
insert into t5 values (10);
create view v1 (c) as SELECT table_name FROM information_schema.TABLES  WHERE table_schema IN ('mysql', 'information_schema', 'test', 'mysqltest') AND        table_name COLLATE utf8_general_ci not like 'ndb_%' AND        table_name COLLATE utf8_general_ci not like 'innodb_%';
select * from v1;
select c,table_name from v1inner join information_schema.TABLES v2 on (v1.c=v2.table_name)where v1.c rlike "t[1-5]{1}$" order by c;
select c,table_name from v1left join information_schema.TABLES v2 on (v1.c=v2.table_name)where v1.c rlike "t[1-5]{1}$" order by c;
select c, v2.table_name from v1right join information_schema.TABLES v2 on (v1.c=v2.table_name)where v1.c rlike "t[1-5]{1}$" order by c;
select table_name from information_schema.TABLESwhere table_schema = "mysqltest" andtable_name rlike "t[1-5]{1}$" order by table_name;
select * from information_schema.STATISTICS where TABLE_SCHEMA = "mysqltest" order by table_name, index_name;
show keys from t3 where Key_name = "a_data";
show tables like 't%';
analyze table t2, t3, t5;
show table status;
show full columns from t3 like "a%";
show full columns from mysql.db like "Insert%";
show full columns from v1;
select * from information_schema.COLUMNS where table_name="t1"and column_name= "a" order by table_name;
show columns from mysqltest.t1 where field like "%a%";
create view mysqltest.v1 (c) as select a from mysqltest.t1;
grant select (a) on mysqltest.t1 to mysqltest_2@localhost;
grant select on mysqltest.v1 to mysqltest_3;
connect (user3,localhost,mysqltest_2,,);
connection user3;
select table_name, column_name, privileges from information_schema.columnswhere table_schema = 'mysqltest' and table_name = 't1' order by table_name, column_name;
show columns from mysqltest.t1;
connect (user4,localhost,mysqltest_3,,mysqltest);
connection user4;
select table_name, column_name, privileges from information_schema.columnswhere table_schema = 'mysqltest' and table_name = 'v1' order by table_name, column_name;
explain select * from v1;
connection default;
disconnect user4;
drop view v1, mysqltest.v1;
drop tables mysqltest.t4, mysqltest.t1, t2, t3, t5;
drop database mysqltest;
select * from information_schema.CHARACTER_SETSwhere CHARACTER_SET_NAME like 'latin1%' order by character_set_name;
SHOW CHARACTER SET LIKE 'latin1%';
SHOW CHARACTER SET WHERE charset like 'latin1%';
select * from information_schema.COLLATIONSwhere COLLATION_NAME like 'latin1%' order by collation_name;
SHOW COLLATION LIKE 'latin1%';
SHOW COLLATION WHERE collation like 'latin1%';
select * from information_schema.COLLATION_CHARACTER_SET_APPLICABILITYwhere COLLATION_NAME like 'latin1%' ORDER BY COLLATION_NAME;
drop procedure if exists sel2;
drop function if exists sub1;
drop function if exists sub2;
create function sub1(i int) returns int  return i+1;
delimiter |;
create procedure sel2()begin  select * from t1;
  select * from t2;
end|delimiter ;|select parameter_style, sql_data_access, dtd_identifierfrom information_schema.routines where routine_schema='test';
show procedure status where db='test';
show function status where db='test';
select a.ROUTINE_NAME from information_schema.ROUTINES a,information_schema.SCHEMATA b wherea.ROUTINE_SCHEMA = b.SCHEMA_NAME AND b.SCHEMA_NAME='test'ORDER BY a.ROUTINE_NAME;
select count(*) from information_schema.ROUTINES where routine_schema='test';
create view v1 as select routine_schema, routine_name from information_schema.routines where routine_schema='test'order by routine_schema, routine_name;
select * from v1;
drop view v1;
connect (user1,localhost,mysqltest_1,,);
connection user1;
select ROUTINE_NAME, ROUTINE_DEFINITION from information_schema.ROUTINESWHERE ROUTINE_SCHEMA='test' ORDER BY ROUTINE_NAME;
show create function sub1;
connection user3;
select ROUTINE_NAME, ROUTINE_DEFINITION from information_schema.ROUTINESWHERE ROUTINE_SCHEMA='test' ORDER BY ROUTINE_NAME;
connection default;
grant all privileges on test.* to mysqltest_1@localhost;
connect (user2,localhost,mysqltest_1,,);
connection user2;
select ROUTINE_NAME, ROUTINE_DEFINITION from information_schema.ROUTINESWHERE ROUTINE_SCHEMA='test' ORDER BY ROUTINE_NAME;
create function sub2(i int) returns int  return i+1;
select ROUTINE_NAME, ROUTINE_DEFINITION from information_schema.ROUTINESWHERE ROUTINE_SCHEMA='test' ORDER BY ROUTINE_NAME;
show create procedure sel2;
show create function sub1;
show create function sub2;
show function status like "sub2";
connection default;
disconnect user1;
disconnect user3;
drop function sub2;
show create procedure sel2;
create view v0 (c) as select schema_name from information_schema.schemata order by schema_name;
select * from v0;
explain select * from v0;
create view v1 (c) as select table_name from information_schema.tableswhere table_name="v1" order by table_name;
select * from v1;
create view v2 (c) as select column_name from information_schema.columnswhere table_name="v2" order by column_name;
select * from v2;
create view v3 (c) as select CHARACTER_SET_NAME from information_schema.character_setswhere CHARACTER_SET_NAME like "latin1%" order by character_set_name;
select * from v3;
create view v4 (c) as select COLLATION_NAME from information_schema.collationswhere COLLATION_NAME like "latin1%" order by collation_name;
select * from v4;
show keys from v4;
select * from information_schema.views where TABLE_SCHEMA != 'sys' andTABLE_NAME rlike "v[0-4]{1}$" order by table_name;
drop view v0, v1, v2, v3, v4;
create table t1 (a int);
grant select,update,insert on t1 to mysqltest_1@localhost;
grant select (a), update (a),insert(a), references(a) on t1 to mysqltest_1@localhost;
grant all on test.* to mysqltest_1@localhost with grant option;
select * from information_schema.USER_PRIVILEGES where grantee like '%mysqltest_1%';
select * from information_schema.SCHEMA_PRIVILEGES where grantee like '%mysqltest_1%';
select * from information_schema.TABLE_PRIVILEGES where grantee like '%mysqltest_1%';
select * from information_schema.COLUMN_PRIVILEGES where grantee like '%mysqltest_1%';
delete from mysql.user where user like 'mysqltest%';
delete from mysql.db where user like 'mysqltest%';
delete from mysql.tables_priv where user like 'mysqltest%';
delete from mysql.columns_priv where user like 'mysqltest%';
flush privileges;
drop table t1;
create table t1 (a int not null, primary key(a));
alter table t1 add constraint constraint_1 unique (a);
alter table t1 add constraint unique key_1(a);
alter table t1 add constraint constraint_2 unique key_2(a);
show create table t1;
select * from information_schema.TABLE_CONSTRAINTS whereTABLE_SCHEMA= "test" order by constraint_name;
select * from information_schema.key_column_usage whereTABLE_SCHEMA= "test" order by constraint_name;
connection user2;
select table_name from information_schema.TABLES where table_schema like "test%" order by table_name;
select table_name,column_name from information_schema.COLUMNSwhere table_schema like "test%" order by table_name, column_name;
SELECT ROUTINE_NAME FROM information_schema.ROUTINESWHERE ROUTINE_SCHEMA != 'sys' ORDER BY ROUTINE_NAME;
disconnect user2;
connection default;
delete from mysql.user where user='mysqltest_1';
drop table t1;
drop procedure sel2;
drop function sub1;
create table t1(a int);
create view v1 (c) as select a from t1 with check option;
create view v2 (c) as select a from t1 WITH LOCAL CHECK OPTION;
create view v3 (c) as select a from t1 WITH CASCADED CHECK OPTION;
create user joe@localhost;
select * from information_schema.views where table_schema !='sys' order by table_name;
grant select (a) on test.t1 to joe@localhost with grant option;
select * from INFORMATION_SCHEMA.COLUMN_PRIVILEGES WHERE table_schema != 'sys';
select * from INFORMATION_SCHEMA.TABLE_PRIVILEGES WHERE table_schema NOT IN ('sys','mysql');
drop view v1, v2, v3;
drop table t1;
delete from mysql.user where user='joe';
delete from mysql.db where user='joe';
delete from mysql.tables_priv where user='joe';
delete from mysql.columns_priv where user='joe';
flush privileges;
delimiter //;
create procedure px5 ()begindeclare v int;
declare c cursor for select version frominformation_schema.tables where table_schema <> 'information_schema';
open c;
fetch c into v;
select v;
close c;
end;//call px5()//call px5()//delimiter ;//select sql_mode from information_schema.ROUTINES where ROUTINE_SCHEMA != 'sys';
drop procedure px5;
create table t1 (a int not null auto_increment,b int, primary key (a));
insert into t1 values (1,1),(NULL,3),(NULL,4);
analyze table t1;
select AUTO_INCREMENT from information_schema.tables where table_name = 't1';
drop table t1;
create table t1 (s1 int);
insert into t1 values (0),(9),(0);
select s1 from t1 where s1 in (select version frominformation_schema.tables) union select version frominformation_schema.tables;
drop table t1;
SHOW CREATE TABLE INFORMATION_SCHEMA.character_sets;
set names latin2;
SHOW CREATE TABLE INFORMATION_SCHEMA.character_sets;
set names latin1;
create table t1 select * from information_schema.CHARACTER_SETSwhere CHARACTER_SET_NAME like "latin1" order by character_set_name;
select * from t1;
alter table t1 default character set utf8;
show create table t1;
drop table t1;
create view v1 as select * from information_schema.TABLES;
drop view v1;
create table t1(a NUMERIC(5,3), b NUMERIC(5,1), c float(5,2), d NUMERIC(6,4), e float, f DECIMAL(6,3), g int(11), h DOUBLE(10,3), i DOUBLE);
select COLUMN_NAME,COLUMN_TYPE, CHARACTER_MAXIMUM_LENGTH, CHARACTER_OCTET_LENGTH, NUMERIC_PRECISION, NUMERIC_SCALEfrom information_schema.columns where table_name= 't1';
drop table t1;
delimiter //;
create procedure p108 () begin declare c cursor for select data_typefrom information_schema.columns;  open c; open c; end;//call p108()//delimiter ;//drop procedure p108;
create view v1 as select A1.table_name from information_schema.TABLES A1where table_name= "user" order by table_name;
select * from v1;
drop view v1;
create view vo as select 'a' union select 'a';
show index from vo;
select * from information_schema.TABLE_CONSTRAINTS whereTABLE_NAME= "vo";
select * from information_schema.key_column_usage whereTABLE_NAME= "vo";
drop view vo;
select TABLE_NAME,TABLE_TYPE,ENGINEfrom information_schema.tableswhere table_schema='information_schema'order by table_name collate utf8_general_ci limit 2;
show tables from information_schema like "T%";
create database information_schema;
use information_schema;
show full tables like "T%";
create table t1(a int);
use test;
show tables;
use information_schema;
show tables like "T%";
select table_name from tables where table_name='user';
select column_name, privileges from columnswhere table_name='user' and column_name like '%o%' order by column_name;
use test;
create function sub1(i int) returns int  return i+1;
create table t1(f1 int);
create view v2 (c) as select f1 from t1;
create view v3 (c) as select sub1(1);
create table t4(f1 int, KEY f1_key (f1));
drop table t1;
drop function sub1;
select table_name from information_schema.viewswhere table_schema='test' order by table_name;
select table_name from information_schema.viewswhere table_schema='test' order by table_name;
select column_name from information_schema.columnswhere table_schema='test' order by column_name;
select index_name from information_schema.statistics wheretable_schema='test' order by index_name;
select constraint_name from information_schema.table_constraintswhere table_schema='test' order by constraint_name;
show create view v2;
show create table v3;
drop view v2;
drop view v3;
drop table t4;
select * from information_schema.table_names;
select column_type from information_schema.columnswhere table_schema="information_schema" and table_name="COLUMNS" and(column_name="character_set_name" or column_name="collation_name");
select TABLE_ROWS from information_schema.tables wheretable_schema="information_schema" and table_name="COLUMNS";
select table_type from information_schema.tableswhere table_schema="mysql" and table_name="user";
show open tables where `table` like "user";
show status where variable_name like "%database%";
show variables where variable_name like "skip_show_databas";
show global status like "Threads_running";
create table t1(f1 int);
create table t2(f2 int);
create view v1 as select * from t1, t2;
set @got_val= (select count(*) from information_schema.columns);
drop view v1;
drop table t1, t2;
use test;
CREATE TABLE t_crashme ( f1 BIGINT);
CREATE VIEW a1 (t_CRASHME) AS SELECT f1 FROM t_crashme GROUP BY f1;
CREATE VIEW a2 AS SELECT t_CRASHME FROM a1;
while ($tab_count)     EVAL CREATE TABLE t_$tab_count (f1 BIGINT);
     dec $tab_count ;
SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES;
SELECT count(*) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA='test';
while ($tab_count)     EVAL DROP TABLE t_$tab_count;
     dec $tab_count ;
drop view a2, a1;
drop table t_crashme;
select table_schema, table_name, column_name from information_schema.columnswhere table_schema not in ('performance_schema', 'sys', 'mysql')  and data_type = 'longtext' order by table_name, column_name;
select table_name, column_name, data_type from information_schema.columnswhere table_schema not in ('performance_schema', 'sys')  and data_type = 'datetime'  and table_name COLLATE utf8_general_ci not like 'innodb_%' order by table_name, column_name;
SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES AWHERE NOT EXISTS(SELECT * FROM INFORMATION_SCHEMA.COLUMNS B  WHERE A.TABLE_SCHEMA = B.TABLE_SCHEMA  AND A.TABLE_NAME = B.TABLE_NAME);
create table t1( x_bigint BIGINT,  x_integer INTEGER,  x_smallint SMALLINT,  x_decimal DECIMAL(5,3),  x_numeric NUMERIC(5,3),  x_real REAL,  x_float FLOAT,  x_double_precision DOUBLE PRECISION );
SELECT COLUMN_NAME, CHARACTER_MAXIMUM_LENGTH, CHARACTER_OCTET_LENGTHFROM INFORMATION_SCHEMA.COLUMNSWHERE TABLE_NAME= 't1' ORDER BY COLUMN_NAME;
drop table t1;
create user mysqltest_4@localhost;
grant select on test.* to mysqltest_4@localhost;
connect (user10261,localhost,mysqltest_4,,);
connection user10261;
SELECT TABLE_NAME, COLUMN_NAME, PRIVILEGES FROM INFORMATION_SCHEMA.COLUMNSwhere COLUMN_NAME='TABLE_NAME' ORDER BY TABLE_NAME COLLATE UTF8_GENERAL_CI;
connection default;
disconnect user10261;
delete from mysql.user where user='mysqltest_4';
delete from mysql.db where user='mysqltest_4';
flush privileges;
SELECT table_schema, count(*) FROM information_schema.TABLES WHEREtable_schema IN ('mysql', 'information_schema', 'test', 'mysqltest')AND table_name not like 'ndb%' AND table_name COLLATE utf8_general_ci not like 'innodb_%'GROUP BY TABLE_SCHEMA;
create table t1 (i int, j int);
delimiter |;
create trigger trg1 before insert on t1 for each rowbegin  if new.j > 10 then    set new.j := 10;
  end if;
end|create trigger trg2 before update on t1 for each rowbegin  if old.i % 2 = 0 then    set new.j := -1;
  end if;
end|create trigger trg3 after update on t1 for each rowbegin  if new.j = -1 then    set @fired:= "Yes";
  end if;
end|delimiter ;|show triggers;
select * from information_schema.triggers where trigger_schema in ('mysql', 'information_schema', 'test', 'mysqltest')order by trigger_name;
drop trigger trg1;
drop trigger trg2;
drop trigger trg3;
drop table t1;
create database mysqltest;
create table mysqltest.t1 (f1 int, f2 int);
create table mysqltest.t2 (f1 int);
create user user1@localhost, user2@localhost, user3@localhost, user4@localhost;
grant select (f1) on mysqltest.t1 to user1@localhost;
grant select on mysqltest.t2 to user2@localhost;
grant select on mysqltest.* to user3@localhost;
grant select on *.* to user4@localhost;
connect (con1,localhost,user1,,mysqltest);
connect (con2,localhost,user2,,mysqltest);
connect (con3,localhost,user3,,mysqltest);
connect (con4,localhost,user4,,);
connection con1;
select * from information_schema.column_privileges order by grantee;
select * from information_schema.table_privileges order by grantee;
select * from information_schema.schema_privileges order by grantee;
select * from information_schema.user_privileges order by grantee;
show grants;
connection con2;
select * from information_schema.column_privileges order by grantee;
select * from information_schema.table_privileges order by grantee;
select * from information_schema.schema_privileges order by grantee;
select * from information_schema.user_privileges order by grantee;
show grants;
connection con3;
select * from information_schema.column_privileges order by grantee;
select * from information_schema.table_privileges order by grantee;
select * from information_schema.schema_privileges order by grantee;
select * from information_schema.user_privileges order by grantee;
show grants;
connection con4;
select * from information_schema.column_privileges where grantee like '%user%'order by grantee;
select * from information_schema.table_privileges where grantee like '%user%'and table_schema !='mysql' order by grantee;
select * from information_schema.schema_privileges where grantee like '%user%'and table_schema !='performance_schema' order by grantee;
select * from information_schema.user_privileges where grantee like '%user%' and grantee not like '%session%'order by grantee;
show grants;
connection default;
disconnect con1;
disconnect con2;
disconnect con3;
disconnect con4;
drop user user1@localhost, user2@localhost, user3@localhost, user4@localhost;
use test;
drop database mysqltest;
drop procedure if exists p1;
drop procedure if exists p2;
create procedure p1 () modifies sql data set @a = 5;
create procedure p2 () set @a = 5;
select sql_data_access from information_schema.routineswhere specific_name like 'p%' and ROUTINE_SCHEMA != 'sys';
drop procedure p1;
drop procedure p2;
show create database information_schema;
create table t1(f1 LONGBLOB, f2 LONGTEXT);
select column_name,data_type,CHARACTER_OCTET_LENGTH,       CHARACTER_MAXIMUM_LENGTHfrom information_schema.columnswhere table_name='t1' order by column_name;
drop table t1;
create table t1(f1 tinyint, f2 SMALLINT, f3 mediumint, f4 int,                f5 BIGINT, f6 BIT, f7 bit(64));
select column_name, NUMERIC_PRECISION, NUMERIC_SCALEfrom information_schema.columnswhere table_name='t1' order by column_name;
drop table t1;
create table t1 (f1 integer);
create trigger tr1 after insert on t1 for each row set @test_var=42;
use information_schema;
select trigger_schema, trigger_name from triggers wheretrigger_name='tr1';
use test;
drop table t1;
create table t1 (a int not null, b int);
use information_schema;
select column_name, column_default from columns  where table_schema='test' and table_name='t1';
use test;
show columns from t1;
drop table t1;
CREATE TABLE t1 (a int);
CREATE TABLE t2 (b int);
analyze table t1, t2;
SHOW TABLE STATUS FROM test  WHERE name IN ( SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES                    WHERE TABLE_SCHEMA='test' AND TABLE_TYPE='BASE TABLE');
DROP TABLE t1,t2;
create table t1(f1 int);
create view v1 (c) as select f1 from t1;
connect (con5,localhost,root,,*NO-ONE*);
select database();
show fields from test.v1;
connection default;
disconnect con5;
drop view v1;
drop table t1;
alter database information_schema;
drop database information_schema;
drop table information_schema.tables;
alter table information_schema.tables;
use information_schema;
create temporary table schemata(f1 char(10));
delimiter |;
CREATE PROCEDURE p1 ()BEGIN  SELECT 'foo' FROM DUAL;
END |delimiter ;|select ROUTINE_NAME from routines where ROUTINE_SCHEMA='information_schema';
grant all on information_schema.* to 'user1'@'localhost';
grant select on information_schema.* to 'user1'@'localhost';
use test;
create table t1(id int);
insert into t1(id) values (1);
select 1 from (select 1 from test.t1) a;
use information_schema;
select 1 from (select 1 from test.t1) a;
use test;
drop table t1;
create table t1 (f1 int(11));
create view v1 as select * from t1;
drop table t1;
select table_type from information_schema.tableswhere table_name="v1";
drop view v1;
create temporary table t1(f1 int, index(f1));
show columns from t1;
describe t1;
show indexes from t1;
drop table t1;
create table t1(f1 binary(32), f2 varbinary(64));
select character_maximum_length, character_octet_lengthfrom information_schema.columns where table_name='t1';
drop table t1;
CREATE TABLE t1 (f1 BIGINT, f2 VARCHAR(20), f3 BIGINT);
INSERT INTO t1 SET f1 = 1, f2 = 'Schoenenbourg', f3 = 1;
CREATE FUNCTION func2() RETURNS BIGINT RETURN 1;
delimiter //;
CREATE FUNCTION func1() RETURNS BIGINTBEGIN  RETURN ( SELECT COUNT(*) FROM information_schema.views WHERE TABLE_SCHEMA != 'sys' AND           TABLE_SCHEMA != 'information_schema');
END//delimiter ;//CREATE VIEW v1 AS SELECT 1 FROM t1                    WHERE f3 = (SELECT func2 ());
SELECT func1();
DROP TABLE t1;
DROP VIEW v1;
DROP FUNCTION func1;
DROP FUNCTION func2;
SELECT column_type, GROUP_CONCAT(table_schema, '.', table_name ORDER BY table_name), COUNT(*) AS numFROM information_schema.columns WHEREtable_schema='information_schema' AND(column_type = 'varchar(7)' OR column_type = 'varchar(20)' OR column_type = 'varchar(30)')GROUP BY column_type ORDER BY num, column_type;
create table t1(f1 char(1) not null, f2 char(9) not null)default character set utf8;
select CHARACTER_MAXIMUM_LENGTH, CHARACTER_OCTET_LENGTH frominformation_schema.columns where table_schema='test' and table_name = 't1';
drop table t1;
create user mysqltest_1@localhost;
grant select on test.* to mysqltest_1@localhost;
create table t1 (id int);
create view v1 as select * from t1;
create definer = mysqltest_1@localhostsql security definer view v2 as select 1;
connect (con16681,localhost,mysqltest_1,,test);
connection con16681;
select * from information_schema.viewswhere table_name='v1' or table_name='v2';
connection default;
disconnect con16681;
drop view v1, v2;
drop table t1;
drop user mysqltest_1@localhost;
set @a:= '.';
create table t1(f1 char(5));
create table t2(f1 char(5));
select concat(@a, table_name), @a, table_namefrom information_schema.tables where table_schema = 'test' order by table_name;
drop table t1,t2;
DROP PROCEDURE IF EXISTS p1;
DROP FUNCTION IF EXISTS f1;
CREATE PROCEDURE p1() SET @a= 1;
CREATE FUNCTION f1() RETURNS INT RETURN @a + 1;
CREATE USER mysql_bug20230@localhost;
GRANT EXECUTE ON PROCEDURE p1 TO mysql_bug20230@localhost;
GRANT EXECUTE ON FUNCTION f1 TO mysql_bug20230@localhost;
SELECT ROUTINE_NAME, ROUTINE_DEFINITION FROM INFORMATION_SCHEMA.ROUTINESWHERE ROUTINE_SCHEMA='test' ORDER BY ROUTINE_NAME;
SHOW CREATE PROCEDURE p1;
SHOW CREATE FUNCTION f1;
connect (conn1, localhost, mysql_bug20230,,);
SELECT ROUTINE_NAME, ROUTINE_DEFINITION FROM INFORMATION_SCHEMA.ROUTINESWHERE ROUTINE_SCHEMA='test' ORDER BY ROUTINE_NAME;
SHOW CREATE PROCEDURE p1;
SHOW CREATE FUNCTION f1;
CALL p1();
SELECT f1();
disconnect conn1;
connection default;
DROP FUNCTION f1;
DROP PROCEDURE p1;
DROP USER mysql_bug20230@localhost;
SELECT MAX(table_name)  FROM information_schema.tables  WHERE table_schema IN ('mysql', 'information_schema', 'test');
SELECT table_name FROM information_schema.tables  WHERE table_name=(SELECT MAX(table_name)                      FROM information_schema.tables WHERE                      table_schema IN ('mysql',                                       'information_schema',                                       'test')) order by table_name;
DROP TABLE IF EXISTS bug23037;
DROP FUNCTION IF EXISTS get_value;
DELIMITER |;
CREATE FUNCTION get_value()  RETURNS TEXT  DETERMINISTICBEGIN  DECLARE col1, col2, col3, col4, col6 CHAR(255);
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }  DECLARE default_val VARCHAR(65532) CHARACTER SET latin1;
  DECLARE done INT DEFAULT 0;
  DECLARE cur1 CURSOR FOR SELECT COLUMN_NAME, COLUMN_TYPE, IS_NULLABLE, COLUMN_KEY, COLUMN_DEFAULT, EXTRA FROM INFORMATION_SCHEMA.COLUMNS where TABLE_NAME='bug23037';
  DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
  OPEN cur1;
  FETCH cur1 INTO col1, col2, col3, col4, default_val, col6;
  CLOSE cur1;
  RETURN default_val;
end|DELIMITER ;|eval CREATE TABLE bug23037(fld1 VARCHAR(65532) CHARACTER SET latin1 DEFAULT "$body");
SELECT COLUMN_NAME, MD5(COLUMN_DEFAULT), LENGTH(COLUMN_DEFAULT)  FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME='bug23037'  ORDER BY COLUMN_NAME;
SELECT MD5(get_value());
SELECT COLUMN_NAME, MD5(COLUMN_DEFAULT), LENGTH(COLUMN_DEFAULT), COLUMN_DEFAULT=get_value() FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME='bug23037' ORDER BY COLUMN_NAME;
DROP TABLE bug23037;
DROP FUNCTION get_value;
create view v1 asselect table_schema as object_schema,       table_name   as object_name,       table_type   as object_typefrom information_schema.tablesorder by object_schema;
explain select * from v1;
explain select * from (select table_name from information_schema.tables) as a;
drop view v1;
create table t1 (f1 int(11));
create table t2 (f1 int(11), f2 int(11));
select table_name from information_schema.tableswhere table_schema = 'test' and table_name not in(select table_name from information_schema.columns where table_schema = 'test' and column_name = 'f3') order by table_name;
drop table t1,t2;
select 1 as f1 from information_schema.tables  where "COLUMN_PRIVILEGES"=(select cast(table_name as char)  from information_schema.tables where table_schema != 'performance_schema' order by table_name limit 1) limit 1;
select t.table_name, group_concat(t.table_schema, '.', t.table_name),       count(*) as num1from information_schema.tables tinner join information_schema.columns c1on t.table_schema = c1.table_schema AND t.table_name = c1.table_namewhere t.table_name not like 'ndb%' and      t.table_schema = 'information_schema' and        c1.ordinal_position =        (select isnull(c2.column_type) -         isnull(group_concat(c2.table_schema, '.', c2.table_name)) +         count(*) as num         from information_schema.columns c2 where         c2.table_schema='information_schema' and         (c2.column_type = 'varchar(7)' or c2.column_type = 'varchar(20)')          group by c2.column_type order by num limit 1)        and t.table_name not like 'INNODB_%'group by t.table_name order by num1, t.table_name COLLATE utf8_general_ci;
create table t1(f1 int);
create view v1 as select f1+1 as a from t1;
create table t2 (f1 int, f2 int);
create view v2 as select f1+1 as a, f2 as b from t2;
select table_name, is_updatable from information_schema.views where table_schema != 'sys' order by table_name;
delete from v1;
drop view v1,v2;
drop table t1,t2;
alter database;
alter database test;
create user mysqltest_1@localhost;
create database mysqltest;
create table mysqltest.t1(a int, b int, c int);
create trigger mysqltest.t1_ai after insert on mysqltest.t1  for each row set @a = new.a + new.b + new.c;
grant select(b) on mysqltest.t1 to mysqltest_1@localhost;
select trigger_name from information_schema.triggerswhere event_object_table='t1';
show triggers from mysqltest;
connect (con27629,localhost,mysqltest_1,,mysqltest);
show columns from t1;
select column_name from information_schema.columns where table_name='t1' order by column_name;
show triggers;
select trigger_name from information_schema.triggerswhere event_object_table='t1';
connection default;
disconnect con27629;
drop user mysqltest_1@localhost;
drop database mysqltest;
create table t1 (  f1 varchar(50),  f2 varchar(50) not null,  f3 varchar(50) default '',  f4 varchar(50) default NULL,  f5 bigint not null,  f6 bigint not null default 10,  f7 datetime not null,  f8 datetime default '2006-01-01');
select column_default from information_schema.columns where table_name= 't1';
show columns from t1;
drop table t1;
show fields from information_schema.table_names;
show keys from information_schema.table_names;
USE information_schema;
SET max_heap_table_size = 16384;
CREATE TABLE test.t1( a INT );
SELECT *FROM tables taJOIN collations co ON ( co.collation_name = CONVERT(ta.table_catalog using utf8))JOIN character_sets cs ON ( cs.character_set_name = CONVERT(ta.table_catalog using utf8));
DROP TABLE test.t1;
SET max_heap_table_size = DEFAULT;
USE test;
select * from information_schema.engines WHERE ENGINE="MyISAM";
explain format=tree select * from information_schema.engines WHERE ENGINE="MyISAM";
create user user3148@localhost;
grant select on *.* to user3148@localhost;
connect (con3148,localhost,user3148,,test);
connection con3148;
select user,db from information_schema.processlist;
connection default;
disconnect con3148;
drop user user3148@localhost;
DROP TABLE IF EXISTS server_status;
DROP EVENT IF EXISTS event_status;
SELECT COUNT(*) = 1 FROM information_schema.processlist  WHERE user = 'event_scheduler' AND command = 'Daemon';
DELIMITER $$;
CREATE EVENT event_status ON SCHEDULE AT NOW() ON COMPLETION NOT PRESERVE DOBEGIN  CREATE TABLE server_status  SELECT variable_name  FROM performance_schema.global_status  WHERE variable_name LIKE 'ABORTED_CONNECTS' OR  variable_name LIKE 'BINLOG_CACHE_DISK_USE';
END$$DELIMITER ;$$SELECT variable_name FROM server_status;
DROP TABLE server_status;
SELECT * FROM INFORMATION_SCHEMA.SCHEMATAWHERE SCHEMA_NAME = 'mysqltest';
SELECT * FROM INFORMATION_SCHEMA.SCHEMATAWHERE SCHEMA_NAME = '';
SELECT * FROM INFORMATION_SCHEMA.SCHEMATAWHERE SCHEMA_NAME = 'test';
select count(*) from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA='mysql' AND TABLE_NAME='nonexisting';
select count(*) from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA='mysql' AND TABLE_NAME='';
select count(*) from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA='' AND TABLE_NAME='';
select count(*) from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA='' AND TABLE_NAME='nonexisting';
CREATE VIEW v1AS SELECT *FROM information_schema.TABLES;
SELECT VIEW_DEFINITION FROM INFORMATION_SCHEMA.VIEWS where TABLE_NAME = 'v1';
DROP VIEW v1;
SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATAWHERE SCHEMA_NAME ='information_schema';
SELECT TABLE_COLLATION FROM INFORMATION_SCHEMA.TABLESWHERE TABLE_SCHEMA='mysql' and TABLE_NAME= 'db';
select * from information_schema.columns where table_schema = NULL;
select * from `information_schema`.`COLUMNS` where `TABLE_NAME` = NULL;
select * from `information_schema`.`key_column_usage` where `TABLE_SCHEMA` = NULL;
select * from `information_schema`.`key_column_usage` where `TABLE_NAME` = NULL;
select * from `information_schema`.`PARTITIONS` where `TABLE_SCHEMA` = NULL;
select * from `information_schema`.`PARTITIONS` where `TABLE_NAME` = NULL;
select * from `information_schema`.`REFERENTIAL_CONSTRAINTS` where `CONSTRAINT_SCHEMA` = NULL;
select * from `information_schema`.`REFERENTIAL_CONSTRAINTS` where `TABLE_NAME` = NULL;
select * from information_schema.schemata where schema_name = NULL;
select * from `information_schema`.`STATISTICS` where `TABLE_SCHEMA` = NULL;
select * from `information_schema`.`STATISTICS` where `TABLE_NAME` = NULL;
select * from information_schema.tables where table_schema = NULL;
select * from information_schema.tables where table_catalog = NULL;
select * from information_schema.tables where table_name = NULL;
select * from `information_schema`.`TABLE_CONSTRAINTS` where `TABLE_SCHEMA` = NULL;
select * from `information_schema`.`TABLE_CONSTRAINTS` where `TABLE_NAME` = NULL;
select * from `information_schema`.`TRIGGERS` where `EVENT_OBJECT_SCHEMA` = NULL;
select * from `information_schema`.`TRIGGERS` where `EVENT_OBJECT_TABLE` = NULL;
select * from `information_schema`.`VIEWS` where `TABLE_SCHEMA` = NULL;
select * from `information_schema`.`VIEWS` where `TABLE_NAME` = NULL;
explain select 1 from information_schema.tables;
use information_schema;
show events;
show events from information_schema;
show events where Db= 'information_schema';
use test;
drop table if exists t1;
drop function if exists f1;
create table t1 (a int);
delimiter |;
create function f1() returns int  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $counter = `SELECT $disconnect_timeout * 10`;
while (!$mysql_errno)    show session status;
  dec $counter;
  if (!$counter)  {    if ($show_rpl_debug_info)    {          }      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }begin  insert into t1 (a) values (1);
  return 0;
end|delimiter ;|show open tables where f1()=0;
show open tables where f1()=0;
drop table t1;
drop function f1;
connect (conn1, localhost, root,,);
connection conn1;
send select * from information_schema.tables where 1=sleep(100000);
connection default;
where state='User sleep' andinfo='select * from information_schema.tables where 1=sleep(100000)';
disable_query_log;
eval kill $ID;
enable_query_log;
disconnect conn1;
where state='User sleep' andinfo='select * from information_schema.tables where 1=sleep(100000)';
connect (conn1, localhost, root,,);
connection conn1;
send select * from information_schema.columns where 1=sleep(100000);
connection default;
where state='User sleep' andinfo='select * from information_schema.columns where 1=sleep(100000)';
disable_query_log;
eval kill $ID;
enable_query_log;
disconnect conn1;
where state='User sleep' andinfo='select * from information_schema.columns where 1=sleep(100000)';
set global init_connect="drop table if exists t1;drop table if exists t1;\drop table if exists t1;drop table if exists t1;\drop table if exists t1;drop table if exists t1;\drop table if exists t1;drop table if exists t1;\drop table if exists t1;drop table if exists t1;\drop table if exists t1;drop table if exists t1;\drop table if exists t1;drop table if exists t1;\drop table if exists t1;drop table if exists t1;\drop table if exists t1;drop table if exists t1;\drop table if exists t1;drop table if exists t1;\drop table if exists t1;drop table if exists t1;\drop table if exists t1;drop table if exists t1;\drop table if exists t1;drop table if exists t1;\drop table if exists t1;drop table if exists t1;\drop table if exists t1;drop table if exists t1;\drop table if exists t1;drop table if exists t1;\drop table if exists t1;drop table if exists t1;\drop table if exists t1;drop table if exists t1;\drop table if exists t1;drop table if exists t1;\drop table if exists t1;drop table if exists t1;\drop table if exists t1;drop table if exists t1;";
select * from performance_schema.global_variables where variable_name='init_connect';
set global init_connect="";
create table t0 select * from performance_schema.global_status where VARIABLE_NAME='COM_SELECT';
SELECT 1;
select a.VARIABLE_VALUE - b.VARIABLE_VALUE from t0 b, performance_schema.global_status a   where a.VARIABLE_NAME = b.VARIABLE_NAME;
drop table t0;
CREATE TABLE t1(a INT) KEY_BLOCK_SIZE=1;
SELECT CREATE_OPTIONS FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME='t1';
DROP TABLE t1;
SET TIMESTAMP=@@TIMESTAMP + 10000000;
SELECT 'OK' AS TEST_RESULT FROM INFORMATION_SCHEMA.PROCESSLIST WHERE time < 0;
SET TIMESTAMP=DEFAULT;
CREATE DATABASE db1;
USE db1;
CREATE TABLE t1 (id INT);
CREATE USER nonpriv;
USE test;
connect (nonpriv_con, localhost, nonpriv,,);
connection nonpriv_con;
SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME='t1';
USE INFORMATION_SCHEMA;
SELECT COUNT(*) FROM TABLES WHERE TABLE_NAME='t1';
connection default;
disconnect nonpriv_con;
DROP USER nonpriv;
DROP TABLE db1.t1;
DROP DATABASE db1;
CREATE TABLE variables(f1 INT);
SELECT COLUMN_DEFAULT, TABLE_NAME FROM INFORMATION_SCHEMA.COLUMNSWHERE information_schema.COLUMNS.TABLE_NAME = 'variables';
DROP TABLE variables;
CREATE TABLE ubig (a BIGINT, b BIGINT UNSIGNED);
SELECT TABLE_NAME, COLUMN_NAME, NUMERIC_PRECISION   FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME='ubig';
INSERT IGNORE INTO ubig VALUES (0xFFFFFFFFFFFFFFFF,0xFFFFFFFFFFFFFFFF);
SELECT length(CAST(b AS CHAR)) FROM ubig;
DROP TABLE ubig;
create function f1 (p1 int, p2 datetime, p3 decimal(10,2))returns char(10) return null;
create procedure p1 (p1 float(8,5), p2 char(32), p3 varchar(10)) begin end;
create procedure p2 (p1 enum('c', 's'), p2 blob, p3 text) begin end;
select * from information_schema.parameters where specific_schema='test';
select data_type, character_maximum_length,       character_octet_length, numeric_precision,       numeric_scale, character_set_name,       collation_name, dtd_identifierfrom information_schema.routines where routine_schema='test';
drop procedure p1;
drop procedure p2;
drop function f1;
drop tables if exists t1, t2, t3;
create table t1 (i int);
create table t2 (j int primary key auto_increment);
analyze table t1, t2;
connect (con3726_1,localhost,root,,test);
connection con3726_1;
lock table t2 read;
connect (con3726_2,localhost,root,,test);
connection con3726_2;
connection default;
  select count(*) = 1 from information_schema.processlist  where state = "Waiting for table metadata lock" and        info like "rename table t2 to t3";
select table_name, column_name, data_type from information_schema.columns  where table_schema = 'test' and table_name in ('t1', 't2');
select table_name, auto_increment from information_schema.tables  where table_schema = 'test' and table_name in ('t1', 't2');
connection con3726_1;
unlock tables;
connection con3726_2;
connection default;
disconnect con3726_1;
disconnect con3726_2;
drop tables t1, t3;
create table information_schema.t1 (f1 INT);
drop table information_schema.t1;
drop temporary table if exists information_schema.t1;
create temporary table information_schema.t1 (f1 INT);
drop view information_schema.v1;
create view information_schema.v1;
create trigger mysql.trg1 after insert on information_schema.t1 for each row set @a=1;
create table t1 select * from information_schema.t1;
CREATE TABLE t1(f1 char(100));
REPAIR TABLE t1, information_schema.processlist;
CHECKSUM TABLE t1, information_schema.processlist;
ANALYZE TABLE t1, information_schema.processlist;
CHECK TABLE t1, information_schema.processlist;
OPTIMIZE TABLE t1, information_schema.processlist;
RENAME TABLE v1 to v2, information_schema.processlist to t2;
DROP TABLE t1, information_schema.processlist;
LOCK TABLES t1 READ, information_schema.processlist READ;
DROP TABLE t1;
create function f1() returns int return 1;
select routine_name, routine_type from information_schema.routineswhere routine_schema = 'test';
connection default;
drop function f1;
disconnect con7;
SELECT *FROM INFORMATION_SCHEMA.key_column_usageLEFT JOIN INFORMATION_SCHEMA.COLUMNSUSING (TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME)WHERE COLUMNS.TABLE_SCHEMA = 'test'AND COLUMNS.TABLE_NAME = 't1';
drop table if exists t1;
drop view if exists v1;
create table t1 (a int, b int);
create view v1 as select t1.a, t1.b from t1;
alter table t1 change b c int;
lock table t1 read;
connect(con1, localhost, root,,);
connection con1;
send flush tables;
connection default;
  select count(*) = 1 from information_schema.processlist    where state = "Waiting for table flush" and          info = "flush tables";
select * from information_schema.views  where table_schema != 'sys' order by table_schema, table_name;
unlock tables;
connection con1;
reap;
disconnect con1;
connection default;
drop table t1;
drop view v1;
drop database if exists mysqltest;
create database mysqltest;
use mysqltest;
create table t0 (i int);
create table t1 (j int);
create table t2 (k int);
lock tables t2 read;
connect (con12828477_1, localhost, root,,mysqltest);
connect (con12828477_2, localhost, root,,mysqltest);
  select count(*) = 1 from information_schema.processlist  where state = "Waiting for table metadata lock" and        info = "rename table t1 to t3, t2 to t1, t3 to t2";
SET SESSION information_schema_stats_expiry=0;
connect (con12828477_3, localhost, root,,mysqltest);
  select count(*) = 0 from information_schema.processlist  where state = "Waiting for table metadata lock" and        info = "select event_object_table, trigger_name from information_schema.triggers where event_object_schema='mysqltest'";
rename table t0 to t4;
connection default;
unlock tables;
connection con12828477_1;
connection con12828477_2;
connection default;
disconnect con12828477_1;
disconnect con12828477_2;
disconnect con12828477_3;
drop database if exists mysqltest;
create database mysqltest;
use mysqltest;
create table mysqltest.t(a int, b date, c time, d datetime, e timestamp);
create table mysqltest.t0(a int, b date, c time(0), d datetime(0), e timestamp(0));
create table mysqltest.t1(a int, b date, c time(1), d datetime(1), e timestamp(1));
   let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
     if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $counter = `SELECT $disconnect_timeout * 10`;
while (!$mysql_errno)    show session status;
  dec $counter;
  if (!$counter)  {    if ($show_rpl_debug_info)    {          }      }  create table mysqltest.t2(a int, b date, c time(2), d datetime(2), e timestamp(2));
create table mysqltest.t3(a int, b date, c time(3), d datetime(3), e timestamp(3));
create table mysqltest.t4(a int, b date, c time(4), d datetime(4), e timestamp(4));
create table mysqltest.t5(a int, b date, c time(5), d datetime(5), e timestamp(5));
create table mysqltest.t6(a int, b date, c time(6), d datetime(6), e timestamp(6));
select TABLE_NAME,COLUMN_NAME,DATA_TYPE,DATETIME_PRECISION frominformation_schema.columns where TABLE_SCHEMA='mysqltest' order by table_name, column_name;
drop database mysqltest;
use test;
SELECT * FROM INFORMATION_SCHEMA.TABLES;
SELECT VARIABLE_VALUE INTO @val1 FROM performance_schema.global_status WHERE  VARIABLE_NAME LIKE 'Opened_tables';
SELECT ENGINE FROM INFORMATION_SCHEMA.TABLES;
SELECT VARIABLE_VALUE INTO @val2 FROM performance_schema.global_status WHERE  VARIABLE_NAME LIKE 'Opened_tables';
SELECT @val1 = @val2;
CREATE TABLE t1(a INT PRIMARY KEY);
INSERT INTO t1 VALUES (1);
SELECT MAX(a) FROM information_schema.engines RIGHT JOIN t1 ON 1;
DROP TABLE t1;
CREATE PROCEDURE information_schema.is() BEGIN END;
SELECT ENGINE, SUPPORT, TRANSACTIONS FROM INFORMATION_SCHEMA.ENGINESWHERESUPPORT IN (SELECT DISTINCT SUPPORTFROM INFORMATION_SCHEMA.ENGINESWHEREENGINE IN (SELECT DISTINCT ENGINE FROM INFORMATION_SCHEMA.ENGINESWHERE ENGINE IN ('MEMORY')))ORDER BY ENGINELIMIT 1;
SELECT 1FROM DUALWHERE (SELECT 1 FROM information_schema.tables        WHERE table_schema        ORDER BY table_name        LIMIT 1);
eval EXPLAIN $query;
eval $query;
SELECT 1 AS F1 FROM information_schema.tablesWHERE "COLUMN_PRIVILEGES"=      (SELECT CAST(TABLE_NAME AS CHAR)      FROM information_schema.tables      WHERE table_schema != 'PERFORMANCE_SCHEMA'      ORDER BY table_name LIMIT 1)LIMIT 1;
eval EXPLAIN $query;
eval $query;
connection default;
set names utf8;
CREATE USER user_name_len_22_01234@localhost;
GRANT SELECT ON *.* TO user_name_len_22_01234@localhost;
connect (con_user22,localhost,user_name_len_22_01234,,test);
connection con_user22;
SELECT user,db FROM information_schema.processlist;
connection default;
CREATE USER очень_очень_очень_длинный_юзер__@localhost;
GRANT SELECT ON *.* TO очень_очень_очень_длинный_юзер__@localhost;
connect (con_user32_utf8,localhost,очень_очень_очень_длинный_юзер__,,test);
connection con_user32_utf8;
SELECT user,db FROM information_schema.processlist;
connection default;
disconnect con_user22;
disconnect con_user32_utf8;
DROP USER user_name_len_22_01234@localhost;
DROP USER очень_очень_очень_длинный_юзер__@localhost;
set names default;
SET SESSION information_schema_stats_expiry=default;
set sql_mode= @orig_sql_mode;
CREATE VIEW v1 AS SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLESWHERE TABLE_NAME= "users";
LOCK TABLE v1 READ;
connect(con1, localhost, root,,);
send FLUSH TABLES;
connection default;
  SELECT COUNT(*) = 1 FROM INFORMATION_SCHEMA.PROCESSLIST  WHERE state = "Waiting for table flush" AND  info = "flush tables";
SELECT * FROM v1;
UNLOCK TABLES;
connection con1;
reap;
disconnect con1;
connection default;
DROP VIEW v1;
SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = 'ndbinfo';
SELECT table_name FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'ndbinfo';
CREATE TABLE t1 (c1 INT,c2 INT,c3 CHAR(255),c4 CHAR(255),c5 CHAR(255),c6 POINT NOT NULL,c7 GEOMETRY NOT NULL SRID 0,SPATIAL INDEX(c7),KEY c2_key (c2),FULLTEXT KEY c3_fts (c3),FULLTEXT KEY c4_fts (c4, c5));
SELECT COLUMN_NAME, IS_NULLABLE,       DATA_TYPE, COLLATION_NAME, COLUMN_KEY  FROM INFORMATION_SCHEMA.COLUMNS  WHERE TABLE_SCHEMA='test' ORDER BY COLUMN_NAME;
SHOW COLUMNS FROM t1;
DROP TABLE t1;
SELECT INTERNAL_TABLE_ROWS(NULL, NULL, NULL, NULL);
SELECT INTERNAL_AVG_ROW_LENGTH(NULL, NULL, NULL, NULL);
SELECT INTERNAL_DATA_LENGTH(NULL, NULL, NULL, NULL);
SELECT INTERNAL_MAX_DATA_LENGTH(NULL, NULL, NULL, NULL);
SELECT INTERNAL_INDEX_LENGTH(NULL, NULL, NULL, NULL);
SELECT INTERNAL_DATA_FREE(NULL, NULL, NULL, NULL);
SELECT INTERNAL_AUTO_INCREMENT(NULL, NULL, NULL, NULL);
SELECT INTERNAL_UPDATE_TIME(NULL, NULL, NULL, NULL);
SELECT INTERNAL_CHECK_TIME(NULL, NULL, NULL, NULL);
SELECT INTERNAL_CHECKSUM(NULL, NULL, NULL, NULL);
SELECT INTERNAL_DD_CHAR_LENGTH(NULL, NULL, NULL, NULL);
SELECT INTERNAL_INDEX_COLUMN_CARDINALITY(NULL, NULL, NULL, NULL, NULL, NULL, NULL);
SELECT GET_DD_INDEX_SUB_PART_LENGTH(NULL, NULL, NULL, NULL, NULL);
SELECT GET_DD_COLUMN_PRIVILEGES(NULL, NULL, NULL);
SELECT INTERNAL_GET_VIEW_WARNING_OR_ERROR(NULL, NULL, NULL, NULL);
SELECT INTERNAL_GET_COMMENT_OR_ERROR(NULL, NULL, NULL, NULL, NULL);
SELECT INTERNAL_KEYS_DISABLED(NULL);
SELECT CAN_ACCESS_DATABASE(NULL);
SELECT CAN_ACCESS_TABLE(NULL, NULL);
SELECT CAN_ACCESS_VIEW(NULL, NULL, NULL, NULL);
SELECT CAN_ACCESS_COLUMN(NULL, NULL, NULL);
SELECT GET_DD_CREATE_OPTIONS(NULL, NULL);
SELECT CAN_ACCESS_TRIGGER(NULL, NULL);
SELECT CAN_ACCESS_ROUTINE(NULL, NULL, NULL, NULL, NULL);
SELECT CAN_ACCESS_EVENT(NULL);
CREATE TABLE t1(f1 INT);
CREATE TABLE t3 AS SELECT CAN_ACCESS_TABLE("test", "t1");
CREATE VIEW v2 AS SELECT CAN_ACCESS_TABLE("test", "t1");
SELECT * FROM t1 WHERE CAN_ACCESS_TABLE("test", "t1") = 1;
SELECT * FROM INFORMARTION_SCHEMA.TABLES WHERE CAN_ACCESS_TABLE("test", "t1") = 1;
SELECT CAN_ACCESS_TABLE("test", "t1") AS f1, COLUMN_NAME AS F2  FROM INFORMATION_SCHEMA.COLUMNS;
PREPARE stmt FROM 'SELECT CAN_ACCESS_TABLE("test", "t1") AS f1, COLUMN_NAME AS F2  FROM INFORMATION_SCHEMA.COLUMNS';
SELECT CAN_ACCESS_USER(NULL, NULL);
SELECT * FROM INFORMATION_SCHEMA.TABLES where table_name='t1';
SELECT t.table_schema, t.table_name, c.column_name  FROM INFORMATION_SCHEMA.TABLES t,       INFORMATION_SCHEMA.COLUMNS c       WHERE t.table_schema = c.table_schema       AND t.table_name = c.table_name       AND t.table_name = 't1' limit 1;
CREATE VIEW v1 ASSELECT t.table_schema, t.table_name, c.column_name  FROM INFORMATION_SCHEMA.TABLES t,       INFORMATION_SCHEMA.COLUMNS c       WHERE t.table_schema = c.table_schema       AND t.table_name = c.table_name       AND t.table_name = 't1' limit 1;
SHOW CREATE VIEW v1;
CREATE TABLE t2 ASSELECT t.table_schema, t.table_name, c.column_name  FROM INFORMATION_SCHEMA.TABLES t,       INFORMATION_SCHEMA.COLUMNS c       WHERE t.table_schema = c.table_schema       AND t.table_name = c.table_name       AND t.table_name = 't1' limit 1;
SHOW CREATE TABLE t2;
DROP TABLE t1, t2;
DROP VIEW v1;
SELECT * FROM information_schema.ST_GEOMETRY_COLUMNS  WHERE TABLE_SCHEMA='test' AND TABLE_NAME='t1';
CREATE TABLE t1(g GEOMETRY, pt POINT, ls LINESTRING, py POLYGON, mpt MULTIPOINT,  mls MULTILINESTRING, mpy MULTIPOLYGON, gc GEOMETRYCOLLECTION);
SELECT * FROM information_schema.ST_GEOMETRY_COLUMNS  WHERE TABLE_SCHEMA='test' AND TABLE_NAME='t1'  ORDER BY COLUMN_NAME;
DROP TABLE t1;
DESCRIBE `aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa`;
EXPLAIN `aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa`;
SHOW KEYS FROM `aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa`;
SHOW COLUMNS FROM `aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa`;
DESCRIBE `aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa`.`t1`;
EXPLAIN `aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa`.`t1`;
SHOW KEYS FROM `aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa`.`t1`;
SHOW COLUMNS FROM `aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa`.`t1`;
CREATE TABLE t1 (a VARCHAR(200), b TEXT, FULLTEXT (a,b))ENGINE = InnoDB charset utf8mb4;
SELECT * FROM INFORMATION_SCHEMA.`REFERENTIAL_CONSTRAINTS`;
DROP TABLE t1;
SET SESSION information_schema_stats_expiry= 0;
SELECT INDEX_NAME FROM INFORMATION_SCHEMA.`STATISTICS` WHERE `TABLE_NAME` = 'innodb_table_stats' AND Cardinality ;
SET SESSION information_schema_stats_expiry= default;
CREATE TABLE t1 (a INT);
SET SESSION optimizer_switch='derived_merge=off';
SHOW FIELDS FROM t1;
SET SESSION optimizer_switch=DEFAULT;
DROP TABLE t1;
SELECT * FROM INFORMATION_SCHEMA.CHARACTER_SETS WHERE DESCRIPTION LIKE '%japanese%';
SELECT * FROM INFORMATION_SCHEMA.SHOW_STATISTICS;
CREATE TABLE t1 (a CHAR(40) NOT NULL, UNIQUE idx1(a(2)))  COMMENT="testing a fix" MAX_ROWS=10;
SELECT create_options, UPPER(create_options),       table_comment, UPPER(table_comment)  FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 't1';
SELECT privileges, UPPER(privileges)  FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 't1';
DROP TABLE t1;
SELECT t.table_name, c1.column_name  FROM information_schema.tables t       INNER JOIN       information_schema.columns c1       ON t.table_schema = c1.table_schema AND          t.table_name = c1.table_name  WHERE t.table_schema = 'information_schema' AND        c1.ordinal_position =        ( SELECT COALESCE(MIN(c2.ordinal_position),1)            FROM information_schema.columns c2            WHERE c2.table_schema = t.table_schema AND                  c2.table_name = t.table_name AND                  c2.column_name LIKE '%SCHEMA%'        )  AND t.table_name NOT LIKE 'ndb%'  AND t.table_name NOT LIKE 'INNODB%'  ORDER BY t.table_name COLLATE utf8_general_ci,           c1.column_name COLLATE utf8_general_ci;
SELECT t.table_name, c1.column_name  FROM information_schema.tables t       INNER JOIN       information_schema.columns c1       ON t.table_schema = c1.table_schema AND          t.table_name = c1.table_name  WHERE t.table_schema = 'information_schema' AND        c1.ordinal_position =        ( SELECT COALESCE(MIN(c2.ordinal_position),1)            FROM information_schema.columns c2            WHERE c2.table_schema = 'information_schema' AND                  c2.table_name = t.table_name AND                  c2.column_name LIKE '%SCHEMA%'        )  AND t.table_name NOT LIKE 'ndb%'  AND t.table_name NOT LIKE 'INNODB%'  ORDER BY t.table_name COLLATE utf8_general_ci,           c1.column_name COLLATE utf8_general_ci;
CREATE TABLE t1(fld1 BINARY(10) NOT NULL DEFAULT 'a',                fld2 BINARY(10) NOT NULL DEFAULT 0xAA,                fld3 BINARY(10) NOT NULL DEFAULT 0xA,                fld4 BINARY(10) NOT NULL DEFAULT b'1001',                fld5 VARBINARY(5) NOT NULL DEFAULT 'a',                fld6 VARBINARY(5) NOT NULL DEFAULT 0xAA,                fld7 VARBINARY(5) NOT NULL DEFAULT 0xA,                fld8 VARBINARY(5) NOT NULL DEFAULT b'1001');
SHOW COLUMNS from t1;
SELECT COLUMN_DEFAULT FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME= 't1';
DROP TABLE t1;
RENAME USER root@localhost TO master@localhost;
FLUSH PRIVILEGES;
SHOW DATABASES;
RENAME USER master@localhost TO root@localhost;
FLUSH PRIVILEGES;
CREATE TABLE t1(c1 INT);
LOCK TABLES t1 WRITE;
SELECT file_name, initial_size!=0 FROM information_schema.files  WHERE tablespace_name='test/t1';
UNLOCK TABLES;
DROP TABLE t1;
CREATE TABLE t1(c1 int);
SET TIMESTAMP=UNIX_TIMESTAMP('2017-11-20 10:44:01');
SET SESSION TIME_ZONE='-10:00';
SHOW VARIABLES LIKE 'collation_connection';
SELECT table_rows FROM information_schema.tables  WHERE table_name='t1';
SELECT table_rows FROM information_schema.tables  WHERE table_name='t1' AND table_rows>=0;
SET SESSION collation_connection='utf32_general_ci';
SELECT table_rows FROM information_schema.tables WHERE table_name='t1';
DROP TABLE t1;
SET SESSION TIMESTAMP=default;
SET SESSION collation_connection=default;
CREATE TABLE t1(c1 INT,c2 CHAR (1)COMMENT'')COMMENT='abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcde';
SET big_tables=1;
SET character_set_connection=ucs2;
SHOW TABLE STATUS;
SET big_tables=default;
SET character_set_connection=default;
DROP TABLE t1;
SELECT COUNT(*) = 0  FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS rcons  LEFT OUTER JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS tcons  ON tcons.constraint_catalog = rcons.constraint_catalog AND  tcons.constraint_schema = rcons.constraint_schema AND  tcons.constraint_name = rcons.unique_constraint_name;
connect (conn1,localhost,root,,*NO-ONE*);
connection conn1;
SELECT COUNT(*) > 0 FROM INFORMATION_SCHEMA.KEYWORDS;
connection default;
disconnect conn1;
CREATE TABLE t1 (col1 BLOB(33), INDEX (col1(8)));
SHOW INDEXES FROM t1;
SELECT SUB_PART FROM INFORMATION_SCHEMA.STATISTICS WHERE TABLE_NAME = "t1";
DROP TABLE t1;
CREATE TABLE t1 (col1 TEXT(33) CHARACTER SET utf8mb4, INDEX (col1(2)));
SHOW INDEXES FROM t1;
SELECT SUB_PART FROM INFORMATION_SCHEMA.STATISTICS WHERE TABLE_NAME = "t1";
DROP TABLE t1;
CREATE TABLE t1 (col1 BLOB(33), INDEX (col1(33)));
SHOW INDEXES FROM t1;
SELECT SUB_PART FROM INFORMATION_SCHEMA.STATISTICS WHERE TABLE_NAME = "t1";
DROP TABLE t1;
CREATE TABLE t1 (col1 TEXT(2) CHARACTER SET utf8mb4, INDEX (col1(2)));
SHOW INDEXES FROM t1;
SELECT SUB_PART FROM INFORMATION_SCHEMA.STATISTICS WHERE TABLE_NAME = "t1";
DROP TABLE t1;
CREATE DATABASE db1;
CREATE TABLE db1.t1 ( id int(11) DEFAULT NULL) ENGINE = INNODB COMMENT ='123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_1234__100_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_1234__200_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_1234__300_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_1234__400_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_1234__500_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_1234__600_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_1234__700_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_1234__800_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_1234__900_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_1234_1000_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_1234_1100_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_1234_1200_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_1234_1300_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_1234_1400_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_1234_1500_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_1234_1600_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_1234_1700_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_1234_1800_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_1234_1900_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_1234_2000_123456789_123456789_123456789_123456789_123_2048';
SELECT TABLE_COMMENT FROM INFORMATION_SCHEMA.TABLES  WHERE TABLE_NAME = 't1' ORDER BY TABLE_SCHEMA;
DROP DATABASE db1;
CREATE TABLE t1 (f1 TIMESTAMP);
CREATE VIEW v1 AS SELECT 1 FROM t1 WHERE f1;
ALTER TABLE t1 CHANGE COLUMN f1 f0 BINARY;
SELECT TABLE_NAME, LENGTH(VIEW_DEFINITION) > 0  FROM INFORMATION_SCHEMA.VIEWS  WHERE TABLE_SCHEMA='test';
SET SESSION max_error_count=0;
SELECT TABLE_NAME, LENGTH(VIEW_DEFINITION) > 0  FROM INFORMATION_SCHEMA.VIEWS  WHERE TABLE_SCHEMA='test';
SHOW WARNINGS;
SET SESSION max_error_count=default;
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (f1 TIMESTAMP);
CREATE VIEW v1 AS SELECT 1 FROM t1 WHERE f1;
CREATE VIEW v2 AS SELECT 1 FROM t1 WHERE f1;
ALTER TABLE t1 CHANGE COLUMN f1 f0 BINARY;
SELECT TABLE_NAME, TABLE_COMMENT  FROM INFORMATION_SCHEMA.TABLES  WHERE TABLE_SCHEMA='test';
SET SESSION max_error_count=0;
SELECT TABLE_NAME, TABLE_COMMENT  FROM INFORMATION_SCHEMA.TABLES  WHERE TABLE_SCHEMA='test';
SHOW WARNINGS;
SET SESSION max_error_count=default;
DROP VIEW v1, v2;
DROP TABLE t1;
CREATE TABLE t1 (f1 DATE NOT SECONDARY);
SELECT TABLE_NAME, COLUMN_NAME, EXTRA FROM INFORMATION_SCHEMA.COLUMNS  WHERE TABLE_NAME='t1';
DROP TABLE t1;
CREATE TABLE t1 (f1 DATE);
SELECT TABLE_NAME, COLUMN_NAME, EXTRA FROM INFORMATION_SCHEMA.COLUMNS  WHERE TABLE_NAME='t1';
ALTER TABLE  t1 MODIFY f1 DATE NOT SECONDARY;
SELECT TABLE_NAME, COLUMN_NAME, EXTRA FROM INFORMATION_SCHEMA.COLUMNS  WHERE TABLE_NAME='t1';
DROP TABLE t1;
CREATE TABLE t1 (f1 INT) SECONDARY_ENGINE=myisam;
SELECT TABLE_NAME, CREATE_OPTIONS  FROM INFORMATION_SCHEMA.TABLES  WHERE TABLE_NAME = 't1';
DROP TABLE t1;
CREATE TABLE t1 (f1 INT);
SELECT TABLE_NAME, CREATE_OPTIONS FROM INFORMATION_SCHEMA.TABLES  WHERE TABLE_NAME = 't1';
ALTER TABLE t1 SECONDARY_ENGINE=myisam;
SELECT TABLE_NAME, CREATE_OPTIONS FROM INFORMATION_SCHEMA.TABLES  WHERE TABLE_NAME = 't1';
DROP TABLE t1;
  SELECT TABLE_SCHEMA, TABLE_NAME, TABLE_TYPE, TABLE_COMMENT  FROM INFORMATION_SCHEMA.TABLES  WHERE TABLE_SCHEMA = 'sys' AND TABLE_NAME = 'sys_config';
SET OPTIMIZER_SWITCH='DERIVED_MERGE=ON';
SET OPTIMIZER_SWITCH='DERIVED_MERGE=OFF';
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES(1);
CREATE VIEW v1 AS SELECT * FROM t1;
ANALYZE TABLE t1;
SELECT * FROM INFORMATION_SCHEMA.TABLESWHERE TABLE_SCHEMA = 'test' AND TABLE_NAME = 'v1';
SET OPTIMIZER_SWITCH=default;
DROP VIEW v1;
DROP TABLE t1;
SET @@SESSION.optimizer_switch="derived_merge=off";
LOCK TABLE mysql.user READ;
SELECT * FROM information_schema.ST_GEOMETRY_COLUMNS;
UNLOCK TABLES;
CREATE TABLE t1 (f1 INT);
FLUSH TABLES t1 FOR EXPORT;
SELECT * FROM INFORMATION_SCHEMA.APPLICABLE_ROLES;
UNLOCK TABLES;
DROP TABLE t1;
