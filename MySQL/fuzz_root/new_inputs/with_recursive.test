set cte_max_recursion_depth=50000;
select @@cte_max_recursion_depth;
flush status;
with recursive qn as (select * from qn2),               qn2 as (select * from qn)select * from qn;
with recursive qn as  (select 1 from qn)select * from qn;
with recursive qn as  (select 1 from qn union all   select 1 from dual)select * from qn;
with recursive qn as  (select 1 union all select 1 from qn union all select 1)select * from qn;
with recursive qn as  (select 1 from qn union all select 1 from qn)select * from qn;
with recursive qn as  (select 1 from dual union all   select 1 from dual)select * from qn;
with recursive qn as  (select 1 from dual union   select 1 from qn)select * from qn;
eval EXPLAIN FORMAT=tree $query;
eval $query;
create table t1(b int);
insert into t1 values(10),(20),(10);
with recursive qn as  (select max(b) as a from t1 union   select a from qn)select * from qn;
with recursive qn as  (select b as a from t1 union   select max(a) from qn)select * from qn;
with recursive qn as  (select rank() over (order by b) as a from t1 union   select a from qn)select * from qn;
with recursive qn as  (select b as a from t1 union   select rank() over (order by a) from qn)select * from qn;
drop table t1;
with recursive qn as  (select 1 as a from dual union all   select max(a) from qn)select * from qn;
with recursive qn as  (select 1 as a from dual group by a union all   select a+1 from qn where a<3)select * from qn;
with recursive qn as  (select 1 as a from dual union all   select a from qn group by a)select * from qn;
with recursive qn as (select 1 from dual union allselect 1 from dual where 1 not in(select * from qn))select * from qn;
with recursive qn as (select 1 from dual union allselect 1 from qnorder by (select * from qn))select * from qn;
with recursive qn as (select 1 from dual union allselect * from (select * from qn) as dt)select * from qn;
with recursive qn as (select 1 as a from dual union allselect 1 from qnorder by a)select * from qn;
with recursive qn as (select 1 as a from dual union all(select 1 from qn order by a))select * from qn;
with recursive qn as ((select 1 as a from dual order by a) union allselect a+1 from qn where a<3)select * from qn;
with recursive qn as (select 1 as a from dual union all(select 1 from qn limit 10))select * from qn;
WITH RECURSIVE qn AS(select 1 union all select distinct 3 from qn)select * from qn;
with recursive qn as (select 1 from dual union all                      select 1 from dual                        where 1 not in(select * from qn))select * from qn;
with recursive qn as (select 123 as a union all select 1+a from qn where a<130) select * from qn;
with recursive qn as (select 1 as n, 2 as un union all select 1+n, un*5-6 from qn where n<10) select * from qn;
with recursive qn as (select 1 as n, 1 as un, 1 as unp1 union all select 1+n, unp1, un+unp1 from qn where n<10) select * from qn;
create table t(c char(3), vc varchar(3), b binary(3), vb varbinary(3));
create table uselect cast(c as char(4)), cast(vc as char(4)),       cast(b as binary(4)), cast(vb as binary(4)),       "abc" as literal_c, cast("abc" as char(4)),       _binary "abc" as literal_b, cast(_binary "abc" as binary(4))from t;
show create table u;
drop table t,u;
with recursive qn as (select 1 as n, cast('x' as char(100)) as un union all select 1+n, concat(un,'x') from qn where n<10) select * from qn;
with recursive qn as (select cast("x" as char(10)) as a from dualunion all select concat("x",a) from qn where length(a)<10) select *from qn;
with recursive qn as (select "x" as a from dualunion all select concat("x",a) from qn where length(a)<10) select *from qn;
create temporary table tt select "x" as a from dual;
create temporary table tt1 select "x" as a from dual;
insert into tt1 select concat("x",a) from tt where length(a)<10;
drop temporary table tt,tt1;
eval $query;
with recursive qn as (select 1 as a from dualunion all select a*2000 from qn where a<10000000000000000000) select * from qn;
with recursive qn as (select cast(1 as decimal(30,0)) as a from dualunion all select a*2000 from qn where a<10000000000000000000) select * from qn;
with recursive qn as (select 123 as a union allselect null from qn where a is not null) select * from qn;
with recursive qn as (select 1 as a,1union allselect a+1,ST_PointFromText('POINT(10 10)') from qn where a<2)select * from qn;
with recursive qn as (select 1 as a,ST_PointFromText('POINT(10 10)')union allselect a+1,1 from qn where a<2)select * from qn;
WITH RECURSIVE qn ASselect 1union allselect 3, 0 from qnselect * from qn;
with recursive q (b) as (select 1, 1 union all select 1, 1 from q)select b from q;
with recursive qn as (select 123 as a union allselect 1+qn.a from qn, qn as qn1 where qn1.a<130)select * from qn;
flush status;
with recursive qn as (select 123 as a union allselect 1+a from qn where a<125)select * from qn;
show status like "handler_write";
flush status;
with recursive qn as (select 123 as a union allselect 1+a from qn where a<125)select * from qn, qn as qn1;
show status like "handler_write";
show status like 'Created_tmp%table%';
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as (select * from inner_ limit 10)select * from outer_, outer_ as outer1;
show status like "handler_write";
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as(select inner_.a, inner1.a as a1from inner_, inner_ as inner1 limit 10)select * from outer_;
show status like "handler_write";
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as(select a from inner_ union allselect a*2 from outer_ where a<1000)select a from outer_;
show status like "handler_write";
create table t1(a int);
insert into t1 values(1),(2);
WITH RECURSIVE qn ASselect 1 from t1union allselect 1 from t1 straight_join qnselect * from qn;
WITH RECURSIVE qn ASselect 1 from t1union allselect 1 from t1 left join qn on 1select * from qn;
WITH RECURSIVE qn ASselect a from t1 where 0union allselect a+1 from qnselect * from qn;
WITH RECURSIVE qn ASselect a from t1 where a>10union allselect a+1 from qnselect * from qn;
insert into t1 values(1),(2);
set @c=0, @d=0;
WITH RECURSIVE qn ASselect 1,0 as col from t1union distinctselect 1,0 from t1union allselect 3, 0*(@c:=@c+1) from qn where @c<1union allselect 3, 0*(@d:=@d+1) from qn where @d<1select * from qn;
insert into t1 values(1),(2);
set @c=0, @d=0;
WITH RECURSIVE qn ASselect 1,0 as col from t1union distinctselect 3, 0*(@c:=@c+1) from qn where @c<1union allselect 3, 0*(@d:=@d+1) from qn where @d<1select * from qn;
create table t2with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t2;
drop table t2;
delete from t1;
insert into t1with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t1;
delete from t1;
insert into t1 values(1),(2);
insert into t1with recursive qn as (select 123 as a union all select 1+qn.a from qn, t1 where qn.a<125)select * from qn;
select * from t1;
drop table t1;
create temporary table t1(a int);
insert into t1with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t1;
drop table t1;
create view v1 aswith recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from v1;
drop view v1;
with recursive qn (n) as ( select 1 where 0 union all select n+1 from qn where 0) select * from qn;
eval explain $query;
eval $query;
with recursive qn (n) as ( select 1 where 1 union all select n+1 from qn where 0) select * from qn;
eval explain $query;
eval $query;
with recursive q (b) as (select 1 union all select 1+b from q where b<10) select (select q1.b from q as q2 where q2.b=3) from q as q1 where q1.b=3;
eval explain $query;
eval $query;
create table t1(a int);
insert into t1with recursive qn (n) as ( select 1 union all select n+1 from qn where n<10) select * from qn;
select * from t1;
with recursive qn (n) as ( select 5 union all select n+2 from qn where n<10) delete t1 from t1 where a in (select * from qn);
select * from t1;
with recursive qn (n) as ( select 4 union all select n+2 from qn where n<10) delete from t1 where a in (select * from qn);
select * from t1;
with recursive qn (n) as ( select 2 union all select n+2 from qn where n<10) update t1,qn set t1.a=qn.n where t1.a=1+qn.n;
select * from t1;
drop table t1;
CREATE TABLE employees (ID INT PRIMARY KEY,NAME VARCHAR(100),MANAGER_ID INT,INDEX (MANAGER_ID),FOREIGN KEY (MANAGER_ID) REFERENCES employees(ID));
INSERT INTO employees VALUES(333, "Yasmina", NULL),(198, "John", 333),(692, "Tarek", 333),(29, "Pedro", 198),(4610, "Sarah", 29),(72, "Pierre", 29),(123, "Adil", 692);
ANALYZE TABLE employees;
WITH RECURSIVE employees_extended(ID, NAME, PATH)AS  SELECT ID, NAME, CAST(ID AS CHAR(200))  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY PATH;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT 0 AS SEQ, ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT M.SEQ+1, S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY SEQ, NAME;
WITH RECURSIVE employees_extendedAS  SELECT (@s:=0) AS SEQ, ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT (@s:=@s+1), S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY SEQ;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extendedWHERE FIND_IN_SET((SELECT ID FROM employees WHERE NAME='John'),                  PATH);
WITH RECURSIVE employees_extended(ID, NAME, PATH)AS  SELECT ID, NAME, CAST(ID AS CHAR(200))  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_ID),JOHN_ID AS (SELECT ID FROM employees WHERE NAME='John')SELECT e.* FROM employees_extended e, JOHN_IDWHERE FIND_IN_SET(JOHN_ID.ID,                  PATH)      AND e.ID<>JOHN_ID.ID;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='Pierre'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre' OR NAME='Sarah'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre' OR NAME='Sarah'UNION  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
UPDATE employees SET MANAGER_ID=4610 WHERE NAME="John";
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extended(ID, NAME, PATH, IS_CYCLE)AS  SELECT ID, NAME, CAST(ID AS CHAR(200)), 0  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID), FIND_IN_SET(S.ID, M.PATH)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_ID  WHERE M.IS_CYCLE=0SELECT * FROM employees_extended;
DROP TABLE employees;
create table t1 (id int, name char(10), leftpar int, rightpar int);
insert into t1 values(1, "A", 2, 3),  (2, "LA", 4, 5),     (4, "LLA", 6, 7),        (6, "LLLA", null, null),        (7, "RLLA", null, null),     (5, "RLA", 8, 9),        (8, "LRLA", null, null),        (9, "RRLA", null, null),  (3, "RA", 10, 11),     (10, "LRA", 12, 13),     (11, "RRA", 14, 15),        (15, "RRRA", null, null),(16, "B", 17, 18),  (17, "LB", null, null),  (18, "RB", null, null)create table t2 select * from t1 order by rand();
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.leftparunion allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.rightparselect * from tree_of_a;
eval explain $query order by path;
eval $query order by path;
set @optimizer_switch_saved= @@optimizer_switch;
set optimizer_switch='block_nested_loop=off';
eval explain $query order by path;
eval $query order by path;
eval EXPLAIN FORMAT=tree $query order by path;
eval $query;
set @@optimizer_switch=@optimizer_switch_saved;
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a on(t2.id=tree_of_a.leftpar or t2.id=tree_of_a.rightpar)select * from tree_of_aorder by path;
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.leftparunion allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.rightparselect * from tree_of_a where id=2;
eval explain $query;
eval $query;
drop table t1,t2;
with recursive cte as  select 1 as n union all  select n+1 from cte where n<10000select /*+ no_bnl(cte3) */sum(cte1.n*cte2.n*cte3.n)=2490508525950000from cte cte1, cte cte2, cte cte3where cte1.n=cte2.n+10 and cte2.n+20=cte3.n;
eval explain $query;
eval $query;
create table nodes(id int);
create table arcs(from_id int, to_id int);
insert into nodes values(1),(2),(3),(4),(5),(6),(7),(8);
insert into arcs values(1,3), (3,6), (1,4), (4,6), (6,2), (2,1);
with recursive cte as  select id, 0 as depth from nodes where id=1  union all  select to_id, depth+1 from arcs, cte  where from_id=cte.id and depth<8select count(*), max(depth) from cte;
with recursive cte as  select id, cast(id as char(200)) as path, 0 as is_cycle  from nodes where id=1  union all  select to_id, concat(cte.path, ",", to_id), find_in_set(to_id, path)  from arcs, cte  where from_id=cte.id and is_cycle=0select * from cte;
with recursive cte as  select id from nodes where id=1  union  select to_id from arcs, cte where from_id=cte.idselect * from cte;
drop table nodes, arcs;
flush status;
with recursive cte as (  select 1 as n,  repeat('a',500) as f, '' as g,  '' as h, '' as i  union  select n+1,  '','','',''  from cte where n<100)select sum(n) from cte;
show status like 'Created_tmp_disk_tables';
with recursive cte as (  select 1 as n,  repeat('a',500) as f, repeat('a',500) as g,  repeat('a',500) as h, repeat('a',500) as i,  repeat('a',500) as j, repeat('a',500) as k,  repeat('a',500) as l, repeat('a',500) as m  union  select n+1,  '','','','','','','',''  from cte where n<100)select sum(n) from cte;
flush status;
create table t1(a int);
insert into t1 values (), (), (), (), (), (), (), (), (), (), (), (),(), (), ();
analyze table t1;
explain with recursive qn as(select 1 as a from t1 union all select a+1 from qn where qn.a<100)select * from qn;
explain with recursive qn as(select 1 as a from t1 union distinct select a+1 from qn where qn.a<100)select * from qn;
drop table t1;
show status like 'Created_tmp_disk_tables';
set cte_max_recursion_depth=50000;
select @@cte_max_recursion_depth;
flush status;
with recursive qn as (select * from qn2),               qn2 as (select * from qn)select * from qn;
with recursive qn as  (select 1 from qn)select * from qn;
with recursive qn as  (select 1 from qn union all   select 1 from dual)select * from qn;
with recursive qn as  (select 1 union all select 1 from qn union all select 1)select * from qn;
with recursive qn as  (select 1 from qn union all select 1 from qn)select * from qn;
with recursive qn as  (select 1 from dual union all   select 1 from dual)select * from qn;
with recursive qn as  (select 1 from dual union   select 1 from qn)select * from qn;
eval EXPLAIN FORMAT=tree $query;
eval $query;
create table t1(b int);
insert into t1 values(10),(20),(10);
with recursive qn as  (select max(b) as a from t1 union   select a from qn)select * from qn;
with recursive qn as  (select b as a from t1 union   select max(a) from qn)select * from qn;
with recursive qn as  (select rank() over (order by b) as a from t1 union   select a from qn)select * from qn;
with recursive qn as  (select b as a from t1 union   select rank() over (order by a) from qn)select * from qn;
drop table t1;
with recursive qn as  (select 1 as a from dual union all   select max(a) from qn)select * from qn;
with recursive qn as  (select 1 as a from dual group by a union all   select a+1 from qn where a<3)select * from qn;
with recursive qn as  (select 1 as a from dual union all   select a from qn group by a)select * from qn;
with recursive qn as (select 1 from dual union allselect 1 from dual where 1 not in(select * from qn))select * from qn;
with recursive qn as (select 1 from dual union allselect 1 from qnorder by (select * from qn))select * from qn;
with recursive qn as (select 1 from dual union allselect * from (select * from qn) as dt)select * from qn;
with recursive qn as (select 1 as a from dual union allselect 1 from qnorder by a)select * from qn;
with recursive qn as (select 1 as a from dual union all(select 1 from qn order by a))select * from qn;
with recursive qn as ((select 1 as a from dual order by a) union allselect a+1 from qn where a<3)select * from qn;
with recursive qn as (select 1 as a from dual union all(select 1 from qn limit 10))select * from qn;
WITH RECURSIVE qn AS(select 1 union all select distinct 3 from qn)select * from qn;
with recursive qn as (select 1 from dual union all                      select 1 from dual                        where 1 not in(select * from qn))select * from qn;
with recursive qn as (select 123 as a union all select 1+a from qn where a<130) select * from qn;
with recursive qn as (select 1 as n, 2 as un union all select 1+n, un*5-6 from qn where n<10) select * from qn;
with recursive qn as (select 1 as n, 1 as un, 1 as unp1 union all select 1+n, unp1, un+unp1 from qn where n<10) select * from qn;
create table t(c char(3), vc varchar(3), b binary(3), vb varbinary(3));
create table uselect cast(c as char(4)), cast(vc as char(4)),       cast(b as binary(4)), cast(vb as binary(4)),       "abc" as literal_c, cast("abc" as char(4)),       _binary "abc" as literal_b, cast(_binary "abc" as binary(4))from t;
show create table u;
drop table t,u;
with recursive qn as (select 1 as n, cast('x' as char(100)) as un union all select 1+n, concat(un,'x') from qn where n<10) select * from qn;
with recursive qn as (select cast("x" as char(10)) as a from dualunion all select concat("x",a) from qn where length(a)<10) select *from qn;
with recursive qn as (select "x" as a from dualunion all select concat("x",a) from qn where length(a)<10) select *from qn;
create temporary table tt select "x" as a from dual;
create temporary table tt1 select "x" as a from dual;
insert into tt1 select concat("x",a) from tt where length(a)<10;
drop temporary table tt,tt1;
eval $query;
with recursive qn as (select 1 as a from dualunion all select a*2000 from qn where a<10000000000000000000) select * from qn;
with recursive qn as (select cast(1 as decimal(30,0)) as a from dualunion all select a*2000 from qn where a<10000000000000000000) select * from qn;
with recursive qn as (select 123 as a union allselect null from qn where a is not null) select * from qn;
with recursive qn as (select 1 as a,1union allselect a+1,ST_PointFromText('POINT(10 10)') from qn where a<2)select * from qn;
with recursive qn as (select 1 as a,ST_PointFromText('POINT(10 10)')union allselect a+1,1 from qn where a<2)select * from qn;
WITH RECURSIVE qn ASselect 1union allselect 3, 0 from qnselect * from qn;
with recursive q (b) as (select 1, 1 union all select 1, 1 from q)select b from q;
with recursive qn as (select 123 as a union allselect 1+qn.a from qn, qn as qn1 where qn1.a<130)select * from qn;
flush status;
with recursive qn as (select 123 as a union allselect 1+a from qn where a<125)select * from qn;
show status like "handler_write";
flush status;
with recursive qn as (select 123 as a union allselect 1+a from qn where a<125)select * from qn, qn as qn1;
show status like "handler_write";
show status like 'Created_tmp%table%';
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as (select * from inner_ limit 10)select * from outer_, outer_ as outer1;
show status like "handler_write";
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as(select inner_.a, inner1.a as a1from inner_, inner_ as inner1 limit 10)select * from outer_;
show status like "handler_write";
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as(select a from inner_ union allselect a*2 from outer_ where a<1000)select a from outer_;
show status like "handler_write";
create table t1(a int);
insert into t1 values(1),(2);
WITH RECURSIVE qn ASselect 1 from t1union allselect 1 from t1 straight_join qnselect * from qn;
WITH RECURSIVE qn ASselect 1 from t1union allselect 1 from t1 left join qn on 1select * from qn;
WITH RECURSIVE qn ASselect a from t1 where 0union allselect a+1 from qnselect * from qn;
WITH RECURSIVE qn ASselect a from t1 where a>10union allselect a+1 from qnselect * from qn;
insert into t1 values(1),(2);
set @c=0, @d=0;
WITH RECURSIVE qn ASselect 1,0 as col from t1union distinctselect 1,0 from t1union allselect 3, 0*(@c:=@c+1) from qn where @c<1union allselect 3, 0*(@d:=@d+1) from qn where @d<1select * from qn;
insert into t1 values(1),(2);
set @c=0, @d=0;
WITH RECURSIVE qn ASselect 1,0 as col from t1union distinctselect 3, 0*(@c:=@c+1) from qn where @c<1union allselect 3, 0*(@d:=@d+1) from qn where @d<1select * from qn;
create table t2with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t2;
drop table t2;
delete from t1;
insert into t1with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t1;
delete from t1;
insert into t1 values(1),(2);
insert into t1with recursive qn as (select 123 as a union all select 1+qn.a from qn, t1 where qn.a<125)select * from qn;
select * from t1;
drop table t1;
create temporary table t1(a int);
insert into t1with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t1;
drop table t1;
create view v1 aswith recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from v1;
drop view v1;
with recursive qn (n) as ( select 1 where 0 union all select n+1 from qn where 0) select * from qn;
eval explain $query;
eval $query;
with recursive qn (n) as ( select 1 where 1 union all select n+1 from qn where 0) select * from qn;
eval explain $query;
eval $query;
with recursive q (b) as (select 1 union all select 1+b from q where b<10) select (select q1.b from q as q2 where q2.b=3) from q as q1 where q1.b=3;
eval explain $query;
eval $query;
create table t1(a int);
insert into t1with recursive qn (n) as ( select 1 union all select n+1 from qn where n<10) select * from qn;
select * from t1;
with recursive qn (n) as ( select 5 union all select n+2 from qn where n<10) delete t1 from t1 where a in (select * from qn);
select * from t1;
with recursive qn (n) as ( select 4 union all select n+2 from qn where n<10) delete from t1 where a in (select * from qn);
select * from t1;
with recursive qn (n) as ( select 2 union all select n+2 from qn where n<10) update t1,qn set t1.a=qn.n where t1.a=1+qn.n;
select * from t1;
drop table t1;
CREATE TABLE employees (ID INT PRIMARY KEY,NAME VARCHAR(100),MANAGER_ID INT,INDEX (MANAGER_ID),FOREIGN KEY (MANAGER_ID) REFERENCES employees(ID));
INSERT INTO employees VALUES(333, "Yasmina", NULL),(198, "John", 333),(692, "Tarek", 333),(29, "Pedro", 198),(4610, "Sarah", 29),(72, "Pierre", 29),(123, "Adil", 692);
ANALYZE TABLE employees;
WITH RECURSIVE employees_extended(ID, NAME, PATH)AS  SELECT ID, NAME, CAST(ID AS CHAR(200))  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY PATH;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT 0 AS SEQ, ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT M.SEQ+1, S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY SEQ, NAME;
WITH RECURSIVE employees_extendedAS  SELECT (@s:=0) AS SEQ, ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT (@s:=@s+1), S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY SEQ;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extendedWHERE FIND_IN_SET((SELECT ID FROM employees WHERE NAME='John'),                  PATH);
WITH RECURSIVE employees_extended(ID, NAME, PATH)AS  SELECT ID, NAME, CAST(ID AS CHAR(200))  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_ID),JOHN_ID AS (SELECT ID FROM employees WHERE NAME='John')SELECT e.* FROM employees_extended e, JOHN_IDWHERE FIND_IN_SET(JOHN_ID.ID,                  PATH)      AND e.ID<>JOHN_ID.ID;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='Pierre'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre' OR NAME='Sarah'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre' OR NAME='Sarah'UNION  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
UPDATE employees SET MANAGER_ID=4610 WHERE NAME="John";
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extended(ID, NAME, PATH, IS_CYCLE)AS  SELECT ID, NAME, CAST(ID AS CHAR(200)), 0  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID), FIND_IN_SET(S.ID, M.PATH)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_ID  WHERE M.IS_CYCLE=0SELECT * FROM employees_extended;
DROP TABLE employees;
create table t1 (id int, name char(10), leftpar int, rightpar int);
insert into t1 values(1, "A", 2, 3),  (2, "LA", 4, 5),     (4, "LLA", 6, 7),        (6, "LLLA", null, null),        (7, "RLLA", null, null),     (5, "RLA", 8, 9),        (8, "LRLA", null, null),        (9, "RRLA", null, null),  (3, "RA", 10, 11),     (10, "LRA", 12, 13),     (11, "RRA", 14, 15),        (15, "RRRA", null, null),(16, "B", 17, 18),  (17, "LB", null, null),  (18, "RB", null, null)create table t2 select * from t1 order by rand();
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.leftparunion allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.rightparselect * from tree_of_a;
eval explain $query order by path;
eval $query order by path;
set @optimizer_switch_saved= @@optimizer_switch;
set optimizer_switch='block_nested_loop=off';
eval explain $query order by path;
eval $query order by path;
eval EXPLAIN FORMAT=tree $query order by path;
eval $query;
set @@optimizer_switch=@optimizer_switch_saved;
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a on(t2.id=tree_of_a.leftpar or t2.id=tree_of_a.rightpar)select * from tree_of_aorder by path;
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.leftparunion allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.rightparselect * from tree_of_a where id=2;
eval explain $query;
eval $query;
drop table t1,t2;
with recursive cte as  select 1 as n union all  select n+1 from cte where n<10000select /*+ no_bnl(cte3) */sum(cte1.n*cte2.n*cte3.n)=2490508525950000from cte cte1, cte cte2, cte cte3where cte1.n=cte2.n+10 and cte2.n+20=cte3.n;
eval explain $query;
eval $query;
create table nodes(id int);
create table arcs(from_id int, to_id int);
insert into nodes values(1),(2),(3),(4),(5),(6),(7),(8);
insert into arcs values(1,3), (3,6), (1,4), (4,6), (6,2), (2,1);
with recursive cte as  select id, 0 as depth from nodes where id=1  union all  select to_id, depth+1 from arcs, cte  where from_id=cte.id and depth<8select count(*), max(depth) from cte;
with recursive cte as  select id, cast(id as char(200)) as path, 0 as is_cycle  from nodes where id=1  union all  select to_id, concat(cte.path, ",", to_id), find_in_set(to_id, path)  from arcs, cte  where from_id=cte.id and is_cycle=0select * from cte;
with recursive cte as  select id from nodes where id=1  union  select to_id from arcs, cte where from_id=cte.idselect * from cte;
drop table nodes, arcs;
flush status;
with recursive cte as (  select 1 as n,  repeat('a',500) as f, '' as g,  '' as h, '' as i  union  select n+1,  '','','',''  from cte where n<100)select sum(n) from cte;
show status like 'Created_tmp_disk_tables';
with recursive cte as (  select 1 as n,  repeat('a',500) as f, repeat('a',500) as g,  repeat('a',500) as h, repeat('a',500) as i,  repeat('a',500) as j, repeat('a',500) as k,  repeat('a',500) as l, repeat('a',500) as m  union  select n+1,  '','','','','','','',''  from cte where n<100)select sum(n) from cte;
flush status;
create table t1(a int);
insert into t1 values (), (), (), (), (), (), (), (), (), (), (), (),(), (), ();
analyze table t1;
explain with recursive qn as(select 1 as a from t1 union all select a+1 from qn where qn.a<100)select * from qn;
explain with recursive qn as(select 1 as a from t1 union distinct select a+1 from qn where qn.a<100)select * from qn;
drop table t1;
show status like 'Created_tmp_disk_tables';
set big_tables=0;
set big_tables=1;
set cte_max_recursion_depth=50000;
select @@cte_max_recursion_depth;
flush status;
with recursive qn as (select * from qn2),               qn2 as (select * from qn)select * from qn;
with recursive qn as  (select 1 from qn)select * from qn;
with recursive qn as  (select 1 from qn union all   select 1 from dual)select * from qn;
with recursive qn as  (select 1 union all select 1 from qn union all select 1)select * from qn;
with recursive qn as  (select 1 from qn union all select 1 from qn)select * from qn;
with recursive qn as  (select 1 from dual union all   select 1 from dual)select * from qn;
with recursive qn as  (select 1 from dual union   select 1 from qn)select * from qn;
eval EXPLAIN FORMAT=tree $query;
eval $query;
create table t1(b int);
insert into t1 values(10),(20),(10);
with recursive qn as  (select max(b) as a from t1 union   select a from qn)select * from qn;
with recursive qn as  (select b as a from t1 union   select max(a) from qn)select * from qn;
with recursive qn as  (select rank() over (order by b) as a from t1 union   select a from qn)select * from qn;
with recursive qn as  (select b as a from t1 union   select rank() over (order by a) from qn)select * from qn;
drop table t1;
with recursive qn as  (select 1 as a from dual union all   select max(a) from qn)select * from qn;
with recursive qn as  (select 1 as a from dual group by a union all   select a+1 from qn where a<3)select * from qn;
with recursive qn as  (select 1 as a from dual union all   select a from qn group by a)select * from qn;
with recursive qn as (select 1 from dual union allselect 1 from dual where 1 not in(select * from qn))select * from qn;
with recursive qn as (select 1 from dual union allselect 1 from qnorder by (select * from qn))select * from qn;
with recursive qn as (select 1 from dual union allselect * from (select * from qn) as dt)select * from qn;
with recursive qn as (select 1 as a from dual union allselect 1 from qnorder by a)select * from qn;
with recursive qn as (select 1 as a from dual union all(select 1 from qn order by a))select * from qn;
with recursive qn as ((select 1 as a from dual order by a) union allselect a+1 from qn where a<3)select * from qn;
with recursive qn as (select 1 as a from dual union all(select 1 from qn limit 10))select * from qn;
WITH RECURSIVE qn AS(select 1 union all select distinct 3 from qn)select * from qn;
with recursive qn as (select 1 from dual union all                      select 1 from dual                        where 1 not in(select * from qn))select * from qn;
with recursive qn as (select 123 as a union all select 1+a from qn where a<130) select * from qn;
with recursive qn as (select 1 as n, 2 as un union all select 1+n, un*5-6 from qn where n<10) select * from qn;
with recursive qn as (select 1 as n, 1 as un, 1 as unp1 union all select 1+n, unp1, un+unp1 from qn where n<10) select * from qn;
create table t(c char(3), vc varchar(3), b binary(3), vb varbinary(3));
create table uselect cast(c as char(4)), cast(vc as char(4)),       cast(b as binary(4)), cast(vb as binary(4)),       "abc" as literal_c, cast("abc" as char(4)),       _binary "abc" as literal_b, cast(_binary "abc" as binary(4))from t;
show create table u;
drop table t,u;
with recursive qn as (select 1 as n, cast('x' as char(100)) as un union all select 1+n, concat(un,'x') from qn where n<10) select * from qn;
with recursive qn as (select cast("x" as char(10)) as a from dualunion all select concat("x",a) from qn where length(a)<10) select *from qn;
with recursive qn as (select "x" as a from dualunion all select concat("x",a) from qn where length(a)<10) select *from qn;
create temporary table tt select "x" as a from dual;
create temporary table tt1 select "x" as a from dual;
insert into tt1 select concat("x",a) from tt where length(a)<10;
drop temporary table tt,tt1;
eval $query;
with recursive qn as (select 1 as a from dualunion all select a*2000 from qn where a<10000000000000000000) select * from qn;
with recursive qn as (select cast(1 as decimal(30,0)) as a from dualunion all select a*2000 from qn where a<10000000000000000000) select * from qn;
with recursive qn as (select 123 as a union allselect null from qn where a is not null) select * from qn;
with recursive qn as (select 1 as a,1union allselect a+1,ST_PointFromText('POINT(10 10)') from qn where a<2)select * from qn;
with recursive qn as (select 1 as a,ST_PointFromText('POINT(10 10)')union allselect a+1,1 from qn where a<2)select * from qn;
WITH RECURSIVE qn ASselect 1union allselect 3, 0 from qnselect * from qn;
with recursive q (b) as (select 1, 1 union all select 1, 1 from q)select b from q;
with recursive qn as (select 123 as a union allselect 1+qn.a from qn, qn as qn1 where qn1.a<130)select * from qn;
flush status;
with recursive qn as (select 123 as a union allselect 1+a from qn where a<125)select * from qn;
show status like "handler_write";
flush status;
with recursive qn as (select 123 as a union allselect 1+a from qn where a<125)select * from qn, qn as qn1;
show status like "handler_write";
show status like 'Created_tmp%table%';
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as (select * from inner_ limit 10)select * from outer_, outer_ as outer1;
show status like "handler_write";
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as(select inner_.a, inner1.a as a1from inner_, inner_ as inner1 limit 10)select * from outer_;
show status like "handler_write";
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as(select a from inner_ union allselect a*2 from outer_ where a<1000)select a from outer_;
show status like "handler_write";
create table t1(a int);
insert into t1 values(1),(2);
WITH RECURSIVE qn ASselect 1 from t1union allselect 1 from t1 straight_join qnselect * from qn;
WITH RECURSIVE qn ASselect 1 from t1union allselect 1 from t1 left join qn on 1select * from qn;
WITH RECURSIVE qn ASselect a from t1 where 0union allselect a+1 from qnselect * from qn;
WITH RECURSIVE qn ASselect a from t1 where a>10union allselect a+1 from qnselect * from qn;
insert into t1 values(1),(2);
set @c=0, @d=0;
WITH RECURSIVE qn ASselect 1,0 as col from t1union distinctselect 1,0 from t1union allselect 3, 0*(@c:=@c+1) from qn where @c<1union allselect 3, 0*(@d:=@d+1) from qn where @d<1select * from qn;
insert into t1 values(1),(2);
set @c=0, @d=0;
WITH RECURSIVE qn ASselect 1,0 as col from t1union distinctselect 3, 0*(@c:=@c+1) from qn where @c<1union allselect 3, 0*(@d:=@d+1) from qn where @d<1select * from qn;
create table t2with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t2;
drop table t2;
delete from t1;
insert into t1with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t1;
delete from t1;
insert into t1 values(1),(2);
insert into t1with recursive qn as (select 123 as a union all select 1+qn.a from qn, t1 where qn.a<125)select * from qn;
select * from t1;
drop table t1;
create temporary table t1(a int);
insert into t1with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t1;
drop table t1;
create view v1 aswith recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from v1;
drop view v1;
with recursive qn (n) as ( select 1 where 0 union all select n+1 from qn where 0) select * from qn;
eval explain $query;
eval $query;
with recursive qn (n) as ( select 1 where 1 union all select n+1 from qn where 0) select * from qn;
eval explain $query;
eval $query;
with recursive q (b) as (select 1 union all select 1+b from q where b<10) select (select q1.b from q as q2 where q2.b=3) from q as q1 where q1.b=3;
eval explain $query;
eval $query;
create table t1(a int);
insert into t1with recursive qn (n) as ( select 1 union all select n+1 from qn where n<10) select * from qn;
select * from t1;
with recursive qn (n) as ( select 5 union all select n+2 from qn where n<10) delete t1 from t1 where a in (select * from qn);
select * from t1;
with recursive qn (n) as ( select 4 union all select n+2 from qn where n<10) delete from t1 where a in (select * from qn);
select * from t1;
with recursive qn (n) as ( select 2 union all select n+2 from qn where n<10) update t1,qn set t1.a=qn.n where t1.a=1+qn.n;
select * from t1;
drop table t1;
CREATE TABLE employees (ID INT PRIMARY KEY,NAME VARCHAR(100),MANAGER_ID INT,INDEX (MANAGER_ID),FOREIGN KEY (MANAGER_ID) REFERENCES employees(ID));
INSERT INTO employees VALUES(333, "Yasmina", NULL),(198, "John", 333),(692, "Tarek", 333),(29, "Pedro", 198),(4610, "Sarah", 29),(72, "Pierre", 29),(123, "Adil", 692);
ANALYZE TABLE employees;
WITH RECURSIVE employees_extended(ID, NAME, PATH)AS  SELECT ID, NAME, CAST(ID AS CHAR(200))  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY PATH;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT 0 AS SEQ, ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT M.SEQ+1, S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY SEQ, NAME;
WITH RECURSIVE employees_extendedAS  SELECT (@s:=0) AS SEQ, ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT (@s:=@s+1), S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY SEQ;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extendedWHERE FIND_IN_SET((SELECT ID FROM employees WHERE NAME='John'),                  PATH);
WITH RECURSIVE employees_extended(ID, NAME, PATH)AS  SELECT ID, NAME, CAST(ID AS CHAR(200))  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_ID),JOHN_ID AS (SELECT ID FROM employees WHERE NAME='John')SELECT e.* FROM employees_extended e, JOHN_IDWHERE FIND_IN_SET(JOHN_ID.ID,                  PATH)      AND e.ID<>JOHN_ID.ID;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='Pierre'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre' OR NAME='Sarah'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre' OR NAME='Sarah'UNION  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
UPDATE employees SET MANAGER_ID=4610 WHERE NAME="John";
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extended(ID, NAME, PATH, IS_CYCLE)AS  SELECT ID, NAME, CAST(ID AS CHAR(200)), 0  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID), FIND_IN_SET(S.ID, M.PATH)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_ID  WHERE M.IS_CYCLE=0SELECT * FROM employees_extended;
DROP TABLE employees;
create table t1 (id int, name char(10), leftpar int, rightpar int);
insert into t1 values(1, "A", 2, 3),  (2, "LA", 4, 5),     (4, "LLA", 6, 7),        (6, "LLLA", null, null),        (7, "RLLA", null, null),     (5, "RLA", 8, 9),        (8, "LRLA", null, null),        (9, "RRLA", null, null),  (3, "RA", 10, 11),     (10, "LRA", 12, 13),     (11, "RRA", 14, 15),        (15, "RRRA", null, null),(16, "B", 17, 18),  (17, "LB", null, null),  (18, "RB", null, null)create table t2 select * from t1 order by rand();
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.leftparunion allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.rightparselect * from tree_of_a;
eval explain $query order by path;
eval $query order by path;
set @optimizer_switch_saved= @@optimizer_switch;
set optimizer_switch='block_nested_loop=off';
eval explain $query order by path;
eval $query order by path;
eval EXPLAIN FORMAT=tree $query order by path;
eval $query;
set @@optimizer_switch=@optimizer_switch_saved;
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a on(t2.id=tree_of_a.leftpar or t2.id=tree_of_a.rightpar)select * from tree_of_aorder by path;
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.leftparunion allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.rightparselect * from tree_of_a where id=2;
eval explain $query;
eval $query;
drop table t1,t2;
with recursive cte as  select 1 as n union all  select n+1 from cte where n<10000select /*+ no_bnl(cte3) */sum(cte1.n*cte2.n*cte3.n)=2490508525950000from cte cte1, cte cte2, cte cte3where cte1.n=cte2.n+10 and cte2.n+20=cte3.n;
eval explain $query;
eval $query;
create table nodes(id int);
create table arcs(from_id int, to_id int);
insert into nodes values(1),(2),(3),(4),(5),(6),(7),(8);
insert into arcs values(1,3), (3,6), (1,4), (4,6), (6,2), (2,1);
with recursive cte as  select id, 0 as depth from nodes where id=1  union all  select to_id, depth+1 from arcs, cte  where from_id=cte.id and depth<8select count(*), max(depth) from cte;
with recursive cte as  select id, cast(id as char(200)) as path, 0 as is_cycle  from nodes where id=1  union all  select to_id, concat(cte.path, ",", to_id), find_in_set(to_id, path)  from arcs, cte  where from_id=cte.id and is_cycle=0select * from cte;
with recursive cte as  select id from nodes where id=1  union  select to_id from arcs, cte where from_id=cte.idselect * from cte;
drop table nodes, arcs;
flush status;
with recursive cte as (  select 1 as n,  repeat('a',500) as f, '' as g,  '' as h, '' as i  union  select n+1,  '','','',''  from cte where n<100)select sum(n) from cte;
show status like 'Created_tmp_disk_tables';
with recursive cte as (  select 1 as n,  repeat('a',500) as f, repeat('a',500) as g,  repeat('a',500) as h, repeat('a',500) as i,  repeat('a',500) as j, repeat('a',500) as k,  repeat('a',500) as l, repeat('a',500) as m  union  select n+1,  '','','','','','','',''  from cte where n<100)select sum(n) from cte;
flush status;
create table t1(a int);
insert into t1 values (), (), (), (), (), (), (), (), (), (), (), (),(), (), ();
analyze table t1;
explain with recursive qn as(select 1 as a from t1 union all select a+1 from qn where qn.a<100)select * from qn;
explain with recursive qn as(select 1 as a from t1 union distinct select a+1 from qn where qn.a<100)select * from qn;
drop table t1;
show status like 'Created_tmp_disk_tables';
set cte_max_recursion_depth=50000;
select @@cte_max_recursion_depth;
flush status;
with recursive qn as (select * from qn2),               qn2 as (select * from qn)select * from qn;
with recursive qn as  (select 1 from qn)select * from qn;
with recursive qn as  (select 1 from qn union all   select 1 from dual)select * from qn;
with recursive qn as  (select 1 union all select 1 from qn union all select 1)select * from qn;
with recursive qn as  (select 1 from qn union all select 1 from qn)select * from qn;
with recursive qn as  (select 1 from dual union all   select 1 from dual)select * from qn;
with recursive qn as  (select 1 from dual union   select 1 from qn)select * from qn;
eval EXPLAIN FORMAT=tree $query;
eval $query;
create table t1(b int);
insert into t1 values(10),(20),(10);
with recursive qn as  (select max(b) as a from t1 union   select a from qn)select * from qn;
with recursive qn as  (select b as a from t1 union   select max(a) from qn)select * from qn;
with recursive qn as  (select rank() over (order by b) as a from t1 union   select a from qn)select * from qn;
with recursive qn as  (select b as a from t1 union   select rank() over (order by a) from qn)select * from qn;
drop table t1;
with recursive qn as  (select 1 as a from dual union all   select max(a) from qn)select * from qn;
with recursive qn as  (select 1 as a from dual group by a union all   select a+1 from qn where a<3)select * from qn;
with recursive qn as  (select 1 as a from dual union all   select a from qn group by a)select * from qn;
with recursive qn as (select 1 from dual union allselect 1 from dual where 1 not in(select * from qn))select * from qn;
with recursive qn as (select 1 from dual union allselect 1 from qnorder by (select * from qn))select * from qn;
with recursive qn as (select 1 from dual union allselect * from (select * from qn) as dt)select * from qn;
with recursive qn as (select 1 as a from dual union allselect 1 from qnorder by a)select * from qn;
with recursive qn as (select 1 as a from dual union all(select 1 from qn order by a))select * from qn;
with recursive qn as ((select 1 as a from dual order by a) union allselect a+1 from qn where a<3)select * from qn;
with recursive qn as (select 1 as a from dual union all(select 1 from qn limit 10))select * from qn;
WITH RECURSIVE qn AS(select 1 union all select distinct 3 from qn)select * from qn;
with recursive qn as (select 1 from dual union all                      select 1 from dual                        where 1 not in(select * from qn))select * from qn;
with recursive qn as (select 123 as a union all select 1+a from qn where a<130) select * from qn;
with recursive qn as (select 1 as n, 2 as un union all select 1+n, un*5-6 from qn where n<10) select * from qn;
with recursive qn as (select 1 as n, 1 as un, 1 as unp1 union all select 1+n, unp1, un+unp1 from qn where n<10) select * from qn;
create table t(c char(3), vc varchar(3), b binary(3), vb varbinary(3));
create table uselect cast(c as char(4)), cast(vc as char(4)),       cast(b as binary(4)), cast(vb as binary(4)),       "abc" as literal_c, cast("abc" as char(4)),       _binary "abc" as literal_b, cast(_binary "abc" as binary(4))from t;
show create table u;
drop table t,u;
with recursive qn as (select 1 as n, cast('x' as char(100)) as un union all select 1+n, concat(un,'x') from qn where n<10) select * from qn;
with recursive qn as (select cast("x" as char(10)) as a from dualunion all select concat("x",a) from qn where length(a)<10) select *from qn;
with recursive qn as (select "x" as a from dualunion all select concat("x",a) from qn where length(a)<10) select *from qn;
create temporary table tt select "x" as a from dual;
create temporary table tt1 select "x" as a from dual;
insert into tt1 select concat("x",a) from tt where length(a)<10;
drop temporary table tt,tt1;
eval $query;
with recursive qn as (select 1 as a from dualunion all select a*2000 from qn where a<10000000000000000000) select * from qn;
with recursive qn as (select cast(1 as decimal(30,0)) as a from dualunion all select a*2000 from qn where a<10000000000000000000) select * from qn;
with recursive qn as (select 123 as a union allselect null from qn where a is not null) select * from qn;
with recursive qn as (select 1 as a,1union allselect a+1,ST_PointFromText('POINT(10 10)') from qn where a<2)select * from qn;
with recursive qn as (select 1 as a,ST_PointFromText('POINT(10 10)')union allselect a+1,1 from qn where a<2)select * from qn;
WITH RECURSIVE qn ASselect 1union allselect 3, 0 from qnselect * from qn;
with recursive q (b) as (select 1, 1 union all select 1, 1 from q)select b from q;
with recursive qn as (select 123 as a union allselect 1+qn.a from qn, qn as qn1 where qn1.a<130)select * from qn;
flush status;
with recursive qn as (select 123 as a union allselect 1+a from qn where a<125)select * from qn;
show status like "handler_write";
flush status;
with recursive qn as (select 123 as a union allselect 1+a from qn where a<125)select * from qn, qn as qn1;
show status like "handler_write";
show status like 'Created_tmp%table%';
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as (select * from inner_ limit 10)select * from outer_, outer_ as outer1;
show status like "handler_write";
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as(select inner_.a, inner1.a as a1from inner_, inner_ as inner1 limit 10)select * from outer_;
show status like "handler_write";
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as(select a from inner_ union allselect a*2 from outer_ where a<1000)select a from outer_;
show status like "handler_write";
create table t1(a int);
insert into t1 values(1),(2);
WITH RECURSIVE qn ASselect 1 from t1union allselect 1 from t1 straight_join qnselect * from qn;
WITH RECURSIVE qn ASselect 1 from t1union allselect 1 from t1 left join qn on 1select * from qn;
WITH RECURSIVE qn ASselect a from t1 where 0union allselect a+1 from qnselect * from qn;
WITH RECURSIVE qn ASselect a from t1 where a>10union allselect a+1 from qnselect * from qn;
insert into t1 values(1),(2);
set @c=0, @d=0;
WITH RECURSIVE qn ASselect 1,0 as col from t1union distinctselect 1,0 from t1union allselect 3, 0*(@c:=@c+1) from qn where @c<1union allselect 3, 0*(@d:=@d+1) from qn where @d<1select * from qn;
insert into t1 values(1),(2);
set @c=0, @d=0;
WITH RECURSIVE qn ASselect 1,0 as col from t1union distinctselect 3, 0*(@c:=@c+1) from qn where @c<1union allselect 3, 0*(@d:=@d+1) from qn where @d<1select * from qn;
create table t2with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t2;
drop table t2;
delete from t1;
insert into t1with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t1;
delete from t1;
insert into t1 values(1),(2);
insert into t1with recursive qn as (select 123 as a union all select 1+qn.a from qn, t1 where qn.a<125)select * from qn;
select * from t1;
drop table t1;
create temporary table t1(a int);
insert into t1with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t1;
drop table t1;
create view v1 aswith recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from v1;
drop view v1;
with recursive qn (n) as ( select 1 where 0 union all select n+1 from qn where 0) select * from qn;
eval explain $query;
eval $query;
with recursive qn (n) as ( select 1 where 1 union all select n+1 from qn where 0) select * from qn;
eval explain $query;
eval $query;
with recursive q (b) as (select 1 union all select 1+b from q where b<10) select (select q1.b from q as q2 where q2.b=3) from q as q1 where q1.b=3;
eval explain $query;
eval $query;
create table t1(a int);
insert into t1with recursive qn (n) as ( select 1 union all select n+1 from qn where n<10) select * from qn;
select * from t1;
with recursive qn (n) as ( select 5 union all select n+2 from qn where n<10) delete t1 from t1 where a in (select * from qn);
select * from t1;
with recursive qn (n) as ( select 4 union all select n+2 from qn where n<10) delete from t1 where a in (select * from qn);
select * from t1;
with recursive qn (n) as ( select 2 union all select n+2 from qn where n<10) update t1,qn set t1.a=qn.n where t1.a=1+qn.n;
select * from t1;
drop table t1;
CREATE TABLE employees (ID INT PRIMARY KEY,NAME VARCHAR(100),MANAGER_ID INT,INDEX (MANAGER_ID),FOREIGN KEY (MANAGER_ID) REFERENCES employees(ID));
INSERT INTO employees VALUES(333, "Yasmina", NULL),(198, "John", 333),(692, "Tarek", 333),(29, "Pedro", 198),(4610, "Sarah", 29),(72, "Pierre", 29),(123, "Adil", 692);
ANALYZE TABLE employees;
WITH RECURSIVE employees_extended(ID, NAME, PATH)AS  SELECT ID, NAME, CAST(ID AS CHAR(200))  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY PATH;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT 0 AS SEQ, ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT M.SEQ+1, S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY SEQ, NAME;
WITH RECURSIVE employees_extendedAS  SELECT (@s:=0) AS SEQ, ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT (@s:=@s+1), S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY SEQ;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extendedWHERE FIND_IN_SET((SELECT ID FROM employees WHERE NAME='John'),                  PATH);
WITH RECURSIVE employees_extended(ID, NAME, PATH)AS  SELECT ID, NAME, CAST(ID AS CHAR(200))  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_ID),JOHN_ID AS (SELECT ID FROM employees WHERE NAME='John')SELECT e.* FROM employees_extended e, JOHN_IDWHERE FIND_IN_SET(JOHN_ID.ID,                  PATH)      AND e.ID<>JOHN_ID.ID;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='Pierre'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre' OR NAME='Sarah'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre' OR NAME='Sarah'UNION  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
UPDATE employees SET MANAGER_ID=4610 WHERE NAME="John";
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extended(ID, NAME, PATH, IS_CYCLE)AS  SELECT ID, NAME, CAST(ID AS CHAR(200)), 0  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID), FIND_IN_SET(S.ID, M.PATH)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_ID  WHERE M.IS_CYCLE=0SELECT * FROM employees_extended;
DROP TABLE employees;
create table t1 (id int, name char(10), leftpar int, rightpar int);
insert into t1 values(1, "A", 2, 3),  (2, "LA", 4, 5),     (4, "LLA", 6, 7),        (6, "LLLA", null, null),        (7, "RLLA", null, null),     (5, "RLA", 8, 9),        (8, "LRLA", null, null),        (9, "RRLA", null, null),  (3, "RA", 10, 11),     (10, "LRA", 12, 13),     (11, "RRA", 14, 15),        (15, "RRRA", null, null),(16, "B", 17, 18),  (17, "LB", null, null),  (18, "RB", null, null)create table t2 select * from t1 order by rand();
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.leftparunion allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.rightparselect * from tree_of_a;
eval explain $query order by path;
eval $query order by path;
set @optimizer_switch_saved= @@optimizer_switch;
set optimizer_switch='block_nested_loop=off';
eval explain $query order by path;
eval $query order by path;
eval EXPLAIN FORMAT=tree $query order by path;
eval $query;
set @@optimizer_switch=@optimizer_switch_saved;
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a on(t2.id=tree_of_a.leftpar or t2.id=tree_of_a.rightpar)select * from tree_of_aorder by path;
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.leftparunion allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.rightparselect * from tree_of_a where id=2;
eval explain $query;
eval $query;
drop table t1,t2;
with recursive cte as  select 1 as n union all  select n+1 from cte where n<10000select /*+ no_bnl(cte3) */sum(cte1.n*cte2.n*cte3.n)=2490508525950000from cte cte1, cte cte2, cte cte3where cte1.n=cte2.n+10 and cte2.n+20=cte3.n;
eval explain $query;
eval $query;
create table nodes(id int);
create table arcs(from_id int, to_id int);
insert into nodes values(1),(2),(3),(4),(5),(6),(7),(8);
insert into arcs values(1,3), (3,6), (1,4), (4,6), (6,2), (2,1);
with recursive cte as  select id, 0 as depth from nodes where id=1  union all  select to_id, depth+1 from arcs, cte  where from_id=cte.id and depth<8select count(*), max(depth) from cte;
with recursive cte as  select id, cast(id as char(200)) as path, 0 as is_cycle  from nodes where id=1  union all  select to_id, concat(cte.path, ",", to_id), find_in_set(to_id, path)  from arcs, cte  where from_id=cte.id and is_cycle=0select * from cte;
with recursive cte as  select id from nodes where id=1  union  select to_id from arcs, cte where from_id=cte.idselect * from cte;
drop table nodes, arcs;
flush status;
with recursive cte as (  select 1 as n,  repeat('a',500) as f, '' as g,  '' as h, '' as i  union  select n+1,  '','','',''  from cte where n<100)select sum(n) from cte;
show status like 'Created_tmp_disk_tables';
with recursive cte as (  select 1 as n,  repeat('a',500) as f, repeat('a',500) as g,  repeat('a',500) as h, repeat('a',500) as i,  repeat('a',500) as j, repeat('a',500) as k,  repeat('a',500) as l, repeat('a',500) as m  union  select n+1,  '','','','','','','',''  from cte where n<100)select sum(n) from cte;
flush status;
create table t1(a int);
insert into t1 values (), (), (), (), (), (), (), (), (), (), (), (),(), (), ();
analyze table t1;
explain with recursive qn as(select 1 as a from t1 union all select a+1 from qn where qn.a<100)select * from qn;
explain with recursive qn as(select 1 as a from t1 union distinct select a+1 from qn where qn.a<100)select * from qn;
drop table t1;
show status like 'Created_tmp_disk_tables';
set big_tables=0;
set big_tables=1;
set cte_max_recursion_depth=50000;
select @@cte_max_recursion_depth;
flush status;
with recursive qn as (select * from qn2),               qn2 as (select * from qn)select * from qn;
with recursive qn as  (select 1 from qn)select * from qn;
with recursive qn as  (select 1 from qn union all   select 1 from dual)select * from qn;
with recursive qn as  (select 1 union all select 1 from qn union all select 1)select * from qn;
with recursive qn as  (select 1 from qn union all select 1 from qn)select * from qn;
with recursive qn as  (select 1 from dual union all   select 1 from dual)select * from qn;
with recursive qn as  (select 1 from dual union   select 1 from qn)select * from qn;
eval EXPLAIN FORMAT=tree $query;
eval $query;
create table t1(b int);
insert into t1 values(10),(20),(10);
with recursive qn as  (select max(b) as a from t1 union   select a from qn)select * from qn;
with recursive qn as  (select b as a from t1 union   select max(a) from qn)select * from qn;
with recursive qn as  (select rank() over (order by b) as a from t1 union   select a from qn)select * from qn;
with recursive qn as  (select b as a from t1 union   select rank() over (order by a) from qn)select * from qn;
drop table t1;
with recursive qn as  (select 1 as a from dual union all   select max(a) from qn)select * from qn;
with recursive qn as  (select 1 as a from dual group by a union all   select a+1 from qn where a<3)select * from qn;
with recursive qn as  (select 1 as a from dual union all   select a from qn group by a)select * from qn;
with recursive qn as (select 1 from dual union allselect 1 from dual where 1 not in(select * from qn))select * from qn;
with recursive qn as (select 1 from dual union allselect 1 from qnorder by (select * from qn))select * from qn;
with recursive qn as (select 1 from dual union allselect * from (select * from qn) as dt)select * from qn;
with recursive qn as (select 1 as a from dual union allselect 1 from qnorder by a)select * from qn;
with recursive qn as (select 1 as a from dual union all(select 1 from qn order by a))select * from qn;
with recursive qn as ((select 1 as a from dual order by a) union allselect a+1 from qn where a<3)select * from qn;
with recursive qn as (select 1 as a from dual union all(select 1 from qn limit 10))select * from qn;
WITH RECURSIVE qn AS(select 1 union all select distinct 3 from qn)select * from qn;
with recursive qn as (select 1 from dual union all                      select 1 from dual                        where 1 not in(select * from qn))select * from qn;
with recursive qn as (select 123 as a union all select 1+a from qn where a<130) select * from qn;
with recursive qn as (select 1 as n, 2 as un union all select 1+n, un*5-6 from qn where n<10) select * from qn;
with recursive qn as (select 1 as n, 1 as un, 1 as unp1 union all select 1+n, unp1, un+unp1 from qn where n<10) select * from qn;
create table t(c char(3), vc varchar(3), b binary(3), vb varbinary(3));
create table uselect cast(c as char(4)), cast(vc as char(4)),       cast(b as binary(4)), cast(vb as binary(4)),       "abc" as literal_c, cast("abc" as char(4)),       _binary "abc" as literal_b, cast(_binary "abc" as binary(4))from t;
show create table u;
drop table t,u;
with recursive qn as (select 1 as n, cast('x' as char(100)) as un union all select 1+n, concat(un,'x') from qn where n<10) select * from qn;
with recursive qn as (select cast("x" as char(10)) as a from dualunion all select concat("x",a) from qn where length(a)<10) select *from qn;
with recursive qn as (select "x" as a from dualunion all select concat("x",a) from qn where length(a)<10) select *from qn;
create temporary table tt select "x" as a from dual;
create temporary table tt1 select "x" as a from dual;
insert into tt1 select concat("x",a) from tt where length(a)<10;
drop temporary table tt,tt1;
eval $query;
with recursive qn as (select 1 as a from dualunion all select a*2000 from qn where a<10000000000000000000) select * from qn;
with recursive qn as (select cast(1 as decimal(30,0)) as a from dualunion all select a*2000 from qn where a<10000000000000000000) select * from qn;
with recursive qn as (select 123 as a union allselect null from qn where a is not null) select * from qn;
with recursive qn as (select 1 as a,1union allselect a+1,ST_PointFromText('POINT(10 10)') from qn where a<2)select * from qn;
with recursive qn as (select 1 as a,ST_PointFromText('POINT(10 10)')union allselect a+1,1 from qn where a<2)select * from qn;
WITH RECURSIVE qn ASselect 1union allselect 3, 0 from qnselect * from qn;
with recursive q (b) as (select 1, 1 union all select 1, 1 from q)select b from q;
with recursive qn as (select 123 as a union allselect 1+qn.a from qn, qn as qn1 where qn1.a<130)select * from qn;
flush status;
with recursive qn as (select 123 as a union allselect 1+a from qn where a<125)select * from qn;
show status like "handler_write";
flush status;
with recursive qn as (select 123 as a union allselect 1+a from qn where a<125)select * from qn, qn as qn1;
show status like "handler_write";
show status like 'Created_tmp%table%';
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as (select * from inner_ limit 10)select * from outer_, outer_ as outer1;
show status like "handler_write";
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as(select inner_.a, inner1.a as a1from inner_, inner_ as inner1 limit 10)select * from outer_;
show status like "handler_write";
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as(select a from inner_ union allselect a*2 from outer_ where a<1000)select a from outer_;
show status like "handler_write";
create table t1(a int);
insert into t1 values(1),(2);
WITH RECURSIVE qn ASselect 1 from t1union allselect 1 from t1 straight_join qnselect * from qn;
WITH RECURSIVE qn ASselect 1 from t1union allselect 1 from t1 left join qn on 1select * from qn;
WITH RECURSIVE qn ASselect a from t1 where 0union allselect a+1 from qnselect * from qn;
WITH RECURSIVE qn ASselect a from t1 where a>10union allselect a+1 from qnselect * from qn;
insert into t1 values(1),(2);
set @c=0, @d=0;
WITH RECURSIVE qn ASselect 1,0 as col from t1union distinctselect 1,0 from t1union allselect 3, 0*(@c:=@c+1) from qn where @c<1union allselect 3, 0*(@d:=@d+1) from qn where @d<1select * from qn;
insert into t1 values(1),(2);
set @c=0, @d=0;
WITH RECURSIVE qn ASselect 1,0 as col from t1union distinctselect 3, 0*(@c:=@c+1) from qn where @c<1union allselect 3, 0*(@d:=@d+1) from qn where @d<1select * from qn;
create table t2with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t2;
drop table t2;
delete from t1;
insert into t1with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t1;
delete from t1;
insert into t1 values(1),(2);
insert into t1with recursive qn as (select 123 as a union all select 1+qn.a from qn, t1 where qn.a<125)select * from qn;
select * from t1;
drop table t1;
create temporary table t1(a int);
insert into t1with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t1;
drop table t1;
create view v1 aswith recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from v1;
drop view v1;
with recursive qn (n) as ( select 1 where 0 union all select n+1 from qn where 0) select * from qn;
eval explain $query;
eval $query;
with recursive qn (n) as ( select 1 where 1 union all select n+1 from qn where 0) select * from qn;
eval explain $query;
eval $query;
with recursive q (b) as (select 1 union all select 1+b from q where b<10) select (select q1.b from q as q2 where q2.b=3) from q as q1 where q1.b=3;
eval explain $query;
eval $query;
create table t1(a int);
insert into t1with recursive qn (n) as ( select 1 union all select n+1 from qn where n<10) select * from qn;
select * from t1;
with recursive qn (n) as ( select 5 union all select n+2 from qn where n<10) delete t1 from t1 where a in (select * from qn);
select * from t1;
with recursive qn (n) as ( select 4 union all select n+2 from qn where n<10) delete from t1 where a in (select * from qn);
select * from t1;
with recursive qn (n) as ( select 2 union all select n+2 from qn where n<10) update t1,qn set t1.a=qn.n where t1.a=1+qn.n;
select * from t1;
drop table t1;
CREATE TABLE employees (ID INT PRIMARY KEY,NAME VARCHAR(100),MANAGER_ID INT,INDEX (MANAGER_ID),FOREIGN KEY (MANAGER_ID) REFERENCES employees(ID));
INSERT INTO employees VALUES(333, "Yasmina", NULL),(198, "John", 333),(692, "Tarek", 333),(29, "Pedro", 198),(4610, "Sarah", 29),(72, "Pierre", 29),(123, "Adil", 692);
ANALYZE TABLE employees;
WITH RECURSIVE employees_extended(ID, NAME, PATH)AS  SELECT ID, NAME, CAST(ID AS CHAR(200))  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY PATH;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT 0 AS SEQ, ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT M.SEQ+1, S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY SEQ, NAME;
WITH RECURSIVE employees_extendedAS  SELECT (@s:=0) AS SEQ, ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT (@s:=@s+1), S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY SEQ;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extendedWHERE FIND_IN_SET((SELECT ID FROM employees WHERE NAME='John'),                  PATH);
WITH RECURSIVE employees_extended(ID, NAME, PATH)AS  SELECT ID, NAME, CAST(ID AS CHAR(200))  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_ID),JOHN_ID AS (SELECT ID FROM employees WHERE NAME='John')SELECT e.* FROM employees_extended e, JOHN_IDWHERE FIND_IN_SET(JOHN_ID.ID,                  PATH)      AND e.ID<>JOHN_ID.ID;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='Pierre'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre' OR NAME='Sarah'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre' OR NAME='Sarah'UNION  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
UPDATE employees SET MANAGER_ID=4610 WHERE NAME="John";
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extended(ID, NAME, PATH, IS_CYCLE)AS  SELECT ID, NAME, CAST(ID AS CHAR(200)), 0  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID), FIND_IN_SET(S.ID, M.PATH)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_ID  WHERE M.IS_CYCLE=0SELECT * FROM employees_extended;
DROP TABLE employees;
create table t1 (id int, name char(10), leftpar int, rightpar int);
insert into t1 values(1, "A", 2, 3),  (2, "LA", 4, 5),     (4, "LLA", 6, 7),        (6, "LLLA", null, null),        (7, "RLLA", null, null),     (5, "RLA", 8, 9),        (8, "LRLA", null, null),        (9, "RRLA", null, null),  (3, "RA", 10, 11),     (10, "LRA", 12, 13),     (11, "RRA", 14, 15),        (15, "RRRA", null, null),(16, "B", 17, 18),  (17, "LB", null, null),  (18, "RB", null, null)create table t2 select * from t1 order by rand();
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.leftparunion allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.rightparselect * from tree_of_a;
eval explain $query order by path;
eval $query order by path;
set @optimizer_switch_saved= @@optimizer_switch;
set optimizer_switch='block_nested_loop=off';
eval explain $query order by path;
eval $query order by path;
eval EXPLAIN FORMAT=tree $query order by path;
eval $query;
set @@optimizer_switch=@optimizer_switch_saved;
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a on(t2.id=tree_of_a.leftpar or t2.id=tree_of_a.rightpar)select * from tree_of_aorder by path;
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.leftparunion allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.rightparselect * from tree_of_a where id=2;
eval explain $query;
eval $query;
drop table t1,t2;
with recursive cte as  select 1 as n union all  select n+1 from cte where n<10000select /*+ no_bnl(cte3) */sum(cte1.n*cte2.n*cte3.n)=2490508525950000from cte cte1, cte cte2, cte cte3where cte1.n=cte2.n+10 and cte2.n+20=cte3.n;
eval explain $query;
eval $query;
create table nodes(id int);
create table arcs(from_id int, to_id int);
insert into nodes values(1),(2),(3),(4),(5),(6),(7),(8);
insert into arcs values(1,3), (3,6), (1,4), (4,6), (6,2), (2,1);
with recursive cte as  select id, 0 as depth from nodes where id=1  union all  select to_id, depth+1 from arcs, cte  where from_id=cte.id and depth<8select count(*), max(depth) from cte;
with recursive cte as  select id, cast(id as char(200)) as path, 0 as is_cycle  from nodes where id=1  union all  select to_id, concat(cte.path, ",", to_id), find_in_set(to_id, path)  from arcs, cte  where from_id=cte.id and is_cycle=0select * from cte;
with recursive cte as  select id from nodes where id=1  union  select to_id from arcs, cte where from_id=cte.idselect * from cte;
drop table nodes, arcs;
flush status;
with recursive cte as (  select 1 as n,  repeat('a',500) as f, '' as g,  '' as h, '' as i  union  select n+1,  '','','',''  from cte where n<100)select sum(n) from cte;
show status like 'Created_tmp_disk_tables';
with recursive cte as (  select 1 as n,  repeat('a',500) as f, repeat('a',500) as g,  repeat('a',500) as h, repeat('a',500) as i,  repeat('a',500) as j, repeat('a',500) as k,  repeat('a',500) as l, repeat('a',500) as m  union  select n+1,  '','','','','','','',''  from cte where n<100)select sum(n) from cte;
flush status;
create table t1(a int);
insert into t1 values (), (), (), (), (), (), (), (), (), (), (), (),(), (), ();
analyze table t1;
explain with recursive qn as(select 1 as a from t1 union all select a+1 from qn where qn.a<100)select * from qn;
explain with recursive qn as(select 1 as a from t1 union distinct select a+1 from qn where qn.a<100)select * from qn;
drop table t1;
show status like 'Created_tmp_disk_tables';
set cte_max_recursion_depth=50000;
select @@cte_max_recursion_depth;
flush status;
with recursive qn as (select * from qn2),               qn2 as (select * from qn)select * from qn;
with recursive qn as  (select 1 from qn)select * from qn;
with recursive qn as  (select 1 from qn union all   select 1 from dual)select * from qn;
with recursive qn as  (select 1 union all select 1 from qn union all select 1)select * from qn;
with recursive qn as  (select 1 from qn union all select 1 from qn)select * from qn;
with recursive qn as  (select 1 from dual union all   select 1 from dual)select * from qn;
with recursive qn as  (select 1 from dual union   select 1 from qn)select * from qn;
eval EXPLAIN FORMAT=tree $query;
eval $query;
create table t1(b int);
insert into t1 values(10),(20),(10);
with recursive qn as  (select max(b) as a from t1 union   select a from qn)select * from qn;
with recursive qn as  (select b as a from t1 union   select max(a) from qn)select * from qn;
with recursive qn as  (select rank() over (order by b) as a from t1 union   select a from qn)select * from qn;
with recursive qn as  (select b as a from t1 union   select rank() over (order by a) from qn)select * from qn;
drop table t1;
with recursive qn as  (select 1 as a from dual union all   select max(a) from qn)select * from qn;
with recursive qn as  (select 1 as a from dual group by a union all   select a+1 from qn where a<3)select * from qn;
with recursive qn as  (select 1 as a from dual union all   select a from qn group by a)select * from qn;
with recursive qn as (select 1 from dual union allselect 1 from dual where 1 not in(select * from qn))select * from qn;
with recursive qn as (select 1 from dual union allselect 1 from qnorder by (select * from qn))select * from qn;
with recursive qn as (select 1 from dual union allselect * from (select * from qn) as dt)select * from qn;
with recursive qn as (select 1 as a from dual union allselect 1 from qnorder by a)select * from qn;
with recursive qn as (select 1 as a from dual union all(select 1 from qn order by a))select * from qn;
with recursive qn as ((select 1 as a from dual order by a) union allselect a+1 from qn where a<3)select * from qn;
with recursive qn as (select 1 as a from dual union all(select 1 from qn limit 10))select * from qn;
WITH RECURSIVE qn AS(select 1 union all select distinct 3 from qn)select * from qn;
with recursive qn as (select 1 from dual union all                      select 1 from dual                        where 1 not in(select * from qn))select * from qn;
with recursive qn as (select 123 as a union all select 1+a from qn where a<130) select * from qn;
with recursive qn as (select 1 as n, 2 as un union all select 1+n, un*5-6 from qn where n<10) select * from qn;
with recursive qn as (select 1 as n, 1 as un, 1 as unp1 union all select 1+n, unp1, un+unp1 from qn where n<10) select * from qn;
create table t(c char(3), vc varchar(3), b binary(3), vb varbinary(3));
create table uselect cast(c as char(4)), cast(vc as char(4)),       cast(b as binary(4)), cast(vb as binary(4)),       "abc" as literal_c, cast("abc" as char(4)),       _binary "abc" as literal_b, cast(_binary "abc" as binary(4))from t;
show create table u;
drop table t,u;
with recursive qn as (select 1 as n, cast('x' as char(100)) as un union all select 1+n, concat(un,'x') from qn where n<10) select * from qn;
with recursive qn as (select cast("x" as char(10)) as a from dualunion all select concat("x",a) from qn where length(a)<10) select *from qn;
with recursive qn as (select "x" as a from dualunion all select concat("x",a) from qn where length(a)<10) select *from qn;
create temporary table tt select "x" as a from dual;
create temporary table tt1 select "x" as a from dual;
insert into tt1 select concat("x",a) from tt where length(a)<10;
drop temporary table tt,tt1;
eval $query;
with recursive qn as (select 1 as a from dualunion all select a*2000 from qn where a<10000000000000000000) select * from qn;
with recursive qn as (select cast(1 as decimal(30,0)) as a from dualunion all select a*2000 from qn where a<10000000000000000000) select * from qn;
with recursive qn as (select 123 as a union allselect null from qn where a is not null) select * from qn;
with recursive qn as (select 1 as a,1union allselect a+1,ST_PointFromText('POINT(10 10)') from qn where a<2)select * from qn;
with recursive qn as (select 1 as a,ST_PointFromText('POINT(10 10)')union allselect a+1,1 from qn where a<2)select * from qn;
WITH RECURSIVE qn ASselect 1union allselect 3, 0 from qnselect * from qn;
with recursive q (b) as (select 1, 1 union all select 1, 1 from q)select b from q;
with recursive qn as (select 123 as a union allselect 1+qn.a from qn, qn as qn1 where qn1.a<130)select * from qn;
flush status;
with recursive qn as (select 123 as a union allselect 1+a from qn where a<125)select * from qn;
show status like "handler_write";
flush status;
with recursive qn as (select 123 as a union allselect 1+a from qn where a<125)select * from qn, qn as qn1;
show status like "handler_write";
show status like 'Created_tmp%table%';
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as (select * from inner_ limit 10)select * from outer_, outer_ as outer1;
show status like "handler_write";
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as(select inner_.a, inner1.a as a1from inner_, inner_ as inner1 limit 10)select * from outer_;
show status like "handler_write";
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as(select a from inner_ union allselect a*2 from outer_ where a<1000)select a from outer_;
show status like "handler_write";
create table t1(a int);
insert into t1 values(1),(2);
WITH RECURSIVE qn ASselect 1 from t1union allselect 1 from t1 straight_join qnselect * from qn;
WITH RECURSIVE qn ASselect 1 from t1union allselect 1 from t1 left join qn on 1select * from qn;
WITH RECURSIVE qn ASselect a from t1 where 0union allselect a+1 from qnselect * from qn;
WITH RECURSIVE qn ASselect a from t1 where a>10union allselect a+1 from qnselect * from qn;
insert into t1 values(1),(2);
set @c=0, @d=0;
WITH RECURSIVE qn ASselect 1,0 as col from t1union distinctselect 1,0 from t1union allselect 3, 0*(@c:=@c+1) from qn where @c<1union allselect 3, 0*(@d:=@d+1) from qn where @d<1select * from qn;
insert into t1 values(1),(2);
set @c=0, @d=0;
WITH RECURSIVE qn ASselect 1,0 as col from t1union distinctselect 3, 0*(@c:=@c+1) from qn where @c<1union allselect 3, 0*(@d:=@d+1) from qn where @d<1select * from qn;
create table t2with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t2;
drop table t2;
delete from t1;
insert into t1with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t1;
delete from t1;
insert into t1 values(1),(2);
insert into t1with recursive qn as (select 123 as a union all select 1+qn.a from qn, t1 where qn.a<125)select * from qn;
select * from t1;
drop table t1;
create temporary table t1(a int);
insert into t1with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t1;
drop table t1;
create view v1 aswith recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from v1;
drop view v1;
with recursive qn (n) as ( select 1 where 0 union all select n+1 from qn where 0) select * from qn;
eval explain $query;
eval $query;
with recursive qn (n) as ( select 1 where 1 union all select n+1 from qn where 0) select * from qn;
eval explain $query;
eval $query;
with recursive q (b) as (select 1 union all select 1+b from q where b<10) select (select q1.b from q as q2 where q2.b=3) from q as q1 where q1.b=3;
eval explain $query;
eval $query;
create table t1(a int);
insert into t1with recursive qn (n) as ( select 1 union all select n+1 from qn where n<10) select * from qn;
select * from t1;
with recursive qn (n) as ( select 5 union all select n+2 from qn where n<10) delete t1 from t1 where a in (select * from qn);
select * from t1;
with recursive qn (n) as ( select 4 union all select n+2 from qn where n<10) delete from t1 where a in (select * from qn);
select * from t1;
with recursive qn (n) as ( select 2 union all select n+2 from qn where n<10) update t1,qn set t1.a=qn.n where t1.a=1+qn.n;
select * from t1;
drop table t1;
CREATE TABLE employees (ID INT PRIMARY KEY,NAME VARCHAR(100),MANAGER_ID INT,INDEX (MANAGER_ID),FOREIGN KEY (MANAGER_ID) REFERENCES employees(ID));
INSERT INTO employees VALUES(333, "Yasmina", NULL),(198, "John", 333),(692, "Tarek", 333),(29, "Pedro", 198),(4610, "Sarah", 29),(72, "Pierre", 29),(123, "Adil", 692);
ANALYZE TABLE employees;
WITH RECURSIVE employees_extended(ID, NAME, PATH)AS  SELECT ID, NAME, CAST(ID AS CHAR(200))  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY PATH;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT 0 AS SEQ, ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT M.SEQ+1, S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY SEQ, NAME;
WITH RECURSIVE employees_extendedAS  SELECT (@s:=0) AS SEQ, ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT (@s:=@s+1), S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY SEQ;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extendedWHERE FIND_IN_SET((SELECT ID FROM employees WHERE NAME='John'),                  PATH);
WITH RECURSIVE employees_extended(ID, NAME, PATH)AS  SELECT ID, NAME, CAST(ID AS CHAR(200))  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_ID),JOHN_ID AS (SELECT ID FROM employees WHERE NAME='John')SELECT e.* FROM employees_extended e, JOHN_IDWHERE FIND_IN_SET(JOHN_ID.ID,                  PATH)      AND e.ID<>JOHN_ID.ID;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='Pierre'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre' OR NAME='Sarah'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre' OR NAME='Sarah'UNION  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
UPDATE employees SET MANAGER_ID=4610 WHERE NAME="John";
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extended(ID, NAME, PATH, IS_CYCLE)AS  SELECT ID, NAME, CAST(ID AS CHAR(200)), 0  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID), FIND_IN_SET(S.ID, M.PATH)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_ID  WHERE M.IS_CYCLE=0SELECT * FROM employees_extended;
DROP TABLE employees;
create table t1 (id int, name char(10), leftpar int, rightpar int);
insert into t1 values(1, "A", 2, 3),  (2, "LA", 4, 5),     (4, "LLA", 6, 7),        (6, "LLLA", null, null),        (7, "RLLA", null, null),     (5, "RLA", 8, 9),        (8, "LRLA", null, null),        (9, "RRLA", null, null),  (3, "RA", 10, 11),     (10, "LRA", 12, 13),     (11, "RRA", 14, 15),        (15, "RRRA", null, null),(16, "B", 17, 18),  (17, "LB", null, null),  (18, "RB", null, null)create table t2 select * from t1 order by rand();
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.leftparunion allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.rightparselect * from tree_of_a;
eval explain $query order by path;
eval $query order by path;
set @optimizer_switch_saved= @@optimizer_switch;
set optimizer_switch='block_nested_loop=off';
eval explain $query order by path;
eval $query order by path;
eval EXPLAIN FORMAT=tree $query order by path;
eval $query;
set @@optimizer_switch=@optimizer_switch_saved;
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a on(t2.id=tree_of_a.leftpar or t2.id=tree_of_a.rightpar)select * from tree_of_aorder by path;
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.leftparunion allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.rightparselect * from tree_of_a where id=2;
eval explain $query;
eval $query;
drop table t1,t2;
with recursive cte as  select 1 as n union all  select n+1 from cte where n<10000select /*+ no_bnl(cte3) */sum(cte1.n*cte2.n*cte3.n)=2490508525950000from cte cte1, cte cte2, cte cte3where cte1.n=cte2.n+10 and cte2.n+20=cte3.n;
eval explain $query;
eval $query;
create table nodes(id int);
create table arcs(from_id int, to_id int);
insert into nodes values(1),(2),(3),(4),(5),(6),(7),(8);
insert into arcs values(1,3), (3,6), (1,4), (4,6), (6,2), (2,1);
with recursive cte as  select id, 0 as depth from nodes where id=1  union all  select to_id, depth+1 from arcs, cte  where from_id=cte.id and depth<8select count(*), max(depth) from cte;
with recursive cte as  select id, cast(id as char(200)) as path, 0 as is_cycle  from nodes where id=1  union all  select to_id, concat(cte.path, ",", to_id), find_in_set(to_id, path)  from arcs, cte  where from_id=cte.id and is_cycle=0select * from cte;
with recursive cte as  select id from nodes where id=1  union  select to_id from arcs, cte where from_id=cte.idselect * from cte;
drop table nodes, arcs;
flush status;
with recursive cte as (  select 1 as n,  repeat('a',500) as f, '' as g,  '' as h, '' as i  union  select n+1,  '','','',''  from cte where n<100)select sum(n) from cte;
show status like 'Created_tmp_disk_tables';
with recursive cte as (  select 1 as n,  repeat('a',500) as f, repeat('a',500) as g,  repeat('a',500) as h, repeat('a',500) as i,  repeat('a',500) as j, repeat('a',500) as k,  repeat('a',500) as l, repeat('a',500) as m  union  select n+1,  '','','','','','','',''  from cte where n<100)select sum(n) from cte;
flush status;
create table t1(a int);
insert into t1 values (), (), (), (), (), (), (), (), (), (), (), (),(), (), ();
analyze table t1;
explain with recursive qn as(select 1 as a from t1 union all select a+1 from qn where qn.a<100)select * from qn;
explain with recursive qn as(select 1 as a from t1 union distinct select a+1 from qn where qn.a<100)select * from qn;
drop table t1;
show status like 'Created_tmp_disk_tables';
set big_tables=0;
set big_tables=1;
set cte_max_recursion_depth=50000;
select @@cte_max_recursion_depth;
flush status;
with recursive qn as (select * from qn2),               qn2 as (select * from qn)select * from qn;
with recursive qn as  (select 1 from qn)select * from qn;
with recursive qn as  (select 1 from qn union all   select 1 from dual)select * from qn;
with recursive qn as  (select 1 union all select 1 from qn union all select 1)select * from qn;
with recursive qn as  (select 1 from qn union all select 1 from qn)select * from qn;
with recursive qn as  (select 1 from dual union all   select 1 from dual)select * from qn;
with recursive qn as  (select 1 from dual union   select 1 from qn)select * from qn;
eval EXPLAIN FORMAT=tree $query;
eval $query;
create table t1(b int);
insert into t1 values(10),(20),(10);
with recursive qn as  (select max(b) as a from t1 union   select a from qn)select * from qn;
with recursive qn as  (select b as a from t1 union   select max(a) from qn)select * from qn;
with recursive qn as  (select rank() over (order by b) as a from t1 union   select a from qn)select * from qn;
with recursive qn as  (select b as a from t1 union   select rank() over (order by a) from qn)select * from qn;
drop table t1;
with recursive qn as  (select 1 as a from dual union all   select max(a) from qn)select * from qn;
with recursive qn as  (select 1 as a from dual group by a union all   select a+1 from qn where a<3)select * from qn;
with recursive qn as  (select 1 as a from dual union all   select a from qn group by a)select * from qn;
with recursive qn as (select 1 from dual union allselect 1 from dual where 1 not in(select * from qn))select * from qn;
with recursive qn as (select 1 from dual union allselect 1 from qnorder by (select * from qn))select * from qn;
with recursive qn as (select 1 from dual union allselect * from (select * from qn) as dt)select * from qn;
with recursive qn as (select 1 as a from dual union allselect 1 from qnorder by a)select * from qn;
with recursive qn as (select 1 as a from dual union all(select 1 from qn order by a))select * from qn;
with recursive qn as ((select 1 as a from dual order by a) union allselect a+1 from qn where a<3)select * from qn;
with recursive qn as (select 1 as a from dual union all(select 1 from qn limit 10))select * from qn;
WITH RECURSIVE qn AS(select 1 union all select distinct 3 from qn)select * from qn;
with recursive qn as (select 1 from dual union all                      select 1 from dual                        where 1 not in(select * from qn))select * from qn;
with recursive qn as (select 123 as a union all select 1+a from qn where a<130) select * from qn;
with recursive qn as (select 1 as n, 2 as un union all select 1+n, un*5-6 from qn where n<10) select * from qn;
with recursive qn as (select 1 as n, 1 as un, 1 as unp1 union all select 1+n, unp1, un+unp1 from qn where n<10) select * from qn;
create table t(c char(3), vc varchar(3), b binary(3), vb varbinary(3));
create table uselect cast(c as char(4)), cast(vc as char(4)),       cast(b as binary(4)), cast(vb as binary(4)),       "abc" as literal_c, cast("abc" as char(4)),       _binary "abc" as literal_b, cast(_binary "abc" as binary(4))from t;
show create table u;
drop table t,u;
with recursive qn as (select 1 as n, cast('x' as char(100)) as un union all select 1+n, concat(un,'x') from qn where n<10) select * from qn;
with recursive qn as (select cast("x" as char(10)) as a from dualunion all select concat("x",a) from qn where length(a)<10) select *from qn;
with recursive qn as (select "x" as a from dualunion all select concat("x",a) from qn where length(a)<10) select *from qn;
create temporary table tt select "x" as a from dual;
create temporary table tt1 select "x" as a from dual;
insert into tt1 select concat("x",a) from tt where length(a)<10;
drop temporary table tt,tt1;
eval $query;
with recursive qn as (select 1 as a from dualunion all select a*2000 from qn where a<10000000000000000000) select * from qn;
with recursive qn as (select cast(1 as decimal(30,0)) as a from dualunion all select a*2000 from qn where a<10000000000000000000) select * from qn;
with recursive qn as (select 123 as a union allselect null from qn where a is not null) select * from qn;
with recursive qn as (select 1 as a,1union allselect a+1,ST_PointFromText('POINT(10 10)') from qn where a<2)select * from qn;
with recursive qn as (select 1 as a,ST_PointFromText('POINT(10 10)')union allselect a+1,1 from qn where a<2)select * from qn;
WITH RECURSIVE qn ASselect 1union allselect 3, 0 from qnselect * from qn;
with recursive q (b) as (select 1, 1 union all select 1, 1 from q)select b from q;
with recursive qn as (select 123 as a union allselect 1+qn.a from qn, qn as qn1 where qn1.a<130)select * from qn;
flush status;
with recursive qn as (select 123 as a union allselect 1+a from qn where a<125)select * from qn;
show status like "handler_write";
flush status;
with recursive qn as (select 123 as a union allselect 1+a from qn where a<125)select * from qn, qn as qn1;
show status like "handler_write";
show status like 'Created_tmp%table%';
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as (select * from inner_ limit 10)select * from outer_, outer_ as outer1;
show status like "handler_write";
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as(select inner_.a, inner1.a as a1from inner_, inner_ as inner1 limit 10)select * from outer_;
show status like "handler_write";
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as(select a from inner_ union allselect a*2 from outer_ where a<1000)select a from outer_;
show status like "handler_write";
create table t1(a int);
insert into t1 values(1),(2);
WITH RECURSIVE qn ASselect 1 from t1union allselect 1 from t1 straight_join qnselect * from qn;
WITH RECURSIVE qn ASselect 1 from t1union allselect 1 from t1 left join qn on 1select * from qn;
WITH RECURSIVE qn ASselect a from t1 where 0union allselect a+1 from qnselect * from qn;
WITH RECURSIVE qn ASselect a from t1 where a>10union allselect a+1 from qnselect * from qn;
insert into t1 values(1),(2);
set @c=0, @d=0;
WITH RECURSIVE qn ASselect 1,0 as col from t1union distinctselect 1,0 from t1union allselect 3, 0*(@c:=@c+1) from qn where @c<1union allselect 3, 0*(@d:=@d+1) from qn where @d<1select * from qn;
insert into t1 values(1),(2);
set @c=0, @d=0;
WITH RECURSIVE qn ASselect 1,0 as col from t1union distinctselect 3, 0*(@c:=@c+1) from qn where @c<1union allselect 3, 0*(@d:=@d+1) from qn where @d<1select * from qn;
create table t2with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t2;
drop table t2;
delete from t1;
insert into t1with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t1;
delete from t1;
insert into t1 values(1),(2);
insert into t1with recursive qn as (select 123 as a union all select 1+qn.a from qn, t1 where qn.a<125)select * from qn;
select * from t1;
drop table t1;
create temporary table t1(a int);
insert into t1with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t1;
drop table t1;
create view v1 aswith recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from v1;
drop view v1;
with recursive qn (n) as ( select 1 where 0 union all select n+1 from qn where 0) select * from qn;
eval explain $query;
eval $query;
with recursive qn (n) as ( select 1 where 1 union all select n+1 from qn where 0) select * from qn;
eval explain $query;
eval $query;
with recursive q (b) as (select 1 union all select 1+b from q where b<10) select (select q1.b from q as q2 where q2.b=3) from q as q1 where q1.b=3;
eval explain $query;
eval $query;
create table t1(a int);
insert into t1with recursive qn (n) as ( select 1 union all select n+1 from qn where n<10) select * from qn;
select * from t1;
with recursive qn (n) as ( select 5 union all select n+2 from qn where n<10) delete t1 from t1 where a in (select * from qn);
select * from t1;
with recursive qn (n) as ( select 4 union all select n+2 from qn where n<10) delete from t1 where a in (select * from qn);
select * from t1;
with recursive qn (n) as ( select 2 union all select n+2 from qn where n<10) update t1,qn set t1.a=qn.n where t1.a=1+qn.n;
select * from t1;
drop table t1;
CREATE TABLE employees (ID INT PRIMARY KEY,NAME VARCHAR(100),MANAGER_ID INT,INDEX (MANAGER_ID),FOREIGN KEY (MANAGER_ID) REFERENCES employees(ID));
INSERT INTO employees VALUES(333, "Yasmina", NULL),(198, "John", 333),(692, "Tarek", 333),(29, "Pedro", 198),(4610, "Sarah", 29),(72, "Pierre", 29),(123, "Adil", 692);
ANALYZE TABLE employees;
WITH RECURSIVE employees_extended(ID, NAME, PATH)AS  SELECT ID, NAME, CAST(ID AS CHAR(200))  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY PATH;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT 0 AS SEQ, ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT M.SEQ+1, S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY SEQ, NAME;
WITH RECURSIVE employees_extendedAS  SELECT (@s:=0) AS SEQ, ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT (@s:=@s+1), S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY SEQ;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extendedWHERE FIND_IN_SET((SELECT ID FROM employees WHERE NAME='John'),                  PATH);
WITH RECURSIVE employees_extended(ID, NAME, PATH)AS  SELECT ID, NAME, CAST(ID AS CHAR(200))  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_ID),JOHN_ID AS (SELECT ID FROM employees WHERE NAME='John')SELECT e.* FROM employees_extended e, JOHN_IDWHERE FIND_IN_SET(JOHN_ID.ID,                  PATH)      AND e.ID<>JOHN_ID.ID;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='Pierre'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre' OR NAME='Sarah'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre' OR NAME='Sarah'UNION  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
UPDATE employees SET MANAGER_ID=4610 WHERE NAME="John";
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extended(ID, NAME, PATH, IS_CYCLE)AS  SELECT ID, NAME, CAST(ID AS CHAR(200)), 0  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID), FIND_IN_SET(S.ID, M.PATH)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_ID  WHERE M.IS_CYCLE=0SELECT * FROM employees_extended;
DROP TABLE employees;
create table t1 (id int, name char(10), leftpar int, rightpar int);
insert into t1 values(1, "A", 2, 3),  (2, "LA", 4, 5),     (4, "LLA", 6, 7),        (6, "LLLA", null, null),        (7, "RLLA", null, null),     (5, "RLA", 8, 9),        (8, "LRLA", null, null),        (9, "RRLA", null, null),  (3, "RA", 10, 11),     (10, "LRA", 12, 13),     (11, "RRA", 14, 15),        (15, "RRRA", null, null),(16, "B", 17, 18),  (17, "LB", null, null),  (18, "RB", null, null)create table t2 select * from t1 order by rand();
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.leftparunion allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.rightparselect * from tree_of_a;
eval explain $query order by path;
eval $query order by path;
set @optimizer_switch_saved= @@optimizer_switch;
set optimizer_switch='block_nested_loop=off';
eval explain $query order by path;
eval $query order by path;
eval EXPLAIN FORMAT=tree $query order by path;
eval $query;
set @@optimizer_switch=@optimizer_switch_saved;
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a on(t2.id=tree_of_a.leftpar or t2.id=tree_of_a.rightpar)select * from tree_of_aorder by path;
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.leftparunion allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.rightparselect * from tree_of_a where id=2;
eval explain $query;
eval $query;
drop table t1,t2;
with recursive cte as  select 1 as n union all  select n+1 from cte where n<10000select /*+ no_bnl(cte3) */sum(cte1.n*cte2.n*cte3.n)=2490508525950000from cte cte1, cte cte2, cte cte3where cte1.n=cte2.n+10 and cte2.n+20=cte3.n;
eval explain $query;
eval $query;
create table nodes(id int);
create table arcs(from_id int, to_id int);
insert into nodes values(1),(2),(3),(4),(5),(6),(7),(8);
insert into arcs values(1,3), (3,6), (1,4), (4,6), (6,2), (2,1);
with recursive cte as  select id, 0 as depth from nodes where id=1  union all  select to_id, depth+1 from arcs, cte  where from_id=cte.id and depth<8select count(*), max(depth) from cte;
with recursive cte as  select id, cast(id as char(200)) as path, 0 as is_cycle  from nodes where id=1  union all  select to_id, concat(cte.path, ",", to_id), find_in_set(to_id, path)  from arcs, cte  where from_id=cte.id and is_cycle=0select * from cte;
with recursive cte as  select id from nodes where id=1  union  select to_id from arcs, cte where from_id=cte.idselect * from cte;
drop table nodes, arcs;
flush status;
with recursive cte as (  select 1 as n,  repeat('a',500) as f, '' as g,  '' as h, '' as i  union  select n+1,  '','','',''  from cte where n<100)select sum(n) from cte;
show status like 'Created_tmp_disk_tables';
with recursive cte as (  select 1 as n,  repeat('a',500) as f, repeat('a',500) as g,  repeat('a',500) as h, repeat('a',500) as i,  repeat('a',500) as j, repeat('a',500) as k,  repeat('a',500) as l, repeat('a',500) as m  union  select n+1,  '','','','','','','',''  from cte where n<100)select sum(n) from cte;
flush status;
create table t1(a int);
insert into t1 values (), (), (), (), (), (), (), (), (), (), (), (),(), (), ();
analyze table t1;
explain with recursive qn as(select 1 as a from t1 union all select a+1 from qn where qn.a<100)select * from qn;
explain with recursive qn as(select 1 as a from t1 union distinct select a+1 from qn where qn.a<100)select * from qn;
drop table t1;
show status like 'Created_tmp_disk_tables';
set cte_max_recursion_depth=50000;
select @@cte_max_recursion_depth;
flush status;
with recursive qn as (select * from qn2),               qn2 as (select * from qn)select * from qn;
with recursive qn as  (select 1 from qn)select * from qn;
with recursive qn as  (select 1 from qn union all   select 1 from dual)select * from qn;
with recursive qn as  (select 1 union all select 1 from qn union all select 1)select * from qn;
with recursive qn as  (select 1 from qn union all select 1 from qn)select * from qn;
with recursive qn as  (select 1 from dual union all   select 1 from dual)select * from qn;
with recursive qn as  (select 1 from dual union   select 1 from qn)select * from qn;
eval EXPLAIN FORMAT=tree $query;
eval $query;
create table t1(b int);
insert into t1 values(10),(20),(10);
with recursive qn as  (select max(b) as a from t1 union   select a from qn)select * from qn;
with recursive qn as  (select b as a from t1 union   select max(a) from qn)select * from qn;
with recursive qn as  (select rank() over (order by b) as a from t1 union   select a from qn)select * from qn;
with recursive qn as  (select b as a from t1 union   select rank() over (order by a) from qn)select * from qn;
drop table t1;
with recursive qn as  (select 1 as a from dual union all   select max(a) from qn)select * from qn;
with recursive qn as  (select 1 as a from dual group by a union all   select a+1 from qn where a<3)select * from qn;
with recursive qn as  (select 1 as a from dual union all   select a from qn group by a)select * from qn;
with recursive qn as (select 1 from dual union allselect 1 from dual where 1 not in(select * from qn))select * from qn;
with recursive qn as (select 1 from dual union allselect 1 from qnorder by (select * from qn))select * from qn;
with recursive qn as (select 1 from dual union allselect * from (select * from qn) as dt)select * from qn;
with recursive qn as (select 1 as a from dual union allselect 1 from qnorder by a)select * from qn;
with recursive qn as (select 1 as a from dual union all(select 1 from qn order by a))select * from qn;
with recursive qn as ((select 1 as a from dual order by a) union allselect a+1 from qn where a<3)select * from qn;
with recursive qn as (select 1 as a from dual union all(select 1 from qn limit 10))select * from qn;
WITH RECURSIVE qn AS(select 1 union all select distinct 3 from qn)select * from qn;
with recursive qn as (select 1 from dual union all                      select 1 from dual                        where 1 not in(select * from qn))select * from qn;
with recursive qn as (select 123 as a union all select 1+a from qn where a<130) select * from qn;
with recursive qn as (select 1 as n, 2 as un union all select 1+n, un*5-6 from qn where n<10) select * from qn;
with recursive qn as (select 1 as n, 1 as un, 1 as unp1 union all select 1+n, unp1, un+unp1 from qn where n<10) select * from qn;
create table t(c char(3), vc varchar(3), b binary(3), vb varbinary(3));
create table uselect cast(c as char(4)), cast(vc as char(4)),       cast(b as binary(4)), cast(vb as binary(4)),       "abc" as literal_c, cast("abc" as char(4)),       _binary "abc" as literal_b, cast(_binary "abc" as binary(4))from t;
show create table u;
drop table t,u;
with recursive qn as (select 1 as n, cast('x' as char(100)) as un union all select 1+n, concat(un,'x') from qn where n<10) select * from qn;
with recursive qn as (select cast("x" as char(10)) as a from dualunion all select concat("x",a) from qn where length(a)<10) select *from qn;
with recursive qn as (select "x" as a from dualunion all select concat("x",a) from qn where length(a)<10) select *from qn;
create temporary table tt select "x" as a from dual;
create temporary table tt1 select "x" as a from dual;
insert into tt1 select concat("x",a) from tt where length(a)<10;
drop temporary table tt,tt1;
eval $query;
with recursive qn as (select 1 as a from dualunion all select a*2000 from qn where a<10000000000000000000) select * from qn;
with recursive qn as (select cast(1 as decimal(30,0)) as a from dualunion all select a*2000 from qn where a<10000000000000000000) select * from qn;
with recursive qn as (select 123 as a union allselect null from qn where a is not null) select * from qn;
with recursive qn as (select 1 as a,1union allselect a+1,ST_PointFromText('POINT(10 10)') from qn where a<2)select * from qn;
with recursive qn as (select 1 as a,ST_PointFromText('POINT(10 10)')union allselect a+1,1 from qn where a<2)select * from qn;
WITH RECURSIVE qn ASselect 1union allselect 3, 0 from qnselect * from qn;
with recursive q (b) as (select 1, 1 union all select 1, 1 from q)select b from q;
with recursive qn as (select 123 as a union allselect 1+qn.a from qn, qn as qn1 where qn1.a<130)select * from qn;
flush status;
with recursive qn as (select 123 as a union allselect 1+a from qn where a<125)select * from qn;
show status like "handler_write";
flush status;
with recursive qn as (select 123 as a union allselect 1+a from qn where a<125)select * from qn, qn as qn1;
show status like "handler_write";
show status like 'Created_tmp%table%';
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as (select * from inner_ limit 10)select * from outer_, outer_ as outer1;
show status like "handler_write";
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as(select inner_.a, inner1.a as a1from inner_, inner_ as inner1 limit 10)select * from outer_;
show status like "handler_write";
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as(select a from inner_ union allselect a*2 from outer_ where a<1000)select a from outer_;
show status like "handler_write";
create table t1(a int);
insert into t1 values(1),(2);
WITH RECURSIVE qn ASselect 1 from t1union allselect 1 from t1 straight_join qnselect * from qn;
WITH RECURSIVE qn ASselect 1 from t1union allselect 1 from t1 left join qn on 1select * from qn;
WITH RECURSIVE qn ASselect a from t1 where 0union allselect a+1 from qnselect * from qn;
WITH RECURSIVE qn ASselect a from t1 where a>10union allselect a+1 from qnselect * from qn;
insert into t1 values(1),(2);
set @c=0, @d=0;
WITH RECURSIVE qn ASselect 1,0 as col from t1union distinctselect 1,0 from t1union allselect 3, 0*(@c:=@c+1) from qn where @c<1union allselect 3, 0*(@d:=@d+1) from qn where @d<1select * from qn;
insert into t1 values(1),(2);
set @c=0, @d=0;
WITH RECURSIVE qn ASselect 1,0 as col from t1union distinctselect 3, 0*(@c:=@c+1) from qn where @c<1union allselect 3, 0*(@d:=@d+1) from qn where @d<1select * from qn;
create table t2with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t2;
drop table t2;
delete from t1;
insert into t1with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t1;
delete from t1;
insert into t1 values(1),(2);
insert into t1with recursive qn as (select 123 as a union all select 1+qn.a from qn, t1 where qn.a<125)select * from qn;
select * from t1;
drop table t1;
create temporary table t1(a int);
insert into t1with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t1;
drop table t1;
create view v1 aswith recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from v1;
drop view v1;
with recursive qn (n) as ( select 1 where 0 union all select n+1 from qn where 0) select * from qn;
eval explain $query;
eval $query;
with recursive qn (n) as ( select 1 where 1 union all select n+1 from qn where 0) select * from qn;
eval explain $query;
eval $query;
with recursive q (b) as (select 1 union all select 1+b from q where b<10) select (select q1.b from q as q2 where q2.b=3) from q as q1 where q1.b=3;
eval explain $query;
eval $query;
create table t1(a int);
insert into t1with recursive qn (n) as ( select 1 union all select n+1 from qn where n<10) select * from qn;
select * from t1;
with recursive qn (n) as ( select 5 union all select n+2 from qn where n<10) delete t1 from t1 where a in (select * from qn);
select * from t1;
with recursive qn (n) as ( select 4 union all select n+2 from qn where n<10) delete from t1 where a in (select * from qn);
select * from t1;
with recursive qn (n) as ( select 2 union all select n+2 from qn where n<10) update t1,qn set t1.a=qn.n where t1.a=1+qn.n;
select * from t1;
drop table t1;
CREATE TABLE employees (ID INT PRIMARY KEY,NAME VARCHAR(100),MANAGER_ID INT,INDEX (MANAGER_ID),FOREIGN KEY (MANAGER_ID) REFERENCES employees(ID));
INSERT INTO employees VALUES(333, "Yasmina", NULL),(198, "John", 333),(692, "Tarek", 333),(29, "Pedro", 198),(4610, "Sarah", 29),(72, "Pierre", 29),(123, "Adil", 692);
ANALYZE TABLE employees;
WITH RECURSIVE employees_extended(ID, NAME, PATH)AS  SELECT ID, NAME, CAST(ID AS CHAR(200))  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY PATH;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT 0 AS SEQ, ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT M.SEQ+1, S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY SEQ, NAME;
WITH RECURSIVE employees_extendedAS  SELECT (@s:=0) AS SEQ, ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT (@s:=@s+1), S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY SEQ;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extendedWHERE FIND_IN_SET((SELECT ID FROM employees WHERE NAME='John'),                  PATH);
WITH RECURSIVE employees_extended(ID, NAME, PATH)AS  SELECT ID, NAME, CAST(ID AS CHAR(200))  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_ID),JOHN_ID AS (SELECT ID FROM employees WHERE NAME='John')SELECT e.* FROM employees_extended e, JOHN_IDWHERE FIND_IN_SET(JOHN_ID.ID,                  PATH)      AND e.ID<>JOHN_ID.ID;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='Pierre'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre' OR NAME='Sarah'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre' OR NAME='Sarah'UNION  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
UPDATE employees SET MANAGER_ID=4610 WHERE NAME="John";
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extended(ID, NAME, PATH, IS_CYCLE)AS  SELECT ID, NAME, CAST(ID AS CHAR(200)), 0  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID), FIND_IN_SET(S.ID, M.PATH)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_ID  WHERE M.IS_CYCLE=0SELECT * FROM employees_extended;
DROP TABLE employees;
create table t1 (id int, name char(10), leftpar int, rightpar int);
insert into t1 values(1, "A", 2, 3),  (2, "LA", 4, 5),     (4, "LLA", 6, 7),        (6, "LLLA", null, null),        (7, "RLLA", null, null),     (5, "RLA", 8, 9),        (8, "LRLA", null, null),        (9, "RRLA", null, null),  (3, "RA", 10, 11),     (10, "LRA", 12, 13),     (11, "RRA", 14, 15),        (15, "RRRA", null, null),(16, "B", 17, 18),  (17, "LB", null, null),  (18, "RB", null, null)create table t2 select * from t1 order by rand();
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.leftparunion allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.rightparselect * from tree_of_a;
eval explain $query order by path;
eval $query order by path;
set @optimizer_switch_saved= @@optimizer_switch;
set optimizer_switch='block_nested_loop=off';
eval explain $query order by path;
eval $query order by path;
eval EXPLAIN FORMAT=tree $query order by path;
eval $query;
set @@optimizer_switch=@optimizer_switch_saved;
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a on(t2.id=tree_of_a.leftpar or t2.id=tree_of_a.rightpar)select * from tree_of_aorder by path;
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.leftparunion allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.rightparselect * from tree_of_a where id=2;
eval explain $query;
eval $query;
drop table t1,t2;
with recursive cte as  select 1 as n union all  select n+1 from cte where n<10000select /*+ no_bnl(cte3) */sum(cte1.n*cte2.n*cte3.n)=2490508525950000from cte cte1, cte cte2, cte cte3where cte1.n=cte2.n+10 and cte2.n+20=cte3.n;
eval explain $query;
eval $query;
create table nodes(id int);
create table arcs(from_id int, to_id int);
insert into nodes values(1),(2),(3),(4),(5),(6),(7),(8);
insert into arcs values(1,3), (3,6), (1,4), (4,6), (6,2), (2,1);
with recursive cte as  select id, 0 as depth from nodes where id=1  union all  select to_id, depth+1 from arcs, cte  where from_id=cte.id and depth<8select count(*), max(depth) from cte;
with recursive cte as  select id, cast(id as char(200)) as path, 0 as is_cycle  from nodes where id=1  union all  select to_id, concat(cte.path, ",", to_id), find_in_set(to_id, path)  from arcs, cte  where from_id=cte.id and is_cycle=0select * from cte;
with recursive cte as  select id from nodes where id=1  union  select to_id from arcs, cte where from_id=cte.idselect * from cte;
drop table nodes, arcs;
flush status;
with recursive cte as (  select 1 as n,  repeat('a',500) as f, '' as g,  '' as h, '' as i  union  select n+1,  '','','',''  from cte where n<100)select sum(n) from cte;
show status like 'Created_tmp_disk_tables';
with recursive cte as (  select 1 as n,  repeat('a',500) as f, repeat('a',500) as g,  repeat('a',500) as h, repeat('a',500) as i,  repeat('a',500) as j, repeat('a',500) as k,  repeat('a',500) as l, repeat('a',500) as m  union  select n+1,  '','','','','','','',''  from cte where n<100)select sum(n) from cte;
flush status;
create table t1(a int);
insert into t1 values (), (), (), (), (), (), (), (), (), (), (), (),(), (), ();
analyze table t1;
explain with recursive qn as(select 1 as a from t1 union all select a+1 from qn where qn.a<100)select * from qn;
explain with recursive qn as(select 1 as a from t1 union distinct select a+1 from qn where qn.a<100)select * from qn;
drop table t1;
show status like 'Created_tmp_disk_tables';
set big_tables=0;
set big_tables=1;
set cte_max_recursion_depth=50000;
select @@cte_max_recursion_depth;
flush status;
with recursive qn as (select * from qn2),               qn2 as (select * from qn)select * from qn;
with recursive qn as  (select 1 from qn)select * from qn;
with recursive qn as  (select 1 from qn union all   select 1 from dual)select * from qn;
with recursive qn as  (select 1 union all select 1 from qn union all select 1)select * from qn;
with recursive qn as  (select 1 from qn union all select 1 from qn)select * from qn;
with recursive qn as  (select 1 from dual union all   select 1 from dual)select * from qn;
with recursive qn as  (select 1 from dual union   select 1 from qn)select * from qn;
eval EXPLAIN FORMAT=tree $query;
eval $query;
create table t1(b int);
insert into t1 values(10),(20),(10);
with recursive qn as  (select max(b) as a from t1 union   select a from qn)select * from qn;
with recursive qn as  (select b as a from t1 union   select max(a) from qn)select * from qn;
with recursive qn as  (select rank() over (order by b) as a from t1 union   select a from qn)select * from qn;
with recursive qn as  (select b as a from t1 union   select rank() over (order by a) from qn)select * from qn;
drop table t1;
with recursive qn as  (select 1 as a from dual union all   select max(a) from qn)select * from qn;
with recursive qn as  (select 1 as a from dual group by a union all   select a+1 from qn where a<3)select * from qn;
with recursive qn as  (select 1 as a from dual union all   select a from qn group by a)select * from qn;
with recursive qn as (select 1 from dual union allselect 1 from dual where 1 not in(select * from qn))select * from qn;
with recursive qn as (select 1 from dual union allselect 1 from qnorder by (select * from qn))select * from qn;
with recursive qn as (select 1 from dual union allselect * from (select * from qn) as dt)select * from qn;
with recursive qn as (select 1 as a from dual union allselect 1 from qnorder by a)select * from qn;
with recursive qn as (select 1 as a from dual union all(select 1 from qn order by a))select * from qn;
with recursive qn as ((select 1 as a from dual order by a) union allselect a+1 from qn where a<3)select * from qn;
with recursive qn as (select 1 as a from dual union all(select 1 from qn limit 10))select * from qn;
WITH RECURSIVE qn AS(select 1 union all select distinct 3 from qn)select * from qn;
with recursive qn as (select 1 from dual union all                      select 1 from dual                        where 1 not in(select * from qn))select * from qn;
with recursive qn as (select 123 as a union all select 1+a from qn where a<130) select * from qn;
with recursive qn as (select 1 as n, 2 as un union all select 1+n, un*5-6 from qn where n<10) select * from qn;
with recursive qn as (select 1 as n, 1 as un, 1 as unp1 union all select 1+n, unp1, un+unp1 from qn where n<10) select * from qn;
create table t(c char(3), vc varchar(3), b binary(3), vb varbinary(3));
create table uselect cast(c as char(4)), cast(vc as char(4)),       cast(b as binary(4)), cast(vb as binary(4)),       "abc" as literal_c, cast("abc" as char(4)),       _binary "abc" as literal_b, cast(_binary "abc" as binary(4))from t;
show create table u;
drop table t,u;
with recursive qn as (select 1 as n, cast('x' as char(100)) as un union all select 1+n, concat(un,'x') from qn where n<10) select * from qn;
with recursive qn as (select cast("x" as char(10)) as a from dualunion all select concat("x",a) from qn where length(a)<10) select *from qn;
with recursive qn as (select "x" as a from dualunion all select concat("x",a) from qn where length(a)<10) select *from qn;
create temporary table tt select "x" as a from dual;
create temporary table tt1 select "x" as a from dual;
insert into tt1 select concat("x",a) from tt where length(a)<10;
drop temporary table tt,tt1;
eval $query;
with recursive qn as (select 1 as a from dualunion all select a*2000 from qn where a<10000000000000000000) select * from qn;
with recursive qn as (select cast(1 as decimal(30,0)) as a from dualunion all select a*2000 from qn where a<10000000000000000000) select * from qn;
with recursive qn as (select 123 as a union allselect null from qn where a is not null) select * from qn;
with recursive qn as (select 1 as a,1union allselect a+1,ST_PointFromText('POINT(10 10)') from qn where a<2)select * from qn;
with recursive qn as (select 1 as a,ST_PointFromText('POINT(10 10)')union allselect a+1,1 from qn where a<2)select * from qn;
WITH RECURSIVE qn ASselect 1union allselect 3, 0 from qnselect * from qn;
with recursive q (b) as (select 1, 1 union all select 1, 1 from q)select b from q;
with recursive qn as (select 123 as a union allselect 1+qn.a from qn, qn as qn1 where qn1.a<130)select * from qn;
flush status;
with recursive qn as (select 123 as a union allselect 1+a from qn where a<125)select * from qn;
show status like "handler_write";
flush status;
with recursive qn as (select 123 as a union allselect 1+a from qn where a<125)select * from qn, qn as qn1;
show status like "handler_write";
show status like 'Created_tmp%table%';
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as (select * from inner_ limit 10)select * from outer_, outer_ as outer1;
show status like "handler_write";
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as(select inner_.a, inner1.a as a1from inner_, inner_ as inner1 limit 10)select * from outer_;
show status like "handler_write";
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as(select a from inner_ union allselect a*2 from outer_ where a<1000)select a from outer_;
show status like "handler_write";
create table t1(a int);
insert into t1 values(1),(2);
WITH RECURSIVE qn ASselect 1 from t1union allselect 1 from t1 straight_join qnselect * from qn;
WITH RECURSIVE qn ASselect 1 from t1union allselect 1 from t1 left join qn on 1select * from qn;
WITH RECURSIVE qn ASselect a from t1 where 0union allselect a+1 from qnselect * from qn;
WITH RECURSIVE qn ASselect a from t1 where a>10union allselect a+1 from qnselect * from qn;
insert into t1 values(1),(2);
set @c=0, @d=0;
WITH RECURSIVE qn ASselect 1,0 as col from t1union distinctselect 1,0 from t1union allselect 3, 0*(@c:=@c+1) from qn where @c<1union allselect 3, 0*(@d:=@d+1) from qn where @d<1select * from qn;
insert into t1 values(1),(2);
set @c=0, @d=0;
WITH RECURSIVE qn ASselect 1,0 as col from t1union distinctselect 3, 0*(@c:=@c+1) from qn where @c<1union allselect 3, 0*(@d:=@d+1) from qn where @d<1select * from qn;
create table t2with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t2;
drop table t2;
delete from t1;
insert into t1with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t1;
delete from t1;
insert into t1 values(1),(2);
insert into t1with recursive qn as (select 123 as a union all select 1+qn.a from qn, t1 where qn.a<125)select * from qn;
select * from t1;
drop table t1;
create temporary table t1(a int);
insert into t1with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t1;
drop table t1;
create view v1 aswith recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from v1;
drop view v1;
with recursive qn (n) as ( select 1 where 0 union all select n+1 from qn where 0) select * from qn;
eval explain $query;
eval $query;
with recursive qn (n) as ( select 1 where 1 union all select n+1 from qn where 0) select * from qn;
eval explain $query;
eval $query;
with recursive q (b) as (select 1 union all select 1+b from q where b<10) select (select q1.b from q as q2 where q2.b=3) from q as q1 where q1.b=3;
eval explain $query;
eval $query;
create table t1(a int);
insert into t1with recursive qn (n) as ( select 1 union all select n+1 from qn where n<10) select * from qn;
select * from t1;
with recursive qn (n) as ( select 5 union all select n+2 from qn where n<10) delete t1 from t1 where a in (select * from qn);
select * from t1;
with recursive qn (n) as ( select 4 union all select n+2 from qn where n<10) delete from t1 where a in (select * from qn);
select * from t1;
with recursive qn (n) as ( select 2 union all select n+2 from qn where n<10) update t1,qn set t1.a=qn.n where t1.a=1+qn.n;
select * from t1;
drop table t1;
CREATE TABLE employees (ID INT PRIMARY KEY,NAME VARCHAR(100),MANAGER_ID INT,INDEX (MANAGER_ID),FOREIGN KEY (MANAGER_ID) REFERENCES employees(ID));
INSERT INTO employees VALUES(333, "Yasmina", NULL),(198, "John", 333),(692, "Tarek", 333),(29, "Pedro", 198),(4610, "Sarah", 29),(72, "Pierre", 29),(123, "Adil", 692);
ANALYZE TABLE employees;
WITH RECURSIVE employees_extended(ID, NAME, PATH)AS  SELECT ID, NAME, CAST(ID AS CHAR(200))  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY PATH;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT 0 AS SEQ, ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT M.SEQ+1, S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY SEQ, NAME;
WITH RECURSIVE employees_extendedAS  SELECT (@s:=0) AS SEQ, ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT (@s:=@s+1), S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY SEQ;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extendedWHERE FIND_IN_SET((SELECT ID FROM employees WHERE NAME='John'),                  PATH);
WITH RECURSIVE employees_extended(ID, NAME, PATH)AS  SELECT ID, NAME, CAST(ID AS CHAR(200))  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_ID),JOHN_ID AS (SELECT ID FROM employees WHERE NAME='John')SELECT e.* FROM employees_extended e, JOHN_IDWHERE FIND_IN_SET(JOHN_ID.ID,                  PATH)      AND e.ID<>JOHN_ID.ID;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='Pierre'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre' OR NAME='Sarah'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre' OR NAME='Sarah'UNION  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
UPDATE employees SET MANAGER_ID=4610 WHERE NAME="John";
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extended(ID, NAME, PATH, IS_CYCLE)AS  SELECT ID, NAME, CAST(ID AS CHAR(200)), 0  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID), FIND_IN_SET(S.ID, M.PATH)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_ID  WHERE M.IS_CYCLE=0SELECT * FROM employees_extended;
DROP TABLE employees;
create table t1 (id int, name char(10), leftpar int, rightpar int);
insert into t1 values(1, "A", 2, 3),  (2, "LA", 4, 5),     (4, "LLA", 6, 7),        (6, "LLLA", null, null),        (7, "RLLA", null, null),     (5, "RLA", 8, 9),        (8, "LRLA", null, null),        (9, "RRLA", null, null),  (3, "RA", 10, 11),     (10, "LRA", 12, 13),     (11, "RRA", 14, 15),        (15, "RRRA", null, null),(16, "B", 17, 18),  (17, "LB", null, null),  (18, "RB", null, null)create table t2 select * from t1 order by rand();
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.leftparunion allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.rightparselect * from tree_of_a;
eval explain $query order by path;
eval $query order by path;
set @optimizer_switch_saved= @@optimizer_switch;
set optimizer_switch='block_nested_loop=off';
eval explain $query order by path;
eval $query order by path;
eval EXPLAIN FORMAT=tree $query order by path;
eval $query;
set @@optimizer_switch=@optimizer_switch_saved;
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a on(t2.id=tree_of_a.leftpar or t2.id=tree_of_a.rightpar)select * from tree_of_aorder by path;
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.leftparunion allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.rightparselect * from tree_of_a where id=2;
eval explain $query;
eval $query;
drop table t1,t2;
with recursive cte as  select 1 as n union all  select n+1 from cte where n<10000select /*+ no_bnl(cte3) */sum(cte1.n*cte2.n*cte3.n)=2490508525950000from cte cte1, cte cte2, cte cte3where cte1.n=cte2.n+10 and cte2.n+20=cte3.n;
eval explain $query;
eval $query;
create table nodes(id int);
create table arcs(from_id int, to_id int);
insert into nodes values(1),(2),(3),(4),(5),(6),(7),(8);
insert into arcs values(1,3), (3,6), (1,4), (4,6), (6,2), (2,1);
with recursive cte as  select id, 0 as depth from nodes where id=1  union all  select to_id, depth+1 from arcs, cte  where from_id=cte.id and depth<8select count(*), max(depth) from cte;
with recursive cte as  select id, cast(id as char(200)) as path, 0 as is_cycle  from nodes where id=1  union all  select to_id, concat(cte.path, ",", to_id), find_in_set(to_id, path)  from arcs, cte  where from_id=cte.id and is_cycle=0select * from cte;
with recursive cte as  select id from nodes where id=1  union  select to_id from arcs, cte where from_id=cte.idselect * from cte;
drop table nodes, arcs;
flush status;
with recursive cte as (  select 1 as n,  repeat('a',500) as f, '' as g,  '' as h, '' as i  union  select n+1,  '','','',''  from cte where n<100)select sum(n) from cte;
show status like 'Created_tmp_disk_tables';
with recursive cte as (  select 1 as n,  repeat('a',500) as f, repeat('a',500) as g,  repeat('a',500) as h, repeat('a',500) as i,  repeat('a',500) as j, repeat('a',500) as k,  repeat('a',500) as l, repeat('a',500) as m  union  select n+1,  '','','','','','','',''  from cte where n<100)select sum(n) from cte;
flush status;
create table t1(a int);
insert into t1 values (), (), (), (), (), (), (), (), (), (), (), (),(), (), ();
analyze table t1;
explain with recursive qn as(select 1 as a from t1 union all select a+1 from qn where qn.a<100)select * from qn;
explain with recursive qn as(select 1 as a from t1 union distinct select a+1 from qn where qn.a<100)select * from qn;
drop table t1;
show status like 'Created_tmp_disk_tables';
set cte_max_recursion_depth=50000;
select @@cte_max_recursion_depth;
flush status;
with recursive qn as (select * from qn2),               qn2 as (select * from qn)select * from qn;
with recursive qn as  (select 1 from qn)select * from qn;
with recursive qn as  (select 1 from qn union all   select 1 from dual)select * from qn;
with recursive qn as  (select 1 union all select 1 from qn union all select 1)select * from qn;
with recursive qn as  (select 1 from qn union all select 1 from qn)select * from qn;
with recursive qn as  (select 1 from dual union all   select 1 from dual)select * from qn;
with recursive qn as  (select 1 from dual union   select 1 from qn)select * from qn;
eval EXPLAIN FORMAT=tree $query;
eval $query;
create table t1(b int);
insert into t1 values(10),(20),(10);
with recursive qn as  (select max(b) as a from t1 union   select a from qn)select * from qn;
with recursive qn as  (select b as a from t1 union   select max(a) from qn)select * from qn;
with recursive qn as  (select rank() over (order by b) as a from t1 union   select a from qn)select * from qn;
with recursive qn as  (select b as a from t1 union   select rank() over (order by a) from qn)select * from qn;
drop table t1;
with recursive qn as  (select 1 as a from dual union all   select max(a) from qn)select * from qn;
with recursive qn as  (select 1 as a from dual group by a union all   select a+1 from qn where a<3)select * from qn;
with recursive qn as  (select 1 as a from dual union all   select a from qn group by a)select * from qn;
with recursive qn as (select 1 from dual union allselect 1 from dual where 1 not in(select * from qn))select * from qn;
with recursive qn as (select 1 from dual union allselect 1 from qnorder by (select * from qn))select * from qn;
with recursive qn as (select 1 from dual union allselect * from (select * from qn) as dt)select * from qn;
with recursive qn as (select 1 as a from dual union allselect 1 from qnorder by a)select * from qn;
with recursive qn as (select 1 as a from dual union all(select 1 from qn order by a))select * from qn;
with recursive qn as ((select 1 as a from dual order by a) union allselect a+1 from qn where a<3)select * from qn;
with recursive qn as (select 1 as a from dual union all(select 1 from qn limit 10))select * from qn;
WITH RECURSIVE qn AS(select 1 union all select distinct 3 from qn)select * from qn;
with recursive qn as (select 1 from dual union all                      select 1 from dual                        where 1 not in(select * from qn))select * from qn;
with recursive qn as (select 123 as a union all select 1+a from qn where a<130) select * from qn;
with recursive qn as (select 1 as n, 2 as un union all select 1+n, un*5-6 from qn where n<10) select * from qn;
with recursive qn as (select 1 as n, 1 as un, 1 as unp1 union all select 1+n, unp1, un+unp1 from qn where n<10) select * from qn;
create table t(c char(3), vc varchar(3), b binary(3), vb varbinary(3));
create table uselect cast(c as char(4)), cast(vc as char(4)),       cast(b as binary(4)), cast(vb as binary(4)),       "abc" as literal_c, cast("abc" as char(4)),       _binary "abc" as literal_b, cast(_binary "abc" as binary(4))from t;
show create table u;
drop table t,u;
with recursive qn as (select 1 as n, cast('x' as char(100)) as un union all select 1+n, concat(un,'x') from qn where n<10) select * from qn;
with recursive qn as (select cast("x" as char(10)) as a from dualunion all select concat("x",a) from qn where length(a)<10) select *from qn;
with recursive qn as (select "x" as a from dualunion all select concat("x",a) from qn where length(a)<10) select *from qn;
create temporary table tt select "x" as a from dual;
create temporary table tt1 select "x" as a from dual;
insert into tt1 select concat("x",a) from tt where length(a)<10;
drop temporary table tt,tt1;
eval $query;
with recursive qn as (select 1 as a from dualunion all select a*2000 from qn where a<10000000000000000000) select * from qn;
with recursive qn as (select cast(1 as decimal(30,0)) as a from dualunion all select a*2000 from qn where a<10000000000000000000) select * from qn;
with recursive qn as (select 123 as a union allselect null from qn where a is not null) select * from qn;
with recursive qn as (select 1 as a,1union allselect a+1,ST_PointFromText('POINT(10 10)') from qn where a<2)select * from qn;
with recursive qn as (select 1 as a,ST_PointFromText('POINT(10 10)')union allselect a+1,1 from qn where a<2)select * from qn;
WITH RECURSIVE qn ASselect 1union allselect 3, 0 from qnselect * from qn;
with recursive q (b) as (select 1, 1 union all select 1, 1 from q)select b from q;
with recursive qn as (select 123 as a union allselect 1+qn.a from qn, qn as qn1 where qn1.a<130)select * from qn;
flush status;
with recursive qn as (select 123 as a union allselect 1+a from qn where a<125)select * from qn;
show status like "handler_write";
flush status;
with recursive qn as (select 123 as a union allselect 1+a from qn where a<125)select * from qn, qn as qn1;
show status like "handler_write";
show status like 'Created_tmp%table%';
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as (select * from inner_ limit 10)select * from outer_, outer_ as outer1;
show status like "handler_write";
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as(select inner_.a, inner1.a as a1from inner_, inner_ as inner1 limit 10)select * from outer_;
show status like "handler_write";
flush status;
with recursive inner_ as (select 123 as a union allselect 1+a from inner_ where a<125),outer_ as(select a from inner_ union allselect a*2 from outer_ where a<1000)select a from outer_;
show status like "handler_write";
create table t1(a int);
insert into t1 values(1),(2);
WITH RECURSIVE qn ASselect 1 from t1union allselect 1 from t1 straight_join qnselect * from qn;
WITH RECURSIVE qn ASselect 1 from t1union allselect 1 from t1 left join qn on 1select * from qn;
WITH RECURSIVE qn ASselect a from t1 where 0union allselect a+1 from qnselect * from qn;
WITH RECURSIVE qn ASselect a from t1 where a>10union allselect a+1 from qnselect * from qn;
insert into t1 values(1),(2);
set @c=0, @d=0;
WITH RECURSIVE qn ASselect 1,0 as col from t1union distinctselect 1,0 from t1union allselect 3, 0*(@c:=@c+1) from qn where @c<1union allselect 3, 0*(@d:=@d+1) from qn where @d<1select * from qn;
insert into t1 values(1),(2);
set @c=0, @d=0;
WITH RECURSIVE qn ASselect 1,0 as col from t1union distinctselect 3, 0*(@c:=@c+1) from qn where @c<1union allselect 3, 0*(@d:=@d+1) from qn where @d<1select * from qn;
create table t2with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t2;
drop table t2;
delete from t1;
insert into t1with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t1;
delete from t1;
insert into t1 values(1),(2);
insert into t1with recursive qn as (select 123 as a union all select 1+qn.a from qn, t1 where qn.a<125)select * from qn;
select * from t1;
drop table t1;
create temporary table t1(a int);
insert into t1with recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from t1;
drop table t1;
create view v1 aswith recursive qn as (select 123 as a union all select 1+a from qn where a<130)select * from qn;
select * from v1;
drop view v1;
with recursive qn (n) as ( select 1 where 0 union all select n+1 from qn where 0) select * from qn;
eval explain $query;
eval $query;
with recursive qn (n) as ( select 1 where 1 union all select n+1 from qn where 0) select * from qn;
eval explain $query;
eval $query;
with recursive q (b) as (select 1 union all select 1+b from q where b<10) select (select q1.b from q as q2 where q2.b=3) from q as q1 where q1.b=3;
eval explain $query;
eval $query;
create table t1(a int);
insert into t1with recursive qn (n) as ( select 1 union all select n+1 from qn where n<10) select * from qn;
select * from t1;
with recursive qn (n) as ( select 5 union all select n+2 from qn where n<10) delete t1 from t1 where a in (select * from qn);
select * from t1;
with recursive qn (n) as ( select 4 union all select n+2 from qn where n<10) delete from t1 where a in (select * from qn);
select * from t1;
with recursive qn (n) as ( select 2 union all select n+2 from qn where n<10) update t1,qn set t1.a=qn.n where t1.a=1+qn.n;
select * from t1;
drop table t1;
CREATE TABLE employees (ID INT PRIMARY KEY,NAME VARCHAR(100),MANAGER_ID INT,INDEX (MANAGER_ID),FOREIGN KEY (MANAGER_ID) REFERENCES employees(ID));
INSERT INTO employees VALUES(333, "Yasmina", NULL),(198, "John", 333),(692, "Tarek", 333),(29, "Pedro", 198),(4610, "Sarah", 29),(72, "Pierre", 29),(123, "Adil", 692);
ANALYZE TABLE employees;
WITH RECURSIVE employees_extended(ID, NAME, PATH)AS  SELECT ID, NAME, CAST(ID AS CHAR(200))  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY PATH;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT 0 AS SEQ, ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT M.SEQ+1, S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY SEQ, NAME;
WITH RECURSIVE employees_extendedAS  SELECT (@s:=0) AS SEQ, ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT (@s:=@s+1), S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended ORDER BY SEQ;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extendedWHERE FIND_IN_SET((SELECT ID FROM employees WHERE NAME='John'),                  PATH);
WITH RECURSIVE employees_extended(ID, NAME, PATH)AS  SELECT ID, NAME, CAST(ID AS CHAR(200))  FROM employees  WHERE MANAGER_ID IS NULLUNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_ID),JOHN_ID AS (SELECT ID FROM employees WHERE NAME='John')SELECT e.* FROM employees_extended e, JOHN_IDWHERE FIND_IN_SET(JOHN_ID.ID,                  PATH)      AND e.ID<>JOHN_ID.ID;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='Pierre'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre' OR NAME='Sarah'UNION ALL  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, MANAGER_ID  FROM employees  WHERE NAME='Pierre' OR NAME='Sarah'UNION  SELECT S.ID, S.NAME, S.MANAGER_ID  FROM employees_extended M JOIN employees S ON M.MANAGER_ID=S.IDSELECT * FROM employees_extended;
UPDATE employees SET MANAGER_ID=4610 WHERE NAME="John";
WITH RECURSIVE employees_extendedAS  SELECT ID, NAME, CAST(ID AS CHAR(200)) AS PATH  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_IDSELECT * FROM employees_extended;
WITH RECURSIVE employees_extended(ID, NAME, PATH, IS_CYCLE)AS  SELECT ID, NAME, CAST(ID AS CHAR(200)), 0  FROM employees  WHERE NAME='John'UNION ALL  SELECT S.ID, S.NAME, CONCAT(M.PATH, ",", S.ID), FIND_IN_SET(S.ID, M.PATH)  FROM employees_extended M STRAIGHT_JOIN employees S ON M.ID=S.MANAGER_ID  WHERE M.IS_CYCLE=0SELECT * FROM employees_extended;
DROP TABLE employees;
create table t1 (id int, name char(10), leftpar int, rightpar int);
insert into t1 values(1, "A", 2, 3),  (2, "LA", 4, 5),     (4, "LLA", 6, 7),        (6, "LLLA", null, null),        (7, "RLLA", null, null),     (5, "RLA", 8, 9),        (8, "LRLA", null, null),        (9, "RRLA", null, null),  (3, "RA", 10, 11),     (10, "LRA", 12, 13),     (11, "RRA", 14, 15),        (15, "RRRA", null, null),(16, "B", 17, 18),  (17, "LB", null, null),  (18, "RB", null, null)create table t2 select * from t1 order by rand();
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.leftparunion allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.rightparselect * from tree_of_a;
eval explain $query order by path;
eval $query order by path;
set @optimizer_switch_saved= @@optimizer_switch;
set optimizer_switch='block_nested_loop=off';
eval explain $query order by path;
eval $query order by path;
eval EXPLAIN FORMAT=tree $query order by path;
eval $query;
set @@optimizer_switch=@optimizer_switch_saved;
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a on(t2.id=tree_of_a.leftpar or t2.id=tree_of_a.rightpar)select * from tree_of_aorder by path;
with recursive tree_of_a asselect *, cast(id as char(200)) as path from t2 where name="A"union allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.leftparunion allselect t2.*, concat(tree_of_a.path,",",t2.id) from t2 join tree_of_a ont2.id=tree_of_a.rightparselect * from tree_of_a where id=2;
eval explain $query;
eval $query;
drop table t1,t2;
with recursive cte as  select 1 as n union all  select n+1 from cte where n<10000select /*+ no_bnl(cte3) */sum(cte1.n*cte2.n*cte3.n)=2490508525950000from cte cte1, cte cte2, cte cte3where cte1.n=cte2.n+10 and cte2.n+20=cte3.n;
eval explain $query;
eval $query;
create table nodes(id int);
create table arcs(from_id int, to_id int);
insert into nodes values(1),(2),(3),(4),(5),(6),(7),(8);
insert into arcs values(1,3), (3,6), (1,4), (4,6), (6,2), (2,1);
with recursive cte as  select id, 0 as depth from nodes where id=1  union all  select to_id, depth+1 from arcs, cte  where from_id=cte.id and depth<8select count(*), max(depth) from cte;
with recursive cte as  select id, cast(id as char(200)) as path, 0 as is_cycle  from nodes where id=1  union all  select to_id, concat(cte.path, ",", to_id), find_in_set(to_id, path)  from arcs, cte  where from_id=cte.id and is_cycle=0select * from cte;
with recursive cte as  select id from nodes where id=1  union  select to_id from arcs, cte where from_id=cte.idselect * from cte;
drop table nodes, arcs;
flush status;
with recursive cte as (  select 1 as n,  repeat('a',500) as f, '' as g,  '' as h, '' as i  union  select n+1,  '','','',''  from cte where n<100)select sum(n) from cte;
show status like 'Created_tmp_disk_tables';
with recursive cte as (  select 1 as n,  repeat('a',500) as f, repeat('a',500) as g,  repeat('a',500) as h, repeat('a',500) as i,  repeat('a',500) as j, repeat('a',500) as k,  repeat('a',500) as l, repeat('a',500) as m  union  select n+1,  '','','','','','','',''  from cte where n<100)select sum(n) from cte;
flush status;
create table t1(a int);
insert into t1 values (), (), (), (), (), (), (), (), (), (), (), (),(), (), ();
analyze table t1;
explain with recursive qn as(select 1 as a from t1 union all select a+1 from qn where qn.a<100)select * from qn;
explain with recursive qn as(select 1 as a from t1 union distinct select a+1 from qn where qn.a<100)select * from qn;
drop table t1;
show status like 'Created_tmp_disk_tables';
set big_tables=0;
set big_tables=1;
