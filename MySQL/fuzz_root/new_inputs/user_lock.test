connection default;
SELECT IS_USED_LOCK('test') IS NULL AS expect_1;
SELECT IS_FREE_LOCK('test') = 1 AS expect_1;
SELECT RELEASE_LOCK('test') IS NULL AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 0 AS expect_1;
SELECT GET_LOCK('test', 0) = 1 AS expect_1;
SELECT IS_USED_LOCK('test') = CONNECTION_ID() AS expect_1;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
connect (con1,localhost,root,,);
connection con1;
eval SET @aux = $default_id;
SELECT IS_USED_LOCK('test') = @aux AS expect_1;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
SELECT GET_LOCK('test', 0) = 0 expect_1;
SELECT RELEASE_LOCK('test') = 0 AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 0 AS expect_1;
connection default;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
SELECT RELEASE_LOCK('test') IS NULL;
SELECT GET_LOCK('test1',0);
SELECT GET_LOCK('test2',0);
SELECT IS_USED_LOCK('test1') = CONNECTION_ID()   AND IS_USED_LOCK('test2') = CONNECTION_ID() AS expect_1;
SELECT RELEASE_LOCK('test1') = 1 AS expect_1;
SELECT IS_FREE_LOCK('test1') = 1 AS expect_1;
SELECT IS_FREE_LOCK('test2') = 0 AS expect_1;
SELECT RELEASE_LOCK('test2') = 1 AS expect_1;
SELECT GET_LOCK('test1',0);
SELECT GET_LOCK('test2',0);
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT IS_FREE_LOCK('test1') AND IS_FREE_LOCK('test2') AS expect_1;
SELECT GET_LOCK('test1',0), GET_LOCK('test2',0);
SELECT IS_USED_LOCK('test1') = CONNECTION_ID()   AND IS_USED_LOCK('test2') = CONNECTION_ID() AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT IS_USED_LOCK('test1') IS NULL AND IS_USED_LOCK('test2') IS NULL AS expect_1;
SELECT GET_LOCK('test1',0) FROM (SELECT 1 AS col1) AS my_tabWHERE GET_LOCK('test2',0) = 1;
SELECT IS_USED_LOCK('test1') = CONNECTION_ID()   AND IS_USED_LOCK('test2') = CONNECTION_ID() AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT IS_USED_LOCK('test1') IS NULL AND IS_USED_LOCK('test2') IS NULL AS expect_1;
SELECT GET_LOCK(col1,0) FROM (SELECT 'test1' AS col1 UNION SELECT 'test2') AS my_tab;
SELECT IS_USED_LOCK('test1') = CONNECTION_ID()   AND IS_USED_LOCK('test2') = CONNECTION_ID() AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT IS_USED_LOCK('test1') IS NULL AND IS_USED_LOCK('test2') IS NULL AS expect_1;
SELECT GET_LOCK('test', 0);
SELECT GET_LOCK('test', 0);
SELECT GET_LOCK('test', 0);
SELECT RELEASE_LOCK('test');
SELECT RELEASE_LOCK('test');
SELECT RELEASE_LOCK('test');
SELECT RELEASE_LOCK('test') IS NULL AS expect_1;
SELECT GET_LOCK('test', 0), GET_LOCK('test', 0);
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT GET_LOCK('test', 0);
connection con1;
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state='User lock';
source include/wait_condition.inc;
eval SET @aux = $con1_id;
KILL QUERY @aux;
connection con1;
reap;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
SELECT IS_USED_LOCK('test') <> CONNECTION_ID() AS expect_1;
connection default;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
connection con1;
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state='User sleep';
source include/wait_condition.inc;
eval SET @aux = $con1_id;
eval KILL QUERY @aux;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
connection con1;
reap;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
SELECT IS_USED_LOCK('test') = CONNECTION_ID() AS expect_1;
connection default;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
connection con1;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
connection con1;
SELECT GET_LOCK('test1', 0);
SELECT GET_LOCK('test1', 0);
connection default;
SELECT IS_FREE_LOCK('test1') = 0 AS expect_1;
eval SET @aux = $con1_id;
eval KILL @aux;
                     WHERE id = $con1_id;
source include/wait_condition.inc;
SELECT IS_FREE_LOCK('test1') = 1 AS expect_1;
connection con1;
disconnect con1;
connect (con1,localhost,root,,);
connection default;
SELECT GET_LOCK('test1', 0);
connection con1;
SELECT GET_LOCK('test2', 0);
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state='User lock';
source include/wait_condition.inc;
SELECT GET_LOCK('test2', 7200);
SELECT RELEASE_LOCK('test1');
connection con1;
reap;
SELECT RELEASE_LOCK('test2') + RELEASE_LOCK('test1') = 2 AS expect_1;
connection default;
CREATE TABLE t1 (id INT);
SELECT GET_LOCK('test1', 0);
LOCK TABLE t1 WRITE;
SELECT GET_LOCK('test2', 0);
UNLOCK TABLES;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT GET_LOCK('test1', 0);
FLUSH TABLES WITH READ LOCK;
SELECT GET_LOCK('test2', 0);
UNLOCK TABLES;
SELECT (RELEASE_LOCK('test1') = 1) AND (RELEASE_LOCK('test3') IS NULL)   AND (RELEASE_LOCK('test2') = 1) AS expect_1;
DELETE FROM t1;
BEGIN;
INSERT INTO t1 SET id = 1;
SELECT GET_LOCK('test1', 0);
COMMIT;
BEGIN;
INSERT INTO t1 SET id = 2;
SELECT GET_LOCK('test2', 0);
ROLLBACK;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT id FROM t1 ORDER BY id;
DELETE FROM t1;
SELECT GET_LOCK('test', 0);
connection con1;
BEGIN;
INSERT INTO t1 VALUES (1);
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state = 'User lock';
source include/wait_condition.inc;
eval $stmt1;
connection con1;
reap;
                     WHERE info LIKE 'rename%' AND state = 'Waiting for table metadata lock';
source include/wait_condition.inc;
COMMIT;
connection default;
reap;
RENAME TABLE t2 TO t1;
SELECT RELEASE_LOCK('test');
connection con1;
SELECT COUNT(*) = 1 AS expect_1 FROM t1 WHERE id = 1;
connection default;
SELECT GET_LOCK('test', 0);
connection con1;
LOCK TABLE t1 WRITE;
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state = 'User lock';
source include/wait_condition.inc;
SELECT COUNT(*) FROM t1;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
connection con1;
reap;
SELECT RELEASE_LOCK('test');
UNLOCK TABLES;
connection default;
DELETE FROM t1;
CREATE TRIGGER trig_t1_ins BEFORE INSERT ON t1 FOR EACH ROWSET @aux = GET_LOCK(new.id,7200);
SELECT GET_LOCK(CAST(2 AS CHAR),0);
INSERT INTO t1 VALUES(1),(2),(3);
SELECT RELEASE_LOCK(1) = 1 AS expect_1;
SELECT RELEASE_LOCK(2) = 1 AS expect_1;
SELECT RELEASE_LOCK(2) = 1 AS expect_1;
SELECT RELEASE_LOCK(3) = 1 AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 0 AS expect_1;
SELECT COUNT(*) FROM t1;
connection default;
DELETE FROM t1;
SELECT GET_LOCK(2,0);
connection con1;
eval $stmt;
connection default;
                     WHERE info LIKE 'SET @aux%' AND state = 'User lock';
source include/wait_condition.inc;
RENAME TABLE t1 TO t1x;
RENAME TABLE t1x TO t1;
connection con1;
reap;
SELECT RELEASE_ALL_LOCKS();
SELECT COUNT(*) FROM t1;
connection default;
SELECT RELEASE_ALL_LOCKS();
connection default;
DELETE FROM t1;
DROP TRIGGER trig_t1_ins;
CREATE TRIGGER trig_t1_ins BEFORE INSERT ON t1 FOR EACH ROWBEGIN  SET @aux = GET_LOCK(2,1);
  IF @aux <> 1 THEN      SIGNAL SQLSTATE '45000'      SET MESSAGE_TEXT = 'LOCK 2 not got. Abort.', MYSQL_ERRNO = 9999;
  END IF;
END;|SELECT GET_LOCK(CAST(2 AS CHAR),0);
connection con1;
SELECT GET_LOCK(CAST(1 AS CHAR),0);
connection default;
eval $stmt;
connection con1;
                     WHERE info LIKE 'select%' AND state = 'User lock';
source include/wait_condition.inc;
INSERT INTO t1 VALUES(1),(2),(3);
SELECT RELEASE_ALL_LOCKS();
SELECT COUNT(*) FROM t1;
connection default;
SELECT RELEASE_ALL_LOCKS();
connection default;
DELETE FROM t1;
SELECT GET_LOCK(CAST(2 AS CHAR),0);
connection con1;
INSERT INTO t1 VALUES(1),(2),(3);
SELECT @aux;
SELECT RELEASE_ALL_LOCKS();
SELECT COUNT(*) FROM t1;
connection default;
SELECT RELEASE_ALL_LOCKS();
DROP TRIGGER trig_t1_ins;
connection default;
CREATE TABLE t2 (col1 INT, col2 INT, PRIMARY KEY(col1));
DELETE FROM t1;
INSERT INTO t1 VALUES(1),(2),(1);
INSERT INTO t2 SELECT id, GET_LOCK(id,0) FROM t1;
SELECT RELEASE_ALL_LOCKS();
SELECT * FROM t2;
DELETE FROM t1;
DELETE FROM t2;
INSERT INTO t1 VALUES(1),(1),(2);
INSERT INTO t2 SELECT id, GET_LOCK(id,0) FROM t1;
SELECT RELEASE_ALL_LOCKS();
SELECT * FROM t2;
DROP TABLE t2;
SELECT GET_LOCK('test', 0) ORDER BY oscar;
SELECT RELEASE_ALL_LOCKS() = 0 AS expect_1;
connection default;
DROP TABLE t1;
SELECT GET_LOCK('test', 0), RELEASE_LOCK('test');
SELECT IS_FREE_LOCK('test') = 1 AS expect_1;
SELECT GET_LOCK('test', 0), RELEASE_LOCK('test'), GET_LOCK('test', 0);
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $counter = `SELECT $disconnect_timeout * 10`;
while (!$mysql_errno)    show session status;
  dec $counter;
  if (!$counter)  {    if ($show_rpl_debug_info)    {          }      }  SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
SELECT GET_LOCK('test', 0), GET_LOCK('test1', 0), RELEASE_ALL_LOCKS(),       GET_LOCK('test', 0);
SELECT RELEASE_ALL_LOCKS() = 1 AS expect_1;
CREATE TABLE t1 AS SELECT GET_LOCK('test', 0) AS g, RELEASE_LOCK('test') AS r,RELEASE_ALL_LOCKS() AS ra, IS_USED_LOCK('test') AS isu,                       IS_FREE_LOCK('test') AS isf;
DESCRIBE t1;
DROP TABLE t1;
SELECT GET_LOCK(NULL, 0);
SELECT GET_LOCK("", 0);
SELECT RELEASE_LOCK(NULL);
SELECT RELEASE_LOCK("");
SELECT IS_USED_LOCK(NULL);
SELECT IS_USED_LOCK("");
SELECT IS_FREE_LOCK(NULL);
SELECT IS_FREE_LOCK("");
SELECT GET_LOCK(REPEAT('a', 64), 0) = 1 AS expect_1;
SELECT IS_USED_LOCK(REPEAT('a', 64)) = CONNECTION_ID() AS expect_1;
SELECT IS_FREE_LOCK(REPEAT('a', 64)) = 0 AS expect_1;
SELECT RELEASE_LOCK(REPEAT('a', 64)) = 1 AS expect_1;
SELECT GET_LOCK(REPEAT('a', 65), 0);
SELECT IS_USED_LOCK(REPEAT('a', 65));
SELECT IS_FREE_LOCK(REPEAT('a', 65));
SELECT RELEASE_LOCK(REPEAT('a', 65));
SELECT GET_LOCK('A', 0);
connection con1;
SELECT GET_LOCK('a', 0);
connection default;
SELECT IS_USED_LOCK('a') = CONNECTION_ID();
SELECT IS_FREE_LOCK('a');
SELECT RELEASE_LOCK('a');
SELECT GET_LOCK(_cp1251 0xf2e5f1f2, 0);
connection con1;
SELECT GET_LOCK(_utf8 0xd182d0b5d181d182, 0);
connection default;
SELECT IS_USED_LOCK(_koi8r 0xd4c5d3d4) = CONNECTION_ID();
SELECT IS_FREE_LOCK(_utf8 0xd182d0b5d181d182);
SELECT RELEASE_LOCK(_utf8 0xd182d0b5d181d182);
SELECT GET_LOCK('test');
SELECT GET_LOCK('test', 0, 1);
SELECT RELEASE_LOCK();
SELECT RELEASE_LOCK('test', 1);
SELECT RELEASE_ALL_LOCKS('test');
SELECT IS_USED_LOCK();
SELECT IS_USED_LOCK('test', 'test2');
SELECT IS_FREE_LOCK();
SELECT IS_FREE_LOCK('test', 'test2');
connection con1;
SELECT GET_LOCK("test", 0);
connection default;
SELECT GET_LOCK("test", NULL) = 0 AS expect_1;
connection con1;
SELECT RELEASE_LOCK("test");
connection default;
connection default;
SELECT GET_LOCK('test', 0);
connection con1;
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state = 'User lock';
source include/wait_condition.inc;
SELECT RELEASE_LOCK('test');
connection con1;
reap;
SELECT RELEASE_LOCK('test');
disconnect con1;
connection default;
CREATE TABLE t1 (conn CHAR(7), connection_id INT);
INSERT INTO t1 VALUES ('default', CONNECTION_ID());
SELECT GET_LOCK('bug16501',600);
connect (con1,localhost,root,,);
INSERT INTO t1 VALUES ('con1', CONNECTION_ID());
SELECT IS_USED_LOCK('bug16501') = connection_idFROM t1WHERE conn = 'default';
eval $stmt;
connection default;
SELECT IS_USED_LOCK('bug16501') = CONNECTION_ID();
SELECT RELEASE_LOCK('bug16501');
connection con1;
reap;
connection default;
SELECT IS_USED_LOCK('bug16501') = connection_idFROM t1WHERE conn = 'con1';
connection con1;
SELECT IS_USED_LOCK('bug16501') = CONNECTION_ID();
SELECT RELEASE_LOCK('bug16501');
SELECT IS_USED_LOCK('bug16501');
connection default;
SELECT RELEASE_ALL_LOCKS();
DROP TABLE t1;
connection con1;
disconnect con1;
connection default;
SET @@session.div_precision_increment=0;
select * from(SELECT MIN(GET_LOCK(0,0) / 1 ^ 0)) as a;
select * from(SELECT MAX(RELEASE_LOCK(0) / 1 ^ 0)) as a;
select * from(SELECT MAX(RELEASE_ALL_LOCKS() / 1 ^ 0)) as a;
SET @@session.div_precision_increment=default;
connection default;
SELECT IS_USED_LOCK('test') IS NULL AS expect_1;
SELECT IS_FREE_LOCK('test') = 1 AS expect_1;
SELECT RELEASE_LOCK('test') IS NULL AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 0 AS expect_1;
SELECT GET_LOCK('test', 0) = 1 AS expect_1;
SELECT IS_USED_LOCK('test') = CONNECTION_ID() AS expect_1;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
connect (con1,localhost,root,,);
connection con1;
eval SET @aux = $default_id;
SELECT IS_USED_LOCK('test') = @aux AS expect_1;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
SELECT GET_LOCK('test', 0) = 0 expect_1;
SELECT RELEASE_LOCK('test') = 0 AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 0 AS expect_1;
connection default;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
SELECT RELEASE_LOCK('test') IS NULL;
SELECT GET_LOCK('test1',0);
SELECT GET_LOCK('test2',0);
SELECT IS_USED_LOCK('test1') = CONNECTION_ID()   AND IS_USED_LOCK('test2') = CONNECTION_ID() AS expect_1;
SELECT RELEASE_LOCK('test1') = 1 AS expect_1;
SELECT IS_FREE_LOCK('test1') = 1 AS expect_1;
SELECT IS_FREE_LOCK('test2') = 0 AS expect_1;
SELECT RELEASE_LOCK('test2') = 1 AS expect_1;
SELECT GET_LOCK('test1',0);
SELECT GET_LOCK('test2',0);
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT IS_FREE_LOCK('test1') AND IS_FREE_LOCK('test2') AS expect_1;
SELECT GET_LOCK('test1',0), GET_LOCK('test2',0);
SELECT IS_USED_LOCK('test1') = CONNECTION_ID()   AND IS_USED_LOCK('test2') = CONNECTION_ID() AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT IS_USED_LOCK('test1') IS NULL AND IS_USED_LOCK('test2') IS NULL AS expect_1;
SELECT GET_LOCK('test1',0) FROM (SELECT 1 AS col1) AS my_tabWHERE GET_LOCK('test2',0) = 1;
SELECT IS_USED_LOCK('test1') = CONNECTION_ID()   AND IS_USED_LOCK('test2') = CONNECTION_ID() AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT IS_USED_LOCK('test1') IS NULL AND IS_USED_LOCK('test2') IS NULL AS expect_1;
SELECT GET_LOCK(col1,0) FROM (SELECT 'test1' AS col1 UNION SELECT 'test2') AS my_tab;
SELECT IS_USED_LOCK('test1') = CONNECTION_ID()   AND IS_USED_LOCK('test2') = CONNECTION_ID() AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT IS_USED_LOCK('test1') IS NULL AND IS_USED_LOCK('test2') IS NULL AS expect_1;
SELECT GET_LOCK('test', 0);
SELECT GET_LOCK('test', 0);
SELECT GET_LOCK('test', 0);
SELECT RELEASE_LOCK('test');
SELECT RELEASE_LOCK('test');
SELECT RELEASE_LOCK('test');
SELECT RELEASE_LOCK('test') IS NULL AS expect_1;
SELECT GET_LOCK('test', 0), GET_LOCK('test', 0);
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT GET_LOCK('test', 0);
connection con1;
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state='User lock';
source include/wait_condition.inc;
eval SET @aux = $con1_id;
KILL QUERY @aux;
connection con1;
reap;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
SELECT IS_USED_LOCK('test') <> CONNECTION_ID() AS expect_1;
connection default;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
connection con1;
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state='User sleep';
source include/wait_condition.inc;
eval SET @aux = $con1_id;
eval KILL QUERY @aux;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
connection con1;
reap;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
SELECT IS_USED_LOCK('test') = CONNECTION_ID() AS expect_1;
connection default;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
connection con1;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
connection con1;
SELECT GET_LOCK('test1', 0);
SELECT GET_LOCK('test1', 0);
connection default;
SELECT IS_FREE_LOCK('test1') = 0 AS expect_1;
eval SET @aux = $con1_id;
eval KILL @aux;
                     WHERE id = $con1_id;
source include/wait_condition.inc;
SELECT IS_FREE_LOCK('test1') = 1 AS expect_1;
connection con1;
disconnect con1;
connect (con1,localhost,root,,);
connection default;
SELECT GET_LOCK('test1', 0);
connection con1;
SELECT GET_LOCK('test2', 0);
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state='User lock';
source include/wait_condition.inc;
SELECT GET_LOCK('test2', 7200);
SELECT RELEASE_LOCK('test1');
connection con1;
reap;
SELECT RELEASE_LOCK('test2') + RELEASE_LOCK('test1') = 2 AS expect_1;
connection default;
CREATE TABLE t1 (id INT);
SELECT GET_LOCK('test1', 0);
LOCK TABLE t1 WRITE;
SELECT GET_LOCK('test2', 0);
UNLOCK TABLES;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT GET_LOCK('test1', 0);
FLUSH TABLES WITH READ LOCK;
SELECT GET_LOCK('test2', 0);
UNLOCK TABLES;
SELECT (RELEASE_LOCK('test1') = 1) AND (RELEASE_LOCK('test3') IS NULL)   AND (RELEASE_LOCK('test2') = 1) AS expect_1;
DELETE FROM t1;
BEGIN;
INSERT INTO t1 SET id = 1;
SELECT GET_LOCK('test1', 0);
COMMIT;
BEGIN;
INSERT INTO t1 SET id = 2;
SELECT GET_LOCK('test2', 0);
ROLLBACK;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT id FROM t1 ORDER BY id;
DELETE FROM t1;
SELECT GET_LOCK('test', 0);
connection con1;
BEGIN;
INSERT INTO t1 VALUES (1);
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state = 'User lock';
source include/wait_condition.inc;
eval $stmt1;
connection con1;
reap;
                     WHERE info LIKE 'rename%' AND state = 'Waiting for table metadata lock';
source include/wait_condition.inc;
COMMIT;
connection default;
reap;
RENAME TABLE t2 TO t1;
SELECT RELEASE_LOCK('test');
connection con1;
SELECT COUNT(*) = 1 AS expect_1 FROM t1 WHERE id = 1;
connection default;
SELECT GET_LOCK('test', 0);
connection con1;
LOCK TABLE t1 WRITE;
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state = 'User lock';
source include/wait_condition.inc;
SELECT COUNT(*) FROM t1;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
connection con1;
reap;
SELECT RELEASE_LOCK('test');
UNLOCK TABLES;
connection default;
DELETE FROM t1;
CREATE TRIGGER trig_t1_ins BEFORE INSERT ON t1 FOR EACH ROWSET @aux = GET_LOCK(new.id,7200);
SELECT GET_LOCK(CAST(2 AS CHAR),0);
INSERT INTO t1 VALUES(1),(2),(3);
SELECT RELEASE_LOCK(1) = 1 AS expect_1;
SELECT RELEASE_LOCK(2) = 1 AS expect_1;
SELECT RELEASE_LOCK(2) = 1 AS expect_1;
SELECT RELEASE_LOCK(3) = 1 AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 0 AS expect_1;
SELECT COUNT(*) FROM t1;
connection default;
DELETE FROM t1;
SELECT GET_LOCK(2,0);
connection con1;
eval $stmt;
connection default;
                     WHERE info LIKE 'SET @aux%' AND state = 'User lock';
source include/wait_condition.inc;
RENAME TABLE t1 TO t1x;
RENAME TABLE t1x TO t1;
connection con1;
reap;
SELECT RELEASE_ALL_LOCKS();
SELECT COUNT(*) FROM t1;
connection default;
SELECT RELEASE_ALL_LOCKS();
connection default;
DELETE FROM t1;
DROP TRIGGER trig_t1_ins;
CREATE TRIGGER trig_t1_ins BEFORE INSERT ON t1 FOR EACH ROWBEGIN  SET @aux = GET_LOCK(2,1);
  IF @aux <> 1 THEN      SIGNAL SQLSTATE '45000'      SET MESSAGE_TEXT = 'LOCK 2 not got. Abort.', MYSQL_ERRNO = 9999;
  END IF;
END;|SELECT GET_LOCK(CAST(2 AS CHAR),0);
connection con1;
SELECT GET_LOCK(CAST(1 AS CHAR),0);
connection default;
eval $stmt;
connection con1;
                     WHERE info LIKE 'select%' AND state = 'User lock';
source include/wait_condition.inc;
INSERT INTO t1 VALUES(1),(2),(3);
SELECT RELEASE_ALL_LOCKS();
SELECT COUNT(*) FROM t1;
connection default;
SELECT RELEASE_ALL_LOCKS();
connection default;
DELETE FROM t1;
SELECT GET_LOCK(CAST(2 AS CHAR),0);
connection con1;
INSERT INTO t1 VALUES(1),(2),(3);
SELECT @aux;
SELECT RELEASE_ALL_LOCKS();
SELECT COUNT(*) FROM t1;
connection default;
SELECT RELEASE_ALL_LOCKS();
DROP TRIGGER trig_t1_ins;
connection default;
CREATE TABLE t2 (col1 INT, col2 INT, PRIMARY KEY(col1));
DELETE FROM t1;
INSERT INTO t1 VALUES(1),(2),(1);
INSERT INTO t2 SELECT id, GET_LOCK(id,0) FROM t1;
SELECT RELEASE_ALL_LOCKS();
SELECT * FROM t2;
DELETE FROM t1;
DELETE FROM t2;
INSERT INTO t1 VALUES(1),(1),(2);
INSERT INTO t2 SELECT id, GET_LOCK(id,0) FROM t1;
SELECT RELEASE_ALL_LOCKS();
SELECT * FROM t2;
DROP TABLE t2;
SELECT GET_LOCK('test', 0) ORDER BY oscar;
SELECT RELEASE_ALL_LOCKS() = 0 AS expect_1;
connection default;
DROP TABLE t1;
SELECT GET_LOCK('test', 0), RELEASE_LOCK('test');
SELECT IS_FREE_LOCK('test') = 1 AS expect_1;
SELECT GET_LOCK('test', 0), RELEASE_LOCK('test'), GET_LOCK('test', 0);
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $counter = `SELECT $disconnect_timeout * 10`;
while (!$mysql_errno)    show session status;
  dec $counter;
  if (!$counter)  {    if ($show_rpl_debug_info)    {          }      }  SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
SELECT GET_LOCK('test', 0), GET_LOCK('test1', 0), RELEASE_ALL_LOCKS(),       GET_LOCK('test', 0);
SELECT RELEASE_ALL_LOCKS() = 1 AS expect_1;
CREATE TABLE t1 AS SELECT GET_LOCK('test', 0) AS g, RELEASE_LOCK('test') AS r,RELEASE_ALL_LOCKS() AS ra, IS_USED_LOCK('test') AS isu,                       IS_FREE_LOCK('test') AS isf;
DESCRIBE t1;
DROP TABLE t1;
SELECT GET_LOCK(NULL, 0);
SELECT GET_LOCK("", 0);
SELECT RELEASE_LOCK(NULL);
SELECT RELEASE_LOCK("");
SELECT IS_USED_LOCK(NULL);
SELECT IS_USED_LOCK("");
SELECT IS_FREE_LOCK(NULL);
SELECT IS_FREE_LOCK("");
SELECT GET_LOCK(REPEAT('a', 64), 0) = 1 AS expect_1;
SELECT IS_USED_LOCK(REPEAT('a', 64)) = CONNECTION_ID() AS expect_1;
SELECT IS_FREE_LOCK(REPEAT('a', 64)) = 0 AS expect_1;
SELECT RELEASE_LOCK(REPEAT('a', 64)) = 1 AS expect_1;
SELECT GET_LOCK(REPEAT('a', 65), 0);
SELECT IS_USED_LOCK(REPEAT('a', 65));
SELECT IS_FREE_LOCK(REPEAT('a', 65));
SELECT RELEASE_LOCK(REPEAT('a', 65));
SELECT GET_LOCK('A', 0);
connection con1;
SELECT GET_LOCK('a', 0);
connection default;
SELECT IS_USED_LOCK('a') = CONNECTION_ID();
SELECT IS_FREE_LOCK('a');
SELECT RELEASE_LOCK('a');
SELECT GET_LOCK(_cp1251 0xf2e5f1f2, 0);
connection con1;
SELECT GET_LOCK(_utf8 0xd182d0b5d181d182, 0);
connection default;
SELECT IS_USED_LOCK(_koi8r 0xd4c5d3d4) = CONNECTION_ID();
SELECT IS_FREE_LOCK(_utf8 0xd182d0b5d181d182);
SELECT RELEASE_LOCK(_utf8 0xd182d0b5d181d182);
SELECT GET_LOCK('test');
SELECT GET_LOCK('test', 0, 1);
SELECT RELEASE_LOCK();
SELECT RELEASE_LOCK('test', 1);
SELECT RELEASE_ALL_LOCKS('test');
SELECT IS_USED_LOCK();
SELECT IS_USED_LOCK('test', 'test2');
SELECT IS_FREE_LOCK();
SELECT IS_FREE_LOCK('test', 'test2');
connection con1;
SELECT GET_LOCK("test", 0);
connection default;
SELECT GET_LOCK("test", NULL) = 0 AS expect_1;
connection con1;
SELECT RELEASE_LOCK("test");
connection default;
connection default;
SELECT GET_LOCK('test', 0);
connection con1;
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state = 'User lock';
source include/wait_condition.inc;
SELECT RELEASE_LOCK('test');
connection con1;
reap;
SELECT RELEASE_LOCK('test');
disconnect con1;
connection default;
CREATE TABLE t1 (conn CHAR(7), connection_id INT);
INSERT INTO t1 VALUES ('default', CONNECTION_ID());
SELECT GET_LOCK('bug16501',600);
connect (con1,localhost,root,,);
INSERT INTO t1 VALUES ('con1', CONNECTION_ID());
SELECT IS_USED_LOCK('bug16501') = connection_idFROM t1WHERE conn = 'default';
eval $stmt;
connection default;
SELECT IS_USED_LOCK('bug16501') = CONNECTION_ID();
SELECT RELEASE_LOCK('bug16501');
connection con1;
reap;
connection default;
SELECT IS_USED_LOCK('bug16501') = connection_idFROM t1WHERE conn = 'con1';
connection con1;
SELECT IS_USED_LOCK('bug16501') = CONNECTION_ID();
SELECT RELEASE_LOCK('bug16501');
SELECT IS_USED_LOCK('bug16501');
connection default;
SELECT RELEASE_ALL_LOCKS();
DROP TABLE t1;
connection con1;
disconnect con1;
connection default;
SET @@session.div_precision_increment=0;
select * from(SELECT MIN(GET_LOCK(0,0) / 1 ^ 0)) as a;
select * from(SELECT MAX(RELEASE_LOCK(0) / 1 ^ 0)) as a;
select * from(SELECT MAX(RELEASE_ALL_LOCKS() / 1 ^ 0)) as a;
SET @@session.div_precision_increment=default;
connection default;
SELECT IS_USED_LOCK('test') IS NULL AS expect_1;
SELECT IS_FREE_LOCK('test') = 1 AS expect_1;
SELECT RELEASE_LOCK('test') IS NULL AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 0 AS expect_1;
SELECT GET_LOCK('test', 0) = 1 AS expect_1;
SELECT IS_USED_LOCK('test') = CONNECTION_ID() AS expect_1;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
connect (con1,localhost,root,,);
connection con1;
eval SET @aux = $default_id;
SELECT IS_USED_LOCK('test') = @aux AS expect_1;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
SELECT GET_LOCK('test', 0) = 0 expect_1;
SELECT RELEASE_LOCK('test') = 0 AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 0 AS expect_1;
connection default;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
SELECT RELEASE_LOCK('test') IS NULL;
SELECT GET_LOCK('test1',0);
SELECT GET_LOCK('test2',0);
SELECT IS_USED_LOCK('test1') = CONNECTION_ID()   AND IS_USED_LOCK('test2') = CONNECTION_ID() AS expect_1;
SELECT RELEASE_LOCK('test1') = 1 AS expect_1;
SELECT IS_FREE_LOCK('test1') = 1 AS expect_1;
SELECT IS_FREE_LOCK('test2') = 0 AS expect_1;
SELECT RELEASE_LOCK('test2') = 1 AS expect_1;
SELECT GET_LOCK('test1',0);
SELECT GET_LOCK('test2',0);
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT IS_FREE_LOCK('test1') AND IS_FREE_LOCK('test2') AS expect_1;
SELECT GET_LOCK('test1',0), GET_LOCK('test2',0);
SELECT IS_USED_LOCK('test1') = CONNECTION_ID()   AND IS_USED_LOCK('test2') = CONNECTION_ID() AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT IS_USED_LOCK('test1') IS NULL AND IS_USED_LOCK('test2') IS NULL AS expect_1;
SELECT GET_LOCK('test1',0) FROM (SELECT 1 AS col1) AS my_tabWHERE GET_LOCK('test2',0) = 1;
SELECT IS_USED_LOCK('test1') = CONNECTION_ID()   AND IS_USED_LOCK('test2') = CONNECTION_ID() AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT IS_USED_LOCK('test1') IS NULL AND IS_USED_LOCK('test2') IS NULL AS expect_1;
SELECT GET_LOCK(col1,0) FROM (SELECT 'test1' AS col1 UNION SELECT 'test2') AS my_tab;
SELECT IS_USED_LOCK('test1') = CONNECTION_ID()   AND IS_USED_LOCK('test2') = CONNECTION_ID() AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT IS_USED_LOCK('test1') IS NULL AND IS_USED_LOCK('test2') IS NULL AS expect_1;
SELECT GET_LOCK('test', 0);
SELECT GET_LOCK('test', 0);
SELECT GET_LOCK('test', 0);
SELECT RELEASE_LOCK('test');
SELECT RELEASE_LOCK('test');
SELECT RELEASE_LOCK('test');
SELECT RELEASE_LOCK('test') IS NULL AS expect_1;
SELECT GET_LOCK('test', 0), GET_LOCK('test', 0);
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT GET_LOCK('test', 0);
connection con1;
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state='User lock';
source include/wait_condition.inc;
eval SET @aux = $con1_id;
KILL QUERY @aux;
connection con1;
reap;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
SELECT IS_USED_LOCK('test') <> CONNECTION_ID() AS expect_1;
connection default;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
connection con1;
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state='User sleep';
source include/wait_condition.inc;
eval SET @aux = $con1_id;
eval KILL QUERY @aux;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
connection con1;
reap;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
SELECT IS_USED_LOCK('test') = CONNECTION_ID() AS expect_1;
connection default;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
connection con1;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
connection con1;
SELECT GET_LOCK('test1', 0);
SELECT GET_LOCK('test1', 0);
connection default;
SELECT IS_FREE_LOCK('test1') = 0 AS expect_1;
eval SET @aux = $con1_id;
eval KILL @aux;
                     WHERE id = $con1_id;
source include/wait_condition.inc;
SELECT IS_FREE_LOCK('test1') = 1 AS expect_1;
connection con1;
disconnect con1;
connect (con1,localhost,root,,);
connection default;
SELECT GET_LOCK('test1', 0);
connection con1;
SELECT GET_LOCK('test2', 0);
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state='User lock';
source include/wait_condition.inc;
SELECT GET_LOCK('test2', 7200);
SELECT RELEASE_LOCK('test1');
connection con1;
reap;
SELECT RELEASE_LOCK('test2') + RELEASE_LOCK('test1') = 2 AS expect_1;
connection default;
CREATE TABLE t1 (id INT);
SELECT GET_LOCK('test1', 0);
LOCK TABLE t1 WRITE;
SELECT GET_LOCK('test2', 0);
UNLOCK TABLES;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT GET_LOCK('test1', 0);
FLUSH TABLES WITH READ LOCK;
SELECT GET_LOCK('test2', 0);
UNLOCK TABLES;
SELECT (RELEASE_LOCK('test1') = 1) AND (RELEASE_LOCK('test3') IS NULL)   AND (RELEASE_LOCK('test2') = 1) AS expect_1;
DELETE FROM t1;
BEGIN;
INSERT INTO t1 SET id = 1;
SELECT GET_LOCK('test1', 0);
COMMIT;
BEGIN;
INSERT INTO t1 SET id = 2;
SELECT GET_LOCK('test2', 0);
ROLLBACK;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT id FROM t1 ORDER BY id;
DELETE FROM t1;
SELECT GET_LOCK('test', 0);
connection con1;
BEGIN;
INSERT INTO t1 VALUES (1);
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state = 'User lock';
source include/wait_condition.inc;
eval $stmt1;
connection con1;
reap;
                     WHERE info LIKE 'rename%' AND state = 'Waiting for table metadata lock';
source include/wait_condition.inc;
COMMIT;
connection default;
reap;
RENAME TABLE t2 TO t1;
SELECT RELEASE_LOCK('test');
connection con1;
SELECT COUNT(*) = 1 AS expect_1 FROM t1 WHERE id = 1;
connection default;
SELECT GET_LOCK('test', 0);
connection con1;
LOCK TABLE t1 WRITE;
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state = 'User lock';
source include/wait_condition.inc;
SELECT COUNT(*) FROM t1;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
connection con1;
reap;
SELECT RELEASE_LOCK('test');
UNLOCK TABLES;
connection default;
DELETE FROM t1;
CREATE TRIGGER trig_t1_ins BEFORE INSERT ON t1 FOR EACH ROWSET @aux = GET_LOCK(new.id,7200);
SELECT GET_LOCK(CAST(2 AS CHAR),0);
INSERT INTO t1 VALUES(1),(2),(3);
SELECT RELEASE_LOCK(1) = 1 AS expect_1;
SELECT RELEASE_LOCK(2) = 1 AS expect_1;
SELECT RELEASE_LOCK(2) = 1 AS expect_1;
SELECT RELEASE_LOCK(3) = 1 AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 0 AS expect_1;
SELECT COUNT(*) FROM t1;
connection default;
DELETE FROM t1;
SELECT GET_LOCK(2,0);
connection con1;
eval $stmt;
connection default;
                     WHERE info LIKE 'SET @aux%' AND state = 'User lock';
source include/wait_condition.inc;
RENAME TABLE t1 TO t1x;
RENAME TABLE t1x TO t1;
connection con1;
reap;
SELECT RELEASE_ALL_LOCKS();
SELECT COUNT(*) FROM t1;
connection default;
SELECT RELEASE_ALL_LOCKS();
connection default;
DELETE FROM t1;
DROP TRIGGER trig_t1_ins;
CREATE TRIGGER trig_t1_ins BEFORE INSERT ON t1 FOR EACH ROWBEGIN  SET @aux = GET_LOCK(2,1);
  IF @aux <> 1 THEN      SIGNAL SQLSTATE '45000'      SET MESSAGE_TEXT = 'LOCK 2 not got. Abort.', MYSQL_ERRNO = 9999;
  END IF;
END;|SELECT GET_LOCK(CAST(2 AS CHAR),0);
connection con1;
SELECT GET_LOCK(CAST(1 AS CHAR),0);
connection default;
eval $stmt;
connection con1;
                     WHERE info LIKE 'select%' AND state = 'User lock';
source include/wait_condition.inc;
INSERT INTO t1 VALUES(1),(2),(3);
SELECT RELEASE_ALL_LOCKS();
SELECT COUNT(*) FROM t1;
connection default;
SELECT RELEASE_ALL_LOCKS();
connection default;
DELETE FROM t1;
SELECT GET_LOCK(CAST(2 AS CHAR),0);
connection con1;
INSERT INTO t1 VALUES(1),(2),(3);
SELECT @aux;
SELECT RELEASE_ALL_LOCKS();
SELECT COUNT(*) FROM t1;
connection default;
SELECT RELEASE_ALL_LOCKS();
DROP TRIGGER trig_t1_ins;
connection default;
CREATE TABLE t2 (col1 INT, col2 INT, PRIMARY KEY(col1));
DELETE FROM t1;
INSERT INTO t1 VALUES(1),(2),(1);
INSERT INTO t2 SELECT id, GET_LOCK(id,0) FROM t1;
SELECT RELEASE_ALL_LOCKS();
SELECT * FROM t2;
DELETE FROM t1;
DELETE FROM t2;
INSERT INTO t1 VALUES(1),(1),(2);
INSERT INTO t2 SELECT id, GET_LOCK(id,0) FROM t1;
SELECT RELEASE_ALL_LOCKS();
SELECT * FROM t2;
DROP TABLE t2;
SELECT GET_LOCK('test', 0) ORDER BY oscar;
SELECT RELEASE_ALL_LOCKS() = 0 AS expect_1;
connection default;
DROP TABLE t1;
SELECT GET_LOCK('test', 0), RELEASE_LOCK('test');
SELECT IS_FREE_LOCK('test') = 1 AS expect_1;
SELECT GET_LOCK('test', 0), RELEASE_LOCK('test'), GET_LOCK('test', 0);
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $counter = `SELECT $disconnect_timeout * 10`;
while (!$mysql_errno)    show session status;
  dec $counter;
  if (!$counter)  {    if ($show_rpl_debug_info)    {          }      }  SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
SELECT GET_LOCK('test', 0), GET_LOCK('test1', 0), RELEASE_ALL_LOCKS(),       GET_LOCK('test', 0);
SELECT RELEASE_ALL_LOCKS() = 1 AS expect_1;
CREATE TABLE t1 AS SELECT GET_LOCK('test', 0) AS g, RELEASE_LOCK('test') AS r,RELEASE_ALL_LOCKS() AS ra, IS_USED_LOCK('test') AS isu,                       IS_FREE_LOCK('test') AS isf;
DESCRIBE t1;
DROP TABLE t1;
SELECT GET_LOCK(NULL, 0);
SELECT GET_LOCK("", 0);
SELECT RELEASE_LOCK(NULL);
SELECT RELEASE_LOCK("");
SELECT IS_USED_LOCK(NULL);
SELECT IS_USED_LOCK("");
SELECT IS_FREE_LOCK(NULL);
SELECT IS_FREE_LOCK("");
SELECT GET_LOCK(REPEAT('a', 64), 0) = 1 AS expect_1;
SELECT IS_USED_LOCK(REPEAT('a', 64)) = CONNECTION_ID() AS expect_1;
SELECT IS_FREE_LOCK(REPEAT('a', 64)) = 0 AS expect_1;
SELECT RELEASE_LOCK(REPEAT('a', 64)) = 1 AS expect_1;
SELECT GET_LOCK(REPEAT('a', 65), 0);
SELECT IS_USED_LOCK(REPEAT('a', 65));
SELECT IS_FREE_LOCK(REPEAT('a', 65));
SELECT RELEASE_LOCK(REPEAT('a', 65));
SELECT GET_LOCK('A', 0);
connection con1;
SELECT GET_LOCK('a', 0);
connection default;
SELECT IS_USED_LOCK('a') = CONNECTION_ID();
SELECT IS_FREE_LOCK('a');
SELECT RELEASE_LOCK('a');
SELECT GET_LOCK(_cp1251 0xf2e5f1f2, 0);
connection con1;
SELECT GET_LOCK(_utf8 0xd182d0b5d181d182, 0);
connection default;
SELECT IS_USED_LOCK(_koi8r 0xd4c5d3d4) = CONNECTION_ID();
SELECT IS_FREE_LOCK(_utf8 0xd182d0b5d181d182);
SELECT RELEASE_LOCK(_utf8 0xd182d0b5d181d182);
SELECT GET_LOCK('test');
SELECT GET_LOCK('test', 0, 1);
SELECT RELEASE_LOCK();
SELECT RELEASE_LOCK('test', 1);
SELECT RELEASE_ALL_LOCKS('test');
SELECT IS_USED_LOCK();
SELECT IS_USED_LOCK('test', 'test2');
SELECT IS_FREE_LOCK();
SELECT IS_FREE_LOCK('test', 'test2');
connection con1;
SELECT GET_LOCK("test", 0);
connection default;
SELECT GET_LOCK("test", NULL) = 0 AS expect_1;
connection con1;
SELECT RELEASE_LOCK("test");
connection default;
connection default;
SELECT GET_LOCK('test', 0);
connection con1;
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state = 'User lock';
source include/wait_condition.inc;
SELECT RELEASE_LOCK('test');
connection con1;
reap;
SELECT RELEASE_LOCK('test');
disconnect con1;
connection default;
CREATE TABLE t1 (conn CHAR(7), connection_id INT);
INSERT INTO t1 VALUES ('default', CONNECTION_ID());
SELECT GET_LOCK('bug16501',600);
connect (con1,localhost,root,,);
INSERT INTO t1 VALUES ('con1', CONNECTION_ID());
SELECT IS_USED_LOCK('bug16501') = connection_idFROM t1WHERE conn = 'default';
eval $stmt;
connection default;
SELECT IS_USED_LOCK('bug16501') = CONNECTION_ID();
SELECT RELEASE_LOCK('bug16501');
connection con1;
reap;
connection default;
SELECT IS_USED_LOCK('bug16501') = connection_idFROM t1WHERE conn = 'con1';
connection con1;
SELECT IS_USED_LOCK('bug16501') = CONNECTION_ID();
SELECT RELEASE_LOCK('bug16501');
SELECT IS_USED_LOCK('bug16501');
connection default;
SELECT RELEASE_ALL_LOCKS();
DROP TABLE t1;
connection con1;
disconnect con1;
connection default;
SET @@session.div_precision_increment=0;
select * from(SELECT MIN(GET_LOCK(0,0) / 1 ^ 0)) as a;
select * from(SELECT MAX(RELEASE_LOCK(0) / 1 ^ 0)) as a;
select * from(SELECT MAX(RELEASE_ALL_LOCKS() / 1 ^ 0)) as a;
SET @@session.div_precision_increment=default;
connection default;
SELECT IS_USED_LOCK('test') IS NULL AS expect_1;
SELECT IS_FREE_LOCK('test') = 1 AS expect_1;
SELECT RELEASE_LOCK('test') IS NULL AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 0 AS expect_1;
SELECT GET_LOCK('test', 0) = 1 AS expect_1;
SELECT IS_USED_LOCK('test') = CONNECTION_ID() AS expect_1;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
connect (con1,localhost,root,,);
connection con1;
eval SET @aux = $default_id;
SELECT IS_USED_LOCK('test') = @aux AS expect_1;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
SELECT GET_LOCK('test', 0) = 0 expect_1;
SELECT RELEASE_LOCK('test') = 0 AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 0 AS expect_1;
connection default;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
SELECT RELEASE_LOCK('test') IS NULL;
SELECT GET_LOCK('test1',0);
SELECT GET_LOCK('test2',0);
SELECT IS_USED_LOCK('test1') = CONNECTION_ID()   AND IS_USED_LOCK('test2') = CONNECTION_ID() AS expect_1;
SELECT RELEASE_LOCK('test1') = 1 AS expect_1;
SELECT IS_FREE_LOCK('test1') = 1 AS expect_1;
SELECT IS_FREE_LOCK('test2') = 0 AS expect_1;
SELECT RELEASE_LOCK('test2') = 1 AS expect_1;
SELECT GET_LOCK('test1',0);
SELECT GET_LOCK('test2',0);
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT IS_FREE_LOCK('test1') AND IS_FREE_LOCK('test2') AS expect_1;
SELECT GET_LOCK('test1',0), GET_LOCK('test2',0);
SELECT IS_USED_LOCK('test1') = CONNECTION_ID()   AND IS_USED_LOCK('test2') = CONNECTION_ID() AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT IS_USED_LOCK('test1') IS NULL AND IS_USED_LOCK('test2') IS NULL AS expect_1;
SELECT GET_LOCK('test1',0) FROM (SELECT 1 AS col1) AS my_tabWHERE GET_LOCK('test2',0) = 1;
SELECT IS_USED_LOCK('test1') = CONNECTION_ID()   AND IS_USED_LOCK('test2') = CONNECTION_ID() AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT IS_USED_LOCK('test1') IS NULL AND IS_USED_LOCK('test2') IS NULL AS expect_1;
SELECT GET_LOCK(col1,0) FROM (SELECT 'test1' AS col1 UNION SELECT 'test2') AS my_tab;
SELECT IS_USED_LOCK('test1') = CONNECTION_ID()   AND IS_USED_LOCK('test2') = CONNECTION_ID() AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT IS_USED_LOCK('test1') IS NULL AND IS_USED_LOCK('test2') IS NULL AS expect_1;
SELECT GET_LOCK('test', 0);
SELECT GET_LOCK('test', 0);
SELECT GET_LOCK('test', 0);
SELECT RELEASE_LOCK('test');
SELECT RELEASE_LOCK('test');
SELECT RELEASE_LOCK('test');
SELECT RELEASE_LOCK('test') IS NULL AS expect_1;
SELECT GET_LOCK('test', 0), GET_LOCK('test', 0);
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT GET_LOCK('test', 0);
connection con1;
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state='User lock';
source include/wait_condition.inc;
eval SET @aux = $con1_id;
KILL QUERY @aux;
connection con1;
reap;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
SELECT IS_USED_LOCK('test') <> CONNECTION_ID() AS expect_1;
connection default;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
connection con1;
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state='User sleep';
source include/wait_condition.inc;
eval SET @aux = $con1_id;
eval KILL QUERY @aux;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
connection con1;
reap;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
SELECT IS_USED_LOCK('test') = CONNECTION_ID() AS expect_1;
connection default;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
connection con1;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
connection con1;
SELECT GET_LOCK('test1', 0);
SELECT GET_LOCK('test1', 0);
connection default;
SELECT IS_FREE_LOCK('test1') = 0 AS expect_1;
eval SET @aux = $con1_id;
eval KILL @aux;
                     WHERE id = $con1_id;
source include/wait_condition.inc;
SELECT IS_FREE_LOCK('test1') = 1 AS expect_1;
connection con1;
disconnect con1;
connect (con1,localhost,root,,);
connection default;
SELECT GET_LOCK('test1', 0);
connection con1;
SELECT GET_LOCK('test2', 0);
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state='User lock';
source include/wait_condition.inc;
SELECT GET_LOCK('test2', 7200);
SELECT RELEASE_LOCK('test1');
connection con1;
reap;
SELECT RELEASE_LOCK('test2') + RELEASE_LOCK('test1') = 2 AS expect_1;
connection default;
CREATE TABLE t1 (id INT);
SELECT GET_LOCK('test1', 0);
LOCK TABLE t1 WRITE;
SELECT GET_LOCK('test2', 0);
UNLOCK TABLES;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT GET_LOCK('test1', 0);
FLUSH TABLES WITH READ LOCK;
SELECT GET_LOCK('test2', 0);
UNLOCK TABLES;
SELECT (RELEASE_LOCK('test1') = 1) AND (RELEASE_LOCK('test3') IS NULL)   AND (RELEASE_LOCK('test2') = 1) AS expect_1;
DELETE FROM t1;
BEGIN;
INSERT INTO t1 SET id = 1;
SELECT GET_LOCK('test1', 0);
COMMIT;
BEGIN;
INSERT INTO t1 SET id = 2;
SELECT GET_LOCK('test2', 0);
ROLLBACK;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT id FROM t1 ORDER BY id;
DELETE FROM t1;
SELECT GET_LOCK('test', 0);
connection con1;
BEGIN;
INSERT INTO t1 VALUES (1);
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state = 'User lock';
source include/wait_condition.inc;
eval $stmt1;
connection con1;
reap;
                     WHERE info LIKE 'rename%' AND state = 'Waiting for table metadata lock';
source include/wait_condition.inc;
COMMIT;
connection default;
reap;
RENAME TABLE t2 TO t1;
SELECT RELEASE_LOCK('test');
connection con1;
SELECT COUNT(*) = 1 AS expect_1 FROM t1 WHERE id = 1;
connection default;
SELECT GET_LOCK('test', 0);
connection con1;
LOCK TABLE t1 WRITE;
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state = 'User lock';
source include/wait_condition.inc;
SELECT COUNT(*) FROM t1;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
connection con1;
reap;
SELECT RELEASE_LOCK('test');
UNLOCK TABLES;
connection default;
DELETE FROM t1;
CREATE TRIGGER trig_t1_ins BEFORE INSERT ON t1 FOR EACH ROWSET @aux = GET_LOCK(new.id,7200);
SELECT GET_LOCK(CAST(2 AS CHAR),0);
INSERT INTO t1 VALUES(1),(2),(3);
SELECT RELEASE_LOCK(1) = 1 AS expect_1;
SELECT RELEASE_LOCK(2) = 1 AS expect_1;
SELECT RELEASE_LOCK(2) = 1 AS expect_1;
SELECT RELEASE_LOCK(3) = 1 AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 0 AS expect_1;
SELECT COUNT(*) FROM t1;
connection default;
DELETE FROM t1;
SELECT GET_LOCK(2,0);
connection con1;
eval $stmt;
connection default;
                     WHERE info LIKE 'SET @aux%' AND state = 'User lock';
source include/wait_condition.inc;
RENAME TABLE t1 TO t1x;
RENAME TABLE t1x TO t1;
connection con1;
reap;
SELECT RELEASE_ALL_LOCKS();
SELECT COUNT(*) FROM t1;
connection default;
SELECT RELEASE_ALL_LOCKS();
connection default;
DELETE FROM t1;
DROP TRIGGER trig_t1_ins;
CREATE TRIGGER trig_t1_ins BEFORE INSERT ON t1 FOR EACH ROWBEGIN  SET @aux = GET_LOCK(2,1);
  IF @aux <> 1 THEN      SIGNAL SQLSTATE '45000'      SET MESSAGE_TEXT = 'LOCK 2 not got. Abort.', MYSQL_ERRNO = 9999;
  END IF;
END;|SELECT GET_LOCK(CAST(2 AS CHAR),0);
connection con1;
SELECT GET_LOCK(CAST(1 AS CHAR),0);
connection default;
eval $stmt;
connection con1;
                     WHERE info LIKE 'select%' AND state = 'User lock';
source include/wait_condition.inc;
INSERT INTO t1 VALUES(1),(2),(3);
SELECT RELEASE_ALL_LOCKS();
SELECT COUNT(*) FROM t1;
connection default;
SELECT RELEASE_ALL_LOCKS();
connection default;
DELETE FROM t1;
SELECT GET_LOCK(CAST(2 AS CHAR),0);
connection con1;
INSERT INTO t1 VALUES(1),(2),(3);
SELECT @aux;
SELECT RELEASE_ALL_LOCKS();
SELECT COUNT(*) FROM t1;
connection default;
SELECT RELEASE_ALL_LOCKS();
DROP TRIGGER trig_t1_ins;
connection default;
CREATE TABLE t2 (col1 INT, col2 INT, PRIMARY KEY(col1));
DELETE FROM t1;
INSERT INTO t1 VALUES(1),(2),(1);
INSERT INTO t2 SELECT id, GET_LOCK(id,0) FROM t1;
SELECT RELEASE_ALL_LOCKS();
SELECT * FROM t2;
DELETE FROM t1;
DELETE FROM t2;
INSERT INTO t1 VALUES(1),(1),(2);
INSERT INTO t2 SELECT id, GET_LOCK(id,0) FROM t1;
SELECT RELEASE_ALL_LOCKS();
SELECT * FROM t2;
DROP TABLE t2;
SELECT GET_LOCK('test', 0) ORDER BY oscar;
SELECT RELEASE_ALL_LOCKS() = 0 AS expect_1;
connection default;
DROP TABLE t1;
SELECT GET_LOCK('test', 0), RELEASE_LOCK('test');
SELECT IS_FREE_LOCK('test') = 1 AS expect_1;
SELECT GET_LOCK('test', 0), RELEASE_LOCK('test'), GET_LOCK('test', 0);
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $counter = `SELECT $disconnect_timeout * 10`;
while (!$mysql_errno)    show session status;
  dec $counter;
  if (!$counter)  {    if ($show_rpl_debug_info)    {          }      }  SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
SELECT GET_LOCK('test', 0), GET_LOCK('test1', 0), RELEASE_ALL_LOCKS(),       GET_LOCK('test', 0);
SELECT RELEASE_ALL_LOCKS() = 1 AS expect_1;
CREATE TABLE t1 AS SELECT GET_LOCK('test', 0) AS g, RELEASE_LOCK('test') AS r,RELEASE_ALL_LOCKS() AS ra, IS_USED_LOCK('test') AS isu,                       IS_FREE_LOCK('test') AS isf;
DESCRIBE t1;
DROP TABLE t1;
SELECT GET_LOCK(NULL, 0);
SELECT GET_LOCK("", 0);
SELECT RELEASE_LOCK(NULL);
SELECT RELEASE_LOCK("");
SELECT IS_USED_LOCK(NULL);
SELECT IS_USED_LOCK("");
SELECT IS_FREE_LOCK(NULL);
SELECT IS_FREE_LOCK("");
SELECT GET_LOCK(REPEAT('a', 64), 0) = 1 AS expect_1;
SELECT IS_USED_LOCK(REPEAT('a', 64)) = CONNECTION_ID() AS expect_1;
SELECT IS_FREE_LOCK(REPEAT('a', 64)) = 0 AS expect_1;
SELECT RELEASE_LOCK(REPEAT('a', 64)) = 1 AS expect_1;
SELECT GET_LOCK(REPEAT('a', 65), 0);
SELECT IS_USED_LOCK(REPEAT('a', 65));
SELECT IS_FREE_LOCK(REPEAT('a', 65));
SELECT RELEASE_LOCK(REPEAT('a', 65));
SELECT GET_LOCK('A', 0);
connection con1;
SELECT GET_LOCK('a', 0);
connection default;
SELECT IS_USED_LOCK('a') = CONNECTION_ID();
SELECT IS_FREE_LOCK('a');
SELECT RELEASE_LOCK('a');
SELECT GET_LOCK(_cp1251 0xf2e5f1f2, 0);
connection con1;
SELECT GET_LOCK(_utf8 0xd182d0b5d181d182, 0);
connection default;
SELECT IS_USED_LOCK(_koi8r 0xd4c5d3d4) = CONNECTION_ID();
SELECT IS_FREE_LOCK(_utf8 0xd182d0b5d181d182);
SELECT RELEASE_LOCK(_utf8 0xd182d0b5d181d182);
SELECT GET_LOCK('test');
SELECT GET_LOCK('test', 0, 1);
SELECT RELEASE_LOCK();
SELECT RELEASE_LOCK('test', 1);
SELECT RELEASE_ALL_LOCKS('test');
SELECT IS_USED_LOCK();
SELECT IS_USED_LOCK('test', 'test2');
SELECT IS_FREE_LOCK();
SELECT IS_FREE_LOCK('test', 'test2');
connection con1;
SELECT GET_LOCK("test", 0);
connection default;
SELECT GET_LOCK("test", NULL) = 0 AS expect_1;
connection con1;
SELECT RELEASE_LOCK("test");
connection default;
connection default;
SELECT GET_LOCK('test', 0);
connection con1;
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state = 'User lock';
source include/wait_condition.inc;
SELECT RELEASE_LOCK('test');
connection con1;
reap;
SELECT RELEASE_LOCK('test');
disconnect con1;
connection default;
CREATE TABLE t1 (conn CHAR(7), connection_id INT);
INSERT INTO t1 VALUES ('default', CONNECTION_ID());
SELECT GET_LOCK('bug16501',600);
connect (con1,localhost,root,,);
INSERT INTO t1 VALUES ('con1', CONNECTION_ID());
SELECT IS_USED_LOCK('bug16501') = connection_idFROM t1WHERE conn = 'default';
eval $stmt;
connection default;
SELECT IS_USED_LOCK('bug16501') = CONNECTION_ID();
SELECT RELEASE_LOCK('bug16501');
connection con1;
reap;
connection default;
SELECT IS_USED_LOCK('bug16501') = connection_idFROM t1WHERE conn = 'con1';
connection con1;
SELECT IS_USED_LOCK('bug16501') = CONNECTION_ID();
SELECT RELEASE_LOCK('bug16501');
SELECT IS_USED_LOCK('bug16501');
connection default;
SELECT RELEASE_ALL_LOCKS();
DROP TABLE t1;
connection con1;
disconnect con1;
connection default;
SET @@session.div_precision_increment=0;
select * from(SELECT MIN(GET_LOCK(0,0) / 1 ^ 0)) as a;
select * from(SELECT MAX(RELEASE_LOCK(0) / 1 ^ 0)) as a;
select * from(SELECT MAX(RELEASE_ALL_LOCKS() / 1 ^ 0)) as a;
SET @@session.div_precision_increment=default;
connection default;
SELECT IS_USED_LOCK('test') IS NULL AS expect_1;
SELECT IS_FREE_LOCK('test') = 1 AS expect_1;
SELECT RELEASE_LOCK('test') IS NULL AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 0 AS expect_1;
SELECT GET_LOCK('test', 0) = 1 AS expect_1;
SELECT IS_USED_LOCK('test') = CONNECTION_ID() AS expect_1;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
connect (con1,localhost,root,,);
connection con1;
eval SET @aux = $default_id;
SELECT IS_USED_LOCK('test') = @aux AS expect_1;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
SELECT GET_LOCK('test', 0) = 0 expect_1;
SELECT RELEASE_LOCK('test') = 0 AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 0 AS expect_1;
connection default;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
SELECT RELEASE_LOCK('test') IS NULL;
SELECT GET_LOCK('test1',0);
SELECT GET_LOCK('test2',0);
SELECT IS_USED_LOCK('test1') = CONNECTION_ID()   AND IS_USED_LOCK('test2') = CONNECTION_ID() AS expect_1;
SELECT RELEASE_LOCK('test1') = 1 AS expect_1;
SELECT IS_FREE_LOCK('test1') = 1 AS expect_1;
SELECT IS_FREE_LOCK('test2') = 0 AS expect_1;
SELECT RELEASE_LOCK('test2') = 1 AS expect_1;
SELECT GET_LOCK('test1',0);
SELECT GET_LOCK('test2',0);
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT IS_FREE_LOCK('test1') AND IS_FREE_LOCK('test2') AS expect_1;
SELECT GET_LOCK('test1',0), GET_LOCK('test2',0);
SELECT IS_USED_LOCK('test1') = CONNECTION_ID()   AND IS_USED_LOCK('test2') = CONNECTION_ID() AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT IS_USED_LOCK('test1') IS NULL AND IS_USED_LOCK('test2') IS NULL AS expect_1;
SELECT GET_LOCK('test1',0) FROM (SELECT 1 AS col1) AS my_tabWHERE GET_LOCK('test2',0) = 1;
SELECT IS_USED_LOCK('test1') = CONNECTION_ID()   AND IS_USED_LOCK('test2') = CONNECTION_ID() AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT IS_USED_LOCK('test1') IS NULL AND IS_USED_LOCK('test2') IS NULL AS expect_1;
SELECT GET_LOCK(col1,0) FROM (SELECT 'test1' AS col1 UNION SELECT 'test2') AS my_tab;
SELECT IS_USED_LOCK('test1') = CONNECTION_ID()   AND IS_USED_LOCK('test2') = CONNECTION_ID() AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT IS_USED_LOCK('test1') IS NULL AND IS_USED_LOCK('test2') IS NULL AS expect_1;
SELECT GET_LOCK('test', 0);
SELECT GET_LOCK('test', 0);
SELECT GET_LOCK('test', 0);
SELECT RELEASE_LOCK('test');
SELECT RELEASE_LOCK('test');
SELECT RELEASE_LOCK('test');
SELECT RELEASE_LOCK('test') IS NULL AS expect_1;
SELECT GET_LOCK('test', 0), GET_LOCK('test', 0);
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT GET_LOCK('test', 0);
connection con1;
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state='User lock';
source include/wait_condition.inc;
eval SET @aux = $con1_id;
KILL QUERY @aux;
connection con1;
reap;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
SELECT IS_USED_LOCK('test') <> CONNECTION_ID() AS expect_1;
connection default;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
connection con1;
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state='User sleep';
source include/wait_condition.inc;
eval SET @aux = $con1_id;
eval KILL QUERY @aux;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
connection con1;
reap;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
SELECT IS_USED_LOCK('test') = CONNECTION_ID() AS expect_1;
connection default;
SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
connection con1;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
connection con1;
SELECT GET_LOCK('test1', 0);
SELECT GET_LOCK('test1', 0);
connection default;
SELECT IS_FREE_LOCK('test1') = 0 AS expect_1;
eval SET @aux = $con1_id;
eval KILL @aux;
                     WHERE id = $con1_id;
source include/wait_condition.inc;
SELECT IS_FREE_LOCK('test1') = 1 AS expect_1;
connection con1;
disconnect con1;
connect (con1,localhost,root,,);
connection default;
SELECT GET_LOCK('test1', 0);
connection con1;
SELECT GET_LOCK('test2', 0);
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state='User lock';
source include/wait_condition.inc;
SELECT GET_LOCK('test2', 7200);
SELECT RELEASE_LOCK('test1');
connection con1;
reap;
SELECT RELEASE_LOCK('test2') + RELEASE_LOCK('test1') = 2 AS expect_1;
connection default;
CREATE TABLE t1 (id INT);
SELECT GET_LOCK('test1', 0);
LOCK TABLE t1 WRITE;
SELECT GET_LOCK('test2', 0);
UNLOCK TABLES;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT GET_LOCK('test1', 0);
FLUSH TABLES WITH READ LOCK;
SELECT GET_LOCK('test2', 0);
UNLOCK TABLES;
SELECT (RELEASE_LOCK('test1') = 1) AND (RELEASE_LOCK('test3') IS NULL)   AND (RELEASE_LOCK('test2') = 1) AS expect_1;
DELETE FROM t1;
BEGIN;
INSERT INTO t1 SET id = 1;
SELECT GET_LOCK('test1', 0);
COMMIT;
BEGIN;
INSERT INTO t1 SET id = 2;
SELECT GET_LOCK('test2', 0);
ROLLBACK;
SELECT RELEASE_ALL_LOCKS() = 2 AS expect_1;
SELECT id FROM t1 ORDER BY id;
DELETE FROM t1;
SELECT GET_LOCK('test', 0);
connection con1;
BEGIN;
INSERT INTO t1 VALUES (1);
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state = 'User lock';
source include/wait_condition.inc;
eval $stmt1;
connection con1;
reap;
                     WHERE info LIKE 'rename%' AND state = 'Waiting for table metadata lock';
source include/wait_condition.inc;
COMMIT;
connection default;
reap;
RENAME TABLE t2 TO t1;
SELECT RELEASE_LOCK('test');
connection con1;
SELECT COUNT(*) = 1 AS expect_1 FROM t1 WHERE id = 1;
connection default;
SELECT GET_LOCK('test', 0);
connection con1;
LOCK TABLE t1 WRITE;
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state = 'User lock';
source include/wait_condition.inc;
SELECT COUNT(*) FROM t1;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
connection con1;
reap;
SELECT RELEASE_LOCK('test');
UNLOCK TABLES;
connection default;
DELETE FROM t1;
CREATE TRIGGER trig_t1_ins BEFORE INSERT ON t1 FOR EACH ROWSET @aux = GET_LOCK(new.id,7200);
SELECT GET_LOCK(CAST(2 AS CHAR),0);
INSERT INTO t1 VALUES(1),(2),(3);
SELECT RELEASE_LOCK(1) = 1 AS expect_1;
SELECT RELEASE_LOCK(2) = 1 AS expect_1;
SELECT RELEASE_LOCK(2) = 1 AS expect_1;
SELECT RELEASE_LOCK(3) = 1 AS expect_1;
SELECT RELEASE_ALL_LOCKS() = 0 AS expect_1;
SELECT COUNT(*) FROM t1;
connection default;
DELETE FROM t1;
SELECT GET_LOCK(2,0);
connection con1;
eval $stmt;
connection default;
                     WHERE info LIKE 'SET @aux%' AND state = 'User lock';
source include/wait_condition.inc;
RENAME TABLE t1 TO t1x;
RENAME TABLE t1x TO t1;
connection con1;
reap;
SELECT RELEASE_ALL_LOCKS();
SELECT COUNT(*) FROM t1;
connection default;
SELECT RELEASE_ALL_LOCKS();
connection default;
DELETE FROM t1;
DROP TRIGGER trig_t1_ins;
CREATE TRIGGER trig_t1_ins BEFORE INSERT ON t1 FOR EACH ROWBEGIN  SET @aux = GET_LOCK(2,1);
  IF @aux <> 1 THEN      SIGNAL SQLSTATE '45000'      SET MESSAGE_TEXT = 'LOCK 2 not got. Abort.', MYSQL_ERRNO = 9999;
  END IF;
END;|SELECT GET_LOCK(CAST(2 AS CHAR),0);
connection con1;
SELECT GET_LOCK(CAST(1 AS CHAR),0);
connection default;
eval $stmt;
connection con1;
                     WHERE info LIKE 'select%' AND state = 'User lock';
source include/wait_condition.inc;
INSERT INTO t1 VALUES(1),(2),(3);
SELECT RELEASE_ALL_LOCKS();
SELECT COUNT(*) FROM t1;
connection default;
SELECT RELEASE_ALL_LOCKS();
connection default;
DELETE FROM t1;
SELECT GET_LOCK(CAST(2 AS CHAR),0);
connection con1;
INSERT INTO t1 VALUES(1),(2),(3);
SELECT @aux;
SELECT RELEASE_ALL_LOCKS();
SELECT COUNT(*) FROM t1;
connection default;
SELECT RELEASE_ALL_LOCKS();
DROP TRIGGER trig_t1_ins;
connection default;
CREATE TABLE t2 (col1 INT, col2 INT, PRIMARY KEY(col1));
DELETE FROM t1;
INSERT INTO t1 VALUES(1),(2),(1);
INSERT INTO t2 SELECT id, GET_LOCK(id,0) FROM t1;
SELECT RELEASE_ALL_LOCKS();
SELECT * FROM t2;
DELETE FROM t1;
DELETE FROM t2;
INSERT INTO t1 VALUES(1),(1),(2);
INSERT INTO t2 SELECT id, GET_LOCK(id,0) FROM t1;
SELECT RELEASE_ALL_LOCKS();
SELECT * FROM t2;
DROP TABLE t2;
SELECT GET_LOCK('test', 0) ORDER BY oscar;
SELECT RELEASE_ALL_LOCKS() = 0 AS expect_1;
connection default;
DROP TABLE t1;
SELECT GET_LOCK('test', 0), RELEASE_LOCK('test');
SELECT IS_FREE_LOCK('test') = 1 AS expect_1;
SELECT GET_LOCK('test', 0), RELEASE_LOCK('test'), GET_LOCK('test', 0);
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $counter = `SELECT $disconnect_timeout * 10`;
while (!$mysql_errno)    show session status;
  dec $counter;
  if (!$counter)  {    if ($show_rpl_debug_info)    {          }      }  SELECT IS_FREE_LOCK('test') = 0 AS expect_1;
SELECT RELEASE_LOCK('test') = 1 AS expect_1;
SELECT GET_LOCK('test', 0), GET_LOCK('test1', 0), RELEASE_ALL_LOCKS(),       GET_LOCK('test', 0);
SELECT RELEASE_ALL_LOCKS() = 1 AS expect_1;
CREATE TABLE t1 AS SELECT GET_LOCK('test', 0) AS g, RELEASE_LOCK('test') AS r,RELEASE_ALL_LOCKS() AS ra, IS_USED_LOCK('test') AS isu,                       IS_FREE_LOCK('test') AS isf;
DESCRIBE t1;
DROP TABLE t1;
SELECT GET_LOCK(NULL, 0);
SELECT GET_LOCK("", 0);
SELECT RELEASE_LOCK(NULL);
SELECT RELEASE_LOCK("");
SELECT IS_USED_LOCK(NULL);
SELECT IS_USED_LOCK("");
SELECT IS_FREE_LOCK(NULL);
SELECT IS_FREE_LOCK("");
SELECT GET_LOCK(REPEAT('a', 64), 0) = 1 AS expect_1;
SELECT IS_USED_LOCK(REPEAT('a', 64)) = CONNECTION_ID() AS expect_1;
SELECT IS_FREE_LOCK(REPEAT('a', 64)) = 0 AS expect_1;
SELECT RELEASE_LOCK(REPEAT('a', 64)) = 1 AS expect_1;
SELECT GET_LOCK(REPEAT('a', 65), 0);
SELECT IS_USED_LOCK(REPEAT('a', 65));
SELECT IS_FREE_LOCK(REPEAT('a', 65));
SELECT RELEASE_LOCK(REPEAT('a', 65));
SELECT GET_LOCK('A', 0);
connection con1;
SELECT GET_LOCK('a', 0);
connection default;
SELECT IS_USED_LOCK('a') = CONNECTION_ID();
SELECT IS_FREE_LOCK('a');
SELECT RELEASE_LOCK('a');
SELECT GET_LOCK(_cp1251 0xf2e5f1f2, 0);
connection con1;
SELECT GET_LOCK(_utf8 0xd182d0b5d181d182, 0);
connection default;
SELECT IS_USED_LOCK(_koi8r 0xd4c5d3d4) = CONNECTION_ID();
SELECT IS_FREE_LOCK(_utf8 0xd182d0b5d181d182);
SELECT RELEASE_LOCK(_utf8 0xd182d0b5d181d182);
SELECT GET_LOCK('test');
SELECT GET_LOCK('test', 0, 1);
SELECT RELEASE_LOCK();
SELECT RELEASE_LOCK('test', 1);
SELECT RELEASE_ALL_LOCKS('test');
SELECT IS_USED_LOCK();
SELECT IS_USED_LOCK('test', 'test2');
SELECT IS_FREE_LOCK();
SELECT IS_FREE_LOCK('test', 'test2');
connection con1;
SELECT GET_LOCK("test", 0);
connection default;
SELECT GET_LOCK("test", NULL) = 0 AS expect_1;
connection con1;
SELECT RELEASE_LOCK("test");
connection default;
connection default;
SELECT GET_LOCK('test', 0);
connection con1;
eval $stmt;
connection default;
                     WHERE info LIKE 'select%' AND state = 'User lock';
source include/wait_condition.inc;
SELECT RELEASE_LOCK('test');
connection con1;
reap;
SELECT RELEASE_LOCK('test');
disconnect con1;
connection default;
CREATE TABLE t1 (conn CHAR(7), connection_id INT);
INSERT INTO t1 VALUES ('default', CONNECTION_ID());
SELECT GET_LOCK('bug16501',600);
connect (con1,localhost,root,,);
INSERT INTO t1 VALUES ('con1', CONNECTION_ID());
SELECT IS_USED_LOCK('bug16501') = connection_idFROM t1WHERE conn = 'default';
eval $stmt;
connection default;
SELECT IS_USED_LOCK('bug16501') = CONNECTION_ID();
SELECT RELEASE_LOCK('bug16501');
connection con1;
reap;
connection default;
SELECT IS_USED_LOCK('bug16501') = connection_idFROM t1WHERE conn = 'con1';
connection con1;
SELECT IS_USED_LOCK('bug16501') = CONNECTION_ID();
SELECT RELEASE_LOCK('bug16501');
SELECT IS_USED_LOCK('bug16501');
connection default;
SELECT RELEASE_ALL_LOCKS();
DROP TABLE t1;
connection con1;
disconnect con1;
connection default;
SET @@session.div_precision_increment=0;
select * from(SELECT MIN(GET_LOCK(0,0) / 1 ^ 0)) as a;
select * from(SELECT MAX(RELEASE_LOCK(0) / 1 ^ 0)) as a;
select * from(SELECT MAX(RELEASE_ALL_LOCKS() / 1 ^ 0)) as a;
SET @@session.div_precision_increment=default;
