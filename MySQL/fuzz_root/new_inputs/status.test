  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }   let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   set @old_concurrent_insert= @@global.concurrent_insert;
set @@global.concurrent_insert= 0;
SET @old_log_output = @@global.log_output;
SET GLOBAL LOG_OUTPUT = 'FILE';
connect (con1,localhost,root,,);
connect (con2,localhost,root,,);
connection default;
flush status;
show status like 'Table_lock%';
select * from performance_schema.session_status where variable_name like 'Table_lock%';
set sql_log_bin=0;
set @old_general_log = @@global.general_log;
set global general_log = 'OFF';
drop table if exists t1;
create table t1(n int);
insert into t1 values(1);
select get_lock('mysqltest_lock', 100);
connection con2;
connection con1;
                     where STATE = "User lock" and                           INFO = "update t1 set n = get_lock('mysqltest_lock', 100)";
connection default;
    where ID = (select connection_id()) and STATE = "Waiting for table level lock";
select release_lock('mysqltest_lock');
connection con2;
select release_lock('mysqltest_lock');
connection con1;
reap;
show status like 'Table_locks_waited';
connection default;
drop table t1;
set global general_log = @old_general_log;
disconnect con2;
disconnect con1;
select 1;
show status like 'last_query_cost';
create table t1 (a int);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
analyze table t1;
select * from t1 where a=6;
show status like 'last_query_cost';
show status like 'last_query_cost';
select 1;
show status like 'last_query_cost';
drop table t1;
FLUSH STATUS;
eval SET @wait_left = $disconnect_timeout;
eval SET @max_used_connections = SUBSTRING('$max_used_connections', 21)+0;
while ($wait_more)  sleep 1;
  FLUSH STATUS;
  SET @wait_left = @wait_left - 1;
  let $max_used_connections = `SHOW STATUS LIKE 'max_used_connections'`;
  eval SET @max_used_connections = SUBSTRING('$max_used_connections', 21)+0;
  let $wait_more = `SELECT @max_used_connections != 1 && @wait_left > 0`;
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
SET @save_thread_cache_size=@@thread_cache_size;
SET GLOBAL thread_cache_size=3;
connect (con1,localhost,root,,);
connect (con2,localhost,root,,);
connection con1;
disconnect con2;
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
FLUSH STATUS;
eval SET @wait_left = $disconnect_timeout;
eval SET @max_used_connections = SUBSTRING('$max_used_connections', 21)+0;
while ($wait_more)  sleep 1;
  FLUSH STATUS;
  SET @wait_left = @wait_left - 1;
  let $max_used_connections = `SHOW STATUS LIKE 'max_used_connections'`;
  eval SET @max_used_connections = SUBSTRING('$max_used_connections', 21)+0;
  let $wait_more = `SELECT @max_used_connections != 2 && @wait_left > 0`;
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
connect (con2,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
connect (con3,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
connection default;
SET GLOBAL thread_cache_size=@save_thread_cache_size;
disconnect con3;
disconnect con2;
disconnect con1;
CREATE TABLE t1 ( a INT );
INSERT INTO t1 VALUES (1), (2);
analyze table t1;
SELECT a FROM t1 LIMIT 1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT a FROM t1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
SELECT a FROM t1 UNION SELECT a FROM t1 ORDER BY a;
SHOW SESSION STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT a FROM t1 UNION SELECT a FROM t1 ORDER BY a;
SHOW SESSION STATUS LIKE 'Last_query_cost';
SELECT a IN (SELECT a FROM t1) FROM t1 LIMIT 1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
SELECT (SELECT a FROM t1 LIMIT 1) x FROM t1 LIMIT 1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
SELECT * FROM t1 a, t1 b ORDER BY a.a, b.a LIMIT 1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
DROP TABLE t1;
flush status;
show status like 'Com%function';
DELIMITER //;
create function f1 (x INTEGER) returns integer  begin    declare ret integer;
    set ret = x * 10;
    return ret;
  end //DELIMITER ;//drop function f1;
show status like 'Com%function';
connect (root, localhost, root,,test);
connection root;
create database db37908;
create table db37908.t1(f1 int);
insert into db37908.t1 values(1);
create user mysqltest_1@localhost;
grant usage,execute on test.* to mysqltest_1@localhost;
delimiter |;
create procedure proc37908() begin select 1; end |create function func37908() returns int sql security invoker  return (select * from db37908.t1 limit 1)|delimiter ;|connect (user1,localhost,mysqltest_1,,test);
connection user1;
select * from db37908.t1;
show status where variable_name ='uptime' and 2 in (select * from db37908.t1);
show procedure status where name ='proc37908' and 1 in (select f1 from db37908.t1);
show function status where name ='func37908' and 1 in (select func37908());
connection default;
disconnect user1;
disconnect root;
drop database db37908;
drop procedure proc37908;
drop function func37908;
REVOKE ALL PRIVILEGES, GRANT OPTION FROM mysqltest_1@localhost;
DROP USER mysqltest_1@localhost;
  SELECT COUNT(*) = 0  FROM information_schema.processlist  WHERE  id in ('$root_connection_id','$user1_connection_id');
connect (con1,localhost,root,,);
connection con1;
DROP PROCEDURE IF EXISTS p1;
DROP FUNCTION IF EXISTS f1;
DELIMITER $$;
CREATE FUNCTION f1() RETURNS INTEGERBEGIN  DECLARE foo INTEGER;
  DECLARE bar INTEGER;
  SET foo=1;
  SET bar=2;
  RETURN foo;
END $$CREATE PROCEDURE p1()  BEGIN  SELECT 1;
END $$DELIMITER ;$$SELECT f1();
CALL p1();
eval SELECT $diff;
disconnect con1;
connection default;
DROP PROCEDURE p1;
DROP FUNCTION f1;
create table t1 (i int);
create table t2 (j int);
create table t3 (k int);
flush tables;
flush status;
set @old_table_open_cache= @@table_open_cache;
show status like 'table_open_cache_%';
select * from t1;
show status like 'table_open_cache_%';
select * from t1;
show status like 'table_open_cache_%';
select * from t2;
show status like 'table_open_cache_%';
select * from t2;
show status like 'table_open_cache_%';
select * from t1 as a, t2 as b, t1 as c, t2 as d, t1 as e, t2 as f;
show status like 'table_open_cache_%';
set @@global.table_open_cache= 4;
select * from t1;
show status like 'table_open_cache_%';
select * from t1 as a, t2 as b, t1 as c, t2 as d, t1 as e, t2 as f;
show status like 'table_open_cache_%';
select * from t3;
show status like 'table_open_cache_%';
set @@global.table_open_cache= @old_table_open_cache;
drop tables t1, t2, t3;
connect (con1,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections_time';
connect (con2,localhost,root,,);
connect (con3,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections';
disconnect con2;
connect (con4,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections';
disconnect con1;
disconnect con3;
FLUSH STATUS;
disconnect con4;
set @@global.concurrent_insert= @old_concurrent_insert;
SET GLOBAL log_output = 'FILE,TABLE';
CREATE TABLE t1(x INT, y INT);
INSERT INTO t1 VALUES (1, 2), (3, 4), (5, 6);
ANALYZE TABLE t1;
EXPLAIN SELECT * FROM t1;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT (SELECT MAX(x) FROM t1) FROM t1;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE x IN (SELECT MAX(x) FROM t1);
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT /*+ NO_MERGE(a) */ * FROM (SELECT * FROM t1) a, t1 b;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE x > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE x > 0        UNION ALL        SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE x > 0        UNION DISTINCT        SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN INSERT INTO t1 SELECT * FROM t1;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN INSERT INTO t1        SELECT * FROM t1 WHERE x > 0        UNION ALL        SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN INSERT INTO t1        SELECT * FROM t1 WHERE x > 0        UNION DISTINCT        SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
DROP TABLE t1;
CREATE TABLE t1 (pk INTEGER PRIMARY KEY,                 i1 INTEGER,                 i2 INTEGER NOT NULL,                 INDEX k1 (i1),                 INDEX k2 (i1, i2));
INSERT INTO t1 VALUES  (1, NULL, 43), (11, NULL, 103), (10, 32,50), (9, 12, 43),  (8, NULL, 13), (7, 48, 90), (6, 56, 90), (5, 87, 84),  (4, 58, 98), (3, 30, 82), (2, 54, 57), (12, 232, 43),  (13, 43, 103), (14, 32, 45), (15, 12, 43), (16, 89, 23),  (17, 48, 90), (18, 56, 90), (19, 87, 84);
CREATE TABLE t2 (pk INTEGER PRIMARY KEY,                 i1 INTEGER NOT NULL,                 INDEX k1 (i1));
INSERT INTO t2 VALUES  (3, 89), (4, 98), (5, 84), (6, 8), (7, 99), (8, 110),  (9, 84), (10, 98), (11, 103), (12, 50), (13, 84),  (14, 57), (15, 82), (16, 103), (2, 98), (1, 90);
ANALYZE TABLE t1, t2;
EXPLAIN SELECT * FROM t1, t2 WHERE t1.i1 = t2.i1 ORDER BY t1.i1 LIMIT 10;
SHOW STATUS LIKE 'Last_query_cost';
DROP TABLE t1, t2;
SET @@global.log_output = @old_log_output;
SET @@global.general_log = @old_general_log;
TRUNCATE TABLE mysql.general_log;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }   let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   set @old_concurrent_insert= @@global.concurrent_insert;
set @@global.concurrent_insert= 0;
SET @old_log_output = @@global.log_output;
SET GLOBAL LOG_OUTPUT = 'FILE';
connect (con1,localhost,root,,);
connect (con2,localhost,root,,);
connection default;
flush status;
show status like 'Table_lock%';
select * from performance_schema.session_status where variable_name like 'Table_lock%';
set sql_log_bin=0;
set @old_general_log = @@global.general_log;
set global general_log = 'OFF';
drop table if exists t1;
create table t1(n int);
insert into t1 values(1);
select get_lock('mysqltest_lock', 100);
connection con2;
connection con1;
                     where STATE = "User lock" and                           INFO = "update t1 set n = get_lock('mysqltest_lock', 100)";
connection default;
    where ID = (select connection_id()) and STATE = "Waiting for table level lock";
select release_lock('mysqltest_lock');
connection con2;
select release_lock('mysqltest_lock');
connection con1;
reap;
show status like 'Table_locks_waited';
connection default;
drop table t1;
set global general_log = @old_general_log;
disconnect con2;
disconnect con1;
select 1;
show status like 'last_query_cost';
create table t1 (a int);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
analyze table t1;
select * from t1 where a=6;
show status like 'last_query_cost';
show status like 'last_query_cost';
select 1;
show status like 'last_query_cost';
drop table t1;
FLUSH STATUS;
eval SET @wait_left = $disconnect_timeout;
eval SET @max_used_connections = SUBSTRING('$max_used_connections', 21)+0;
while ($wait_more)  sleep 1;
  FLUSH STATUS;
  SET @wait_left = @wait_left - 1;
  let $max_used_connections = `SHOW STATUS LIKE 'max_used_connections'`;
  eval SET @max_used_connections = SUBSTRING('$max_used_connections', 21)+0;
  let $wait_more = `SELECT @max_used_connections != 1 && @wait_left > 0`;
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
SET @save_thread_cache_size=@@thread_cache_size;
SET GLOBAL thread_cache_size=3;
connect (con1,localhost,root,,);
connect (con2,localhost,root,,);
connection con1;
disconnect con2;
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
FLUSH STATUS;
eval SET @wait_left = $disconnect_timeout;
eval SET @max_used_connections = SUBSTRING('$max_used_connections', 21)+0;
while ($wait_more)  sleep 1;
  FLUSH STATUS;
  SET @wait_left = @wait_left - 1;
  let $max_used_connections = `SHOW STATUS LIKE 'max_used_connections'`;
  eval SET @max_used_connections = SUBSTRING('$max_used_connections', 21)+0;
  let $wait_more = `SELECT @max_used_connections != 2 && @wait_left > 0`;
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
connect (con2,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
connect (con3,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
connection default;
SET GLOBAL thread_cache_size=@save_thread_cache_size;
disconnect con3;
disconnect con2;
disconnect con1;
CREATE TABLE t1 ( a INT );
INSERT INTO t1 VALUES (1), (2);
analyze table t1;
SELECT a FROM t1 LIMIT 1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT a FROM t1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
SELECT a FROM t1 UNION SELECT a FROM t1 ORDER BY a;
SHOW SESSION STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT a FROM t1 UNION SELECT a FROM t1 ORDER BY a;
SHOW SESSION STATUS LIKE 'Last_query_cost';
SELECT a IN (SELECT a FROM t1) FROM t1 LIMIT 1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
SELECT (SELECT a FROM t1 LIMIT 1) x FROM t1 LIMIT 1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
SELECT * FROM t1 a, t1 b ORDER BY a.a, b.a LIMIT 1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
DROP TABLE t1;
flush status;
show status like 'Com%function';
DELIMITER //;
create function f1 (x INTEGER) returns integer  begin    declare ret integer;
    set ret = x * 10;
    return ret;
  end //DELIMITER ;//drop function f1;
show status like 'Com%function';
connect (root, localhost, root,,test);
connection root;
create database db37908;
create table db37908.t1(f1 int);
insert into db37908.t1 values(1);
create user mysqltest_1@localhost;
grant usage,execute on test.* to mysqltest_1@localhost;
delimiter |;
create procedure proc37908() begin select 1; end |create function func37908() returns int sql security invoker  return (select * from db37908.t1 limit 1)|delimiter ;|connect (user1,localhost,mysqltest_1,,test);
connection user1;
select * from db37908.t1;
show status where variable_name ='uptime' and 2 in (select * from db37908.t1);
show procedure status where name ='proc37908' and 1 in (select f1 from db37908.t1);
show function status where name ='func37908' and 1 in (select func37908());
connection default;
disconnect user1;
disconnect root;
drop database db37908;
drop procedure proc37908;
drop function func37908;
REVOKE ALL PRIVILEGES, GRANT OPTION FROM mysqltest_1@localhost;
DROP USER mysqltest_1@localhost;
  SELECT COUNT(*) = 0  FROM information_schema.processlist  WHERE  id in ('$root_connection_id','$user1_connection_id');
connect (con1,localhost,root,,);
connection con1;
DROP PROCEDURE IF EXISTS p1;
DROP FUNCTION IF EXISTS f1;
DELIMITER $$;
CREATE FUNCTION f1() RETURNS INTEGERBEGIN  DECLARE foo INTEGER;
  DECLARE bar INTEGER;
  SET foo=1;
  SET bar=2;
  RETURN foo;
END $$CREATE PROCEDURE p1()  BEGIN  SELECT 1;
END $$DELIMITER ;$$SELECT f1();
CALL p1();
eval SELECT $diff;
disconnect con1;
connection default;
DROP PROCEDURE p1;
DROP FUNCTION f1;
create table t1 (i int);
create table t2 (j int);
create table t3 (k int);
flush tables;
flush status;
set @old_table_open_cache= @@table_open_cache;
show status like 'table_open_cache_%';
select * from t1;
show status like 'table_open_cache_%';
select * from t1;
show status like 'table_open_cache_%';
select * from t2;
show status like 'table_open_cache_%';
select * from t2;
show status like 'table_open_cache_%';
select * from t1 as a, t2 as b, t1 as c, t2 as d, t1 as e, t2 as f;
show status like 'table_open_cache_%';
set @@global.table_open_cache= 4;
select * from t1;
show status like 'table_open_cache_%';
select * from t1 as a, t2 as b, t1 as c, t2 as d, t1 as e, t2 as f;
show status like 'table_open_cache_%';
select * from t3;
show status like 'table_open_cache_%';
set @@global.table_open_cache= @old_table_open_cache;
drop tables t1, t2, t3;
connect (con1,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections_time';
connect (con2,localhost,root,,);
connect (con3,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections';
disconnect con2;
connect (con4,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections';
disconnect con1;
disconnect con3;
FLUSH STATUS;
disconnect con4;
set @@global.concurrent_insert= @old_concurrent_insert;
SET GLOBAL log_output = 'FILE,TABLE';
CREATE TABLE t1(x INT, y INT);
INSERT INTO t1 VALUES (1, 2), (3, 4), (5, 6);
ANALYZE TABLE t1;
EXPLAIN SELECT * FROM t1;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT (SELECT MAX(x) FROM t1) FROM t1;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE x IN (SELECT MAX(x) FROM t1);
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT /*+ NO_MERGE(a) */ * FROM (SELECT * FROM t1) a, t1 b;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE x > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE x > 0        UNION ALL        SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE x > 0        UNION DISTINCT        SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN INSERT INTO t1 SELECT * FROM t1;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN INSERT INTO t1        SELECT * FROM t1 WHERE x > 0        UNION ALL        SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN INSERT INTO t1        SELECT * FROM t1 WHERE x > 0        UNION DISTINCT        SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
DROP TABLE t1;
CREATE TABLE t1 (pk INTEGER PRIMARY KEY,                 i1 INTEGER,                 i2 INTEGER NOT NULL,                 INDEX k1 (i1),                 INDEX k2 (i1, i2));
INSERT INTO t1 VALUES  (1, NULL, 43), (11, NULL, 103), (10, 32,50), (9, 12, 43),  (8, NULL, 13), (7, 48, 90), (6, 56, 90), (5, 87, 84),  (4, 58, 98), (3, 30, 82), (2, 54, 57), (12, 232, 43),  (13, 43, 103), (14, 32, 45), (15, 12, 43), (16, 89, 23),  (17, 48, 90), (18, 56, 90), (19, 87, 84);
CREATE TABLE t2 (pk INTEGER PRIMARY KEY,                 i1 INTEGER NOT NULL,                 INDEX k1 (i1));
INSERT INTO t2 VALUES  (3, 89), (4, 98), (5, 84), (6, 8), (7, 99), (8, 110),  (9, 84), (10, 98), (11, 103), (12, 50), (13, 84),  (14, 57), (15, 82), (16, 103), (2, 98), (1, 90);
ANALYZE TABLE t1, t2;
EXPLAIN SELECT * FROM t1, t2 WHERE t1.i1 = t2.i1 ORDER BY t1.i1 LIMIT 10;
SHOW STATUS LIKE 'Last_query_cost';
DROP TABLE t1, t2;
SET @@global.log_output = @old_log_output;
SET @@global.general_log = @old_general_log;
TRUNCATE TABLE mysql.general_log;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }   let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   set @old_concurrent_insert= @@global.concurrent_insert;
set @@global.concurrent_insert= 0;
SET @old_log_output = @@global.log_output;
SET GLOBAL LOG_OUTPUT = 'FILE';
connect (con1,localhost,root,,);
connect (con2,localhost,root,,);
connection default;
flush status;
show status like 'Table_lock%';
select * from performance_schema.session_status where variable_name like 'Table_lock%';
set sql_log_bin=0;
set @old_general_log = @@global.general_log;
set global general_log = 'OFF';
drop table if exists t1;
create table t1(n int);
insert into t1 values(1);
select get_lock('mysqltest_lock', 100);
connection con2;
connection con1;
                     where STATE = "User lock" and                           INFO = "update t1 set n = get_lock('mysqltest_lock', 100)";
connection default;
    where ID = (select connection_id()) and STATE = "Waiting for table level lock";
select release_lock('mysqltest_lock');
connection con2;
select release_lock('mysqltest_lock');
connection con1;
reap;
show status like 'Table_locks_waited';
connection default;
drop table t1;
set global general_log = @old_general_log;
disconnect con2;
disconnect con1;
select 1;
show status like 'last_query_cost';
create table t1 (a int);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
analyze table t1;
select * from t1 where a=6;
show status like 'last_query_cost';
show status like 'last_query_cost';
select 1;
show status like 'last_query_cost';
drop table t1;
FLUSH STATUS;
eval SET @wait_left = $disconnect_timeout;
eval SET @max_used_connections = SUBSTRING('$max_used_connections', 21)+0;
while ($wait_more)  sleep 1;
  FLUSH STATUS;
  SET @wait_left = @wait_left - 1;
  let $max_used_connections = `SHOW STATUS LIKE 'max_used_connections'`;
  eval SET @max_used_connections = SUBSTRING('$max_used_connections', 21)+0;
  let $wait_more = `SELECT @max_used_connections != 1 && @wait_left > 0`;
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
SET @save_thread_cache_size=@@thread_cache_size;
SET GLOBAL thread_cache_size=3;
connect (con1,localhost,root,,);
connect (con2,localhost,root,,);
connection con1;
disconnect con2;
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
FLUSH STATUS;
eval SET @wait_left = $disconnect_timeout;
eval SET @max_used_connections = SUBSTRING('$max_used_connections', 21)+0;
while ($wait_more)  sleep 1;
  FLUSH STATUS;
  SET @wait_left = @wait_left - 1;
  let $max_used_connections = `SHOW STATUS LIKE 'max_used_connections'`;
  eval SET @max_used_connections = SUBSTRING('$max_used_connections', 21)+0;
  let $wait_more = `SELECT @max_used_connections != 2 && @wait_left > 0`;
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
connect (con2,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
connect (con3,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
connection default;
SET GLOBAL thread_cache_size=@save_thread_cache_size;
disconnect con3;
disconnect con2;
disconnect con1;
CREATE TABLE t1 ( a INT );
INSERT INTO t1 VALUES (1), (2);
analyze table t1;
SELECT a FROM t1 LIMIT 1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT a FROM t1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
SELECT a FROM t1 UNION SELECT a FROM t1 ORDER BY a;
SHOW SESSION STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT a FROM t1 UNION SELECT a FROM t1 ORDER BY a;
SHOW SESSION STATUS LIKE 'Last_query_cost';
SELECT a IN (SELECT a FROM t1) FROM t1 LIMIT 1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
SELECT (SELECT a FROM t1 LIMIT 1) x FROM t1 LIMIT 1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
SELECT * FROM t1 a, t1 b ORDER BY a.a, b.a LIMIT 1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
DROP TABLE t1;
flush status;
show status like 'Com%function';
DELIMITER //;
create function f1 (x INTEGER) returns integer  begin    declare ret integer;
    set ret = x * 10;
    return ret;
  end //DELIMITER ;//drop function f1;
show status like 'Com%function';
connect (root, localhost, root,,test);
connection root;
create database db37908;
create table db37908.t1(f1 int);
insert into db37908.t1 values(1);
create user mysqltest_1@localhost;
grant usage,execute on test.* to mysqltest_1@localhost;
delimiter |;
create procedure proc37908() begin select 1; end |create function func37908() returns int sql security invoker  return (select * from db37908.t1 limit 1)|delimiter ;|connect (user1,localhost,mysqltest_1,,test);
connection user1;
select * from db37908.t1;
show status where variable_name ='uptime' and 2 in (select * from db37908.t1);
show procedure status where name ='proc37908' and 1 in (select f1 from db37908.t1);
show function status where name ='func37908' and 1 in (select func37908());
connection default;
disconnect user1;
disconnect root;
drop database db37908;
drop procedure proc37908;
drop function func37908;
REVOKE ALL PRIVILEGES, GRANT OPTION FROM mysqltest_1@localhost;
DROP USER mysqltest_1@localhost;
  SELECT COUNT(*) = 0  FROM information_schema.processlist  WHERE  id in ('$root_connection_id','$user1_connection_id');
connect (con1,localhost,root,,);
connection con1;
DROP PROCEDURE IF EXISTS p1;
DROP FUNCTION IF EXISTS f1;
DELIMITER $$;
CREATE FUNCTION f1() RETURNS INTEGERBEGIN  DECLARE foo INTEGER;
  DECLARE bar INTEGER;
  SET foo=1;
  SET bar=2;
  RETURN foo;
END $$CREATE PROCEDURE p1()  BEGIN  SELECT 1;
END $$DELIMITER ;$$SELECT f1();
CALL p1();
eval SELECT $diff;
disconnect con1;
connection default;
DROP PROCEDURE p1;
DROP FUNCTION f1;
create table t1 (i int);
create table t2 (j int);
create table t3 (k int);
flush tables;
flush status;
set @old_table_open_cache= @@table_open_cache;
show status like 'table_open_cache_%';
select * from t1;
show status like 'table_open_cache_%';
select * from t1;
show status like 'table_open_cache_%';
select * from t2;
show status like 'table_open_cache_%';
select * from t2;
show status like 'table_open_cache_%';
select * from t1 as a, t2 as b, t1 as c, t2 as d, t1 as e, t2 as f;
show status like 'table_open_cache_%';
set @@global.table_open_cache= 4;
select * from t1;
show status like 'table_open_cache_%';
select * from t1 as a, t2 as b, t1 as c, t2 as d, t1 as e, t2 as f;
show status like 'table_open_cache_%';
select * from t3;
show status like 'table_open_cache_%';
set @@global.table_open_cache= @old_table_open_cache;
drop tables t1, t2, t3;
connect (con1,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections_time';
connect (con2,localhost,root,,);
connect (con3,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections';
disconnect con2;
connect (con4,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections';
disconnect con1;
disconnect con3;
FLUSH STATUS;
disconnect con4;
set @@global.concurrent_insert= @old_concurrent_insert;
SET GLOBAL log_output = 'FILE,TABLE';
CREATE TABLE t1(x INT, y INT);
INSERT INTO t1 VALUES (1, 2), (3, 4), (5, 6);
ANALYZE TABLE t1;
EXPLAIN SELECT * FROM t1;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT (SELECT MAX(x) FROM t1) FROM t1;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE x IN (SELECT MAX(x) FROM t1);
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT /*+ NO_MERGE(a) */ * FROM (SELECT * FROM t1) a, t1 b;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE x > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE x > 0        UNION ALL        SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE x > 0        UNION DISTINCT        SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN INSERT INTO t1 SELECT * FROM t1;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN INSERT INTO t1        SELECT * FROM t1 WHERE x > 0        UNION ALL        SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN INSERT INTO t1        SELECT * FROM t1 WHERE x > 0        UNION DISTINCT        SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
DROP TABLE t1;
CREATE TABLE t1 (pk INTEGER PRIMARY KEY,                 i1 INTEGER,                 i2 INTEGER NOT NULL,                 INDEX k1 (i1),                 INDEX k2 (i1, i2));
INSERT INTO t1 VALUES  (1, NULL, 43), (11, NULL, 103), (10, 32,50), (9, 12, 43),  (8, NULL, 13), (7, 48, 90), (6, 56, 90), (5, 87, 84),  (4, 58, 98), (3, 30, 82), (2, 54, 57), (12, 232, 43),  (13, 43, 103), (14, 32, 45), (15, 12, 43), (16, 89, 23),  (17, 48, 90), (18, 56, 90), (19, 87, 84);
CREATE TABLE t2 (pk INTEGER PRIMARY KEY,                 i1 INTEGER NOT NULL,                 INDEX k1 (i1));
INSERT INTO t2 VALUES  (3, 89), (4, 98), (5, 84), (6, 8), (7, 99), (8, 110),  (9, 84), (10, 98), (11, 103), (12, 50), (13, 84),  (14, 57), (15, 82), (16, 103), (2, 98), (1, 90);
ANALYZE TABLE t1, t2;
EXPLAIN SELECT * FROM t1, t2 WHERE t1.i1 = t2.i1 ORDER BY t1.i1 LIMIT 10;
SHOW STATUS LIKE 'Last_query_cost';
DROP TABLE t1, t2;
SET @@global.log_output = @old_log_output;
SET @@global.general_log = @old_general_log;
TRUNCATE TABLE mysql.general_log;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }   let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   set @old_concurrent_insert= @@global.concurrent_insert;
set @@global.concurrent_insert= 0;
SET @old_log_output = @@global.log_output;
SET GLOBAL LOG_OUTPUT = 'FILE';
connect (con1,localhost,root,,);
connect (con2,localhost,root,,);
connection default;
flush status;
show status like 'Table_lock%';
select * from performance_schema.session_status where variable_name like 'Table_lock%';
set sql_log_bin=0;
set @old_general_log = @@global.general_log;
set global general_log = 'OFF';
drop table if exists t1;
create table t1(n int);
insert into t1 values(1);
select get_lock('mysqltest_lock', 100);
connection con2;
connection con1;
                     where STATE = "User lock" and                           INFO = "update t1 set n = get_lock('mysqltest_lock', 100)";
connection default;
    where ID = (select connection_id()) and STATE = "Waiting for table level lock";
select release_lock('mysqltest_lock');
connection con2;
select release_lock('mysqltest_lock');
connection con1;
reap;
show status like 'Table_locks_waited';
connection default;
drop table t1;
set global general_log = @old_general_log;
disconnect con2;
disconnect con1;
select 1;
show status like 'last_query_cost';
create table t1 (a int);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
analyze table t1;
select * from t1 where a=6;
show status like 'last_query_cost';
show status like 'last_query_cost';
select 1;
show status like 'last_query_cost';
drop table t1;
FLUSH STATUS;
eval SET @wait_left = $disconnect_timeout;
eval SET @max_used_connections = SUBSTRING('$max_used_connections', 21)+0;
while ($wait_more)  sleep 1;
  FLUSH STATUS;
  SET @wait_left = @wait_left - 1;
  let $max_used_connections = `SHOW STATUS LIKE 'max_used_connections'`;
  eval SET @max_used_connections = SUBSTRING('$max_used_connections', 21)+0;
  let $wait_more = `SELECT @max_used_connections != 1 && @wait_left > 0`;
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
SET @save_thread_cache_size=@@thread_cache_size;
SET GLOBAL thread_cache_size=3;
connect (con1,localhost,root,,);
connect (con2,localhost,root,,);
connection con1;
disconnect con2;
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
FLUSH STATUS;
eval SET @wait_left = $disconnect_timeout;
eval SET @max_used_connections = SUBSTRING('$max_used_connections', 21)+0;
while ($wait_more)  sleep 1;
  FLUSH STATUS;
  SET @wait_left = @wait_left - 1;
  let $max_used_connections = `SHOW STATUS LIKE 'max_used_connections'`;
  eval SET @max_used_connections = SUBSTRING('$max_used_connections', 21)+0;
  let $wait_more = `SELECT @max_used_connections != 2 && @wait_left > 0`;
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
connect (con2,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
connect (con3,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
connection default;
SET GLOBAL thread_cache_size=@save_thread_cache_size;
disconnect con3;
disconnect con2;
disconnect con1;
CREATE TABLE t1 ( a INT );
INSERT INTO t1 VALUES (1), (2);
analyze table t1;
SELECT a FROM t1 LIMIT 1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT a FROM t1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
SELECT a FROM t1 UNION SELECT a FROM t1 ORDER BY a;
SHOW SESSION STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT a FROM t1 UNION SELECT a FROM t1 ORDER BY a;
SHOW SESSION STATUS LIKE 'Last_query_cost';
SELECT a IN (SELECT a FROM t1) FROM t1 LIMIT 1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
SELECT (SELECT a FROM t1 LIMIT 1) x FROM t1 LIMIT 1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
SELECT * FROM t1 a, t1 b ORDER BY a.a, b.a LIMIT 1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
DROP TABLE t1;
flush status;
show status like 'Com%function';
DELIMITER //;
create function f1 (x INTEGER) returns integer  begin    declare ret integer;
    set ret = x * 10;
    return ret;
  end //DELIMITER ;//drop function f1;
show status like 'Com%function';
connect (root, localhost, root,,test);
connection root;
create database db37908;
create table db37908.t1(f1 int);
insert into db37908.t1 values(1);
create user mysqltest_1@localhost;
grant usage,execute on test.* to mysqltest_1@localhost;
delimiter |;
create procedure proc37908() begin select 1; end |create function func37908() returns int sql security invoker  return (select * from db37908.t1 limit 1)|delimiter ;|connect (user1,localhost,mysqltest_1,,test);
connection user1;
select * from db37908.t1;
show status where variable_name ='uptime' and 2 in (select * from db37908.t1);
show procedure status where name ='proc37908' and 1 in (select f1 from db37908.t1);
show function status where name ='func37908' and 1 in (select func37908());
connection default;
disconnect user1;
disconnect root;
drop database db37908;
drop procedure proc37908;
drop function func37908;
REVOKE ALL PRIVILEGES, GRANT OPTION FROM mysqltest_1@localhost;
DROP USER mysqltest_1@localhost;
  SELECT COUNT(*) = 0  FROM information_schema.processlist  WHERE  id in ('$root_connection_id','$user1_connection_id');
connect (con1,localhost,root,,);
connection con1;
DROP PROCEDURE IF EXISTS p1;
DROP FUNCTION IF EXISTS f1;
DELIMITER $$;
CREATE FUNCTION f1() RETURNS INTEGERBEGIN  DECLARE foo INTEGER;
  DECLARE bar INTEGER;
  SET foo=1;
  SET bar=2;
  RETURN foo;
END $$CREATE PROCEDURE p1()  BEGIN  SELECT 1;
END $$DELIMITER ;$$SELECT f1();
CALL p1();
eval SELECT $diff;
disconnect con1;
connection default;
DROP PROCEDURE p1;
DROP FUNCTION f1;
create table t1 (i int);
create table t2 (j int);
create table t3 (k int);
flush tables;
flush status;
set @old_table_open_cache= @@table_open_cache;
show status like 'table_open_cache_%';
select * from t1;
show status like 'table_open_cache_%';
select * from t1;
show status like 'table_open_cache_%';
select * from t2;
show status like 'table_open_cache_%';
select * from t2;
show status like 'table_open_cache_%';
select * from t1 as a, t2 as b, t1 as c, t2 as d, t1 as e, t2 as f;
show status like 'table_open_cache_%';
set @@global.table_open_cache= 4;
select * from t1;
show status like 'table_open_cache_%';
select * from t1 as a, t2 as b, t1 as c, t2 as d, t1 as e, t2 as f;
show status like 'table_open_cache_%';
select * from t3;
show status like 'table_open_cache_%';
set @@global.table_open_cache= @old_table_open_cache;
drop tables t1, t2, t3;
connect (con1,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections_time';
connect (con2,localhost,root,,);
connect (con3,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections';
disconnect con2;
connect (con4,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections';
disconnect con1;
disconnect con3;
FLUSH STATUS;
disconnect con4;
set @@global.concurrent_insert= @old_concurrent_insert;
SET GLOBAL log_output = 'FILE,TABLE';
CREATE TABLE t1(x INT, y INT);
INSERT INTO t1 VALUES (1, 2), (3, 4), (5, 6);
ANALYZE TABLE t1;
EXPLAIN SELECT * FROM t1;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT (SELECT MAX(x) FROM t1) FROM t1;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE x IN (SELECT MAX(x) FROM t1);
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT /*+ NO_MERGE(a) */ * FROM (SELECT * FROM t1) a, t1 b;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE x > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE x > 0        UNION ALL        SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE x > 0        UNION DISTINCT        SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN INSERT INTO t1 SELECT * FROM t1;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN INSERT INTO t1        SELECT * FROM t1 WHERE x > 0        UNION ALL        SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN INSERT INTO t1        SELECT * FROM t1 WHERE x > 0        UNION DISTINCT        SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
DROP TABLE t1;
CREATE TABLE t1 (pk INTEGER PRIMARY KEY,                 i1 INTEGER,                 i2 INTEGER NOT NULL,                 INDEX k1 (i1),                 INDEX k2 (i1, i2));
INSERT INTO t1 VALUES  (1, NULL, 43), (11, NULL, 103), (10, 32,50), (9, 12, 43),  (8, NULL, 13), (7, 48, 90), (6, 56, 90), (5, 87, 84),  (4, 58, 98), (3, 30, 82), (2, 54, 57), (12, 232, 43),  (13, 43, 103), (14, 32, 45), (15, 12, 43), (16, 89, 23),  (17, 48, 90), (18, 56, 90), (19, 87, 84);
CREATE TABLE t2 (pk INTEGER PRIMARY KEY,                 i1 INTEGER NOT NULL,                 INDEX k1 (i1));
INSERT INTO t2 VALUES  (3, 89), (4, 98), (5, 84), (6, 8), (7, 99), (8, 110),  (9, 84), (10, 98), (11, 103), (12, 50), (13, 84),  (14, 57), (15, 82), (16, 103), (2, 98), (1, 90);
ANALYZE TABLE t1, t2;
EXPLAIN SELECT * FROM t1, t2 WHERE t1.i1 = t2.i1 ORDER BY t1.i1 LIMIT 10;
SHOW STATUS LIKE 'Last_query_cost';
DROP TABLE t1, t2;
SET @@global.log_output = @old_log_output;
SET @@global.general_log = @old_general_log;
TRUNCATE TABLE mysql.general_log;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }   let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   set @old_concurrent_insert= @@global.concurrent_insert;
set @@global.concurrent_insert= 0;
SET @old_log_output = @@global.log_output;
SET GLOBAL LOG_OUTPUT = 'FILE';
connect (con1,localhost,root,,);
connect (con2,localhost,root,,);
connection default;
flush status;
show status like 'Table_lock%';
select * from performance_schema.session_status where variable_name like 'Table_lock%';
set sql_log_bin=0;
set @old_general_log = @@global.general_log;
set global general_log = 'OFF';
drop table if exists t1;
create table t1(n int);
insert into t1 values(1);
select get_lock('mysqltest_lock', 100);
connection con2;
connection con1;
                     where STATE = "User lock" and                           INFO = "update t1 set n = get_lock('mysqltest_lock', 100)";
connection default;
    where ID = (select connection_id()) and STATE = "Waiting for table level lock";
select release_lock('mysqltest_lock');
connection con2;
select release_lock('mysqltest_lock');
connection con1;
reap;
show status like 'Table_locks_waited';
connection default;
drop table t1;
set global general_log = @old_general_log;
disconnect con2;
disconnect con1;
select 1;
show status like 'last_query_cost';
create table t1 (a int);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
analyze table t1;
select * from t1 where a=6;
show status like 'last_query_cost';
show status like 'last_query_cost';
select 1;
show status like 'last_query_cost';
drop table t1;
FLUSH STATUS;
eval SET @wait_left = $disconnect_timeout;
eval SET @max_used_connections = SUBSTRING('$max_used_connections', 21)+0;
while ($wait_more)  sleep 1;
  FLUSH STATUS;
  SET @wait_left = @wait_left - 1;
  let $max_used_connections = `SHOW STATUS LIKE 'max_used_connections'`;
  eval SET @max_used_connections = SUBSTRING('$max_used_connections', 21)+0;
  let $wait_more = `SELECT @max_used_connections != 1 && @wait_left > 0`;
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
SET @save_thread_cache_size=@@thread_cache_size;
SET GLOBAL thread_cache_size=3;
connect (con1,localhost,root,,);
connect (con2,localhost,root,,);
connection con1;
disconnect con2;
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
FLUSH STATUS;
eval SET @wait_left = $disconnect_timeout;
eval SET @max_used_connections = SUBSTRING('$max_used_connections', 21)+0;
while ($wait_more)  sleep 1;
  FLUSH STATUS;
  SET @wait_left = @wait_left - 1;
  let $max_used_connections = `SHOW STATUS LIKE 'max_used_connections'`;
  eval SET @max_used_connections = SUBSTRING('$max_used_connections', 21)+0;
  let $wait_more = `SELECT @max_used_connections != 2 && @wait_left > 0`;
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
connect (con2,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
connect (con3,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections';
SELECT * FROM performance_schema.session_status WHERE VARIABLE_NAME LIKE 'max_used_connections';
connection default;
SET GLOBAL thread_cache_size=@save_thread_cache_size;
disconnect con3;
disconnect con2;
disconnect con1;
CREATE TABLE t1 ( a INT );
INSERT INTO t1 VALUES (1), (2);
analyze table t1;
SELECT a FROM t1 LIMIT 1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT a FROM t1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
SELECT a FROM t1 UNION SELECT a FROM t1 ORDER BY a;
SHOW SESSION STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT a FROM t1 UNION SELECT a FROM t1 ORDER BY a;
SHOW SESSION STATUS LIKE 'Last_query_cost';
SELECT a IN (SELECT a FROM t1) FROM t1 LIMIT 1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
SELECT (SELECT a FROM t1 LIMIT 1) x FROM t1 LIMIT 1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
SELECT * FROM t1 a, t1 b ORDER BY a.a, b.a LIMIT 1;
SHOW SESSION STATUS LIKE 'Last_query_cost';
DROP TABLE t1;
flush status;
show status like 'Com%function';
DELIMITER //;
create function f1 (x INTEGER) returns integer  begin    declare ret integer;
    set ret = x * 10;
    return ret;
  end //DELIMITER ;//drop function f1;
show status like 'Com%function';
connect (root, localhost, root,,test);
connection root;
create database db37908;
create table db37908.t1(f1 int);
insert into db37908.t1 values(1);
create user mysqltest_1@localhost;
grant usage,execute on test.* to mysqltest_1@localhost;
delimiter |;
create procedure proc37908() begin select 1; end |create function func37908() returns int sql security invoker  return (select * from db37908.t1 limit 1)|delimiter ;|connect (user1,localhost,mysqltest_1,,test);
connection user1;
select * from db37908.t1;
show status where variable_name ='uptime' and 2 in (select * from db37908.t1);
show procedure status where name ='proc37908' and 1 in (select f1 from db37908.t1);
show function status where name ='func37908' and 1 in (select func37908());
connection default;
disconnect user1;
disconnect root;
drop database db37908;
drop procedure proc37908;
drop function func37908;
REVOKE ALL PRIVILEGES, GRANT OPTION FROM mysqltest_1@localhost;
DROP USER mysqltest_1@localhost;
  SELECT COUNT(*) = 0  FROM information_schema.processlist  WHERE  id in ('$root_connection_id','$user1_connection_id');
connect (con1,localhost,root,,);
connection con1;
DROP PROCEDURE IF EXISTS p1;
DROP FUNCTION IF EXISTS f1;
DELIMITER $$;
CREATE FUNCTION f1() RETURNS INTEGERBEGIN  DECLARE foo INTEGER;
  DECLARE bar INTEGER;
  SET foo=1;
  SET bar=2;
  RETURN foo;
END $$CREATE PROCEDURE p1()  BEGIN  SELECT 1;
END $$DELIMITER ;$$SELECT f1();
CALL p1();
eval SELECT $diff;
disconnect con1;
connection default;
DROP PROCEDURE p1;
DROP FUNCTION f1;
create table t1 (i int);
create table t2 (j int);
create table t3 (k int);
flush tables;
flush status;
set @old_table_open_cache= @@table_open_cache;
show status like 'table_open_cache_%';
select * from t1;
show status like 'table_open_cache_%';
select * from t1;
show status like 'table_open_cache_%';
select * from t2;
show status like 'table_open_cache_%';
select * from t2;
show status like 'table_open_cache_%';
select * from t1 as a, t2 as b, t1 as c, t2 as d, t1 as e, t2 as f;
show status like 'table_open_cache_%';
set @@global.table_open_cache= 4;
select * from t1;
show status like 'table_open_cache_%';
select * from t1 as a, t2 as b, t1 as c, t2 as d, t1 as e, t2 as f;
show status like 'table_open_cache_%';
select * from t3;
show status like 'table_open_cache_%';
set @@global.table_open_cache= @old_table_open_cache;
drop tables t1, t2, t3;
connect (con1,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections_time';
connect (con2,localhost,root,,);
connect (con3,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections';
disconnect con2;
connect (con4,localhost,root,,);
SHOW STATUS LIKE 'max_used_connections';
disconnect con1;
disconnect con3;
FLUSH STATUS;
disconnect con4;
set @@global.concurrent_insert= @old_concurrent_insert;
SET GLOBAL log_output = 'FILE,TABLE';
CREATE TABLE t1(x INT, y INT);
INSERT INTO t1 VALUES (1, 2), (3, 4), (5, 6);
ANALYZE TABLE t1;
EXPLAIN SELECT * FROM t1;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT (SELECT MAX(x) FROM t1) FROM t1;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE x IN (SELECT MAX(x) FROM t1);
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT /*+ NO_MERGE(a) */ * FROM (SELECT * FROM t1) a, t1 b;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE x > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE x > 0        UNION ALL        SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN SELECT * FROM t1 WHERE x > 0        UNION DISTINCT        SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN INSERT INTO t1 SELECT * FROM t1;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN INSERT INTO t1        SELECT * FROM t1 WHERE x > 0        UNION ALL        SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
EXPLAIN INSERT INTO t1        SELECT * FROM t1 WHERE x > 0        UNION DISTINCT        SELECT * FROM t1 WHERE y > 0;
SHOW STATUS LIKE 'Last_query_cost';
DROP TABLE t1;
CREATE TABLE t1 (pk INTEGER PRIMARY KEY,                 i1 INTEGER,                 i2 INTEGER NOT NULL,                 INDEX k1 (i1),                 INDEX k2 (i1, i2));
INSERT INTO t1 VALUES  (1, NULL, 43), (11, NULL, 103), (10, 32,50), (9, 12, 43),  (8, NULL, 13), (7, 48, 90), (6, 56, 90), (5, 87, 84),  (4, 58, 98), (3, 30, 82), (2, 54, 57), (12, 232, 43),  (13, 43, 103), (14, 32, 45), (15, 12, 43), (16, 89, 23),  (17, 48, 90), (18, 56, 90), (19, 87, 84);
CREATE TABLE t2 (pk INTEGER PRIMARY KEY,                 i1 INTEGER NOT NULL,                 INDEX k1 (i1));
INSERT INTO t2 VALUES  (3, 89), (4, 98), (5, 84), (6, 8), (7, 99), (8, 110),  (9, 84), (10, 98), (11, 103), (12, 50), (13, 84),  (14, 57), (15, 82), (16, 103), (2, 98), (1, 90);
ANALYZE TABLE t1, t2;
EXPLAIN SELECT * FROM t1, t2 WHERE t1.i1 = t2.i1 ORDER BY t1.i1 LIMIT 10;
SHOW STATUS LIKE 'Last_query_cost';
DROP TABLE t1, t2;
SET @@global.log_output = @old_log_output;
SET @@global.general_log = @old_general_log;
TRUNCATE TABLE mysql.general_log;
