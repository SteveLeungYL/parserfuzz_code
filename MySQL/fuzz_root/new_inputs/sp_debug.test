     let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   CREATE FUNCTION f1() RETURNS INT return 1;
CREATE PROCEDURE p1() SELECT 1 AS my_column;
SET DEBUG='+d,fail_stored_routine_load';
SELECT f1();
CALL p1();
SET DEBUG='-d,fail_stored_routine_load';
SELECT f1();
CALL p1();
DROP FUNCTION f1;
DROP PROCEDURE p1;
SET DEBUG='+d,simulate_routine_length_error';
CREATE PROCEDURE p1() SELECT "simulate_routine_length_error";
SET DEBUG='-d,simulate_routine_length_error';
CREATE SCHEMA new_db;
CREATE PROCEDURE new_db.proc() SELECT 1 AS my_column;
SET DEBUG='+d,fail_drop_db_routines';
DROP SCHEMA IF EXISTS new_db;
SET DEBUG='-d,fail_drop_db_routines';
DROP SCHEMA IF EXISTS new_db;
CREATE SCHEMA new_db;
DROP SCHEMA new_db;
CREATE TABLE t1 (a INT);
DELIMITER |;
CREATE FUNCTION f1() RETURNS INTBEGIN  INSERT INTO t1 VALUES (1);
  RETURN 1;
END|DELIMITER ;|SET DEBUG_SYNC= "sp_lex_instr_before_exec_core SIGNAL sp_ready WAIT_FOR sp_finish";
send SELECT f1();
SET DEBUG_SYNC="now WAIT_FOR sp_ready";
SET DEBUG_SYNC="now SIGNAL sp_finish";
reap;
SET DEBUG_SYNC='RESET';
DROP TABLE t1;
DROP FUNCTION f1;
disconnect con1;
SET NAMES utf8;
SET DEBUG='+d,simulate_lctn_two_case_for_schema_case_compare';
CREATE DATABASE `tèst-db`;
CREATE PROCEDURE `tèst-db`.test() SELECT 1;
DROP DATABASE `tèst-db`;
SET DEBUG='-d,simulate_lctn_two_case_for_schema_case_compare';
SET NAMES default;
CREATE SCHEMA testdb;
CREATE USER usr_no_priv@localhost, usr_show_routine@localhost, usr_global_select@localhost, usr_definer@localhost, usr_role@localhost, usr_create_routine@localhost, usr_alter_routine@localhost, usr_execute@localhost;
CREATE ROLE role_show_routine;
GRANT role_show_routine to usr_role@localhost;
GRANT SHOW_ROUTINE ON *.* TO usr_show_routine@localhost, role_show_routine;
GRANT SELECT ON *.* TO usr_global_select@localhost;
GRANT EXECUTE ON *.* TO usr_execute@localhost;
GRANT CREATE ROUTINE ON *.* TO usr_create_routine@localhost;
GRANT ALTER ROUTINE ON *.* TO usr_alter_routine@localhost;
CREATE PROCEDURE testdb.proc_root() SELECT "ProcRoot";
CREATE FUNCTION testdb.func_root() RETURNS VARCHAR(8) DETERMINISTIC RETURN "FuncRoot";
CREATE DEFINER = `usr_definer`@`localhost` PROCEDURE testdb.proc_definer() SELECT "ProcDefiner";
CREATE DEFINER = `usr_definer`@`localhost` FUNCTION testdb.func_definer() RETURNS VARCHAR(11) DETERMINISTIC RETURN "FuncDefiner";
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SET ROLE role_show_routine;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW FUNCTION CODE testdb.func_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SET @start_partial_revokes = @@global.partial_revokes;
SET @@global.partial_revokes=ON;
REVOKE SELECT ON testdb.* FROM usr_global_select@localhost;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
DROP USER usr_global_select@localhost;
SET @@global.partial_revokes = @start_partial_revokes;
DROP USER usr_no_priv@localhost, usr_show_routine@localhost, usr_definer@localhost, usr_role@localhost, usr_create_routine@localhost, usr_alter_routine@localhost, usr_execute@localhost;
DROP ROLE role_show_routine;
DROP SCHEMA testdb;
     let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   CREATE FUNCTION f1() RETURNS INT return 1;
CREATE PROCEDURE p1() SELECT 1 AS my_column;
SET DEBUG='+d,fail_stored_routine_load';
SELECT f1();
CALL p1();
SET DEBUG='-d,fail_stored_routine_load';
SELECT f1();
CALL p1();
DROP FUNCTION f1;
DROP PROCEDURE p1;
SET DEBUG='+d,simulate_routine_length_error';
CREATE PROCEDURE p1() SELECT "simulate_routine_length_error";
SET DEBUG='-d,simulate_routine_length_error';
CREATE SCHEMA new_db;
CREATE PROCEDURE new_db.proc() SELECT 1 AS my_column;
SET DEBUG='+d,fail_drop_db_routines';
DROP SCHEMA IF EXISTS new_db;
SET DEBUG='-d,fail_drop_db_routines';
DROP SCHEMA IF EXISTS new_db;
CREATE SCHEMA new_db;
DROP SCHEMA new_db;
CREATE TABLE t1 (a INT);
DELIMITER |;
CREATE FUNCTION f1() RETURNS INTBEGIN  INSERT INTO t1 VALUES (1);
  RETURN 1;
END|DELIMITER ;|SET DEBUG_SYNC= "sp_lex_instr_before_exec_core SIGNAL sp_ready WAIT_FOR sp_finish";
send SELECT f1();
SET DEBUG_SYNC="now WAIT_FOR sp_ready";
SET DEBUG_SYNC="now SIGNAL sp_finish";
reap;
SET DEBUG_SYNC='RESET';
DROP TABLE t1;
DROP FUNCTION f1;
disconnect con1;
SET NAMES utf8;
SET DEBUG='+d,simulate_lctn_two_case_for_schema_case_compare';
CREATE DATABASE `tèst-db`;
CREATE PROCEDURE `tèst-db`.test() SELECT 1;
DROP DATABASE `tèst-db`;
SET DEBUG='-d,simulate_lctn_two_case_for_schema_case_compare';
SET NAMES default;
CREATE SCHEMA testdb;
CREATE USER usr_no_priv@localhost, usr_show_routine@localhost, usr_global_select@localhost, usr_definer@localhost, usr_role@localhost, usr_create_routine@localhost, usr_alter_routine@localhost, usr_execute@localhost;
CREATE ROLE role_show_routine;
GRANT role_show_routine to usr_role@localhost;
GRANT SHOW_ROUTINE ON *.* TO usr_show_routine@localhost, role_show_routine;
GRANT SELECT ON *.* TO usr_global_select@localhost;
GRANT EXECUTE ON *.* TO usr_execute@localhost;
GRANT CREATE ROUTINE ON *.* TO usr_create_routine@localhost;
GRANT ALTER ROUTINE ON *.* TO usr_alter_routine@localhost;
CREATE PROCEDURE testdb.proc_root() SELECT "ProcRoot";
CREATE FUNCTION testdb.func_root() RETURNS VARCHAR(8) DETERMINISTIC RETURN "FuncRoot";
CREATE DEFINER = `usr_definer`@`localhost` PROCEDURE testdb.proc_definer() SELECT "ProcDefiner";
CREATE DEFINER = `usr_definer`@`localhost` FUNCTION testdb.func_definer() RETURNS VARCHAR(11) DETERMINISTIC RETURN "FuncDefiner";
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SET ROLE role_show_routine;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW FUNCTION CODE testdb.func_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SET @start_partial_revokes = @@global.partial_revokes;
SET @@global.partial_revokes=ON;
REVOKE SELECT ON testdb.* FROM usr_global_select@localhost;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
DROP USER usr_global_select@localhost;
SET @@global.partial_revokes = @start_partial_revokes;
DROP USER usr_no_priv@localhost, usr_show_routine@localhost, usr_definer@localhost, usr_role@localhost, usr_create_routine@localhost, usr_alter_routine@localhost, usr_execute@localhost;
DROP ROLE role_show_routine;
DROP SCHEMA testdb;
     let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   CREATE FUNCTION f1() RETURNS INT return 1;
CREATE PROCEDURE p1() SELECT 1 AS my_column;
SET DEBUG='+d,fail_stored_routine_load';
SELECT f1();
CALL p1();
SET DEBUG='-d,fail_stored_routine_load';
SELECT f1();
CALL p1();
DROP FUNCTION f1;
DROP PROCEDURE p1;
SET DEBUG='+d,simulate_routine_length_error';
CREATE PROCEDURE p1() SELECT "simulate_routine_length_error";
SET DEBUG='-d,simulate_routine_length_error';
CREATE SCHEMA new_db;
CREATE PROCEDURE new_db.proc() SELECT 1 AS my_column;
SET DEBUG='+d,fail_drop_db_routines';
DROP SCHEMA IF EXISTS new_db;
SET DEBUG='-d,fail_drop_db_routines';
DROP SCHEMA IF EXISTS new_db;
CREATE SCHEMA new_db;
DROP SCHEMA new_db;
CREATE TABLE t1 (a INT);
DELIMITER |;
CREATE FUNCTION f1() RETURNS INTBEGIN  INSERT INTO t1 VALUES (1);
  RETURN 1;
END|DELIMITER ;|SET DEBUG_SYNC= "sp_lex_instr_before_exec_core SIGNAL sp_ready WAIT_FOR sp_finish";
send SELECT f1();
SET DEBUG_SYNC="now WAIT_FOR sp_ready";
SET DEBUG_SYNC="now SIGNAL sp_finish";
reap;
SET DEBUG_SYNC='RESET';
DROP TABLE t1;
DROP FUNCTION f1;
disconnect con1;
SET NAMES utf8;
SET DEBUG='+d,simulate_lctn_two_case_for_schema_case_compare';
CREATE DATABASE `tèst-db`;
CREATE PROCEDURE `tèst-db`.test() SELECT 1;
DROP DATABASE `tèst-db`;
SET DEBUG='-d,simulate_lctn_two_case_for_schema_case_compare';
SET NAMES default;
CREATE SCHEMA testdb;
CREATE USER usr_no_priv@localhost, usr_show_routine@localhost, usr_global_select@localhost, usr_definer@localhost, usr_role@localhost, usr_create_routine@localhost, usr_alter_routine@localhost, usr_execute@localhost;
CREATE ROLE role_show_routine;
GRANT role_show_routine to usr_role@localhost;
GRANT SHOW_ROUTINE ON *.* TO usr_show_routine@localhost, role_show_routine;
GRANT SELECT ON *.* TO usr_global_select@localhost;
GRANT EXECUTE ON *.* TO usr_execute@localhost;
GRANT CREATE ROUTINE ON *.* TO usr_create_routine@localhost;
GRANT ALTER ROUTINE ON *.* TO usr_alter_routine@localhost;
CREATE PROCEDURE testdb.proc_root() SELECT "ProcRoot";
CREATE FUNCTION testdb.func_root() RETURNS VARCHAR(8) DETERMINISTIC RETURN "FuncRoot";
CREATE DEFINER = `usr_definer`@`localhost` PROCEDURE testdb.proc_definer() SELECT "ProcDefiner";
CREATE DEFINER = `usr_definer`@`localhost` FUNCTION testdb.func_definer() RETURNS VARCHAR(11) DETERMINISTIC RETURN "FuncDefiner";
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SET ROLE role_show_routine;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW FUNCTION CODE testdb.func_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SET @start_partial_revokes = @@global.partial_revokes;
SET @@global.partial_revokes=ON;
REVOKE SELECT ON testdb.* FROM usr_global_select@localhost;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
DROP USER usr_global_select@localhost;
SET @@global.partial_revokes = @start_partial_revokes;
DROP USER usr_no_priv@localhost, usr_show_routine@localhost, usr_definer@localhost, usr_role@localhost, usr_create_routine@localhost, usr_alter_routine@localhost, usr_execute@localhost;
DROP ROLE role_show_routine;
DROP SCHEMA testdb;
     let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   CREATE FUNCTION f1() RETURNS INT return 1;
CREATE PROCEDURE p1() SELECT 1 AS my_column;
SET DEBUG='+d,fail_stored_routine_load';
SELECT f1();
CALL p1();
SET DEBUG='-d,fail_stored_routine_load';
SELECT f1();
CALL p1();
DROP FUNCTION f1;
DROP PROCEDURE p1;
SET DEBUG='+d,simulate_routine_length_error';
CREATE PROCEDURE p1() SELECT "simulate_routine_length_error";
SET DEBUG='-d,simulate_routine_length_error';
CREATE SCHEMA new_db;
CREATE PROCEDURE new_db.proc() SELECT 1 AS my_column;
SET DEBUG='+d,fail_drop_db_routines';
DROP SCHEMA IF EXISTS new_db;
SET DEBUG='-d,fail_drop_db_routines';
DROP SCHEMA IF EXISTS new_db;
CREATE SCHEMA new_db;
DROP SCHEMA new_db;
CREATE TABLE t1 (a INT);
DELIMITER |;
CREATE FUNCTION f1() RETURNS INTBEGIN  INSERT INTO t1 VALUES (1);
  RETURN 1;
END|DELIMITER ;|SET DEBUG_SYNC= "sp_lex_instr_before_exec_core SIGNAL sp_ready WAIT_FOR sp_finish";
send SELECT f1();
SET DEBUG_SYNC="now WAIT_FOR sp_ready";
SET DEBUG_SYNC="now SIGNAL sp_finish";
reap;
SET DEBUG_SYNC='RESET';
DROP TABLE t1;
DROP FUNCTION f1;
disconnect con1;
SET NAMES utf8;
SET DEBUG='+d,simulate_lctn_two_case_for_schema_case_compare';
CREATE DATABASE `tèst-db`;
CREATE PROCEDURE `tèst-db`.test() SELECT 1;
DROP DATABASE `tèst-db`;
SET DEBUG='-d,simulate_lctn_two_case_for_schema_case_compare';
SET NAMES default;
CREATE SCHEMA testdb;
CREATE USER usr_no_priv@localhost, usr_show_routine@localhost, usr_global_select@localhost, usr_definer@localhost, usr_role@localhost, usr_create_routine@localhost, usr_alter_routine@localhost, usr_execute@localhost;
CREATE ROLE role_show_routine;
GRANT role_show_routine to usr_role@localhost;
GRANT SHOW_ROUTINE ON *.* TO usr_show_routine@localhost, role_show_routine;
GRANT SELECT ON *.* TO usr_global_select@localhost;
GRANT EXECUTE ON *.* TO usr_execute@localhost;
GRANT CREATE ROUTINE ON *.* TO usr_create_routine@localhost;
GRANT ALTER ROUTINE ON *.* TO usr_alter_routine@localhost;
CREATE PROCEDURE testdb.proc_root() SELECT "ProcRoot";
CREATE FUNCTION testdb.func_root() RETURNS VARCHAR(8) DETERMINISTIC RETURN "FuncRoot";
CREATE DEFINER = `usr_definer`@`localhost` PROCEDURE testdb.proc_definer() SELECT "ProcDefiner";
CREATE DEFINER = `usr_definer`@`localhost` FUNCTION testdb.func_definer() RETURNS VARCHAR(11) DETERMINISTIC RETURN "FuncDefiner";
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SET ROLE role_show_routine;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW FUNCTION CODE testdb.func_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SET @start_partial_revokes = @@global.partial_revokes;
SET @@global.partial_revokes=ON;
REVOKE SELECT ON testdb.* FROM usr_global_select@localhost;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
DROP USER usr_global_select@localhost;
SET @@global.partial_revokes = @start_partial_revokes;
DROP USER usr_no_priv@localhost, usr_show_routine@localhost, usr_definer@localhost, usr_role@localhost, usr_create_routine@localhost, usr_alter_routine@localhost, usr_execute@localhost;
DROP ROLE role_show_routine;
DROP SCHEMA testdb;
     let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   CREATE FUNCTION f1() RETURNS INT return 1;
CREATE PROCEDURE p1() SELECT 1 AS my_column;
SET DEBUG='+d,fail_stored_routine_load';
SELECT f1();
CALL p1();
SET DEBUG='-d,fail_stored_routine_load';
SELECT f1();
CALL p1();
DROP FUNCTION f1;
DROP PROCEDURE p1;
SET DEBUG='+d,simulate_routine_length_error';
CREATE PROCEDURE p1() SELECT "simulate_routine_length_error";
SET DEBUG='-d,simulate_routine_length_error';
CREATE SCHEMA new_db;
CREATE PROCEDURE new_db.proc() SELECT 1 AS my_column;
SET DEBUG='+d,fail_drop_db_routines';
DROP SCHEMA IF EXISTS new_db;
SET DEBUG='-d,fail_drop_db_routines';
DROP SCHEMA IF EXISTS new_db;
CREATE SCHEMA new_db;
DROP SCHEMA new_db;
CREATE TABLE t1 (a INT);
DELIMITER |;
CREATE FUNCTION f1() RETURNS INTBEGIN  INSERT INTO t1 VALUES (1);
  RETURN 1;
END|DELIMITER ;|SET DEBUG_SYNC= "sp_lex_instr_before_exec_core SIGNAL sp_ready WAIT_FOR sp_finish";
send SELECT f1();
SET DEBUG_SYNC="now WAIT_FOR sp_ready";
SET DEBUG_SYNC="now SIGNAL sp_finish";
reap;
SET DEBUG_SYNC='RESET';
DROP TABLE t1;
DROP FUNCTION f1;
disconnect con1;
SET NAMES utf8;
SET DEBUG='+d,simulate_lctn_two_case_for_schema_case_compare';
CREATE DATABASE `tèst-db`;
CREATE PROCEDURE `tèst-db`.test() SELECT 1;
DROP DATABASE `tèst-db`;
SET DEBUG='-d,simulate_lctn_two_case_for_schema_case_compare';
SET NAMES default;
CREATE SCHEMA testdb;
CREATE USER usr_no_priv@localhost, usr_show_routine@localhost, usr_global_select@localhost, usr_definer@localhost, usr_role@localhost, usr_create_routine@localhost, usr_alter_routine@localhost, usr_execute@localhost;
CREATE ROLE role_show_routine;
GRANT role_show_routine to usr_role@localhost;
GRANT SHOW_ROUTINE ON *.* TO usr_show_routine@localhost, role_show_routine;
GRANT SELECT ON *.* TO usr_global_select@localhost;
GRANT EXECUTE ON *.* TO usr_execute@localhost;
GRANT CREATE ROUTINE ON *.* TO usr_create_routine@localhost;
GRANT ALTER ROUTINE ON *.* TO usr_alter_routine@localhost;
CREATE PROCEDURE testdb.proc_root() SELECT "ProcRoot";
CREATE FUNCTION testdb.func_root() RETURNS VARCHAR(8) DETERMINISTIC RETURN "FuncRoot";
CREATE DEFINER = `usr_definer`@`localhost` PROCEDURE testdb.proc_definer() SELECT "ProcDefiner";
CREATE DEFINER = `usr_definer`@`localhost` FUNCTION testdb.func_definer() RETURNS VARCHAR(11) DETERMINISTIC RETURN "FuncDefiner";
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SET ROLE role_show_routine;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW FUNCTION CODE testdb.func_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
SET @start_partial_revokes = @@global.partial_revokes;
SET @@global.partial_revokes=ON;
REVOKE SELECT ON testdb.* FROM usr_global_select@localhost;
SHOW PROCEDURE CODE testdb.proc_root;
SHOW PROCEDURE CODE testdb.proc_definer;
SHOW FUNCTION CODE testdb.func_root;
SHOW FUNCTION CODE testdb.func_definer;
DROP USER usr_global_select@localhost;
SET @@global.partial_revokes = @start_partial_revokes;
DROP USER usr_no_priv@localhost, usr_show_routine@localhost, usr_definer@localhost, usr_role@localhost, usr_create_routine@localhost, usr_alter_routine@localhost, usr_execute@localhost;
DROP ROLE role_show_routine;
DROP SCHEMA testdb;
