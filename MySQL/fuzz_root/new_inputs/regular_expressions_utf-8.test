CREATE FUNCTION icu_major_version() RETURNS INT  RETURN regexp_replace(icu_version(), '([[:digit:]]+)\..*', '$1');
CREATE TABLE t1 (  subject char(10),  pattern char(10));
SELECT regexp_instr( 'abc', 'a' );
SELECT regexp_instr( 'abc', 'b' );
SELECT regexp_instr( 'abc', 'c' );
SELECT regexp_instr( 'abc', 'd' );
SELECT regexp_instr( NULL, 'a' );
SELECT regexp_instr( 'a', NULL );
SELECT regexp_instr( NULL, NULL );
SET NAMES binary;
SELECT hex( concat(regexp_instr( 'a', 'a' )) );
SET NAMES DEFAULT;
SELECT regexp_instr( 1, 'a' );
SELECT regexp_instr( 1.1, 'a' );
SELECT regexp_instr( 'a', 1 );
SELECT regexp_instr( 'a', 1.1 );
SELECT regexp_instr( subject, pattern ) FROM t1;
SELECT regexp_instr( 'a', '[[:invalid_bracket_expression:]]' );
SELECT regexp_instr( 'abcabcabc', 'a+', 1 );
SELECT regexp_instr( 'abcabcabc', 'a+', 2 );
SELECT regexp_instr( 'abcabcabc', 'b+', 1 );
SELECT regexp_instr( 'abcabcabc', 'b+', 2 );
SELECT regexp_instr( 'abcabcabc', 'b+', 3 );
SELECT regexp_instr( 'a', 'a+', 3 );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 2 );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 3 );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 4 );
SELECT regexp_instr( 'abcabcabc', 'a+', 4, 2 );
SELECT regexp_instr( 'a', 'a+', 1, 1, 2 );
SELECT regexp_instr( 'a', 'a+', 1, 1, -1 );
SELECT regexp_instr( 'a', 'a+', 1, 1, NULL );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 0 );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 1 );
SELECT regexp_instr( 'aaabcabcabc', 'a+', 1, 1, 1 );
SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'c' );
SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'i' );
SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'ci' );
SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'cic' );
SELECT regexp_instr( 'a', 'a+', 1, 1, 1, 'x' );
SELECT regexp_instr( 'a', 'a+', 1, 1, 1, NULL );
SELECT regexp_like( 'abc', 'a' );
SELECT regexp_like( 'abc', 'b' );
SELECT regexp_like( 'abc', 'c' );
SELECT regexp_like( 'abc', 'd' );
SELECT regexp_like( 'a', 'a.*' );
SELECT regexp_like( 'ab', 'a.*' );
SELECT regexp_like( NULL, 'a' );
SELECT regexp_like( 'a', NULL );
SELECT regexp_like( NULL, NULL );
SET NAMES binary;
SELECT hex( concat(regexp_like( 'a', 'a' )) );
SET NAMES DEFAULT;
SELECT regexp_like( 'abc', 'A', 'i' );
SELECT regexp_like( 'abc', 'A', 'c' );
SELECT regexp_like( 'a', 'a+', 'x' );
SELECT regexp_like( 'a', 'a+', 'cmnux' );
SELECT regexp_like( 'a', 'a+', NULL );
SELECT regexp_like( 1, 'a' );
SELECT regexp_like( 1.1, 'a' );
SELECT regexp_like( 'a', 1 );
SELECT regexp_like( 'a', 1.1 );
SELECT regexp_like('a', '[[:invalid_bracket_expression:]]');
SELECT regexp_replace( 'aaa', 'a', 'X' );
SELECT regexp_replace( 'abc', 'b', 'X' );
SELECT regexp_replace( NULL, 'a', 'X' );
SELECT regexp_replace( 'aaa', NULL, 'X' );
SELECT regexp_replace( 'aaa', 'a', NULL );
SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' );
SELECT regexp_replace( 'aaa', 'a', 'X', 0 );
SELECT regexp_replace( 'aaa', 'a', 'X', 1 );
SELECT regexp_replace( 'a', 'a+', 'b', 3 );
SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 0, 1 );
SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 );
SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 2 );
SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>', 1, 2 );
SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x', 1, 0 );
SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x', 1, 0 );
SELECT regexp_replace( 'aaab', 'b', 'x', 1, 2 );
SELECT regexp_replace( 'aaabccc', 'b', 'x', 1, 2 );
SELECT regexp_replace( 'abc', 'b', 'X' );
SELECT regexp_replace( 'abcbdb', 'b', 'X' );
SELECT regexp_replace( 'abcbdb', 'b', 'X', 3 );
SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 1 );
SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 2 );
SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 3 );
SELECT regexp_replace( 'a', '[[:invalid_bracket_expression:]]', '$1' );
SELECT regexp_replace( 'aaa', 'a', 'X', 2 );
SELECT regexp_replace( 'aaa', 'a', 'XX', 2 );
SELECT regexp_substr( 'a' );
SELECT regexp_substr( 'a', 'b', 'c', 'd', 'e', 'f' );
SELECT regexp_substr( 'ab ac ad', '.d' );
SELECT regexp_substr( 'ab ac ad', '.D' );
SELECT concat( regexp_substr( 'aaa', 'a+' ), 'x' );
SELECT regexp_substr( 'ab ac ad', 'a.', 0 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3, 1 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3, 2 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3, 3 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3, 3 ) IS NULL;
SELECT regexp_substr( 'ab ac ad', 'A.', 1, 1, 'c' );
SELECT regexp_substr( 'ab\nac\nad', 'A.', 1, 1, 'i' );
SELECT regexp_substr( 'ab\nac\nad', 'A.', 1, 1, 'im' );
SELECT regexp_substr('a', '[[:invalid_bracket_expression:]]');
SET sql_mode = ''; # Un-strictCREATE TABLE t2 ( g GEOMETRY NOT NULL );
INSERT INTO t2 VALUES ( POINT(1,2) );
SELECT concat( regexp_like(g, g), 'x' ) FROM t2;
SET sql_mode = DEFAULT;
DROP TABLE t2;
DROP TABLE t1;
SELECT regexp_instr( '', '((((((((){80}){}){11}){11}){11}){80}){11}){4}' );
SET GLOBAL regexp_stack_limit = 239;
SELECT regexp_instr( '', '(((((((){120}){11}){11}){11}){80}){11}){4}' );
SET GLOBAL regexp_stack_limit = 32;
SELECT regexp_instr( '', '((((((){11}){11}){11}){160}){11}){160}' );
SELECT regexp_instr( '', '(((((){150}){11}){160}){11}){160}' );
SELECT regexp_instr( '', '((((){255}){255}){255}){255}' );
SET GLOBAL regexp_stack_limit = DEFAULT;
SET GLOBAL regexp_time_limit = 1000;
SELECT regexp_instr( 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC', '(A+)+B' );
SET GLOBAL regexp_time_limit = DEFAULT;
SET NAMES latin1;
SELECT regexp_instr( _latin1 x'61F662', _latin1 x'F6' );
SELECT regexp_instr( _latin1 x'61F662', _utf8mb4'ö' );
SELECT regexp_instr( concat('a', _utf8mb4 x'F09F8DA3'), _utf8mb4 x'F09F8DA3' );
SELECT regexp_instr( _utf8mb4'aöb', _utf8mb4'ö' );
SET NAMES utf8;
SELECT regexp_instr( 'aöb', 'ö' );
SET NAMES DEFAULT;
SET NAMES utf8;
SELECT regexp_instr( 'אב רק', /*k*/'^[^ב]' );
PREPARE stmt1 FROM "select 'a' rlike ?";
DEALLOCATE PREPARE stmt1;
CREATE TABLE t1( a INT, subject CHAR(10) );
CREATE TABLE t2( pattern CHAR(10) );
insert into t1 values (0, 'apa');
insert into t2 values ('apa');
DELIMITER ||;
CREATE DEFINER=root@localhost PROCEDURE p1()BEGIN  UPDATE t1, t2  SET a = 1  WHERE regexp_like(t1.subject, t2.pattern);
END||DELIMITER ;||CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1, t2;
CREATE TABLE t1 ( a INT );
EXPLAIN SELECT 1 FROM t1 WHERE 1 REGEXP (1 IN (SELECT 1 FROM t1));
DROP TABLE t1;
PREPARE stmt1 FROM "SELECT regexp_like( 'a', ? )";
PREPARE stmt2 FROM "SELECT regexp_like( ?, 'a' )";
PREPARE stmt3 FROM "SELECT regexp_like( ?, ? )";
SET @subject = 'a';
SET @pattern = 'a+';
EXECUTE stmt1 USING @pattern;
EXECUTE stmt2 USING @subject;
EXECUTE stmt3 USING @subject, @pattern;
SET @subject = 1;
SET @pattern = 1;
EXECUTE stmt1 USING @pattern;
EXECUTE stmt2 USING @subject;
EXECUTE stmt3 USING @subject, @pattern;
DEALLOCATE PREPARE stmt1;
DEALLOCATE PREPARE stmt2;
DEALLOCATE PREPARE stmt3;
DO 1 rlike multilinestring(point(1, 1));
CREATE TABLE t1 ( a CHAR(10) );
INSERT INTO t1 VALUES ( 'abc' ), ( 'bcd' ), ( 'cde' );
SELECT regexp_like( a, 'a' ) FROM t1;
DROP TABLE t1;
CREATE TABLE t1 ( a CHAR ( 10 ), b CHAR ( 10 ) );
INSERT INTO t1 VALUES( NULL, 'abc' );
INSERT INTO t1 VALUES( 'def', NULL );
SELECT a, b, regexp_like( a, b ) FROM t1;
DROP TABLE t1;
CREATE TABLE t1 (  c CHAR(10) CHARSET latin1 COLLATE latin1_bin,  c_ci CHAR(10) CHARSET latin1 COLLATE latin1_general_ci,  c_cs CHAR(10) CHARSET latin1 COLLATE latin1_general_cs);
INSERT INTO t1VALUES ( 'a', 'a', 'a' ), ( 'A', 'A', 'A' ), ( 'b', 'b', 'b' );
SELECT c, c_ci REGEXP 'A', c_cs REGEXP 'A' FROM t1;
DROP TABLE t1;
SELECT regexp_like( _utf8mb4 'ss' COLLATE utf8mb4_german2_ci,                    _utf8mb4 'ß'  COLLATE utf8mb4_german2_ci );
SELECT regexp_like( _utf8mb4 'ß'  COLLATE utf8mb4_german2_ci,                    _utf8mb4 'ss' );
SELECT regexp_like( _utf8mb4 'ß'  COLLATE utf8mb4_de_pb_0900_as_cs,                    _utf8mb4 'ss' );
SET NAMES latin1;
SELECT regexp_like( 'a', 'A' COLLATE latin1_general_ci );
SELECT 'a' REGEXP 'A' COLLATE latin1_general_ci;
SELECT regexp_like( 'a', 'A' COLLATE latin1_general_cs );
SELECT 'a' REGEXP 'A' COLLATE latin1_general_cs;
SELECT regexp_like( 'a\nb\nc', '^b$' );
SELECT regexp_like( 'a\nb\nc', '(?m)^b$' );
SELECT regexp_like( 'a\nb\nc', '.*' );
SELECT regexp_like( _utf16 'a' , 'a' );
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }DROP FUNCTION icu_major_version;
SELECT regexp_like( _utf16le 'a' , 'a' );
SELECT regexp_like( 'aaa', 'a+', 1 );
SELECT regexp_substr( 'aaa', 'a+', 1, 1, 1 );
SELECT regexp_substr( 'aaa', 'a+', 1, 1, 1 );
SELECT regexp_substr( 'aaa', '+' );
CREATE TABLE t1 (  a CHAR(3) CHARACTER SET utf16le,  b CHAR(3) CHARACTER SET utf16le);
INSERT INTO t1 VALUES ( NULL, 'abc' );
INSERT INTO t1 VALUES ( 'def', NULL );
INSERT INTO t1 VALUES ( NULL, NULL );
SELECT a regexp b FROM t1;
DROP TABLE t1;
CREATE TABLE t1  a REAL,  b INT,  c CHAR(100),  d DECIMAL);
INSERT INTO t1 VALUES ( regexp_instr('a', 'a'),                        regexp_instr('a', 'a'),                        regexp_instr('a', 'a'),                        regexp_instr('a', 'a') );
SELECT * FROM t1;
DELETE FROM t1;
INSERT INTO t1 VALUES ( regexp_like('a', 'a'),                        regexp_like('a', 'a'),                        regexp_like('a', 'a'),                        regexp_like('a', 'a') );
SELECT * FROM t1;
DELETE FROM t1;
INSERT INTO t1 ( a ) VALUES ( regexp_replace('a', 'a', 'a') );
INSERT INTO t1 ( b ) VALUES ( regexp_replace('a', 'a', 'a') );
INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') );
INSERT INTO t1 ( d ) VALUES ( regexp_replace('a', 'a', 'a') );
SELECT * FROM t1;
DELETE FROM t1;
INSERT INTO t1 ( a ) VALUES ( regexp_substr('a', 'a') );
INSERT INTO t1 ( b ) VALUES ( regexp_substr('a', 'a') );
INSERT INTO t1 ( c ) VALUES ( regexp_substr('a', 'a') );
INSERT INTO t1 ( d ) VALUES ( regexp_substr('a', 'a') );
SELECT * FROM t1;
DROP TABLE t1;
SELECT cast( regexp_replace('a', 'a', 'a') AS SIGNED INTEGER );
SELECT cast( regexp_substr ('a', 'a')      AS SIGNED INTEGER );
SELECT cast( regexp_instr  ('a', 'a'     ) AS DATETIME );
SELECT cast( regexp_like   ('a', 'a'     ) AS DATETIME );
SELECT cast( regexp_replace('a', 'a', 'a') AS DATETIME );
SELECT cast( regexp_substr ('a', 'a'     ) AS DATETIME );
SELECT cast( regexp_instr  ('a', 'a'     ) AS TIME );
SELECT cast( regexp_like   ('a', 'a'     ) AS TIME );
SELECT cast( regexp_replace('a', 'a', 'a') AS TIME );
SELECT cast( regexp_substr ('a', 'a'     ) AS TIME );
SET GLOBAL net_buffer_length = 1024;
SET GLOBAL max_allowed_packet = @@global.net_buffer_length;
SELECT @@global.max_allowed_packet;
SET @buf_sz_utf16 = @@global.max_allowed_packet / length( _utf16'x' );
SELECT @buf_sz_utf16;
SELECT length(regexp_replace( repeat('a', @buf_sz_utf16), 'a', 'b' ));
SELECT length(regexp_replace( repeat('a', @buf_sz_utf16 + 1), 'a', 'b' ));
SELECT length(regexp_replace( repeat('a', @buf_sz_utf16), 'a', 'bb' ));
SET GLOBAL net_buffer_length = DEFAULT;
SET GLOBAL max_allowed_packet = DEFAULT;
SELECT regexp_like( 'a', '[[:<:]]a' );
SELECT regexp_like( 'a', '   **' );
SELECT regexp_like( 'a', ' \n  **' );
SELECT regexp_like( 'a', '  +++' );
SELECT regexp_like( 'a', '\\' );
SELECT regexp_like('a','(?{})');
SELECT regexp_like('a','(');
SELECT regexp_like('a','a{}');
SELECT regexp_like('a','a{2,1}');
SELECT regexp_like('a','\\1');
SELECT regexp_substr( 'ab','(?<=a+)b' );
SELECT regexp_like( 'a', 'a[' );
SELECT regexp_substr( 'ab','[b-a]' );
CREATE TABLE t1 ( a TEXT );
INSERT INTO t1 VALUES ( repeat( 'a', 16384 ) );
SELECT char_length ( regexp_replace( a, 'a', 'b' ) ) FROM t1;
SET GLOBAL  regexp_time_limit = 10000;
SELECT regexp_like ( regexp_replace( a, 'a', 'b' ), 'b{16384}' ) FROM t1;
SET GLOBAL  regexp_time_limit = DEFAULT;
DROP TABLE t1;
DO '1' regexp repeat('$', 50000000);
DO ( (@b) regexp (cot (unhex ( 1 )) ) );
DO ( (@c) rlike (cot ( (!( @f )) )) );
DO ( ('') rlike (cot ( ' %' )) );
DO ( (-28277) regexp (period_add ( -10966, 1381205734 )) );
DO ( (( @f )) rlike (json_depth ( 'key4' )) );
DO ( ('-  ') regexp (cot ( right (':#.', 33) )) );
DO ( (1) regexp (exp ( 64826 )) );
DO ( (@g) regexp (cot ( @f )) );
DO ( (@b) regexp (exp ( 0x1fc5574c )) );
DO ( (25091) rlike (exp ( 14373 )) );
SET GLOBAL regexp_time_limit = 1000000;
enable_connect_log;
connect(conn1, localhost, root);
send SELECT regexp_instr('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC', '(A+)+B');
connection default;
replace_result $conn1_id <conn1_id>;
eval KILL QUERY $conn1_id;
connection conn1;
reap;
disconnect conn1;
source include/wait_until_disconnected.inc;
connection default;
disable_connect_log;
SET GLOBAL regexp_time_limit = DEFAULT;
SELECT regexp_instr ( 'a', 'a', NULL );
SELECT regexp_instr ( 'a', 'a', 1, NULL );
SELECT regexp_instr ( 'a', 'a', 1, 0, NULL );
SELECT regexp_instr ( 'a', 'a', 1, 0, 0, NULL );
SELECT regexp_like ( 'a', 'a', NULL );
SELECT regexp_replace ( 'a', 'a', 'a', NULL );
SELECT regexp_replace ( 'a', 'a', 'a', 1, NULL );
SELECT regexp_replace ( 'a', 'a', 'a', 1, 0, NULL );
SELECT regexp_substr ( 'a', 'a', NULL );
SELECT regexp_substr ( 'a', 'a', 1, NULL );
SELECT regexp_substr ( 'a', 'a', 1, 0, NULL );
SELECT regexp_like( reverse(''), 123 );
SELECT regexp_like( soundex(@v1), 'abc' );
SELECT regexp_like( left('', ''), 'abc' );
SELECT regexp_like( repeat(@v1, 'abc'), 'abc' );
SELECT regexp_replace( 'abc' , 'abc', '$abc' );
SET @s := "SELECT regexp_like( '', '', ? / '' )";
PREPARE stmt FROM @s;
EXECUTE stmt;
EXECUTE stmt;
CREATE TABLE t1 ( match_parameter CHAR(1) );
INSERT INTO t1 VALUES ( 'i' ), ( 'c' ), ( 'i' ), ( 'c' );
SELECT match_parameter, regexp_like ( 'a', 'A', match_parameter ) FROM t1;
DROP TABLE t1;
SELECT regexp_replace( ' F' , '^ ', '[,$' );
SELECT regexp_instr( 'abc', '(?-' );
select regexp_instr(char('313:50:35.199734'using utf16le),uuid());
CREATE TABLE t1 ( a VARCHAR(10) );
INSERT INTO t1 VALUES ('a a a'), ('b b b'), ('c c c');
SELECT regexp_replace(a, '^([[:alpha:]]+)[[:space:]].*$', '$1') FROM t1;
DROP TABLE t1;
CREATE TABLE t1 ( a CHAR(3) );
INSERT INTO t1 VALUES ( regexp_replace ('a', 'a', 'x') );
SELECT * FROM t1;
UPDATE t1 SET a = regexp_replace ( 'b', 'b', 'y' );
SELECT * FROM t1;
DROP TABLE t1;
CREATE TABLE t1 ( a CHAR(3) );
INSERT INTO t1 VALUES ( regexp_substr ('a', 'a', 1) );
SELECT * FROM t1;
UPDATE t1 SET a = regexp_substr ('b', 'b', 1);
SELECT * FROM t1;
DROP TABLE t1;
CREATE TABLE t1 AS SELECT  regexp_instr( 'a', 'a' ) AS a,  regexp_like( 'a', 'a' ) AS b,  regexp_replace( 'abc', 'b', 'x' ) AS c,  regexp_substr( 'a', 'a' ) AS d,  regexp_substr( repeat('a', 512), 'a' ) AS e,  regexp_substr( repeat('a', 513), 'a' ) AS f;
SHOW CREATE TABLE t1;
SELECT * FROM t1;
DROP TABLE t1;
SET NAMES DEFAULT;
SELECT regexp_instr( '🍣🍣a', '🍣', 2 );
SELECT regexp_instr( '🍣🍣a', 'a', 3 );
SELECT regexp_instr( '🍣🍣a', 'a', 4 );
SELECT regexp_substr( 'a🍣b', '.', 1 );
SELECT regexp_substr( 'a🍣b', '.', 2 );
SELECT regexp_substr( 'a🍣b', '.', 3 );
SELECT regexp_substr( 'a🍣b', '.', 4 );
SELECT regexp_substr( 'a🍣🍣b', '.', 1 );
SELECT regexp_substr( 'a🍣🍣b', '.', 2 );
SELECT regexp_substr( 'a🍣🍣b', '.', 3 );
SELECT regexp_substr( 'a🍣🍣b', '.', 4 );
SELECT regexp_substr( 'a🍣🍣b', '.', 5 );
SELECT regexp_replace( '🍣🍣🍣', '.', 'a', 2 );
SELECT regexp_replace( '🍣🍣🍣', '.', 'a', 2, 2 );
SELECT hex(regexp_replace( convert( 'abcd' using utf8mb4 ), 'c', ''));
SELECT hex(regexp_replace( convert( 'abcd' using utf16 ), 'c', ''));
SELECT hex(regexp_substr( convert( 'abcd' using utf8mb4 ), 'abc'));
SELECT hex(regexp_substr( convert( 'abcd' using utf16 ), 'abc'));
CREATE TABLE t1 (  a CHAR(10) CHARACTER SET utf16le,  b CHAR(10) CHARACTER SET utf16);
INSERT INTO t1 VALUES (  regexp_substr( convert('abcd' using utf16le), 'abc' ),  regexp_substr( convert('abcd' using utf16), 'abc' ));
INSERT INTO t1 VALUES (  regexp_substr( 'abcd', 'abc' ),  regexp_substr( 'abcd', 'abc' ));
SELECT * FROM t1;
DROP TABLE t1;
SELECT regexp_like('1', x'01');
SELECT regexp_like(x'01', '1');
SELECT regexp_replace('01', '01', x'02');
SELECT regexp_replace('01', x'01', '02');
SELECT regexp_replace('01', x'01', x'02');
SELECT regexp_replace(x'01', '01', '02');
SELECT regexp_replace(x'01', '01', x'02');
SELECT regexp_replace(x'01', x'01', '02');
CREATE TABLE t1(a CHAR(1));
CREATE TABLE t2(a BLOB);
CREATE TABLE t3(a TEXT);
INSERT INTO t1 VALUES('1');
INSERT INTO t2 VALUES('1');
INSERT INTO t3 VALUES('1');
SELECT regexp_like(a, x'01') FROM t1;
SELECT regexp_like(a, x'01') FROM t2;
SELECT regexp_like(a, x'01') FROM t3;
SELECT regexp_like(x'01', a) FROM t1;
SELECT regexp_like(x'01', a) FROM t2;
SELECT regexp_like(x'01', a) FROM t3;
DROP TABLE t1, t2, t3;
SELECT regexp_instr(1, 'a');
SELECT regexp_instr('a', 1);
SELECT regexp_instr(NULL, 'a');
SELECT regexp_instr('a', NULL);
SELECT regexp_like(1, 'a');
SELECT regexp_like('a', 1);
SELECT regexp_like(NULL, 'a');
SELECT regexp_like('a', NULL);
SELECT regexp_replace(1, 1, 'a');
SELECT regexp_replace(1, 'a', 1);
SELECT regexp_replace(1, 'a', 'a');
SELECT regexp_replace('a', 1, 1);
SELECT regexp_replace('a', 1, 'a');
SELECT regexp_replace('a', 'a', 1);
SELECT regexp_replace(NULL, NULL, 'a');
SELECT regexp_replace(NULL, 'a', NULL);
SELECT regexp_replace(NULL, 'a', 'a');
SELECT regexp_replace('a', NULL, NULL);
SELECT regexp_replace('a', NULL, 'a');
SELECT regexp_replace('a', 'a', NULL);
SELECT regexp_substr(1, 'a');
SELECT regexp_substr('a', 1);
SELECT regexp_substr(NULL, 'a');
SELECT regexp_substr('a', NULL);
SELECT hex(regexp_replace(x'01', x'01', x'02'));
SELECT hex(regexp_substr(x'FFFF', x'FFFF'));
CREATE TABLE t1 AS SELECT regexp_substr(x'01', x'01');
SHOW CREATE TABLE t1;
DROP TABLE t1;
CREATE TABLE t1 AS SELECT regexp_replace(x'01', x'01', x'02');
SHOW CREATE TABLE t1;
DROP TABLE t1;
do regexp_like(0, "^{18446744073709551616");
do regexp_instr(0, "^{18446744073709551616");
SET SQL_MODE='';
DO INSERT(regexp_like(1, '['), 0, 1, '');
DO INSERT(regexp_instr(1, '['), 0, 1, '');
SET NAMES latin1;
DO INSERT(regexp_replace(1, '[', 42), 0, 1, '');
SET NAMES DEFAULT;
SET SQL_MODE=DEFAULT;
select ( _utf32', ,*') regexp 13946;
select regexp_instr( ( _utf32', ,*'), 13946);
select regexp_replace( ( _utf32', ,*'), 13946, 42);
select regexp_substr( ( _utf32', ,*'), 13946);
CREATE FUNCTION icu_major_version() RETURNS INT  RETURN regexp_replace(icu_version(), '([[:digit:]]+)\..*', '$1');
CREATE TABLE t1 (  subject char(10),  pattern char(10));
SELECT regexp_instr( 'abc', 'a' );
SELECT regexp_instr( 'abc', 'b' );
SELECT regexp_instr( 'abc', 'c' );
SELECT regexp_instr( 'abc', 'd' );
SELECT regexp_instr( NULL, 'a' );
SELECT regexp_instr( 'a', NULL );
SELECT regexp_instr( NULL, NULL );
SET NAMES binary;
SELECT hex( concat(regexp_instr( 'a', 'a' )) );
SET NAMES DEFAULT;
SELECT regexp_instr( 1, 'a' );
SELECT regexp_instr( 1.1, 'a' );
SELECT regexp_instr( 'a', 1 );
SELECT regexp_instr( 'a', 1.1 );
SELECT regexp_instr( subject, pattern ) FROM t1;
SELECT regexp_instr( 'a', '[[:invalid_bracket_expression:]]' );
SELECT regexp_instr( 'abcabcabc', 'a+', 1 );
SELECT regexp_instr( 'abcabcabc', 'a+', 2 );
SELECT regexp_instr( 'abcabcabc', 'b+', 1 );
SELECT regexp_instr( 'abcabcabc', 'b+', 2 );
SELECT regexp_instr( 'abcabcabc', 'b+', 3 );
SELECT regexp_instr( 'a', 'a+', 3 );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 2 );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 3 );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 4 );
SELECT regexp_instr( 'abcabcabc', 'a+', 4, 2 );
SELECT regexp_instr( 'a', 'a+', 1, 1, 2 );
SELECT regexp_instr( 'a', 'a+', 1, 1, -1 );
SELECT regexp_instr( 'a', 'a+', 1, 1, NULL );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 0 );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 1 );
SELECT regexp_instr( 'aaabcabcabc', 'a+', 1, 1, 1 );
SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'c' );
SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'i' );
SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'ci' );
SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'cic' );
SELECT regexp_instr( 'a', 'a+', 1, 1, 1, 'x' );
SELECT regexp_instr( 'a', 'a+', 1, 1, 1, NULL );
SELECT regexp_like( 'abc', 'a' );
SELECT regexp_like( 'abc', 'b' );
SELECT regexp_like( 'abc', 'c' );
SELECT regexp_like( 'abc', 'd' );
SELECT regexp_like( 'a', 'a.*' );
SELECT regexp_like( 'ab', 'a.*' );
SELECT regexp_like( NULL, 'a' );
SELECT regexp_like( 'a', NULL );
SELECT regexp_like( NULL, NULL );
SET NAMES binary;
SELECT hex( concat(regexp_like( 'a', 'a' )) );
SET NAMES DEFAULT;
SELECT regexp_like( 'abc', 'A', 'i' );
SELECT regexp_like( 'abc', 'A', 'c' );
SELECT regexp_like( 'a', 'a+', 'x' );
SELECT regexp_like( 'a', 'a+', 'cmnux' );
SELECT regexp_like( 'a', 'a+', NULL );
SELECT regexp_like( 1, 'a' );
SELECT regexp_like( 1.1, 'a' );
SELECT regexp_like( 'a', 1 );
SELECT regexp_like( 'a', 1.1 );
SELECT regexp_like('a', '[[:invalid_bracket_expression:]]');
SELECT regexp_replace( 'aaa', 'a', 'X' );
SELECT regexp_replace( 'abc', 'b', 'X' );
SELECT regexp_replace( NULL, 'a', 'X' );
SELECT regexp_replace( 'aaa', NULL, 'X' );
SELECT regexp_replace( 'aaa', 'a', NULL );
SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' );
SELECT regexp_replace( 'aaa', 'a', 'X', 0 );
SELECT regexp_replace( 'aaa', 'a', 'X', 1 );
SELECT regexp_replace( 'a', 'a+', 'b', 3 );
SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 0, 1 );
SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 );
SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 2 );
SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>', 1, 2 );
SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x', 1, 0 );
SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x', 1, 0 );
SELECT regexp_replace( 'aaab', 'b', 'x', 1, 2 );
SELECT regexp_replace( 'aaabccc', 'b', 'x', 1, 2 );
SELECT regexp_replace( 'abc', 'b', 'X' );
SELECT regexp_replace( 'abcbdb', 'b', 'X' );
SELECT regexp_replace( 'abcbdb', 'b', 'X', 3 );
SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 1 );
SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 2 );
SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 3 );
SELECT regexp_replace( 'a', '[[:invalid_bracket_expression:]]', '$1' );
SELECT regexp_replace( 'aaa', 'a', 'X', 2 );
SELECT regexp_replace( 'aaa', 'a', 'XX', 2 );
SELECT regexp_substr( 'a' );
SELECT regexp_substr( 'a', 'b', 'c', 'd', 'e', 'f' );
SELECT regexp_substr( 'ab ac ad', '.d' );
SELECT regexp_substr( 'ab ac ad', '.D' );
SELECT concat( regexp_substr( 'aaa', 'a+' ), 'x' );
SELECT regexp_substr( 'ab ac ad', 'a.', 0 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3, 1 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3, 2 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3, 3 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3, 3 ) IS NULL;
SELECT regexp_substr( 'ab ac ad', 'A.', 1, 1, 'c' );
SELECT regexp_substr( 'ab\nac\nad', 'A.', 1, 1, 'i' );
SELECT regexp_substr( 'ab\nac\nad', 'A.', 1, 1, 'im' );
SELECT regexp_substr('a', '[[:invalid_bracket_expression:]]');
SET sql_mode = ''; # Un-strictCREATE TABLE t2 ( g GEOMETRY NOT NULL );
INSERT INTO t2 VALUES ( POINT(1,2) );
SELECT concat( regexp_like(g, g), 'x' ) FROM t2;
SET sql_mode = DEFAULT;
DROP TABLE t2;
DROP TABLE t1;
SELECT regexp_instr( '', '((((((((){80}){}){11}){11}){11}){80}){11}){4}' );
SET GLOBAL regexp_stack_limit = 239;
SELECT regexp_instr( '', '(((((((){120}){11}){11}){11}){80}){11}){4}' );
SET GLOBAL regexp_stack_limit = 32;
SELECT regexp_instr( '', '((((((){11}){11}){11}){160}){11}){160}' );
SELECT regexp_instr( '', '(((((){150}){11}){160}){11}){160}' );
SELECT regexp_instr( '', '((((){255}){255}){255}){255}' );
SET GLOBAL regexp_stack_limit = DEFAULT;
SET GLOBAL regexp_time_limit = 1000;
SELECT regexp_instr( 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC', '(A+)+B' );
SET GLOBAL regexp_time_limit = DEFAULT;
SET NAMES latin1;
SELECT regexp_instr( _latin1 x'61F662', _latin1 x'F6' );
SELECT regexp_instr( _latin1 x'61F662', _utf8mb4'ö' );
SELECT regexp_instr( concat('a', _utf8mb4 x'F09F8DA3'), _utf8mb4 x'F09F8DA3' );
SELECT regexp_instr( _utf8mb4'aöb', _utf8mb4'ö' );
SET NAMES utf8;
SELECT regexp_instr( 'aöb', 'ö' );
SET NAMES DEFAULT;
SET NAMES utf8;
SELECT regexp_instr( 'אב רק', /*k*/'^[^ב]' );
PREPARE stmt1 FROM "select 'a' rlike ?";
DEALLOCATE PREPARE stmt1;
CREATE TABLE t1( a INT, subject CHAR(10) );
CREATE TABLE t2( pattern CHAR(10) );
insert into t1 values (0, 'apa');
insert into t2 values ('apa');
DELIMITER ||;
CREATE DEFINER=root@localhost PROCEDURE p1()BEGIN  UPDATE t1, t2  SET a = 1  WHERE regexp_like(t1.subject, t2.pattern);
END||DELIMITER ;||CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1, t2;
CREATE TABLE t1 ( a INT );
EXPLAIN SELECT 1 FROM t1 WHERE 1 REGEXP (1 IN (SELECT 1 FROM t1));
DROP TABLE t1;
PREPARE stmt1 FROM "SELECT regexp_like( 'a', ? )";
PREPARE stmt2 FROM "SELECT regexp_like( ?, 'a' )";
PREPARE stmt3 FROM "SELECT regexp_like( ?, ? )";
SET @subject = 'a';
SET @pattern = 'a+';
EXECUTE stmt1 USING @pattern;
EXECUTE stmt2 USING @subject;
EXECUTE stmt3 USING @subject, @pattern;
SET @subject = 1;
SET @pattern = 1;
EXECUTE stmt1 USING @pattern;
EXECUTE stmt2 USING @subject;
EXECUTE stmt3 USING @subject, @pattern;
DEALLOCATE PREPARE stmt1;
DEALLOCATE PREPARE stmt2;
DEALLOCATE PREPARE stmt3;
DO 1 rlike multilinestring(point(1, 1));
CREATE TABLE t1 ( a CHAR(10) );
INSERT INTO t1 VALUES ( 'abc' ), ( 'bcd' ), ( 'cde' );
SELECT regexp_like( a, 'a' ) FROM t1;
DROP TABLE t1;
CREATE TABLE t1 ( a CHAR ( 10 ), b CHAR ( 10 ) );
INSERT INTO t1 VALUES( NULL, 'abc' );
INSERT INTO t1 VALUES( 'def', NULL );
SELECT a, b, regexp_like( a, b ) FROM t1;
DROP TABLE t1;
CREATE TABLE t1 (  c CHAR(10) CHARSET latin1 COLLATE latin1_bin,  c_ci CHAR(10) CHARSET latin1 COLLATE latin1_general_ci,  c_cs CHAR(10) CHARSET latin1 COLLATE latin1_general_cs);
INSERT INTO t1VALUES ( 'a', 'a', 'a' ), ( 'A', 'A', 'A' ), ( 'b', 'b', 'b' );
SELECT c, c_ci REGEXP 'A', c_cs REGEXP 'A' FROM t1;
DROP TABLE t1;
SELECT regexp_like( _utf8mb4 'ss' COLLATE utf8mb4_german2_ci,                    _utf8mb4 'ß'  COLLATE utf8mb4_german2_ci );
SELECT regexp_like( _utf8mb4 'ß'  COLLATE utf8mb4_german2_ci,                    _utf8mb4 'ss' );
SELECT regexp_like( _utf8mb4 'ß'  COLLATE utf8mb4_de_pb_0900_as_cs,                    _utf8mb4 'ss' );
SET NAMES latin1;
SELECT regexp_like( 'a', 'A' COLLATE latin1_general_ci );
SELECT 'a' REGEXP 'A' COLLATE latin1_general_ci;
SELECT regexp_like( 'a', 'A' COLLATE latin1_general_cs );
SELECT 'a' REGEXP 'A' COLLATE latin1_general_cs;
SELECT regexp_like( 'a\nb\nc', '^b$' );
SELECT regexp_like( 'a\nb\nc', '(?m)^b$' );
SELECT regexp_like( 'a\nb\nc', '.*' );
SELECT regexp_like( _utf16 'a' , 'a' );
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }DROP FUNCTION icu_major_version;
SELECT regexp_like( _utf16le 'a' , 'a' );
SELECT regexp_like( 'aaa', 'a+', 1 );
SELECT regexp_substr( 'aaa', 'a+', 1, 1, 1 );
SELECT regexp_substr( 'aaa', 'a+', 1, 1, 1 );
SELECT regexp_substr( 'aaa', '+' );
CREATE TABLE t1 (  a CHAR(3) CHARACTER SET utf16le,  b CHAR(3) CHARACTER SET utf16le);
INSERT INTO t1 VALUES ( NULL, 'abc' );
INSERT INTO t1 VALUES ( 'def', NULL );
INSERT INTO t1 VALUES ( NULL, NULL );
SELECT a regexp b FROM t1;
DROP TABLE t1;
CREATE TABLE t1  a REAL,  b INT,  c CHAR(100),  d DECIMAL);
INSERT INTO t1 VALUES ( regexp_instr('a', 'a'),                        regexp_instr('a', 'a'),                        regexp_instr('a', 'a'),                        regexp_instr('a', 'a') );
SELECT * FROM t1;
DELETE FROM t1;
INSERT INTO t1 VALUES ( regexp_like('a', 'a'),                        regexp_like('a', 'a'),                        regexp_like('a', 'a'),                        regexp_like('a', 'a') );
SELECT * FROM t1;
DELETE FROM t1;
INSERT INTO t1 ( a ) VALUES ( regexp_replace('a', 'a', 'a') );
INSERT INTO t1 ( b ) VALUES ( regexp_replace('a', 'a', 'a') );
INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') );
INSERT INTO t1 ( d ) VALUES ( regexp_replace('a', 'a', 'a') );
SELECT * FROM t1;
DELETE FROM t1;
INSERT INTO t1 ( a ) VALUES ( regexp_substr('a', 'a') );
INSERT INTO t1 ( b ) VALUES ( regexp_substr('a', 'a') );
INSERT INTO t1 ( c ) VALUES ( regexp_substr('a', 'a') );
INSERT INTO t1 ( d ) VALUES ( regexp_substr('a', 'a') );
SELECT * FROM t1;
DROP TABLE t1;
SELECT cast( regexp_replace('a', 'a', 'a') AS SIGNED INTEGER );
SELECT cast( regexp_substr ('a', 'a')      AS SIGNED INTEGER );
SELECT cast( regexp_instr  ('a', 'a'     ) AS DATETIME );
SELECT cast( regexp_like   ('a', 'a'     ) AS DATETIME );
SELECT cast( regexp_replace('a', 'a', 'a') AS DATETIME );
SELECT cast( regexp_substr ('a', 'a'     ) AS DATETIME );
SELECT cast( regexp_instr  ('a', 'a'     ) AS TIME );
SELECT cast( regexp_like   ('a', 'a'     ) AS TIME );
SELECT cast( regexp_replace('a', 'a', 'a') AS TIME );
SELECT cast( regexp_substr ('a', 'a'     ) AS TIME );
SET GLOBAL net_buffer_length = 1024;
SET GLOBAL max_allowed_packet = @@global.net_buffer_length;
SELECT @@global.max_allowed_packet;
SET @buf_sz_utf16 = @@global.max_allowed_packet / length( _utf16'x' );
SELECT @buf_sz_utf16;
SELECT length(regexp_replace( repeat('a', @buf_sz_utf16), 'a', 'b' ));
SELECT length(regexp_replace( repeat('a', @buf_sz_utf16 + 1), 'a', 'b' ));
SELECT length(regexp_replace( repeat('a', @buf_sz_utf16), 'a', 'bb' ));
SET GLOBAL net_buffer_length = DEFAULT;
SET GLOBAL max_allowed_packet = DEFAULT;
SELECT regexp_like( 'a', '[[:<:]]a' );
SELECT regexp_like( 'a', '   **' );
SELECT regexp_like( 'a', ' \n  **' );
SELECT regexp_like( 'a', '  +++' );
SELECT regexp_like( 'a', '\\' );
SELECT regexp_like('a','(?{})');
SELECT regexp_like('a','(');
SELECT regexp_like('a','a{}');
SELECT regexp_like('a','a{2,1}');
SELECT regexp_like('a','\\1');
SELECT regexp_substr( 'ab','(?<=a+)b' );
SELECT regexp_like( 'a', 'a[' );
SELECT regexp_substr( 'ab','[b-a]' );
CREATE TABLE t1 ( a TEXT );
INSERT INTO t1 VALUES ( repeat( 'a', 16384 ) );
SELECT char_length ( regexp_replace( a, 'a', 'b' ) ) FROM t1;
SET GLOBAL  regexp_time_limit = 10000;
SELECT regexp_like ( regexp_replace( a, 'a', 'b' ), 'b{16384}' ) FROM t1;
SET GLOBAL  regexp_time_limit = DEFAULT;
DROP TABLE t1;
DO '1' regexp repeat('$', 50000000);
DO ( (@b) regexp (cot (unhex ( 1 )) ) );
DO ( (@c) rlike (cot ( (!( @f )) )) );
DO ( ('') rlike (cot ( ' %' )) );
DO ( (-28277) regexp (period_add ( -10966, 1381205734 )) );
DO ( (( @f )) rlike (json_depth ( 'key4' )) );
DO ( ('-  ') regexp (cot ( right (':#.', 33) )) );
DO ( (1) regexp (exp ( 64826 )) );
DO ( (@g) regexp (cot ( @f )) );
DO ( (@b) regexp (exp ( 0x1fc5574c )) );
DO ( (25091) rlike (exp ( 14373 )) );
SET GLOBAL regexp_time_limit = 1000000;
enable_connect_log;
connect(conn1, localhost, root);
send SELECT regexp_instr('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC', '(A+)+B');
connection default;
replace_result $conn1_id <conn1_id>;
eval KILL QUERY $conn1_id;
connection conn1;
reap;
disconnect conn1;
source include/wait_until_disconnected.inc;
connection default;
disable_connect_log;
SET GLOBAL regexp_time_limit = DEFAULT;
SELECT regexp_instr ( 'a', 'a', NULL );
SELECT regexp_instr ( 'a', 'a', 1, NULL );
SELECT regexp_instr ( 'a', 'a', 1, 0, NULL );
SELECT regexp_instr ( 'a', 'a', 1, 0, 0, NULL );
SELECT regexp_like ( 'a', 'a', NULL );
SELECT regexp_replace ( 'a', 'a', 'a', NULL );
SELECT regexp_replace ( 'a', 'a', 'a', 1, NULL );
SELECT regexp_replace ( 'a', 'a', 'a', 1, 0, NULL );
SELECT regexp_substr ( 'a', 'a', NULL );
SELECT regexp_substr ( 'a', 'a', 1, NULL );
SELECT regexp_substr ( 'a', 'a', 1, 0, NULL );
SELECT regexp_like( reverse(''), 123 );
SELECT regexp_like( soundex(@v1), 'abc' );
SELECT regexp_like( left('', ''), 'abc' );
SELECT regexp_like( repeat(@v1, 'abc'), 'abc' );
SELECT regexp_replace( 'abc' , 'abc', '$abc' );
SET @s := "SELECT regexp_like( '', '', ? / '' )";
PREPARE stmt FROM @s;
EXECUTE stmt;
EXECUTE stmt;
CREATE TABLE t1 ( match_parameter CHAR(1) );
INSERT INTO t1 VALUES ( 'i' ), ( 'c' ), ( 'i' ), ( 'c' );
SELECT match_parameter, regexp_like ( 'a', 'A', match_parameter ) FROM t1;
DROP TABLE t1;
SELECT regexp_replace( ' F' , '^ ', '[,$' );
SELECT regexp_instr( 'abc', '(?-' );
select regexp_instr(char('313:50:35.199734'using utf16le),uuid());
CREATE TABLE t1 ( a VARCHAR(10) );
INSERT INTO t1 VALUES ('a a a'), ('b b b'), ('c c c');
SELECT regexp_replace(a, '^([[:alpha:]]+)[[:space:]].*$', '$1') FROM t1;
DROP TABLE t1;
CREATE TABLE t1 ( a CHAR(3) );
INSERT INTO t1 VALUES ( regexp_replace ('a', 'a', 'x') );
SELECT * FROM t1;
UPDATE t1 SET a = regexp_replace ( 'b', 'b', 'y' );
SELECT * FROM t1;
DROP TABLE t1;
CREATE TABLE t1 ( a CHAR(3) );
INSERT INTO t1 VALUES ( regexp_substr ('a', 'a', 1) );
SELECT * FROM t1;
UPDATE t1 SET a = regexp_substr ('b', 'b', 1);
SELECT * FROM t1;
DROP TABLE t1;
CREATE TABLE t1 AS SELECT  regexp_instr( 'a', 'a' ) AS a,  regexp_like( 'a', 'a' ) AS b,  regexp_replace( 'abc', 'b', 'x' ) AS c,  regexp_substr( 'a', 'a' ) AS d,  regexp_substr( repeat('a', 512), 'a' ) AS e,  regexp_substr( repeat('a', 513), 'a' ) AS f;
SHOW CREATE TABLE t1;
SELECT * FROM t1;
DROP TABLE t1;
SET NAMES DEFAULT;
SELECT regexp_instr( '🍣🍣a', '🍣', 2 );
SELECT regexp_instr( '🍣🍣a', 'a', 3 );
SELECT regexp_instr( '🍣🍣a', 'a', 4 );
SELECT regexp_substr( 'a🍣b', '.', 1 );
SELECT regexp_substr( 'a🍣b', '.', 2 );
SELECT regexp_substr( 'a🍣b', '.', 3 );
SELECT regexp_substr( 'a🍣b', '.', 4 );
SELECT regexp_substr( 'a🍣🍣b', '.', 1 );
SELECT regexp_substr( 'a🍣🍣b', '.', 2 );
SELECT regexp_substr( 'a🍣🍣b', '.', 3 );
SELECT regexp_substr( 'a🍣🍣b', '.', 4 );
SELECT regexp_substr( 'a🍣🍣b', '.', 5 );
SELECT regexp_replace( '🍣🍣🍣', '.', 'a', 2 );
SELECT regexp_replace( '🍣🍣🍣', '.', 'a', 2, 2 );
SELECT hex(regexp_replace( convert( 'abcd' using utf8mb4 ), 'c', ''));
SELECT hex(regexp_replace( convert( 'abcd' using utf16 ), 'c', ''));
SELECT hex(regexp_substr( convert( 'abcd' using utf8mb4 ), 'abc'));
SELECT hex(regexp_substr( convert( 'abcd' using utf16 ), 'abc'));
CREATE TABLE t1 (  a CHAR(10) CHARACTER SET utf16le,  b CHAR(10) CHARACTER SET utf16);
INSERT INTO t1 VALUES (  regexp_substr( convert('abcd' using utf16le), 'abc' ),  regexp_substr( convert('abcd' using utf16), 'abc' ));
INSERT INTO t1 VALUES (  regexp_substr( 'abcd', 'abc' ),  regexp_substr( 'abcd', 'abc' ));
SELECT * FROM t1;
DROP TABLE t1;
SELECT regexp_like('1', x'01');
SELECT regexp_like(x'01', '1');
SELECT regexp_replace('01', '01', x'02');
SELECT regexp_replace('01', x'01', '02');
SELECT regexp_replace('01', x'01', x'02');
SELECT regexp_replace(x'01', '01', '02');
SELECT regexp_replace(x'01', '01', x'02');
SELECT regexp_replace(x'01', x'01', '02');
CREATE TABLE t1(a CHAR(1));
CREATE TABLE t2(a BLOB);
CREATE TABLE t3(a TEXT);
INSERT INTO t1 VALUES('1');
INSERT INTO t2 VALUES('1');
INSERT INTO t3 VALUES('1');
SELECT regexp_like(a, x'01') FROM t1;
SELECT regexp_like(a, x'01') FROM t2;
SELECT regexp_like(a, x'01') FROM t3;
SELECT regexp_like(x'01', a) FROM t1;
SELECT regexp_like(x'01', a) FROM t2;
SELECT regexp_like(x'01', a) FROM t3;
DROP TABLE t1, t2, t3;
SELECT regexp_instr(1, 'a');
SELECT regexp_instr('a', 1);
SELECT regexp_instr(NULL, 'a');
SELECT regexp_instr('a', NULL);
SELECT regexp_like(1, 'a');
SELECT regexp_like('a', 1);
SELECT regexp_like(NULL, 'a');
SELECT regexp_like('a', NULL);
SELECT regexp_replace(1, 1, 'a');
SELECT regexp_replace(1, 'a', 1);
SELECT regexp_replace(1, 'a', 'a');
SELECT regexp_replace('a', 1, 1);
SELECT regexp_replace('a', 1, 'a');
SELECT regexp_replace('a', 'a', 1);
SELECT regexp_replace(NULL, NULL, 'a');
SELECT regexp_replace(NULL, 'a', NULL);
SELECT regexp_replace(NULL, 'a', 'a');
SELECT regexp_replace('a', NULL, NULL);
SELECT regexp_replace('a', NULL, 'a');
SELECT regexp_replace('a', 'a', NULL);
SELECT regexp_substr(1, 'a');
SELECT regexp_substr('a', 1);
SELECT regexp_substr(NULL, 'a');
SELECT regexp_substr('a', NULL);
SELECT hex(regexp_replace(x'01', x'01', x'02'));
SELECT hex(regexp_substr(x'FFFF', x'FFFF'));
CREATE TABLE t1 AS SELECT regexp_substr(x'01', x'01');
SHOW CREATE TABLE t1;
DROP TABLE t1;
CREATE TABLE t1 AS SELECT regexp_replace(x'01', x'01', x'02');
SHOW CREATE TABLE t1;
DROP TABLE t1;
do regexp_like(0, "^{18446744073709551616");
do regexp_instr(0, "^{18446744073709551616");
SET SQL_MODE='';
DO INSERT(regexp_like(1, '['), 0, 1, '');
DO INSERT(regexp_instr(1, '['), 0, 1, '');
SET NAMES latin1;
DO INSERT(regexp_replace(1, '[', 42), 0, 1, '');
SET NAMES DEFAULT;
SET SQL_MODE=DEFAULT;
select ( _utf32', ,*') regexp 13946;
select regexp_instr( ( _utf32', ,*'), 13946);
select regexp_replace( ( _utf32', ,*'), 13946, 42);
select regexp_substr( ( _utf32', ,*'), 13946);
CREATE FUNCTION icu_major_version() RETURNS INT  RETURN regexp_replace(icu_version(), '([[:digit:]]+)\..*', '$1');
CREATE TABLE t1 (  subject char(10),  pattern char(10));
SELECT regexp_instr( 'abc', 'a' );
SELECT regexp_instr( 'abc', 'b' );
SELECT regexp_instr( 'abc', 'c' );
SELECT regexp_instr( 'abc', 'd' );
SELECT regexp_instr( NULL, 'a' );
SELECT regexp_instr( 'a', NULL );
SELECT regexp_instr( NULL, NULL );
SET NAMES binary;
SELECT hex( concat(regexp_instr( 'a', 'a' )) );
SET NAMES DEFAULT;
SELECT regexp_instr( 1, 'a' );
SELECT regexp_instr( 1.1, 'a' );
SELECT regexp_instr( 'a', 1 );
SELECT regexp_instr( 'a', 1.1 );
SELECT regexp_instr( subject, pattern ) FROM t1;
SELECT regexp_instr( 'a', '[[:invalid_bracket_expression:]]' );
SELECT regexp_instr( 'abcabcabc', 'a+', 1 );
SELECT regexp_instr( 'abcabcabc', 'a+', 2 );
SELECT regexp_instr( 'abcabcabc', 'b+', 1 );
SELECT regexp_instr( 'abcabcabc', 'b+', 2 );
SELECT regexp_instr( 'abcabcabc', 'b+', 3 );
SELECT regexp_instr( 'a', 'a+', 3 );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 2 );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 3 );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 4 );
SELECT regexp_instr( 'abcabcabc', 'a+', 4, 2 );
SELECT regexp_instr( 'a', 'a+', 1, 1, 2 );
SELECT regexp_instr( 'a', 'a+', 1, 1, -1 );
SELECT regexp_instr( 'a', 'a+', 1, 1, NULL );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 0 );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 1 );
SELECT regexp_instr( 'aaabcabcabc', 'a+', 1, 1, 1 );
SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'c' );
SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'i' );
SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'ci' );
SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'cic' );
SELECT regexp_instr( 'a', 'a+', 1, 1, 1, 'x' );
SELECT regexp_instr( 'a', 'a+', 1, 1, 1, NULL );
SELECT regexp_like( 'abc', 'a' );
SELECT regexp_like( 'abc', 'b' );
SELECT regexp_like( 'abc', 'c' );
SELECT regexp_like( 'abc', 'd' );
SELECT regexp_like( 'a', 'a.*' );
SELECT regexp_like( 'ab', 'a.*' );
SELECT regexp_like( NULL, 'a' );
SELECT regexp_like( 'a', NULL );
SELECT regexp_like( NULL, NULL );
SET NAMES binary;
SELECT hex( concat(regexp_like( 'a', 'a' )) );
SET NAMES DEFAULT;
SELECT regexp_like( 'abc', 'A', 'i' );
SELECT regexp_like( 'abc', 'A', 'c' );
SELECT regexp_like( 'a', 'a+', 'x' );
SELECT regexp_like( 'a', 'a+', 'cmnux' );
SELECT regexp_like( 'a', 'a+', NULL );
SELECT regexp_like( 1, 'a' );
SELECT regexp_like( 1.1, 'a' );
SELECT regexp_like( 'a', 1 );
SELECT regexp_like( 'a', 1.1 );
SELECT regexp_like('a', '[[:invalid_bracket_expression:]]');
SELECT regexp_replace( 'aaa', 'a', 'X' );
SELECT regexp_replace( 'abc', 'b', 'X' );
SELECT regexp_replace( NULL, 'a', 'X' );
SELECT regexp_replace( 'aaa', NULL, 'X' );
SELECT regexp_replace( 'aaa', 'a', NULL );
SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' );
SELECT regexp_replace( 'aaa', 'a', 'X', 0 );
SELECT regexp_replace( 'aaa', 'a', 'X', 1 );
SELECT regexp_replace( 'a', 'a+', 'b', 3 );
SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 0, 1 );
SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 );
SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 2 );
SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>', 1, 2 );
SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x', 1, 0 );
SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x', 1, 0 );
SELECT regexp_replace( 'aaab', 'b', 'x', 1, 2 );
SELECT regexp_replace( 'aaabccc', 'b', 'x', 1, 2 );
SELECT regexp_replace( 'abc', 'b', 'X' );
SELECT regexp_replace( 'abcbdb', 'b', 'X' );
SELECT regexp_replace( 'abcbdb', 'b', 'X', 3 );
SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 1 );
SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 2 );
SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 3 );
SELECT regexp_replace( 'a', '[[:invalid_bracket_expression:]]', '$1' );
SELECT regexp_replace( 'aaa', 'a', 'X', 2 );
SELECT regexp_replace( 'aaa', 'a', 'XX', 2 );
SELECT regexp_substr( 'a' );
SELECT regexp_substr( 'a', 'b', 'c', 'd', 'e', 'f' );
SELECT regexp_substr( 'ab ac ad', '.d' );
SELECT regexp_substr( 'ab ac ad', '.D' );
SELECT concat( regexp_substr( 'aaa', 'a+' ), 'x' );
SELECT regexp_substr( 'ab ac ad', 'a.', 0 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3, 1 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3, 2 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3, 3 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3, 3 ) IS NULL;
SELECT regexp_substr( 'ab ac ad', 'A.', 1, 1, 'c' );
SELECT regexp_substr( 'ab\nac\nad', 'A.', 1, 1, 'i' );
SELECT regexp_substr( 'ab\nac\nad', 'A.', 1, 1, 'im' );
SELECT regexp_substr('a', '[[:invalid_bracket_expression:]]');
SET sql_mode = ''; # Un-strictCREATE TABLE t2 ( g GEOMETRY NOT NULL );
INSERT INTO t2 VALUES ( POINT(1,2) );
SELECT concat( regexp_like(g, g), 'x' ) FROM t2;
SET sql_mode = DEFAULT;
DROP TABLE t2;
DROP TABLE t1;
SELECT regexp_instr( '', '((((((((){80}){}){11}){11}){11}){80}){11}){4}' );
SET GLOBAL regexp_stack_limit = 239;
SELECT regexp_instr( '', '(((((((){120}){11}){11}){11}){80}){11}){4}' );
SET GLOBAL regexp_stack_limit = 32;
SELECT regexp_instr( '', '((((((){11}){11}){11}){160}){11}){160}' );
SELECT regexp_instr( '', '(((((){150}){11}){160}){11}){160}' );
SELECT regexp_instr( '', '((((){255}){255}){255}){255}' );
SET GLOBAL regexp_stack_limit = DEFAULT;
SET GLOBAL regexp_time_limit = 1000;
SELECT regexp_instr( 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC', '(A+)+B' );
SET GLOBAL regexp_time_limit = DEFAULT;
SET NAMES latin1;
SELECT regexp_instr( _latin1 x'61F662', _latin1 x'F6' );
SELECT regexp_instr( _latin1 x'61F662', _utf8mb4'ö' );
SELECT regexp_instr( concat('a', _utf8mb4 x'F09F8DA3'), _utf8mb4 x'F09F8DA3' );
SELECT regexp_instr( _utf8mb4'aöb', _utf8mb4'ö' );
SET NAMES utf8;
SELECT regexp_instr( 'aöb', 'ö' );
SET NAMES DEFAULT;
SET NAMES utf8;
SELECT regexp_instr( 'אב רק', /*k*/'^[^ב]' );
PREPARE stmt1 FROM "select 'a' rlike ?";
DEALLOCATE PREPARE stmt1;
CREATE TABLE t1( a INT, subject CHAR(10) );
CREATE TABLE t2( pattern CHAR(10) );
insert into t1 values (0, 'apa');
insert into t2 values ('apa');
DELIMITER ||;
CREATE DEFINER=root@localhost PROCEDURE p1()BEGIN  UPDATE t1, t2  SET a = 1  WHERE regexp_like(t1.subject, t2.pattern);
END||DELIMITER ;||CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1, t2;
CREATE TABLE t1 ( a INT );
EXPLAIN SELECT 1 FROM t1 WHERE 1 REGEXP (1 IN (SELECT 1 FROM t1));
DROP TABLE t1;
PREPARE stmt1 FROM "SELECT regexp_like( 'a', ? )";
PREPARE stmt2 FROM "SELECT regexp_like( ?, 'a' )";
PREPARE stmt3 FROM "SELECT regexp_like( ?, ? )";
SET @subject = 'a';
SET @pattern = 'a+';
EXECUTE stmt1 USING @pattern;
EXECUTE stmt2 USING @subject;
EXECUTE stmt3 USING @subject, @pattern;
SET @subject = 1;
SET @pattern = 1;
EXECUTE stmt1 USING @pattern;
EXECUTE stmt2 USING @subject;
EXECUTE stmt3 USING @subject, @pattern;
DEALLOCATE PREPARE stmt1;
DEALLOCATE PREPARE stmt2;
DEALLOCATE PREPARE stmt3;
DO 1 rlike multilinestring(point(1, 1));
CREATE TABLE t1 ( a CHAR(10) );
INSERT INTO t1 VALUES ( 'abc' ), ( 'bcd' ), ( 'cde' );
SELECT regexp_like( a, 'a' ) FROM t1;
DROP TABLE t1;
CREATE TABLE t1 ( a CHAR ( 10 ), b CHAR ( 10 ) );
INSERT INTO t1 VALUES( NULL, 'abc' );
INSERT INTO t1 VALUES( 'def', NULL );
SELECT a, b, regexp_like( a, b ) FROM t1;
DROP TABLE t1;
CREATE TABLE t1 (  c CHAR(10) CHARSET latin1 COLLATE latin1_bin,  c_ci CHAR(10) CHARSET latin1 COLLATE latin1_general_ci,  c_cs CHAR(10) CHARSET latin1 COLLATE latin1_general_cs);
INSERT INTO t1VALUES ( 'a', 'a', 'a' ), ( 'A', 'A', 'A' ), ( 'b', 'b', 'b' );
SELECT c, c_ci REGEXP 'A', c_cs REGEXP 'A' FROM t1;
DROP TABLE t1;
SELECT regexp_like( _utf8mb4 'ss' COLLATE utf8mb4_german2_ci,                    _utf8mb4 'ß'  COLLATE utf8mb4_german2_ci );
SELECT regexp_like( _utf8mb4 'ß'  COLLATE utf8mb4_german2_ci,                    _utf8mb4 'ss' );
SELECT regexp_like( _utf8mb4 'ß'  COLLATE utf8mb4_de_pb_0900_as_cs,                    _utf8mb4 'ss' );
SET NAMES latin1;
SELECT regexp_like( 'a', 'A' COLLATE latin1_general_ci );
SELECT 'a' REGEXP 'A' COLLATE latin1_general_ci;
SELECT regexp_like( 'a', 'A' COLLATE latin1_general_cs );
SELECT 'a' REGEXP 'A' COLLATE latin1_general_cs;
SELECT regexp_like( 'a\nb\nc', '^b$' );
SELECT regexp_like( 'a\nb\nc', '(?m)^b$' );
SELECT regexp_like( 'a\nb\nc', '.*' );
SELECT regexp_like( _utf16 'a' , 'a' );
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }DROP FUNCTION icu_major_version;
SELECT regexp_like( _utf16le 'a' , 'a' );
SELECT regexp_like( 'aaa', 'a+', 1 );
SELECT regexp_substr( 'aaa', 'a+', 1, 1, 1 );
SELECT regexp_substr( 'aaa', 'a+', 1, 1, 1 );
SELECT regexp_substr( 'aaa', '+' );
CREATE TABLE t1 (  a CHAR(3) CHARACTER SET utf16le,  b CHAR(3) CHARACTER SET utf16le);
INSERT INTO t1 VALUES ( NULL, 'abc' );
INSERT INTO t1 VALUES ( 'def', NULL );
INSERT INTO t1 VALUES ( NULL, NULL );
SELECT a regexp b FROM t1;
DROP TABLE t1;
CREATE TABLE t1  a REAL,  b INT,  c CHAR(100),  d DECIMAL);
INSERT INTO t1 VALUES ( regexp_instr('a', 'a'),                        regexp_instr('a', 'a'),                        regexp_instr('a', 'a'),                        regexp_instr('a', 'a') );
SELECT * FROM t1;
DELETE FROM t1;
INSERT INTO t1 VALUES ( regexp_like('a', 'a'),                        regexp_like('a', 'a'),                        regexp_like('a', 'a'),                        regexp_like('a', 'a') );
SELECT * FROM t1;
DELETE FROM t1;
INSERT INTO t1 ( a ) VALUES ( regexp_replace('a', 'a', 'a') );
INSERT INTO t1 ( b ) VALUES ( regexp_replace('a', 'a', 'a') );
INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') );
INSERT INTO t1 ( d ) VALUES ( regexp_replace('a', 'a', 'a') );
SELECT * FROM t1;
DELETE FROM t1;
INSERT INTO t1 ( a ) VALUES ( regexp_substr('a', 'a') );
INSERT INTO t1 ( b ) VALUES ( regexp_substr('a', 'a') );
INSERT INTO t1 ( c ) VALUES ( regexp_substr('a', 'a') );
INSERT INTO t1 ( d ) VALUES ( regexp_substr('a', 'a') );
SELECT * FROM t1;
DROP TABLE t1;
SELECT cast( regexp_replace('a', 'a', 'a') AS SIGNED INTEGER );
SELECT cast( regexp_substr ('a', 'a')      AS SIGNED INTEGER );
SELECT cast( regexp_instr  ('a', 'a'     ) AS DATETIME );
SELECT cast( regexp_like   ('a', 'a'     ) AS DATETIME );
SELECT cast( regexp_replace('a', 'a', 'a') AS DATETIME );
SELECT cast( regexp_substr ('a', 'a'     ) AS DATETIME );
SELECT cast( regexp_instr  ('a', 'a'     ) AS TIME );
SELECT cast( regexp_like   ('a', 'a'     ) AS TIME );
SELECT cast( regexp_replace('a', 'a', 'a') AS TIME );
SELECT cast( regexp_substr ('a', 'a'     ) AS TIME );
SET GLOBAL net_buffer_length = 1024;
SET GLOBAL max_allowed_packet = @@global.net_buffer_length;
SELECT @@global.max_allowed_packet;
SET @buf_sz_utf16 = @@global.max_allowed_packet / length( _utf16'x' );
SELECT @buf_sz_utf16;
SELECT length(regexp_replace( repeat('a', @buf_sz_utf16), 'a', 'b' ));
SELECT length(regexp_replace( repeat('a', @buf_sz_utf16 + 1), 'a', 'b' ));
SELECT length(regexp_replace( repeat('a', @buf_sz_utf16), 'a', 'bb' ));
SET GLOBAL net_buffer_length = DEFAULT;
SET GLOBAL max_allowed_packet = DEFAULT;
SELECT regexp_like( 'a', '[[:<:]]a' );
SELECT regexp_like( 'a', '   **' );
SELECT regexp_like( 'a', ' \n  **' );
SELECT regexp_like( 'a', '  +++' );
SELECT regexp_like( 'a', '\\' );
SELECT regexp_like('a','(?{})');
SELECT regexp_like('a','(');
SELECT regexp_like('a','a{}');
SELECT regexp_like('a','a{2,1}');
SELECT regexp_like('a','\\1');
SELECT regexp_substr( 'ab','(?<=a+)b' );
SELECT regexp_like( 'a', 'a[' );
SELECT regexp_substr( 'ab','[b-a]' );
CREATE TABLE t1 ( a TEXT );
INSERT INTO t1 VALUES ( repeat( 'a', 16384 ) );
SELECT char_length ( regexp_replace( a, 'a', 'b' ) ) FROM t1;
SET GLOBAL  regexp_time_limit = 10000;
SELECT regexp_like ( regexp_replace( a, 'a', 'b' ), 'b{16384}' ) FROM t1;
SET GLOBAL  regexp_time_limit = DEFAULT;
DROP TABLE t1;
DO '1' regexp repeat('$', 50000000);
DO ( (@b) regexp (cot (unhex ( 1 )) ) );
DO ( (@c) rlike (cot ( (!( @f )) )) );
DO ( ('') rlike (cot ( ' %' )) );
DO ( (-28277) regexp (period_add ( -10966, 1381205734 )) );
DO ( (( @f )) rlike (json_depth ( 'key4' )) );
DO ( ('-  ') regexp (cot ( right (':#.', 33) )) );
DO ( (1) regexp (exp ( 64826 )) );
DO ( (@g) regexp (cot ( @f )) );
DO ( (@b) regexp (exp ( 0x1fc5574c )) );
DO ( (25091) rlike (exp ( 14373 )) );
SET GLOBAL regexp_time_limit = 1000000;
enable_connect_log;
connect(conn1, localhost, root);
send SELECT regexp_instr('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC', '(A+)+B');
connection default;
replace_result $conn1_id <conn1_id>;
eval KILL QUERY $conn1_id;
connection conn1;
reap;
disconnect conn1;
source include/wait_until_disconnected.inc;
connection default;
disable_connect_log;
SET GLOBAL regexp_time_limit = DEFAULT;
SELECT regexp_instr ( 'a', 'a', NULL );
SELECT regexp_instr ( 'a', 'a', 1, NULL );
SELECT regexp_instr ( 'a', 'a', 1, 0, NULL );
SELECT regexp_instr ( 'a', 'a', 1, 0, 0, NULL );
SELECT regexp_like ( 'a', 'a', NULL );
SELECT regexp_replace ( 'a', 'a', 'a', NULL );
SELECT regexp_replace ( 'a', 'a', 'a', 1, NULL );
SELECT regexp_replace ( 'a', 'a', 'a', 1, 0, NULL );
SELECT regexp_substr ( 'a', 'a', NULL );
SELECT regexp_substr ( 'a', 'a', 1, NULL );
SELECT regexp_substr ( 'a', 'a', 1, 0, NULL );
SELECT regexp_like( reverse(''), 123 );
SELECT regexp_like( soundex(@v1), 'abc' );
SELECT regexp_like( left('', ''), 'abc' );
SELECT regexp_like( repeat(@v1, 'abc'), 'abc' );
SELECT regexp_replace( 'abc' , 'abc', '$abc' );
SET @s := "SELECT regexp_like( '', '', ? / '' )";
PREPARE stmt FROM @s;
EXECUTE stmt;
EXECUTE stmt;
CREATE TABLE t1 ( match_parameter CHAR(1) );
INSERT INTO t1 VALUES ( 'i' ), ( 'c' ), ( 'i' ), ( 'c' );
SELECT match_parameter, regexp_like ( 'a', 'A', match_parameter ) FROM t1;
DROP TABLE t1;
SELECT regexp_replace( ' F' , '^ ', '[,$' );
SELECT regexp_instr( 'abc', '(?-' );
select regexp_instr(char('313:50:35.199734'using utf16le),uuid());
CREATE TABLE t1 ( a VARCHAR(10) );
INSERT INTO t1 VALUES ('a a a'), ('b b b'), ('c c c');
SELECT regexp_replace(a, '^([[:alpha:]]+)[[:space:]].*$', '$1') FROM t1;
DROP TABLE t1;
CREATE TABLE t1 ( a CHAR(3) );
INSERT INTO t1 VALUES ( regexp_replace ('a', 'a', 'x') );
SELECT * FROM t1;
UPDATE t1 SET a = regexp_replace ( 'b', 'b', 'y' );
SELECT * FROM t1;
DROP TABLE t1;
CREATE TABLE t1 ( a CHAR(3) );
INSERT INTO t1 VALUES ( regexp_substr ('a', 'a', 1) );
SELECT * FROM t1;
UPDATE t1 SET a = regexp_substr ('b', 'b', 1);
SELECT * FROM t1;
DROP TABLE t1;
CREATE TABLE t1 AS SELECT  regexp_instr( 'a', 'a' ) AS a,  regexp_like( 'a', 'a' ) AS b,  regexp_replace( 'abc', 'b', 'x' ) AS c,  regexp_substr( 'a', 'a' ) AS d,  regexp_substr( repeat('a', 512), 'a' ) AS e,  regexp_substr( repeat('a', 513), 'a' ) AS f;
SHOW CREATE TABLE t1;
SELECT * FROM t1;
DROP TABLE t1;
SET NAMES DEFAULT;
SELECT regexp_instr( '🍣🍣a', '🍣', 2 );
SELECT regexp_instr( '🍣🍣a', 'a', 3 );
SELECT regexp_instr( '🍣🍣a', 'a', 4 );
SELECT regexp_substr( 'a🍣b', '.', 1 );
SELECT regexp_substr( 'a🍣b', '.', 2 );
SELECT regexp_substr( 'a🍣b', '.', 3 );
SELECT regexp_substr( 'a🍣b', '.', 4 );
SELECT regexp_substr( 'a🍣🍣b', '.', 1 );
SELECT regexp_substr( 'a🍣🍣b', '.', 2 );
SELECT regexp_substr( 'a🍣🍣b', '.', 3 );
SELECT regexp_substr( 'a🍣🍣b', '.', 4 );
SELECT regexp_substr( 'a🍣🍣b', '.', 5 );
SELECT regexp_replace( '🍣🍣🍣', '.', 'a', 2 );
SELECT regexp_replace( '🍣🍣🍣', '.', 'a', 2, 2 );
SELECT hex(regexp_replace( convert( 'abcd' using utf8mb4 ), 'c', ''));
SELECT hex(regexp_replace( convert( 'abcd' using utf16 ), 'c', ''));
SELECT hex(regexp_substr( convert( 'abcd' using utf8mb4 ), 'abc'));
SELECT hex(regexp_substr( convert( 'abcd' using utf16 ), 'abc'));
CREATE TABLE t1 (  a CHAR(10) CHARACTER SET utf16le,  b CHAR(10) CHARACTER SET utf16);
INSERT INTO t1 VALUES (  regexp_substr( convert('abcd' using utf16le), 'abc' ),  regexp_substr( convert('abcd' using utf16), 'abc' ));
INSERT INTO t1 VALUES (  regexp_substr( 'abcd', 'abc' ),  regexp_substr( 'abcd', 'abc' ));
SELECT * FROM t1;
DROP TABLE t1;
SELECT regexp_like('1', x'01');
SELECT regexp_like(x'01', '1');
SELECT regexp_replace('01', '01', x'02');
SELECT regexp_replace('01', x'01', '02');
SELECT regexp_replace('01', x'01', x'02');
SELECT regexp_replace(x'01', '01', '02');
SELECT regexp_replace(x'01', '01', x'02');
SELECT regexp_replace(x'01', x'01', '02');
CREATE TABLE t1(a CHAR(1));
CREATE TABLE t2(a BLOB);
CREATE TABLE t3(a TEXT);
INSERT INTO t1 VALUES('1');
INSERT INTO t2 VALUES('1');
INSERT INTO t3 VALUES('1');
SELECT regexp_like(a, x'01') FROM t1;
SELECT regexp_like(a, x'01') FROM t2;
SELECT regexp_like(a, x'01') FROM t3;
SELECT regexp_like(x'01', a) FROM t1;
SELECT regexp_like(x'01', a) FROM t2;
SELECT regexp_like(x'01', a) FROM t3;
DROP TABLE t1, t2, t3;
SELECT regexp_instr(1, 'a');
SELECT regexp_instr('a', 1);
SELECT regexp_instr(NULL, 'a');
SELECT regexp_instr('a', NULL);
SELECT regexp_like(1, 'a');
SELECT regexp_like('a', 1);
SELECT regexp_like(NULL, 'a');
SELECT regexp_like('a', NULL);
SELECT regexp_replace(1, 1, 'a');
SELECT regexp_replace(1, 'a', 1);
SELECT regexp_replace(1, 'a', 'a');
SELECT regexp_replace('a', 1, 1);
SELECT regexp_replace('a', 1, 'a');
SELECT regexp_replace('a', 'a', 1);
SELECT regexp_replace(NULL, NULL, 'a');
SELECT regexp_replace(NULL, 'a', NULL);
SELECT regexp_replace(NULL, 'a', 'a');
SELECT regexp_replace('a', NULL, NULL);
SELECT regexp_replace('a', NULL, 'a');
SELECT regexp_replace('a', 'a', NULL);
SELECT regexp_substr(1, 'a');
SELECT regexp_substr('a', 1);
SELECT regexp_substr(NULL, 'a');
SELECT regexp_substr('a', NULL);
SELECT hex(regexp_replace(x'01', x'01', x'02'));
SELECT hex(regexp_substr(x'FFFF', x'FFFF'));
CREATE TABLE t1 AS SELECT regexp_substr(x'01', x'01');
SHOW CREATE TABLE t1;
DROP TABLE t1;
CREATE TABLE t1 AS SELECT regexp_replace(x'01', x'01', x'02');
SHOW CREATE TABLE t1;
DROP TABLE t1;
do regexp_like(0, "^{18446744073709551616");
do regexp_instr(0, "^{18446744073709551616");
SET SQL_MODE='';
DO INSERT(regexp_like(1, '['), 0, 1, '');
DO INSERT(regexp_instr(1, '['), 0, 1, '');
SET NAMES latin1;
DO INSERT(regexp_replace(1, '[', 42), 0, 1, '');
SET NAMES DEFAULT;
SET SQL_MODE=DEFAULT;
select ( _utf32', ,*') regexp 13946;
select regexp_instr( ( _utf32', ,*'), 13946);
select regexp_replace( ( _utf32', ,*'), 13946, 42);
select regexp_substr( ( _utf32', ,*'), 13946);
CREATE FUNCTION icu_major_version() RETURNS INT  RETURN regexp_replace(icu_version(), '([[:digit:]]+)\..*', '$1');
CREATE TABLE t1 (  subject char(10),  pattern char(10));
SELECT regexp_instr( 'abc', 'a' );
SELECT regexp_instr( 'abc', 'b' );
SELECT regexp_instr( 'abc', 'c' );
SELECT regexp_instr( 'abc', 'd' );
SELECT regexp_instr( NULL, 'a' );
SELECT regexp_instr( 'a', NULL );
SELECT regexp_instr( NULL, NULL );
SET NAMES binary;
SELECT hex( concat(regexp_instr( 'a', 'a' )) );
SET NAMES DEFAULT;
SELECT regexp_instr( 1, 'a' );
SELECT regexp_instr( 1.1, 'a' );
SELECT regexp_instr( 'a', 1 );
SELECT regexp_instr( 'a', 1.1 );
SELECT regexp_instr( subject, pattern ) FROM t1;
SELECT regexp_instr( 'a', '[[:invalid_bracket_expression:]]' );
SELECT regexp_instr( 'abcabcabc', 'a+', 1 );
SELECT regexp_instr( 'abcabcabc', 'a+', 2 );
SELECT regexp_instr( 'abcabcabc', 'b+', 1 );
SELECT regexp_instr( 'abcabcabc', 'b+', 2 );
SELECT regexp_instr( 'abcabcabc', 'b+', 3 );
SELECT regexp_instr( 'a', 'a+', 3 );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 2 );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 3 );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 4 );
SELECT regexp_instr( 'abcabcabc', 'a+', 4, 2 );
SELECT regexp_instr( 'a', 'a+', 1, 1, 2 );
SELECT regexp_instr( 'a', 'a+', 1, 1, -1 );
SELECT regexp_instr( 'a', 'a+', 1, 1, NULL );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 0 );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 1 );
SELECT regexp_instr( 'aaabcabcabc', 'a+', 1, 1, 1 );
SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'c' );
SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'i' );
SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'ci' );
SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'cic' );
SELECT regexp_instr( 'a', 'a+', 1, 1, 1, 'x' );
SELECT regexp_instr( 'a', 'a+', 1, 1, 1, NULL );
SELECT regexp_like( 'abc', 'a' );
SELECT regexp_like( 'abc', 'b' );
SELECT regexp_like( 'abc', 'c' );
SELECT regexp_like( 'abc', 'd' );
SELECT regexp_like( 'a', 'a.*' );
SELECT regexp_like( 'ab', 'a.*' );
SELECT regexp_like( NULL, 'a' );
SELECT regexp_like( 'a', NULL );
SELECT regexp_like( NULL, NULL );
SET NAMES binary;
SELECT hex( concat(regexp_like( 'a', 'a' )) );
SET NAMES DEFAULT;
SELECT regexp_like( 'abc', 'A', 'i' );
SELECT regexp_like( 'abc', 'A', 'c' );
SELECT regexp_like( 'a', 'a+', 'x' );
SELECT regexp_like( 'a', 'a+', 'cmnux' );
SELECT regexp_like( 'a', 'a+', NULL );
SELECT regexp_like( 1, 'a' );
SELECT regexp_like( 1.1, 'a' );
SELECT regexp_like( 'a', 1 );
SELECT regexp_like( 'a', 1.1 );
SELECT regexp_like('a', '[[:invalid_bracket_expression:]]');
SELECT regexp_replace( 'aaa', 'a', 'X' );
SELECT regexp_replace( 'abc', 'b', 'X' );
SELECT regexp_replace( NULL, 'a', 'X' );
SELECT regexp_replace( 'aaa', NULL, 'X' );
SELECT regexp_replace( 'aaa', 'a', NULL );
SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' );
SELECT regexp_replace( 'aaa', 'a', 'X', 0 );
SELECT regexp_replace( 'aaa', 'a', 'X', 1 );
SELECT regexp_replace( 'a', 'a+', 'b', 3 );
SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 0, 1 );
SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 );
SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 2 );
SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>', 1, 2 );
SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x', 1, 0 );
SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x', 1, 0 );
SELECT regexp_replace( 'aaab', 'b', 'x', 1, 2 );
SELECT regexp_replace( 'aaabccc', 'b', 'x', 1, 2 );
SELECT regexp_replace( 'abc', 'b', 'X' );
SELECT regexp_replace( 'abcbdb', 'b', 'X' );
SELECT regexp_replace( 'abcbdb', 'b', 'X', 3 );
SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 1 );
SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 2 );
SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 3 );
SELECT regexp_replace( 'a', '[[:invalid_bracket_expression:]]', '$1' );
SELECT regexp_replace( 'aaa', 'a', 'X', 2 );
SELECT regexp_replace( 'aaa', 'a', 'XX', 2 );
SELECT regexp_substr( 'a' );
SELECT regexp_substr( 'a', 'b', 'c', 'd', 'e', 'f' );
SELECT regexp_substr( 'ab ac ad', '.d' );
SELECT regexp_substr( 'ab ac ad', '.D' );
SELECT concat( regexp_substr( 'aaa', 'a+' ), 'x' );
SELECT regexp_substr( 'ab ac ad', 'a.', 0 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3, 1 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3, 2 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3, 3 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3, 3 ) IS NULL;
SELECT regexp_substr( 'ab ac ad', 'A.', 1, 1, 'c' );
SELECT regexp_substr( 'ab\nac\nad', 'A.', 1, 1, 'i' );
SELECT regexp_substr( 'ab\nac\nad', 'A.', 1, 1, 'im' );
SELECT regexp_substr('a', '[[:invalid_bracket_expression:]]');
SET sql_mode = ''; # Un-strictCREATE TABLE t2 ( g GEOMETRY NOT NULL );
INSERT INTO t2 VALUES ( POINT(1,2) );
SELECT concat( regexp_like(g, g), 'x' ) FROM t2;
SET sql_mode = DEFAULT;
DROP TABLE t2;
DROP TABLE t1;
SELECT regexp_instr( '', '((((((((){80}){}){11}){11}){11}){80}){11}){4}' );
SET GLOBAL regexp_stack_limit = 239;
SELECT regexp_instr( '', '(((((((){120}){11}){11}){11}){80}){11}){4}' );
SET GLOBAL regexp_stack_limit = 32;
SELECT regexp_instr( '', '((((((){11}){11}){11}){160}){11}){160}' );
SELECT regexp_instr( '', '(((((){150}){11}){160}){11}){160}' );
SELECT regexp_instr( '', '((((){255}){255}){255}){255}' );
SET GLOBAL regexp_stack_limit = DEFAULT;
SET GLOBAL regexp_time_limit = 1000;
SELECT regexp_instr( 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC', '(A+)+B' );
SET GLOBAL regexp_time_limit = DEFAULT;
SET NAMES latin1;
SELECT regexp_instr( _latin1 x'61F662', _latin1 x'F6' );
SELECT regexp_instr( _latin1 x'61F662', _utf8mb4'ö' );
SELECT regexp_instr( concat('a', _utf8mb4 x'F09F8DA3'), _utf8mb4 x'F09F8DA3' );
SELECT regexp_instr( _utf8mb4'aöb', _utf8mb4'ö' );
SET NAMES utf8;
SELECT regexp_instr( 'aöb', 'ö' );
SET NAMES DEFAULT;
SET NAMES utf8;
SELECT regexp_instr( 'אב רק', /*k*/'^[^ב]' );
PREPARE stmt1 FROM "select 'a' rlike ?";
DEALLOCATE PREPARE stmt1;
CREATE TABLE t1( a INT, subject CHAR(10) );
CREATE TABLE t2( pattern CHAR(10) );
insert into t1 values (0, 'apa');
insert into t2 values ('apa');
DELIMITER ||;
CREATE DEFINER=root@localhost PROCEDURE p1()BEGIN  UPDATE t1, t2  SET a = 1  WHERE regexp_like(t1.subject, t2.pattern);
END||DELIMITER ;||CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1, t2;
CREATE TABLE t1 ( a INT );
EXPLAIN SELECT 1 FROM t1 WHERE 1 REGEXP (1 IN (SELECT 1 FROM t1));
DROP TABLE t1;
PREPARE stmt1 FROM "SELECT regexp_like( 'a', ? )";
PREPARE stmt2 FROM "SELECT regexp_like( ?, 'a' )";
PREPARE stmt3 FROM "SELECT regexp_like( ?, ? )";
SET @subject = 'a';
SET @pattern = 'a+';
EXECUTE stmt1 USING @pattern;
EXECUTE stmt2 USING @subject;
EXECUTE stmt3 USING @subject, @pattern;
SET @subject = 1;
SET @pattern = 1;
EXECUTE stmt1 USING @pattern;
EXECUTE stmt2 USING @subject;
EXECUTE stmt3 USING @subject, @pattern;
DEALLOCATE PREPARE stmt1;
DEALLOCATE PREPARE stmt2;
DEALLOCATE PREPARE stmt3;
DO 1 rlike multilinestring(point(1, 1));
CREATE TABLE t1 ( a CHAR(10) );
INSERT INTO t1 VALUES ( 'abc' ), ( 'bcd' ), ( 'cde' );
SELECT regexp_like( a, 'a' ) FROM t1;
DROP TABLE t1;
CREATE TABLE t1 ( a CHAR ( 10 ), b CHAR ( 10 ) );
INSERT INTO t1 VALUES( NULL, 'abc' );
INSERT INTO t1 VALUES( 'def', NULL );
SELECT a, b, regexp_like( a, b ) FROM t1;
DROP TABLE t1;
CREATE TABLE t1 (  c CHAR(10) CHARSET latin1 COLLATE latin1_bin,  c_ci CHAR(10) CHARSET latin1 COLLATE latin1_general_ci,  c_cs CHAR(10) CHARSET latin1 COLLATE latin1_general_cs);
INSERT INTO t1VALUES ( 'a', 'a', 'a' ), ( 'A', 'A', 'A' ), ( 'b', 'b', 'b' );
SELECT c, c_ci REGEXP 'A', c_cs REGEXP 'A' FROM t1;
DROP TABLE t1;
SELECT regexp_like( _utf8mb4 'ss' COLLATE utf8mb4_german2_ci,                    _utf8mb4 'ß'  COLLATE utf8mb4_german2_ci );
SELECT regexp_like( _utf8mb4 'ß'  COLLATE utf8mb4_german2_ci,                    _utf8mb4 'ss' );
SELECT regexp_like( _utf8mb4 'ß'  COLLATE utf8mb4_de_pb_0900_as_cs,                    _utf8mb4 'ss' );
SET NAMES latin1;
SELECT regexp_like( 'a', 'A' COLLATE latin1_general_ci );
SELECT 'a' REGEXP 'A' COLLATE latin1_general_ci;
SELECT regexp_like( 'a', 'A' COLLATE latin1_general_cs );
SELECT 'a' REGEXP 'A' COLLATE latin1_general_cs;
SELECT regexp_like( 'a\nb\nc', '^b$' );
SELECT regexp_like( 'a\nb\nc', '(?m)^b$' );
SELECT regexp_like( 'a\nb\nc', '.*' );
SELECT regexp_like( _utf16 'a' , 'a' );
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }DROP FUNCTION icu_major_version;
SELECT regexp_like( _utf16le 'a' , 'a' );
SELECT regexp_like( 'aaa', 'a+', 1 );
SELECT regexp_substr( 'aaa', 'a+', 1, 1, 1 );
SELECT regexp_substr( 'aaa', 'a+', 1, 1, 1 );
SELECT regexp_substr( 'aaa', '+' );
CREATE TABLE t1 (  a CHAR(3) CHARACTER SET utf16le,  b CHAR(3) CHARACTER SET utf16le);
INSERT INTO t1 VALUES ( NULL, 'abc' );
INSERT INTO t1 VALUES ( 'def', NULL );
INSERT INTO t1 VALUES ( NULL, NULL );
SELECT a regexp b FROM t1;
DROP TABLE t1;
CREATE TABLE t1  a REAL,  b INT,  c CHAR(100),  d DECIMAL);
INSERT INTO t1 VALUES ( regexp_instr('a', 'a'),                        regexp_instr('a', 'a'),                        regexp_instr('a', 'a'),                        regexp_instr('a', 'a') );
SELECT * FROM t1;
DELETE FROM t1;
INSERT INTO t1 VALUES ( regexp_like('a', 'a'),                        regexp_like('a', 'a'),                        regexp_like('a', 'a'),                        regexp_like('a', 'a') );
SELECT * FROM t1;
DELETE FROM t1;
INSERT INTO t1 ( a ) VALUES ( regexp_replace('a', 'a', 'a') );
INSERT INTO t1 ( b ) VALUES ( regexp_replace('a', 'a', 'a') );
INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') );
INSERT INTO t1 ( d ) VALUES ( regexp_replace('a', 'a', 'a') );
SELECT * FROM t1;
DELETE FROM t1;
INSERT INTO t1 ( a ) VALUES ( regexp_substr('a', 'a') );
INSERT INTO t1 ( b ) VALUES ( regexp_substr('a', 'a') );
INSERT INTO t1 ( c ) VALUES ( regexp_substr('a', 'a') );
INSERT INTO t1 ( d ) VALUES ( regexp_substr('a', 'a') );
SELECT * FROM t1;
DROP TABLE t1;
SELECT cast( regexp_replace('a', 'a', 'a') AS SIGNED INTEGER );
SELECT cast( regexp_substr ('a', 'a')      AS SIGNED INTEGER );
SELECT cast( regexp_instr  ('a', 'a'     ) AS DATETIME );
SELECT cast( regexp_like   ('a', 'a'     ) AS DATETIME );
SELECT cast( regexp_replace('a', 'a', 'a') AS DATETIME );
SELECT cast( regexp_substr ('a', 'a'     ) AS DATETIME );
SELECT cast( regexp_instr  ('a', 'a'     ) AS TIME );
SELECT cast( regexp_like   ('a', 'a'     ) AS TIME );
SELECT cast( regexp_replace('a', 'a', 'a') AS TIME );
SELECT cast( regexp_substr ('a', 'a'     ) AS TIME );
SET GLOBAL net_buffer_length = 1024;
SET GLOBAL max_allowed_packet = @@global.net_buffer_length;
SELECT @@global.max_allowed_packet;
SET @buf_sz_utf16 = @@global.max_allowed_packet / length( _utf16'x' );
SELECT @buf_sz_utf16;
SELECT length(regexp_replace( repeat('a', @buf_sz_utf16), 'a', 'b' ));
SELECT length(regexp_replace( repeat('a', @buf_sz_utf16 + 1), 'a', 'b' ));
SELECT length(regexp_replace( repeat('a', @buf_sz_utf16), 'a', 'bb' ));
SET GLOBAL net_buffer_length = DEFAULT;
SET GLOBAL max_allowed_packet = DEFAULT;
SELECT regexp_like( 'a', '[[:<:]]a' );
SELECT regexp_like( 'a', '   **' );
SELECT regexp_like( 'a', ' \n  **' );
SELECT regexp_like( 'a', '  +++' );
SELECT regexp_like( 'a', '\\' );
SELECT regexp_like('a','(?{})');
SELECT regexp_like('a','(');
SELECT regexp_like('a','a{}');
SELECT regexp_like('a','a{2,1}');
SELECT regexp_like('a','\\1');
SELECT regexp_substr( 'ab','(?<=a+)b' );
SELECT regexp_like( 'a', 'a[' );
SELECT regexp_substr( 'ab','[b-a]' );
CREATE TABLE t1 ( a TEXT );
INSERT INTO t1 VALUES ( repeat( 'a', 16384 ) );
SELECT char_length ( regexp_replace( a, 'a', 'b' ) ) FROM t1;
SET GLOBAL  regexp_time_limit = 10000;
SELECT regexp_like ( regexp_replace( a, 'a', 'b' ), 'b{16384}' ) FROM t1;
SET GLOBAL  regexp_time_limit = DEFAULT;
DROP TABLE t1;
DO '1' regexp repeat('$', 50000000);
DO ( (@b) regexp (cot (unhex ( 1 )) ) );
DO ( (@c) rlike (cot ( (!( @f )) )) );
DO ( ('') rlike (cot ( ' %' )) );
DO ( (-28277) regexp (period_add ( -10966, 1381205734 )) );
DO ( (( @f )) rlike (json_depth ( 'key4' )) );
DO ( ('-  ') regexp (cot ( right (':#.', 33) )) );
DO ( (1) regexp (exp ( 64826 )) );
DO ( (@g) regexp (cot ( @f )) );
DO ( (@b) regexp (exp ( 0x1fc5574c )) );
DO ( (25091) rlike (exp ( 14373 )) );
SET GLOBAL regexp_time_limit = 1000000;
enable_connect_log;
connect(conn1, localhost, root);
send SELECT regexp_instr('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC', '(A+)+B');
connection default;
replace_result $conn1_id <conn1_id>;
eval KILL QUERY $conn1_id;
connection conn1;
reap;
disconnect conn1;
source include/wait_until_disconnected.inc;
connection default;
disable_connect_log;
SET GLOBAL regexp_time_limit = DEFAULT;
SELECT regexp_instr ( 'a', 'a', NULL );
SELECT regexp_instr ( 'a', 'a', 1, NULL );
SELECT regexp_instr ( 'a', 'a', 1, 0, NULL );
SELECT regexp_instr ( 'a', 'a', 1, 0, 0, NULL );
SELECT regexp_like ( 'a', 'a', NULL );
SELECT regexp_replace ( 'a', 'a', 'a', NULL );
SELECT regexp_replace ( 'a', 'a', 'a', 1, NULL );
SELECT regexp_replace ( 'a', 'a', 'a', 1, 0, NULL );
SELECT regexp_substr ( 'a', 'a', NULL );
SELECT regexp_substr ( 'a', 'a', 1, NULL );
SELECT regexp_substr ( 'a', 'a', 1, 0, NULL );
SELECT regexp_like( reverse(''), 123 );
SELECT regexp_like( soundex(@v1), 'abc' );
SELECT regexp_like( left('', ''), 'abc' );
SELECT regexp_like( repeat(@v1, 'abc'), 'abc' );
SELECT regexp_replace( 'abc' , 'abc', '$abc' );
SET @s := "SELECT regexp_like( '', '', ? / '' )";
PREPARE stmt FROM @s;
EXECUTE stmt;
EXECUTE stmt;
CREATE TABLE t1 ( match_parameter CHAR(1) );
INSERT INTO t1 VALUES ( 'i' ), ( 'c' ), ( 'i' ), ( 'c' );
SELECT match_parameter, regexp_like ( 'a', 'A', match_parameter ) FROM t1;
DROP TABLE t1;
SELECT regexp_replace( ' F' , '^ ', '[,$' );
SELECT regexp_instr( 'abc', '(?-' );
select regexp_instr(char('313:50:35.199734'using utf16le),uuid());
CREATE TABLE t1 ( a VARCHAR(10) );
INSERT INTO t1 VALUES ('a a a'), ('b b b'), ('c c c');
SELECT regexp_replace(a, '^([[:alpha:]]+)[[:space:]].*$', '$1') FROM t1;
DROP TABLE t1;
CREATE TABLE t1 ( a CHAR(3) );
INSERT INTO t1 VALUES ( regexp_replace ('a', 'a', 'x') );
SELECT * FROM t1;
UPDATE t1 SET a = regexp_replace ( 'b', 'b', 'y' );
SELECT * FROM t1;
DROP TABLE t1;
CREATE TABLE t1 ( a CHAR(3) );
INSERT INTO t1 VALUES ( regexp_substr ('a', 'a', 1) );
SELECT * FROM t1;
UPDATE t1 SET a = regexp_substr ('b', 'b', 1);
SELECT * FROM t1;
DROP TABLE t1;
CREATE TABLE t1 AS SELECT  regexp_instr( 'a', 'a' ) AS a,  regexp_like( 'a', 'a' ) AS b,  regexp_replace( 'abc', 'b', 'x' ) AS c,  regexp_substr( 'a', 'a' ) AS d,  regexp_substr( repeat('a', 512), 'a' ) AS e,  regexp_substr( repeat('a', 513), 'a' ) AS f;
SHOW CREATE TABLE t1;
SELECT * FROM t1;
DROP TABLE t1;
SET NAMES DEFAULT;
SELECT regexp_instr( '🍣🍣a', '🍣', 2 );
SELECT regexp_instr( '🍣🍣a', 'a', 3 );
SELECT regexp_instr( '🍣🍣a', 'a', 4 );
SELECT regexp_substr( 'a🍣b', '.', 1 );
SELECT regexp_substr( 'a🍣b', '.', 2 );
SELECT regexp_substr( 'a🍣b', '.', 3 );
SELECT regexp_substr( 'a🍣b', '.', 4 );
SELECT regexp_substr( 'a🍣🍣b', '.', 1 );
SELECT regexp_substr( 'a🍣🍣b', '.', 2 );
SELECT regexp_substr( 'a🍣🍣b', '.', 3 );
SELECT regexp_substr( 'a🍣🍣b', '.', 4 );
SELECT regexp_substr( 'a🍣🍣b', '.', 5 );
SELECT regexp_replace( '🍣🍣🍣', '.', 'a', 2 );
SELECT regexp_replace( '🍣🍣🍣', '.', 'a', 2, 2 );
SELECT hex(regexp_replace( convert( 'abcd' using utf8mb4 ), 'c', ''));
SELECT hex(regexp_replace( convert( 'abcd' using utf16 ), 'c', ''));
SELECT hex(regexp_substr( convert( 'abcd' using utf8mb4 ), 'abc'));
SELECT hex(regexp_substr( convert( 'abcd' using utf16 ), 'abc'));
CREATE TABLE t1 (  a CHAR(10) CHARACTER SET utf16le,  b CHAR(10) CHARACTER SET utf16);
INSERT INTO t1 VALUES (  regexp_substr( convert('abcd' using utf16le), 'abc' ),  regexp_substr( convert('abcd' using utf16), 'abc' ));
INSERT INTO t1 VALUES (  regexp_substr( 'abcd', 'abc' ),  regexp_substr( 'abcd', 'abc' ));
SELECT * FROM t1;
DROP TABLE t1;
SELECT regexp_like('1', x'01');
SELECT regexp_like(x'01', '1');
SELECT regexp_replace('01', '01', x'02');
SELECT regexp_replace('01', x'01', '02');
SELECT regexp_replace('01', x'01', x'02');
SELECT regexp_replace(x'01', '01', '02');
SELECT regexp_replace(x'01', '01', x'02');
SELECT regexp_replace(x'01', x'01', '02');
CREATE TABLE t1(a CHAR(1));
CREATE TABLE t2(a BLOB);
CREATE TABLE t3(a TEXT);
INSERT INTO t1 VALUES('1');
INSERT INTO t2 VALUES('1');
INSERT INTO t3 VALUES('1');
SELECT regexp_like(a, x'01') FROM t1;
SELECT regexp_like(a, x'01') FROM t2;
SELECT regexp_like(a, x'01') FROM t3;
SELECT regexp_like(x'01', a) FROM t1;
SELECT regexp_like(x'01', a) FROM t2;
SELECT regexp_like(x'01', a) FROM t3;
DROP TABLE t1, t2, t3;
SELECT regexp_instr(1, 'a');
SELECT regexp_instr('a', 1);
SELECT regexp_instr(NULL, 'a');
SELECT regexp_instr('a', NULL);
SELECT regexp_like(1, 'a');
SELECT regexp_like('a', 1);
SELECT regexp_like(NULL, 'a');
SELECT regexp_like('a', NULL);
SELECT regexp_replace(1, 1, 'a');
SELECT regexp_replace(1, 'a', 1);
SELECT regexp_replace(1, 'a', 'a');
SELECT regexp_replace('a', 1, 1);
SELECT regexp_replace('a', 1, 'a');
SELECT regexp_replace('a', 'a', 1);
SELECT regexp_replace(NULL, NULL, 'a');
SELECT regexp_replace(NULL, 'a', NULL);
SELECT regexp_replace(NULL, 'a', 'a');
SELECT regexp_replace('a', NULL, NULL);
SELECT regexp_replace('a', NULL, 'a');
SELECT regexp_replace('a', 'a', NULL);
SELECT regexp_substr(1, 'a');
SELECT regexp_substr('a', 1);
SELECT regexp_substr(NULL, 'a');
SELECT regexp_substr('a', NULL);
SELECT hex(regexp_replace(x'01', x'01', x'02'));
SELECT hex(regexp_substr(x'FFFF', x'FFFF'));
CREATE TABLE t1 AS SELECT regexp_substr(x'01', x'01');
SHOW CREATE TABLE t1;
DROP TABLE t1;
CREATE TABLE t1 AS SELECT regexp_replace(x'01', x'01', x'02');
SHOW CREATE TABLE t1;
DROP TABLE t1;
do regexp_like(0, "^{18446744073709551616");
do regexp_instr(0, "^{18446744073709551616");
SET SQL_MODE='';
DO INSERT(regexp_like(1, '['), 0, 1, '');
DO INSERT(regexp_instr(1, '['), 0, 1, '');
SET NAMES latin1;
DO INSERT(regexp_replace(1, '[', 42), 0, 1, '');
SET NAMES DEFAULT;
SET SQL_MODE=DEFAULT;
select ( _utf32', ,*') regexp 13946;
select regexp_instr( ( _utf32', ,*'), 13946);
select regexp_replace( ( _utf32', ,*'), 13946, 42);
select regexp_substr( ( _utf32', ,*'), 13946);
CREATE FUNCTION icu_major_version() RETURNS INT  RETURN regexp_replace(icu_version(), '([[:digit:]]+)\..*', '$1');
CREATE TABLE t1 (  subject char(10),  pattern char(10));
SELECT regexp_instr( 'abc', 'a' );
SELECT regexp_instr( 'abc', 'b' );
SELECT regexp_instr( 'abc', 'c' );
SELECT regexp_instr( 'abc', 'd' );
SELECT regexp_instr( NULL, 'a' );
SELECT regexp_instr( 'a', NULL );
SELECT regexp_instr( NULL, NULL );
SET NAMES binary;
SELECT hex( concat(regexp_instr( 'a', 'a' )) );
SET NAMES DEFAULT;
SELECT regexp_instr( 1, 'a' );
SELECT regexp_instr( 1.1, 'a' );
SELECT regexp_instr( 'a', 1 );
SELECT regexp_instr( 'a', 1.1 );
SELECT regexp_instr( subject, pattern ) FROM t1;
SELECT regexp_instr( 'a', '[[:invalid_bracket_expression:]]' );
SELECT regexp_instr( 'abcabcabc', 'a+', 1 );
SELECT regexp_instr( 'abcabcabc', 'a+', 2 );
SELECT regexp_instr( 'abcabcabc', 'b+', 1 );
SELECT regexp_instr( 'abcabcabc', 'b+', 2 );
SELECT regexp_instr( 'abcabcabc', 'b+', 3 );
SELECT regexp_instr( 'a', 'a+', 3 );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 2 );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 3 );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 4 );
SELECT regexp_instr( 'abcabcabc', 'a+', 4, 2 );
SELECT regexp_instr( 'a', 'a+', 1, 1, 2 );
SELECT regexp_instr( 'a', 'a+', 1, 1, -1 );
SELECT regexp_instr( 'a', 'a+', 1, 1, NULL );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 0 );
SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 1 );
SELECT regexp_instr( 'aaabcabcabc', 'a+', 1, 1, 1 );
SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'c' );
SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'i' );
SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'ci' );
SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'cic' );
SELECT regexp_instr( 'a', 'a+', 1, 1, 1, 'x' );
SELECT regexp_instr( 'a', 'a+', 1, 1, 1, NULL );
SELECT regexp_like( 'abc', 'a' );
SELECT regexp_like( 'abc', 'b' );
SELECT regexp_like( 'abc', 'c' );
SELECT regexp_like( 'abc', 'd' );
SELECT regexp_like( 'a', 'a.*' );
SELECT regexp_like( 'ab', 'a.*' );
SELECT regexp_like( NULL, 'a' );
SELECT regexp_like( 'a', NULL );
SELECT regexp_like( NULL, NULL );
SET NAMES binary;
SELECT hex( concat(regexp_like( 'a', 'a' )) );
SET NAMES DEFAULT;
SELECT regexp_like( 'abc', 'A', 'i' );
SELECT regexp_like( 'abc', 'A', 'c' );
SELECT regexp_like( 'a', 'a+', 'x' );
SELECT regexp_like( 'a', 'a+', 'cmnux' );
SELECT regexp_like( 'a', 'a+', NULL );
SELECT regexp_like( 1, 'a' );
SELECT regexp_like( 1.1, 'a' );
SELECT regexp_like( 'a', 1 );
SELECT regexp_like( 'a', 1.1 );
SELECT regexp_like('a', '[[:invalid_bracket_expression:]]');
SELECT regexp_replace( 'aaa', 'a', 'X' );
SELECT regexp_replace( 'abc', 'b', 'X' );
SELECT regexp_replace( NULL, 'a', 'X' );
SELECT regexp_replace( 'aaa', NULL, 'X' );
SELECT regexp_replace( 'aaa', 'a', NULL );
SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' );
SELECT regexp_replace( 'aaa', 'a', 'X', 0 );
SELECT regexp_replace( 'aaa', 'a', 'X', 1 );
SELECT regexp_replace( 'a', 'a+', 'b', 3 );
SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 0, 1 );
SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 );
SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 2 );
SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>', 1, 2 );
SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x', 1, 0 );
SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x', 1, 0 );
SELECT regexp_replace( 'aaab', 'b', 'x', 1, 2 );
SELECT regexp_replace( 'aaabccc', 'b', 'x', 1, 2 );
SELECT regexp_replace( 'abc', 'b', 'X' );
SELECT regexp_replace( 'abcbdb', 'b', 'X' );
SELECT regexp_replace( 'abcbdb', 'b', 'X', 3 );
SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 1 );
SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 2 );
SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 3 );
SELECT regexp_replace( 'a', '[[:invalid_bracket_expression:]]', '$1' );
SELECT regexp_replace( 'aaa', 'a', 'X', 2 );
SELECT regexp_replace( 'aaa', 'a', 'XX', 2 );
SELECT regexp_substr( 'a' );
SELECT regexp_substr( 'a', 'b', 'c', 'd', 'e', 'f' );
SELECT regexp_substr( 'ab ac ad', '.d' );
SELECT regexp_substr( 'ab ac ad', '.D' );
SELECT concat( regexp_substr( 'aaa', 'a+' ), 'x' );
SELECT regexp_substr( 'ab ac ad', 'a.', 0 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3, 1 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3, 2 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3, 3 );
SELECT regexp_substr( 'ab ac ad', 'A.', 3, 3 ) IS NULL;
SELECT regexp_substr( 'ab ac ad', 'A.', 1, 1, 'c' );
SELECT regexp_substr( 'ab\nac\nad', 'A.', 1, 1, 'i' );
SELECT regexp_substr( 'ab\nac\nad', 'A.', 1, 1, 'im' );
SELECT regexp_substr('a', '[[:invalid_bracket_expression:]]');
SET sql_mode = ''; # Un-strictCREATE TABLE t2 ( g GEOMETRY NOT NULL );
INSERT INTO t2 VALUES ( POINT(1,2) );
SELECT concat( regexp_like(g, g), 'x' ) FROM t2;
SET sql_mode = DEFAULT;
DROP TABLE t2;
DROP TABLE t1;
SELECT regexp_instr( '', '((((((((){80}){}){11}){11}){11}){80}){11}){4}' );
SET GLOBAL regexp_stack_limit = 239;
SELECT regexp_instr( '', '(((((((){120}){11}){11}){11}){80}){11}){4}' );
SET GLOBAL regexp_stack_limit = 32;
SELECT regexp_instr( '', '((((((){11}){11}){11}){160}){11}){160}' );
SELECT regexp_instr( '', '(((((){150}){11}){160}){11}){160}' );
SELECT regexp_instr( '', '((((){255}){255}){255}){255}' );
SET GLOBAL regexp_stack_limit = DEFAULT;
SET GLOBAL regexp_time_limit = 1000;
SELECT regexp_instr( 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC', '(A+)+B' );
SET GLOBAL regexp_time_limit = DEFAULT;
SET NAMES latin1;
SELECT regexp_instr( _latin1 x'61F662', _latin1 x'F6' );
SELECT regexp_instr( _latin1 x'61F662', _utf8mb4'ö' );
SELECT regexp_instr( concat('a', _utf8mb4 x'F09F8DA3'), _utf8mb4 x'F09F8DA3' );
SELECT regexp_instr( _utf8mb4'aöb', _utf8mb4'ö' );
SET NAMES utf8;
SELECT regexp_instr( 'aöb', 'ö' );
SET NAMES DEFAULT;
SET NAMES utf8;
SELECT regexp_instr( 'אב רק', /*k*/'^[^ב]' );
PREPARE stmt1 FROM "select 'a' rlike ?";
DEALLOCATE PREPARE stmt1;
CREATE TABLE t1( a INT, subject CHAR(10) );
CREATE TABLE t2( pattern CHAR(10) );
insert into t1 values (0, 'apa');
insert into t2 values ('apa');
DELIMITER ||;
CREATE DEFINER=root@localhost PROCEDURE p1()BEGIN  UPDATE t1, t2  SET a = 1  WHERE regexp_like(t1.subject, t2.pattern);
END||DELIMITER ;||CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1, t2;
CREATE TABLE t1 ( a INT );
EXPLAIN SELECT 1 FROM t1 WHERE 1 REGEXP (1 IN (SELECT 1 FROM t1));
DROP TABLE t1;
PREPARE stmt1 FROM "SELECT regexp_like( 'a', ? )";
PREPARE stmt2 FROM "SELECT regexp_like( ?, 'a' )";
PREPARE stmt3 FROM "SELECT regexp_like( ?, ? )";
SET @subject = 'a';
SET @pattern = 'a+';
EXECUTE stmt1 USING @pattern;
EXECUTE stmt2 USING @subject;
EXECUTE stmt3 USING @subject, @pattern;
SET @subject = 1;
SET @pattern = 1;
EXECUTE stmt1 USING @pattern;
EXECUTE stmt2 USING @subject;
EXECUTE stmt3 USING @subject, @pattern;
DEALLOCATE PREPARE stmt1;
DEALLOCATE PREPARE stmt2;
DEALLOCATE PREPARE stmt3;
DO 1 rlike multilinestring(point(1, 1));
CREATE TABLE t1 ( a CHAR(10) );
INSERT INTO t1 VALUES ( 'abc' ), ( 'bcd' ), ( 'cde' );
SELECT regexp_like( a, 'a' ) FROM t1;
DROP TABLE t1;
CREATE TABLE t1 ( a CHAR ( 10 ), b CHAR ( 10 ) );
INSERT INTO t1 VALUES( NULL, 'abc' );
INSERT INTO t1 VALUES( 'def', NULL );
SELECT a, b, regexp_like( a, b ) FROM t1;
DROP TABLE t1;
CREATE TABLE t1 (  c CHAR(10) CHARSET latin1 COLLATE latin1_bin,  c_ci CHAR(10) CHARSET latin1 COLLATE latin1_general_ci,  c_cs CHAR(10) CHARSET latin1 COLLATE latin1_general_cs);
INSERT INTO t1VALUES ( 'a', 'a', 'a' ), ( 'A', 'A', 'A' ), ( 'b', 'b', 'b' );
SELECT c, c_ci REGEXP 'A', c_cs REGEXP 'A' FROM t1;
DROP TABLE t1;
SELECT regexp_like( _utf8mb4 'ss' COLLATE utf8mb4_german2_ci,                    _utf8mb4 'ß'  COLLATE utf8mb4_german2_ci );
SELECT regexp_like( _utf8mb4 'ß'  COLLATE utf8mb4_german2_ci,                    _utf8mb4 'ss' );
SELECT regexp_like( _utf8mb4 'ß'  COLLATE utf8mb4_de_pb_0900_as_cs,                    _utf8mb4 'ss' );
SET NAMES latin1;
SELECT regexp_like( 'a', 'A' COLLATE latin1_general_ci );
SELECT 'a' REGEXP 'A' COLLATE latin1_general_ci;
SELECT regexp_like( 'a', 'A' COLLATE latin1_general_cs );
SELECT 'a' REGEXP 'A' COLLATE latin1_general_cs;
SELECT regexp_like( 'a\nb\nc', '^b$' );
SELECT regexp_like( 'a\nb\nc', '(?m)^b$' );
SELECT regexp_like( 'a\nb\nc', '.*' );
SELECT regexp_like( _utf16 'a' , 'a' );
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }DROP FUNCTION icu_major_version;
SELECT regexp_like( _utf16le 'a' , 'a' );
SELECT regexp_like( 'aaa', 'a+', 1 );
SELECT regexp_substr( 'aaa', 'a+', 1, 1, 1 );
SELECT regexp_substr( 'aaa', 'a+', 1, 1, 1 );
SELECT regexp_substr( 'aaa', '+' );
CREATE TABLE t1 (  a CHAR(3) CHARACTER SET utf16le,  b CHAR(3) CHARACTER SET utf16le);
INSERT INTO t1 VALUES ( NULL, 'abc' );
INSERT INTO t1 VALUES ( 'def', NULL );
INSERT INTO t1 VALUES ( NULL, NULL );
SELECT a regexp b FROM t1;
DROP TABLE t1;
CREATE TABLE t1  a REAL,  b INT,  c CHAR(100),  d DECIMAL);
INSERT INTO t1 VALUES ( regexp_instr('a', 'a'),                        regexp_instr('a', 'a'),                        regexp_instr('a', 'a'),                        regexp_instr('a', 'a') );
SELECT * FROM t1;
DELETE FROM t1;
INSERT INTO t1 VALUES ( regexp_like('a', 'a'),                        regexp_like('a', 'a'),                        regexp_like('a', 'a'),                        regexp_like('a', 'a') );
SELECT * FROM t1;
DELETE FROM t1;
INSERT INTO t1 ( a ) VALUES ( regexp_replace('a', 'a', 'a') );
INSERT INTO t1 ( b ) VALUES ( regexp_replace('a', 'a', 'a') );
INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') );
INSERT INTO t1 ( d ) VALUES ( regexp_replace('a', 'a', 'a') );
SELECT * FROM t1;
DELETE FROM t1;
INSERT INTO t1 ( a ) VALUES ( regexp_substr('a', 'a') );
INSERT INTO t1 ( b ) VALUES ( regexp_substr('a', 'a') );
INSERT INTO t1 ( c ) VALUES ( regexp_substr('a', 'a') );
INSERT INTO t1 ( d ) VALUES ( regexp_substr('a', 'a') );
SELECT * FROM t1;
DROP TABLE t1;
SELECT cast( regexp_replace('a', 'a', 'a') AS SIGNED INTEGER );
SELECT cast( regexp_substr ('a', 'a')      AS SIGNED INTEGER );
SELECT cast( regexp_instr  ('a', 'a'     ) AS DATETIME );
SELECT cast( regexp_like   ('a', 'a'     ) AS DATETIME );
SELECT cast( regexp_replace('a', 'a', 'a') AS DATETIME );
SELECT cast( regexp_substr ('a', 'a'     ) AS DATETIME );
SELECT cast( regexp_instr  ('a', 'a'     ) AS TIME );
SELECT cast( regexp_like   ('a', 'a'     ) AS TIME );
SELECT cast( regexp_replace('a', 'a', 'a') AS TIME );
SELECT cast( regexp_substr ('a', 'a'     ) AS TIME );
SET GLOBAL net_buffer_length = 1024;
SET GLOBAL max_allowed_packet = @@global.net_buffer_length;
SELECT @@global.max_allowed_packet;
SET @buf_sz_utf16 = @@global.max_allowed_packet / length( _utf16'x' );
SELECT @buf_sz_utf16;
SELECT length(regexp_replace( repeat('a', @buf_sz_utf16), 'a', 'b' ));
SELECT length(regexp_replace( repeat('a', @buf_sz_utf16 + 1), 'a', 'b' ));
SELECT length(regexp_replace( repeat('a', @buf_sz_utf16), 'a', 'bb' ));
SET GLOBAL net_buffer_length = DEFAULT;
SET GLOBAL max_allowed_packet = DEFAULT;
SELECT regexp_like( 'a', '[[:<:]]a' );
SELECT regexp_like( 'a', '   **' );
SELECT regexp_like( 'a', ' \n  **' );
SELECT regexp_like( 'a', '  +++' );
SELECT regexp_like( 'a', '\\' );
SELECT regexp_like('a','(?{})');
SELECT regexp_like('a','(');
SELECT regexp_like('a','a{}');
SELECT regexp_like('a','a{2,1}');
SELECT regexp_like('a','\\1');
SELECT regexp_substr( 'ab','(?<=a+)b' );
SELECT regexp_like( 'a', 'a[' );
SELECT regexp_substr( 'ab','[b-a]' );
CREATE TABLE t1 ( a TEXT );
INSERT INTO t1 VALUES ( repeat( 'a', 16384 ) );
SELECT char_length ( regexp_replace( a, 'a', 'b' ) ) FROM t1;
SET GLOBAL  regexp_time_limit = 10000;
SELECT regexp_like ( regexp_replace( a, 'a', 'b' ), 'b{16384}' ) FROM t1;
SET GLOBAL  regexp_time_limit = DEFAULT;
DROP TABLE t1;
DO '1' regexp repeat('$', 50000000);
DO ( (@b) regexp (cot (unhex ( 1 )) ) );
DO ( (@c) rlike (cot ( (!( @f )) )) );
DO ( ('') rlike (cot ( ' %' )) );
DO ( (-28277) regexp (period_add ( -10966, 1381205734 )) );
DO ( (( @f )) rlike (json_depth ( 'key4' )) );
DO ( ('-  ') regexp (cot ( right (':#.', 33) )) );
DO ( (1) regexp (exp ( 64826 )) );
DO ( (@g) regexp (cot ( @f )) );
DO ( (@b) regexp (exp ( 0x1fc5574c )) );
DO ( (25091) rlike (exp ( 14373 )) );
SET GLOBAL regexp_time_limit = 1000000;
enable_connect_log;
connect(conn1, localhost, root);
send SELECT regexp_instr('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC', '(A+)+B');
connection default;
replace_result $conn1_id <conn1_id>;
eval KILL QUERY $conn1_id;
connection conn1;
reap;
disconnect conn1;
source include/wait_until_disconnected.inc;
connection default;
disable_connect_log;
SET GLOBAL regexp_time_limit = DEFAULT;
SELECT regexp_instr ( 'a', 'a', NULL );
SELECT regexp_instr ( 'a', 'a', 1, NULL );
SELECT regexp_instr ( 'a', 'a', 1, 0, NULL );
SELECT regexp_instr ( 'a', 'a', 1, 0, 0, NULL );
SELECT regexp_like ( 'a', 'a', NULL );
SELECT regexp_replace ( 'a', 'a', 'a', NULL );
SELECT regexp_replace ( 'a', 'a', 'a', 1, NULL );
SELECT regexp_replace ( 'a', 'a', 'a', 1, 0, NULL );
SELECT regexp_substr ( 'a', 'a', NULL );
SELECT regexp_substr ( 'a', 'a', 1, NULL );
SELECT regexp_substr ( 'a', 'a', 1, 0, NULL );
SELECT regexp_like( reverse(''), 123 );
SELECT regexp_like( soundex(@v1), 'abc' );
SELECT regexp_like( left('', ''), 'abc' );
SELECT regexp_like( repeat(@v1, 'abc'), 'abc' );
SELECT regexp_replace( 'abc' , 'abc', '$abc' );
SET @s := "SELECT regexp_like( '', '', ? / '' )";
PREPARE stmt FROM @s;
EXECUTE stmt;
EXECUTE stmt;
CREATE TABLE t1 ( match_parameter CHAR(1) );
INSERT INTO t1 VALUES ( 'i' ), ( 'c' ), ( 'i' ), ( 'c' );
SELECT match_parameter, regexp_like ( 'a', 'A', match_parameter ) FROM t1;
DROP TABLE t1;
SELECT regexp_replace( ' F' , '^ ', '[,$' );
SELECT regexp_instr( 'abc', '(?-' );
select regexp_instr(char('313:50:35.199734'using utf16le),uuid());
CREATE TABLE t1 ( a VARCHAR(10) );
INSERT INTO t1 VALUES ('a a a'), ('b b b'), ('c c c');
SELECT regexp_replace(a, '^([[:alpha:]]+)[[:space:]].*$', '$1') FROM t1;
DROP TABLE t1;
CREATE TABLE t1 ( a CHAR(3) );
INSERT INTO t1 VALUES ( regexp_replace ('a', 'a', 'x') );
SELECT * FROM t1;
UPDATE t1 SET a = regexp_replace ( 'b', 'b', 'y' );
SELECT * FROM t1;
DROP TABLE t1;
CREATE TABLE t1 ( a CHAR(3) );
INSERT INTO t1 VALUES ( regexp_substr ('a', 'a', 1) );
SELECT * FROM t1;
UPDATE t1 SET a = regexp_substr ('b', 'b', 1);
SELECT * FROM t1;
DROP TABLE t1;
CREATE TABLE t1 AS SELECT  regexp_instr( 'a', 'a' ) AS a,  regexp_like( 'a', 'a' ) AS b,  regexp_replace( 'abc', 'b', 'x' ) AS c,  regexp_substr( 'a', 'a' ) AS d,  regexp_substr( repeat('a', 512), 'a' ) AS e,  regexp_substr( repeat('a', 513), 'a' ) AS f;
SHOW CREATE TABLE t1;
SELECT * FROM t1;
DROP TABLE t1;
SET NAMES DEFAULT;
SELECT regexp_instr( '🍣🍣a', '🍣', 2 );
SELECT regexp_instr( '🍣🍣a', 'a', 3 );
SELECT regexp_instr( '🍣🍣a', 'a', 4 );
SELECT regexp_substr( 'a🍣b', '.', 1 );
SELECT regexp_substr( 'a🍣b', '.', 2 );
SELECT regexp_substr( 'a🍣b', '.', 3 );
SELECT regexp_substr( 'a🍣b', '.', 4 );
SELECT regexp_substr( 'a🍣🍣b', '.', 1 );
SELECT regexp_substr( 'a🍣🍣b', '.', 2 );
SELECT regexp_substr( 'a🍣🍣b', '.', 3 );
SELECT regexp_substr( 'a🍣🍣b', '.', 4 );
SELECT regexp_substr( 'a🍣🍣b', '.', 5 );
SELECT regexp_replace( '🍣🍣🍣', '.', 'a', 2 );
SELECT regexp_replace( '🍣🍣🍣', '.', 'a', 2, 2 );
SELECT hex(regexp_replace( convert( 'abcd' using utf8mb4 ), 'c', ''));
SELECT hex(regexp_replace( convert( 'abcd' using utf16 ), 'c', ''));
SELECT hex(regexp_substr( convert( 'abcd' using utf8mb4 ), 'abc'));
SELECT hex(regexp_substr( convert( 'abcd' using utf16 ), 'abc'));
CREATE TABLE t1 (  a CHAR(10) CHARACTER SET utf16le,  b CHAR(10) CHARACTER SET utf16);
INSERT INTO t1 VALUES (  regexp_substr( convert('abcd' using utf16le), 'abc' ),  regexp_substr( convert('abcd' using utf16), 'abc' ));
INSERT INTO t1 VALUES (  regexp_substr( 'abcd', 'abc' ),  regexp_substr( 'abcd', 'abc' ));
SELECT * FROM t1;
DROP TABLE t1;
SELECT regexp_like('1', x'01');
SELECT regexp_like(x'01', '1');
SELECT regexp_replace('01', '01', x'02');
SELECT regexp_replace('01', x'01', '02');
SELECT regexp_replace('01', x'01', x'02');
SELECT regexp_replace(x'01', '01', '02');
SELECT regexp_replace(x'01', '01', x'02');
SELECT regexp_replace(x'01', x'01', '02');
CREATE TABLE t1(a CHAR(1));
CREATE TABLE t2(a BLOB);
CREATE TABLE t3(a TEXT);
INSERT INTO t1 VALUES('1');
INSERT INTO t2 VALUES('1');
INSERT INTO t3 VALUES('1');
SELECT regexp_like(a, x'01') FROM t1;
SELECT regexp_like(a, x'01') FROM t2;
SELECT regexp_like(a, x'01') FROM t3;
SELECT regexp_like(x'01', a) FROM t1;
SELECT regexp_like(x'01', a) FROM t2;
SELECT regexp_like(x'01', a) FROM t3;
DROP TABLE t1, t2, t3;
SELECT regexp_instr(1, 'a');
SELECT regexp_instr('a', 1);
SELECT regexp_instr(NULL, 'a');
SELECT regexp_instr('a', NULL);
SELECT regexp_like(1, 'a');
SELECT regexp_like('a', 1);
SELECT regexp_like(NULL, 'a');
SELECT regexp_like('a', NULL);
SELECT regexp_replace(1, 1, 'a');
SELECT regexp_replace(1, 'a', 1);
SELECT regexp_replace(1, 'a', 'a');
SELECT regexp_replace('a', 1, 1);
SELECT regexp_replace('a', 1, 'a');
SELECT regexp_replace('a', 'a', 1);
SELECT regexp_replace(NULL, NULL, 'a');
SELECT regexp_replace(NULL, 'a', NULL);
SELECT regexp_replace(NULL, 'a', 'a');
SELECT regexp_replace('a', NULL, NULL);
SELECT regexp_replace('a', NULL, 'a');
SELECT regexp_replace('a', 'a', NULL);
SELECT regexp_substr(1, 'a');
SELECT regexp_substr('a', 1);
SELECT regexp_substr(NULL, 'a');
SELECT regexp_substr('a', NULL);
SELECT hex(regexp_replace(x'01', x'01', x'02'));
SELECT hex(regexp_substr(x'FFFF', x'FFFF'));
CREATE TABLE t1 AS SELECT regexp_substr(x'01', x'01');
SHOW CREATE TABLE t1;
DROP TABLE t1;
CREATE TABLE t1 AS SELECT regexp_replace(x'01', x'01', x'02');
SHOW CREATE TABLE t1;
DROP TABLE t1;
do regexp_like(0, "^{18446744073709551616");
do regexp_instr(0, "^{18446744073709551616");
SET SQL_MODE='';
DO INSERT(regexp_like(1, '['), 0, 1, '');
DO INSERT(regexp_instr(1, '['), 0, 1, '');
SET NAMES latin1;
DO INSERT(regexp_replace(1, '[', 42), 0, 1, '');
SET NAMES DEFAULT;
SET SQL_MODE=DEFAULT;
select ( _utf32', ,*') regexp 13946;
select regexp_instr( ( _utf32', ,*'), 13946);
select regexp_replace( ( _utf32', ,*'), 13946, 42);
select regexp_substr( ( _utf32', ,*'), 13946);
