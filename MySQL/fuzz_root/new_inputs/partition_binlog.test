    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          perl;
  # Compute relay log filename.  my $index_file= $ENV{'_RGEORL_INDEX_FILE'};
  my $channel_name= $ENV{'_RGEORL_CHANNEL_NAME'};
  # Remove the single quotes from $channel_name  $channel_name=~ s/\'//g;
  if ($channel_name) {    $index_file =~ s/(.*)(\.index)/$1-$channel_name$2/;
  }  # Read relay log filename.  open FILE, "$index_file" or die "Error $? opening $index_file: $!";
  my $relay_log_file= '';
  while (<FILE>) {    $relay_log_file= $_;
  }  chomp($relay_log_file);
  $relay_log_file =~ s{^\.[/\\]}{};
  close FILE or die "Error $? closing $index_file: $!";
  # Get relay log size.  my $datadir= $ENV{'_RGEORL_DATADIR'};
  my $relay_log_size= (stat("$datadir/$relay_log_file"))[7];
  # Write output file.  my $output_file= $ENV{'_RGEORL_OUTPUT_FILE'};
  open FILE, "> $output_file" or die "Error $? opening $output_file: $!";
  printf FILE "% 10d%s", $relay_log_size, $relay_log_file or die "Error $? writing to $output_file: $!";
  close FILE or die "Error $? writing to $output_file: $!";
EOF      if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                                    perl;
  use strict;
  my $stmt= $ENV{'_WRTF_STATEMENT'};
  # Connecting mysql to same mysqld as current connectiona  # by overriding port and socket  my $mysql= $ENV{'MYSQL'};
  my $server_port= $ENV{'_WRTF_SERVER_PORT'};
  my $server_socket= $ENV{'_WRTF_SERVER_SOCKET'};
  my $redirection_type= $ENV{'_WRTF_APPEND'} ? '>>' : '>';
  $mysql .= "   my $outfile = $ENV{'_WRTF_OUTPUT_FILE'};
  open MYSQL, "| $mysql $redirection_type $outfile" or die "Error $? opening MYSQL pipe '| $mysql > $outfile': $!";
  print MYSQL $stmt, ';' or die "Error $? printing statement '$stmt' to MYSQL pipe '| $mysql > $outfile': $!";
  close MYSQL or $ENV{'_WRTF_ALLOW_ERROR'} or die "Error $? closing MYSQL pipe '| $mysql > $outfile' reading '$stmt': $!";
EOF  if (!$include_silent)  {      }            perl;
  my $pre_script = $ENV{'_FF_PRE_SCRIPT'};
  $pre_script =~ s/DOLLAR/\$/g;
  my $script = $ENV{'_FF_SCRIPT'};
  $script =~ s/DOLLAR/\$/g;
  my $input_file = $ENV{'_FF_INPUT_FILE'};
  my $output_file = $ENV{'_FF_OUTPUT_FILE'};
  my $select_columns = $ENV{'_FF_SELECT_COLUMNS'};
  my $mask_columns = $ENV{'_FF_MASK_COLUMNS'};
  my $debug = $ENV{'_FF_DEBUG'};
  if ($select_columns)  {    chomp($select_columns);
    $select_columns =~ s/[, ]+/,/g;
    $script = '    chomp;
    my @cols = split(/\t/, $_);
    $_ = join("\t", map { $cols[$_ - 1] } ('.$select_columns.'));
    ' . $script;
  }  if ($mask_columns)  {    chomp($mask_columns);
    my $last_col = 0;
    my $regex = '';
    my $pending_tab = '';
    my $replacement = '';
    my $n = 1;
    for my $col (split(/\s*,\s*/, $mask_columns)) {      $regex .= '(' . $pending_tab . '[^\t]*\t' x ($col - $last_col - 1) . ')';
      $regex .= '(?:[^\t]*)';
      $pending_tab = '\t';
      $replacement .= '$' . $n . '#';
      $n++;
      $last_col = $col;
    }    $script = "s/$regex/$replacement/;
    $script";
  }  unless ($keep_quotes)  {    $pre_script = 'my %unquote = ("n"=>"\n","t"=>"\t","\\\\"=>"\\\\");' . $pre_script;
    $script .= ';s{\\\\(.)}{$unquote{$1}}ge;';
  }  if ($debug)  {    $script = 'print "BEFORE:\'$_\'";' . $script . 'print "AFTER:\'$_\'";'  }  # Generate a script (perl is faster if we avoid many calls to eval).  my $full_script =  open FILE, "< $input_file" or die "Error opening $input_file: $!";
  my $filtered_contents = "";
  my %column_names = ();
  '.$pre_script.';
  while (<FILE>)  {    chomp;
    s/\015?\012?$//;
    if ($mask_columns && !%column_names)    {      my $n = 1;
      %column_names = map { $_ => $n++ } split(/\t/, $_);
    }    else    {      ' . $script . '    }    if (length($_) > 0)    {      $filtered_contents .= $_."\n";
    }  }  close FILE or die "Error closing $input_file: $!";
  open FILE, "> $output_file" or die "Error opening $output_file: $!";
  binmode FILE;
  print FILE $filtered_contents or die "Error writing filtered contents to $output_file: $!";
  close FILE or die "Error closing $output_file: $!";
  return 0;
';
  if ($debug)  {    print STDOUT "full_script=<<END_OF_SCRIPT\n${full_script}END_OF_SCRIPT\n"  }  my $eval_ret = eval($full_script);
  defined($eval_ret) or die "Parse error or 'die' invoked when evaluating perl script '$full_script': $@";
  $eval_ret == 0 or die "Non-zero exit value $eval_ret from script '$script'";
EOF      if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                    if ($rpl_channel_name)  {      }    if ($rpl_channel_name)  {      }    if ($binlog_file == 'LAST')  {    if ($is_relay_log)    {          }    if (!$is_relay_log)    {          }  }      # If $binlog_start is not set, we will set it as the second event's  # position.  The first event(Description Event) is always ignored. For  # description event's length might be changed because of adding new events,  # 'SHOW BINLOG EVENTS LIMIT 1' is used to get the right value.                s{/\* xid=.* \*/}{/\* XID # \*/};
  s{COMMIT /\* XID # \*/}{COMMIT /\* XID \*/};
  s{table_id: [0-9]+}{table_id: #};
  s{file_id=[0-9]+}{file_id=#};
  s{block_len=[0-9]+}{block_len=#};
  s{Server ver:.*DOLLAR}{SERVER_VERSION, BINLOG_VERSION};
  s{SQL_LOAD-[a-z,0-9,-]*.[a-z]*}{SQL_LOAD-<SERVER UUID>-<MASTER server-id>-<file-id>.<extension>};
  s{rand_seed1=[0-9]*,rand_seed2=[0-9]*}{rand_seed1=<seed 1>,rand_seed2=<seed 2>};
  s{((?:master|slave|slave-relay)-bin\.[0-9]{6};pos=)[0-9]+DOLLAR}{DOLLAR1POS};
  s{(binlog\.[0-9]{6};pos=)[0-9]+DOLLAR}{DOLLAR1POS};
  s{SONAME ".*"}{SONAME "LIB"};
  s{DOLLARmysqltest_vardir}{MYSQLTEST_VARDIR}g;
||    let $pre_script= $pre_script    my DOLLARdec_size_regex = '(decompressed_size=[0-9]+ bytes)';
  ||        let $pre_script= $pre_script    my DOLLARuuid_regex = '[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}';
    my DOLLARuuid_gno_regex = DOLLARuuid_regex.'(?::[0-9]+(?:-[0-9]+)?)+';
  ||                  if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                  DROP TABLE IF EXISTS t1;
CREATE TABLE t1(id INT)PARTITION BY RANGE (id)(PARTITION p0 VALUES LESS THAN (100), PARTITION pmax VALUES LESS THAN (MAXVALUE));
INSERT INTO t1 VALUES (1), (10), (100), (1000);
RESET MASTER;
ALTER TABLE t1 TRUNCATE PARTITION p1;
ALTER TABLE t1 DROP PARTITION p1;
ALTER TABLE t1 ANALYZE PARTITION p1;
ALTER TABLE t1 CHECK PARTITION p1;
ALTER TABLE t1 OPTIMIZE PARTITION p1;
ALTER TABLE t1 REPAIR PARTITION p1;
ALTER TABLE t1 ANALYZE PARTITION p0;
ALTER TABLE t1 CHECK PARTITION p0;
ALTER TABLE t1 OPTIMIZE PARTITION p0;
ALTER TABLE t1 REPAIR PARTITION p0;
ALTER TABLE t1 TRUNCATE PARTITION p0;
ALTER TABLE t1 DROP PARTITION p0;
DROP TABLE t1;
