    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $counter = `SELECT $disconnect_timeout * 10`;
while (!$mysql_errno)    show session status;
  dec $counter;
  if (!$counter)  {    if ($show_rpl_debug_info)    {          }      }        if ($add_wait_counter) {      }      while ($mysql_errno)  # Strangely enough, the server might return "Too many connections"  # while being shutdown, thus 1040 is an "allowed" error  # See BUG#36228    show session status;
  if ($mysql_errno == 1045){      }  if ($mysql_errname == ER_SECURE_TRANSPORT_REQUIRED){      }    if (!$counter)  {      }      if ( $secondary_engine_bootstrap == ON ) {            while ($secondary_engine_status == OFF) {                  if (!$counter) {              }          }        # Wait till the tables get loaded into secondary engine        my $wait_file= "$ENV{MYSQLTEST_VARDIR}/tmp/wait_until_load";
    while (-e $wait_file) {      select(undef, undef, undef, (100 / 1000));
    }    EOF  }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $counter = `SELECT $disconnect_timeout * 10`;
while (!$mysql_errno)    show session status;
  dec $counter;
  if (!$counter)  {    if ($show_rpl_debug_info)    {          }      }        if ($add_wait_counter) {      }      while ($mysql_errno)  # Strangely enough, the server might return "Too many connections"  # while being shutdown, thus 1040 is an "allowed" error  # See BUG#36228    show session status;
  if ($mysql_errno == 1045){      }  if ($mysql_errname == ER_SECURE_TRANSPORT_REQUIRED){      }    if (!$counter)  {      }      if ( $secondary_engine_bootstrap == ON ) {            while ($secondary_engine_status == OFF) {                  if (!$counter) {              }          }        # Wait till the tables get loaded into secondary engine        my $wait_file= "$ENV{MYSQLTEST_VARDIR}/tmp/wait_until_load";
    while (-e $wait_file) {      select(undef, undef, undef, (100 / 1000));
    }    EOF  }  chdir $ENV{'MYSQL_TMP_DIR'};
mkdir "export";
EOFCREATE SCHEMA s1;
CREATE TABLE s1.t1(i VARCHAR(32)) ENGINE MYISAM;
INSERT INTO s1.t1 VALUES ('abc'), ('DEF'), ('Ghi'), ('ghI');
SELECT I FROM s1.t1 ORDER BY i;
FLUSH TABLES WITH READ LOCK;
UNLOCK TABLES;
DROP TABLE s1.t1;
DROP SCHEMA s1;
CREATE SCHEMA s2;
IMPORT TABLE FROM 's2/t1*.sdi';
DROP SCHEMA s2;
connect (con_noschema,localhost,root,,*NO-ONE*);
IMPORT TABLE FROM 't1_*.sdi';
IMPORT TABLE FROM 's1/t1_*.sdi';
disconnect con_noschema;
connection default;
CREATE TABLE t1(i VARCHAR(32)) ENGINE MYISAM;
INSERT INTO t1 VALUES ('abc'), ('DEF'), ('Ghi'), ('ghI');
SELECT i FROM t1 ORDER BY i;
IMPORT TABLE FROM 't1*.sdi';
DROP TABLE t1;
IMPORT TABLE FROM 'pattern_which_matches_nothing';
eval IMPORT TABLE FROM '$MYSQL_TEST_DIR/t/import.test';
CREATE TABLE t1 (i int) ENGINE MYISAM;
IMPORT TABLE FROM 't1.MYD';
IMPORT TABLE FROM 't1.sdi';
DROP TABLE t1;
CREATE TABLE t1(i INT) ENGINE MYISAM;
DROP TABLE t1;
CREATE TABLE t1(i VARCHAR(32)) ENGINE MYISAM;
INSERT INTO t1 VALUES ('AAA'), ('BBB'), ('CCC');
FLUSH TABLES WITH READ LOCK;
UNLOCK TABLES;
DROP TABLE t1;
IMPORT TABLE FROM 't1_*.sdi';
IMPORT TABLE FROM 't1_*.sdi';
REPAIR TABLE t1;
DROP TABLE t1;
CREATE TABLE t1(i INT) ENGINE MYISAM;
LOCK TABLES t1 WRITE;
connect (importcon,localhost,root,,);
SET @@session.lock_wait_timeout= 1;
IMPORT TABLE FROM 't1_*.sdi';
connection default;
disconnect importcon;
UNLOCK TABLES;
DROP TABLE t1;
CREATE TABLE t1(i INT) ENGINE=MYISAM;
opendir(TMP, "$ENV{'MYSQL_TMP_DIR'}/export");
chdir "$ENV{'MYSQL_TMP_DIR'}/export";
while ($_= readdir(TMP))  next unless (/(.+)_\d+\.sdi/);
  my $base= $1;
  rename $_, "${base}.sdi";
closedir(TMP);
open(T1, "t1.sdi");
open(T1_, ">t1_.sdi");
while (<T1>)  s/("sdi_version": ?)\d+,/${1}42,/g;
  print T1_ $_;
close(T1);
close(T1_);
EOFIMPORT TABLE FROM 't1_.sdi';
DROP TABLE t1;
CREATE SCHEMA s1;
CREATE TABLE s1.t1(i INT) ENGINE MYISAM;
CREATE USER noimportforyou@localhost;
REVOKE ALL ON *.* FROM noimportforyou@localhost;
connect (con_noimport,localhost,noimportforyou,,);
IMPORT TABLE FROM 's1/t1_*.sdi';
disconnect con_noimport;
connection default;
GRANT FILE ON *.* TO noimportforyou@localhost;
connect (con_noimport,localhost,noimportforyou,,);
IMPORT TABLE FROM 's1/t1_*.sdi';
disconnect con_noimport;
connection default;
GRANT CREATE ON *.* TO noimportforyou@localhost;
connect (con_noimport,localhost,noimportforyou,,s1);
IMPORT TABLE FROM 't1_*.sdi';
disconnect con_noimport;
connection default;
REVOKE CREATE ON *.* FROM noimportforyou@localhost;
GRANT CREATE ON s1.* TO noimportforyou@localhost;
connect (con_noimport,localhost,noimportforyou,,s1);
IMPORT TABLE FROM 't1_*.sdi';
disconnect con_noimport;
connection default;
REVOKE CREATE ON s1.* FROM noimportforyou@localhost;
GRANT CREATE ON s1.t1 TO noimportforyou@localhost;
connect (con_noimport,localhost,noimportforyou,,s1);
IMPORT TABLE FROM 't1_*.sdi';
disconnect con_noimport;
connection default;
REVOKE FILE ON *.* FROM noimportforyou@localhost;
connect (con_noimport,localhost,noimportforyou,,s1);
IMPORT TABLE FROM 't1_*.sdi';
disconnect con_noimport;
connection default;
DROP USER noimportforyou@localhost;
DROP TABLE s1.t1;
DROP SCHEMA s1;
CREATE TABLE t1 (i INT) ENGINE=MYISAM;
INSERT INTO t1 VALUES (1), (3), (5);
SELECT * FROM t1;
CREATE TABLE t2 (i INT) ENGINE=MYISAM;
INSERT INTO t2 VALUES (2), (4), (6);
SELECT * FROM t2;
CREATE VIEW v2 AS SELECT * FROM t2;
SELECT * FROM v2;
FLUSH TABLES WITH READ LOCK;
UNLOCK TABLES;
DROP TABLE t1;
DROP TABLE t2;
CHECK TABLE v2;
IMPORT TABLE FROM 't1_*.sdi', 't2_*.sdi';
SHOW CREATE TABLE t1;
SHOW CREATE TABLE t2;
SELECT * FROM t1;
SELECT * FROM t2;
CHECK TABLE v2;
SELECT * FROM v2;
DROP VIEW v2;
DROP TABLE t1;
DROP TABLE t2;
CREATE TABLE t1 (i INT) ENGINE MYISAM;
INSERT INTO t1 VALUES (1), (3), (5);
SELECT * FROM t1 ORDER BY i;
FLUSH TABLES WITH READ LOCK;
UNLOCK TABLES;
DROP TABLE t1;
opendir(TMP, "$ENV{'MYSQL_TMP_DIR'}/export");
chdir "$ENV{'MYSQL_TMP_DIR'}/export";
while ($_= readdir(TMP))  next unless (/(.+)_\d+\.sdi/);
  my $base= $1;
  rename $_, "${base}.sdi";
closedir(TMP);
open(T1, "t1.sdi");
open(T1_, ">t1_.sdi");
while (<T1>) s/("name": ?)"i"/$1"k"/g;
 print T1_ $_;
close(T1);
close(T1_);
EOFIMPORT TABLE FROM 't1_.sdi';
SELECT * FROM t1 ORDER BY k;
DROP TABLE t1;
CREATE SCHEMA s1;
CREATE TABLE s1.t1(i VARCHAR(32)) ENGINE MYISAM;
INSERT INTO s1.t1 VALUES ('abc'), ('DEF'), ('Ghi'), ('ghI');
SELECT I FROM s1.t1 ORDER BY i;
FLUSH TABLES WITH READ LOCK;
UNLOCK TABLES;
DROP TABLE s1.t1;
ALTER SCHEMA s1 DEFAULT COLLATE latin1_bin;
IMPORT TABLE FROM 's1/t1*.sdi';
SELECT i FROM s1.t1 ORDER BY i;
SHOW CREATE TABLE s1.t1;
CREATE TABLE s1.t2(i VARCHAR(32));
INSERT INTO s1.t2 VALUES ('abc'), ('DEF'), ('Ghi'), ('ghI');
SELECT I FROM s1.t2 ORDER BY i;
SHOW CREATE TABLE s1.t2;
DROP TABLE s1.t1;
DROP SCHEMA s1;
CREATE SCHEMA s1;
CREATE TABLE s1.t1(i VARCHAR(32)) ENGINE MYISAM;
INSERT INTO s1.t1 VALUES ('abc'), ('DEF'), ('Ghi'), ('ghI');
SELECT i FROM s1.t1 ORDER BY i;
FLUSH TABLES WITH READ LOCK;
UNLOCK TABLES;
DROP TABLE s1.t1;
DROP SCHEMA s1;
CREATE SCHEMA s1;
IMPORT TABLE FROM 's1/t1*.sdi';
SELECT i FROM s1.t1 ORDER BY i;
DROP TABLE s1.t1;
DROP SCHEMA s1;
CREATE TABLE T_CASE(i INT) ENGINE MYISAM;
INSERT INTO T_CASE VALUES (1), (3), (5);
SELECT * FROM T_CASE ORDER BY i;
FLUSH TABLES WITH READ LOCK;
UNLOCK TABLES;
DROP TABLE T_CASE;
opendir(TMP, "$ENV{'MYSQL_TMP_DIR'}/export");
chdir "$ENV{'MYSQL_TMP_DIR'}/export";
while ($_= readdir(TMP))  if (/(.+)_\d+\.sdi/)  {    my $b= lc($1);
    rename $_, "${b}.sdi";
    next;
  }  if (/(.+)\.MYD/)  {    my $b= lc($1);
    rename $_, "${b}.MYD";
    next;
  }  if (/(.+)\.MYI/)  {    my $b= lc($1);
    rename $_, "${b}.MYI";
  }closedir(TMP);
open(T1, "t_case.sdi");
open(T1_, ">t_case_.sdi");
while (<T1>)  s/T_CASE/t_case/g;
  print T1_ $_;
close(T1);
close(T1_);
rename "t_case_.sdi", "t_case.sdi";
EOFIMPORT TABLE FROM 't_case.sdi';
SELECT i FROM t_case ORDER BY i;
DROP TABLE t_case;
write_file $BOOTSTRAP_SQL;
  CREATE SCHEMA test;
EOFIMPORT TABLE FROM 't_case.sdi';
SELECT i FROM t_case ORDER BY i;
DROP TABLE t_case;
CREATE TABLE t1 (i INT DEFAULT 42, dt DATETIME(3) DEFAULT CURRENT_TIMESTAMP(3),                 de DECIMAL(10,2), j INT GENERATED ALWAYS AS (42+i)) ENGINE=MYISAM;
SHOW CREATE TABLE t1;
INSERT INTO t1(dt,de) VALUES ('2017-03-28 18:48:01', 1.1),                             ('2017-03-28 18:48:02', 1.2),                             ('2017-03-28 18:48:03', 1.5);
SELECT * FROM t1;
FLUSH TABLES WITH READ LOCK;
UNLOCK TABLES;
DROP TABLE t1;
IMPORT TABLE FROM 't1_*.sdi';
SHOW CREATE TABLE t1;
SELECT * FROM t1;
DROP TABLE t1;
START TRANSACTION WITH CONSISTENT SNAPSHOT;
IMPORT TABLE FROM '';
CREATE TABLE t1 (i INT) ENGINE=MYISAM;
FLUSH TABLES WITH READ LOCK;
UNLOCK TABLES;
DROP TABLE t1;
SET SESSION sql_require_primary_key= ON;
IMPORT TABLE FROM 't1_*.sdi';
SET SESSION sql_require_primary_key= OFF;
CREATE TABLE t1 (f1 INT CHECK (f1 < 10)) ENGINE=MyISAM;
DROP TABLE t1;
IMPORT TABLE FROM 'test/t1*.sdi';
SHOW CREATE TABLE t1;
DROP TABLE t1;
