disable_warnings;
disable_query_log;
INSERT IGNORE INTO mysql.user (host, user) VALUES ('localhost','');
FLUSH PRIVILEGES;
enable_query_log;
enable_warnings;
disable_warnings;
disable_query_log;
DELETE FROM mysql.user where host='localhost' and user='';
FLUSH PRIVILEGES;
enable_query_log;
enable_warnings;
perl;
    use strict;
    my $search_file =           $ENV{'SEARCH_FILE'}           or die "SEARCH_FILE not set";
    my $search_pattern =        $ENV{'SEARCH_PATTERN'}        or die "SEARCH_PATTERN not set";
    my $search_echo =           $ENV{'SEARCH_ECHO'}     || "NONE";
    my $ignore_pattern =        $ENV{'IGNORE_PATTERN'}  || "";
    my $search_echo_ctx =       $ENV{'SEARCH_ECHO_CTX'} || 0;
    open(FILE, "< $search_file") or die("Unable to open '$search_file': $!\n");
    # We include the current line and 'n' previous lines in its context    # as a FIFO queue i.e., oldest entries in the queue are removed when    # new lines are read from the file.    my @context = (undef) x ($search_echo_ctx + 1);
    my $line;
    my $flag = 0;
    my $output = "";
    # Read the file line by line    while ($line = <FILE>)    {        my $cur_lineno = $.;
        my $file_pos = tell(FILE);
        if ($line =~ /^CURRENT_TEST: /)        {            $output = "";
            $flag = 0;
            @context = (undef) x ($search_echo_ctx + 1);
        }        # Context stored as a sliding window of size 'n' lines        shift @context;
        push  @context, $line;
        if ($line =~ /$search_pattern/)        {            if (!(length $ignore_pattern) or !($line =~ /$ignore_pattern/))            {                # Line matches the specified pattern                $flag = 1;
                if ($search_echo eq 'FIRST')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    print_succeeding_n_lines($search_echo_ctx, $cur_lineno)                      if ($search_echo_ctx > 0);
                    last;
                }                elsif ($search_echo eq 'ALL')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    if ($search_echo_ctx > 0)                    {                        print_succeeding_n_lines($search_echo_ctx, $cur_lineno);
                        # Return to current file position after reading 'n'                        # succeeding lines                        seek(FILE, $file_pos, 0);
                        $. = $cur_lineno;
                        # Separate each matching line                        $output .= "                    }                }            }        }    }    print $output;
    if ($flag == 1)    {        print "Pattern \"$search_pattern\" found\n";
    }    else    {        print "Pattern \"$search_pattern\" not found\n";
    }    close(FILE);
    sub print_current_and_previous_n_lines()    {        my ($search_echo_ctx, $cur_lineno)= @_;
        my $start_lineno= $cur_lineno - $search_echo_ctx;
        $cur_lineno= $start_lineno > 0 ? $start_lineno: 1;
        for my $ctx_line (@context)        {            next if not defined $ctx_line;
            $output .= "$cur_lineno: $ctx_line";
            $cur_lineno++;
        }    }    sub print_succeeding_n_lines()    {        # Read the next 'n' lines from the file (excluding the current        # line) and print them        my ($search_echo_ctx, $cur_lineno)= @_;
        my $end_lineno= $cur_lineno + $search_echo_ctx;
        while ($line= <FILE>)        {            last if ($. > $end_lineno);
            $output .= "$.: $line";
        }    }EOFperl;
    use strict;
    my $search_file =           $ENV{'SEARCH_FILE'}           or die "SEARCH_FILE not set";
    my $search_pattern =        $ENV{'SEARCH_PATTERN'}        or die "SEARCH_PATTERN not set";
    my $search_echo =           $ENV{'SEARCH_ECHO'}     || "NONE";
    my $ignore_pattern =        $ENV{'IGNORE_PATTERN'}  || "";
    my $search_echo_ctx =       $ENV{'SEARCH_ECHO_CTX'} || 0;
    open(FILE, "< $search_file") or die("Unable to open '$search_file': $!\n");
    # We include the current line and 'n' previous lines in its context    # as a FIFO queue i.e., oldest entries in the queue are removed when    # new lines are read from the file.    my @context = (undef) x ($search_echo_ctx + 1);
    my $line;
    my $flag = 0;
    my $output = "";
    # Read the file line by line    while ($line = <FILE>)    {        my $cur_lineno = $.;
        my $file_pos = tell(FILE);
        if ($line =~ /^CURRENT_TEST: /)        {            $output = "";
            $flag = 0;
            @context = (undef) x ($search_echo_ctx + 1);
        }        # Context stored as a sliding window of size 'n' lines        shift @context;
        push  @context, $line;
        if ($line =~ /$search_pattern/)        {            if (!(length $ignore_pattern) or !($line =~ /$ignore_pattern/))            {                # Line matches the specified pattern                $flag = 1;
                if ($search_echo eq 'FIRST')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    print_succeeding_n_lines($search_echo_ctx, $cur_lineno)                      if ($search_echo_ctx > 0);
                    last;
                }                elsif ($search_echo eq 'ALL')                {                    print_current_and_previous_n_lines($search_echo_ctx,                                                       $cur_lineno);
                    if ($search_echo_ctx > 0)                    {                        print_succeeding_n_lines($search_echo_ctx, $cur_lineno);
                        # Return to current file position after reading 'n'                        # succeeding lines                        seek(FILE, $file_pos, 0);
                        $. = $cur_lineno;
                        # Separate each matching line                        $output .= "                    }                }            }        }    }    print $output;
    if ($flag == 1)    {        print "Pattern \"$search_pattern\" found\n";
    }    else    {        print "Pattern \"$search_pattern\" not found\n";
    }    close(FILE);
    sub print_current_and_previous_n_lines()    {        my ($search_echo_ctx, $cur_lineno)= @_;
        my $start_lineno= $cur_lineno - $search_echo_ctx;
        $cur_lineno= $start_lineno > 0 ? $start_lineno: 1;
        for my $ctx_line (@context)        {            next if not defined $ctx_line;
            $output .= "$cur_lineno: $ctx_line";
            $cur_lineno++;
        }    }    sub print_succeeding_n_lines()    {        # Read the next 'n' lines from the file (excluding the current        # line) and print them        my ($search_echo_ctx, $cur_lineno)= @_;
        my $end_lineno= $cur_lineno + $search_echo_ctx;
        while ($line= <FILE>)        {            last if ($. > $end_lineno);
            $output .= "$.: $line";
        }    }EOF   let $wait_counter= `SELECT $wait_timeout * 10`;
while ($wait_counter)   let $current_sessions= query_get_value(SHOW GLOBAL STATUS LIKE 'Threads_connected', Value, 1);
   let $success= `SELECT $current_sessions <= $count_sessions`;
   if ($success)   {      let $wait_counter= 0;
   }   if (!$success)   {      sleep 0.1;
      dec $wait_counter;
   }         SHOW PROCESSLIST;
   connect (con0,localhost,root,,);
connection con0;
select hex(@a);
connect (con1,localhost,user_1,,);
connection con1;
select hex(@a);
connection con0;
set global init_connect="set @a=2;set @b=3";
connect (con2,localhost,user_1,,);
connection con2;
select @a, @b;
connection con0;
set GLOBAL init_connect=DEFAULT;
connect (con3,localhost,user_1,,);
connection con3;
select @a;
connection con0;
set global init_connect="drop table if exists t1; create table t1(a char(10));\insert into t1 values ('\0');insert into t1 values('abc')";
connect (con4,localhost,user_1,,);
connection con4;
select hex(a) from t1;
connection con0;
set GLOBAL init_connect="adsfsdfsdfs";
connect (con5,localhost,user_1,,);
connection con5;
select @a;
select @a;
connection con0;
drop table t1;
disconnect con1;
disconnect con2;
disconnect con3;
disconnect con4;
disconnect con5;
create table t1 (x int);
insert into t1 values (3), (5), (7);
create table t2 (y int);
create user mysqltest1@localhost;
grant all privileges on test.* to mysqltest1@localhost;
set global init_connect="create procedure p1() select * from t1";
connect (con1,localhost,mysqltest1,,);
connection con1;
call p1();
drop procedure p1;
connection con0;
disconnect con1;
set global init_connect="create procedure p1(x int)\begin\  select count(*) from t1;\  select * from t1;\  set @x = x;
end";
connect (con1,localhost,mysqltest1,,);
connection con1;
call p1(42);
select @x;
connection con0;
disconnect con1;
set global init_connect="call p1(4711)";
connect (con1,localhost,mysqltest1,,);
connection con1;
select @x;
connection con0;
disconnect con1;
set global init_connect="drop procedure if exists p1";
connect (con1,localhost,mysqltest1,,);
connection con1;
call p1();
connection con0;
disconnect con1;
delimiter |;
create procedure p1(out sum int)begin  declare n int default 0;
  declare c cursor for select * from t1;
  declare exit handler for not found    begin      close c;
      set sum = n;
    end;
  open c;
  loop    begin      declare x int;
      fetch c into x;
      if x > 3 then        set n = n + x;
      end if;
    end;
  end loop;
end|delimiter ;|set global init_connect="call p1(@sum)";
connect (con1,localhost,mysqltest1,,);
connection con1;
select @sum;
connection con0;
disconnect con1;
drop procedure p1;
delimiter |;
create procedure p1(tbl char(10), v int)begin  set @s = concat('insert into ', tbl, ' values (?)');
  set @v = v;
  prepare stmt1 from @s;
  execute stmt1 using @v;
  deallocate prepare stmt1;
end|delimiter ;|set global init_connect="call p1('t1', 11)";
connect (con1,localhost,mysqltest1,,);
connection con1;
select * from t1;
connection con0;
disconnect con1;
drop procedure p1;
delimiter |;
create function f1() returns intbegin  declare n int;
  select count(*) into n from t1;
  return n;
end|delimiter ;|set global init_connect="set @x = f1()";
connect (con1,localhost,mysqltest1,,);
connection con1;
select @x;
connection con0;
disconnect con1;
set global init_connect="create view v1 as select f1()";
connect (con1,localhost,mysqltest1,,);
connection con1;
select * from v1;
connection con0;
disconnect con1;
set global init_connect="drop view v1";
connect (con1,localhost,mysqltest1,,);
connection con1;
select * from v1;
connection con0;
disconnect con1;
drop function f1;
create trigger trg1  after insert on t2  for each row  insert into t1 values (new.y);
set global init_connect="insert into t2 values (13), (17), (19)";
connect (con1,localhost,mysqltest1,,);
connection con1;
select * from t1;
connection default;
disconnect con0;
disconnect con1;
drop trigger trg1;
revoke all privileges, grant option from mysqltest1@localhost;
drop user mysqltest1@localhost;
drop table t1, t2;
CREATE USER user1@localhost PASSWORD EXPIRE;
CREATE USER ''@localhost;
UPDATE mysql.user SET password_expired='Y' WHERE user='' AND host='localhost';
SELECT user, password_expired FROM mysql.user WHERE user='' AND host='localhost';
FLUSH PRIVILEGES;
SET GLOBAL init_connect="set @a=2;";
connect (con1,localhost,user1,,);
connection con1;
SELECT @a;
SET PASSWORD = 'abc';
SELECT @a;
connection default;
disconnect con1;
connect (con2,localhost,anonymous,,);
connection con2;
SELECT @a;
connection default;
disconnect con2;
DROP USER user1@localhost;
DROP USER ''@localhost;
set global init_connect="set @a='a\\0c'";
