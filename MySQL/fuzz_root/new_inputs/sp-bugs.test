CREATE SCHEMA testdb;
USE testdb;
DELIMITER |;
CREATE FUNCTION f2 () RETURNS INTEGERBEGIN   DECLARE CONTINUE HANDLER FOR SQLSTATE '42000' SET @aux = 1;
   RETURN f_not_exists () ;
END|CREATE PROCEDURE p3 ( arg1 VARCHAR(32) )BEGIN   CALL p_not_exists ( );
END|DELIMITER ;|CALL p3 ( f2 () );
DROP SCHEMA testdb;
CREATE SCHEMA testdb;
USE testdb;
DELIMITER |;
CREATE FUNCTION f2 () RETURNS INTEGERBEGIN   DECLARE CONTINUE HANDLER FOR SQLSTATE '42000' SET @aux = 1;
   RETURN f_not_exists () ;
END|CREATE PROCEDURE p3 ( arg2 INTEGER )BEGIN   CALL p_not_exists ( );
END|DELIMITER ;|CALL p3 ( f2 () );
DROP SCHEMA testdb;
CREATE SCHEMA testdb;
USE testdb;
DELIMITER |;
CREATE FUNCTION f2 () RETURNS INTEGERBEGIN   DECLARE CONTINUE HANDLER FOR SQLSTATE '42000' SET @aux = 1;
   RETURN f_not_exists () ;
END|DELIMITER ;|SELECT f2 ();
DROP SCHEMA testdb;
USE test;
DROP TABLE IF EXISTS t1;
DROP TRIGGER IF EXISTS tr1;
DROP PROCEDURE IF EXISTS p1;
CREATE TABLE t1 (f1 INTEGER);
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW SET @aux = 1;
CREATE PROCEDURE p1 () DROP TRIGGER tr1;
CALL p1 ();
CALL p1 ();
DROP TABLE t1;
DROP PROCEDURE p1;
DROP TABLE IF EXISTS t1;
DROP TRIGGER IF EXISTS tr1;
DROP PROCEDURE IF EXISTS p1;
CREATE TABLE t1 (f1 INTEGER);
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW SET @aux = 1;
CREATE PROCEDURE p1 () DROP TRIGGER tr1;
CALL p1 ();
CALL p1 ();
DROP TABLE t1;
DROP PROCEDURE p1;
SET @@SQL_MODE = 'STRICT_ALL_TABLES';
DROP DATABASE IF EXISTS db1;
CREATE DATABASE db1;
USE db1;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (c1 int NOT NULL PRIMARY KEY);
INSERT INTO t1 VALUES (1);
DELIMITER $$;
CREATE FUNCTION f1 (	some_value intRETURNS smallintDETERMINISTICBEGIN	INSERT INTO t1 SET c1 = some_value;
        RETURN(LAST_INSERT_ID());
END$$DELIMITER ;$$DROP DATABASE IF EXISTS db2;
CREATE DATABASE db2;
USE db2;
SELECT DATABASE();
SELECT db1.f1(1);
SELECT DATABASE();
USE test;
DROP FUNCTION db1.f1;
DROP TABLE db1.t1;
DROP DATABASE db1;
DROP DATABASE db2;
DROP DATABASE IF EXISTS testdb;
CREATE DATABASE testdb;
USE testdb;
CREATE TABLE t1 (id1 INT PRIMARY KEY);
DELIMITER $;
CREATE PROCEDURE `p1`()BEGIN    CREATE TABLE IF NOT EXISTS t2(id INT PRIMARY KEY,    CONSTRAINT FK FOREIGN KEY (id) REFERENCES t1( id1 ));
END$DELIMITER ;$CALL p1();
CALL p1(); DROP DATABASE testdb;
USE test;
CREATE FUNCTION sf() RETURNS BLOB RETURN "";
SELECT sf();
DROP FUNCTION sf;
SET @@SQL_MODE = '';
DELIMITER $;
CREATE FUNCTION testf_bug11763507() RETURNS INTBEGIN    RETURN 0;
ENDCREATE PROCEDURE testp_bug11763507()BEGIN    SELECT "PROCEDURE testp_bug11763507";
ENDDELIMITER ;$SELECT testf_bug11763507();
SELECT TESTF_bug11763507();
SHOW FUNCTION STATUS LIKE  'testf_bug11763507';
SHOW FUNCTION STATUS WHERE NAME='testf_bug11763507';
SHOW FUNCTION STATUS LIKE  'TESTF_bug11763507';
SHOW FUNCTION STATUS WHERE NAME='TESTF_bug11763507';
SHOW CREATE FUNCTION testf_bug11763507;
SHOW CREATE FUNCTION TESTF_bug11763507;
CALL testp_bug11763507();
CALL TESTP_bug11763507();
SHOW PROCEDURE STATUS LIKE  'testp_bug11763507';
SHOW PROCEDURE STATUS WHERE NAME='testp_bug11763507';
SHOW PROCEDURE STATUS LIKE  'TESTP_bug11763507';
SHOW PROCEDURE STATUS WHERE NAME='TESTP_bug11763507';
SHOW CREATE PROCEDURE testp_bug11763507;
SHOW CREATE PROCEDURE TESTP_bug11763507;
SELECT specific_name FROM INFORMATION_SCHEMA.ROUTINES WHERE specific_name LIKE 'testf_bug11763507';
SELECT specific_name FROM INFORMATION_SCHEMA.ROUTINES WHERE specific_name LIKE 'TESTF_bug11763507';
SELECT specific_name FROM INFORMATION_SCHEMA.ROUTINES WHERE specific_name='testf_bug11763507';
SELECT specific_name FROM INFORMATION_SCHEMA.ROUTINES WHERE specific_name='TESTF_bug11763507';
DROP PROCEDURE testp_bug11763507;
DROP FUNCTION testf_bug11763507;
SET sql_mode='NO_ENGINE_SUBSTITUTION';
delimiter |;
CREATE FUNCTION f1(arg TINYINT UNSIGNED) RETURNS TINYINTBEGIN  RETURN abs('1abcd');
END|delimiter ;|SELECT f1(-25);
SELECT f1(25);
SET sql_mode=default;
SELECT f1(-25);
SELECT f1(10);
DROP FUNCTION f1;
SET sql_mode='NO_ENGINE_SUBSTITUTION';
delimiter |;
CREATE PROCEDURE f1(IN arg TINYINT UNSIGNED)BEGIN  DECLARE arg1 TINYINT;
  select abs('1abcd') into arg;
END|delimiter ;|CALL f1(-25);
CALL f1(25);
SET sql_mode=default;
CALL f1(-25);
CALL f1(10);
DROP PROCEDURE f1;
SELECT SUBTIME('2006-07-16' , '05:05:02.040778');
SELECT abs('1bcd');
delimiter |;
CREATE PROCEDURE sp1()BEGINSELECT SUBTIME('2006-07-16' , '05:05:02.040778');
END|CREATE PROCEDURE sp2()BEGINDECLARE v1 TINYINT DEFAULT 450000;
END|delimiter ;|CALL sp1();
CALL sp2();
DROP PROCEDURE sp1;
DROP PROCEDURE sp2;
CREATE FUNCTION fn1(arg TINYINT UNSIGNED) RETURNS float deterministic RETURN abs('1abcd');
delimiter |;
CREATE FUNCTION fn2() RETURNS tinyintBEGINDECLARE v1 TINYINT DEFAULT 450000;
RETURN v1;
END|delimiter ;|SELECT fn1(25);
SELECT fn1(-25);
SELECT fn2();
SET sql_mode='NO_ENGINE_SUBSTITUTION';
SELECT fn1(-25);
DROP FUNCTION fn1;
DROP FUNCTION fn2;
CREATE FUNCTION fn1() RETURNS float deterministic RETURN floor('1.1a');
SET sql_mode=default;
CREATE TABLE t1(a INT);
CREATE FUNCTION fn2() RETURNS float deterministic RETURN floor('1.1a');
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW SET @a=fn2();
INSERT INTO t1 VALUES(1);
DROP TRIGGER tr1;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW SET @a=fn1();
INSERT INTO t1 VALUES(1);
DROP FUNCTION fn1;
DROP FUNCTION fn2;
DROP TRIGGER tr1;
DROP TABLE t1;
SET sql_mode=traditional;
SELECT 1/0;
SET sql_mode='';
delimiter |;
CREATE PROCEDURE proc_c()BEGIN  DECLARE div_zero INTEGER;
  SET SQL_MODE='TRADITIONAL';
  SELECT 1/0;
END|delimiter ;|CALL proc_c();
DROP PROCEDURE proc_c;
SET sql_mode=traditional;
delimiter |;
CREATE FUNCTION fn1() RETURNS TINYINTBEGINSET  @x=floor('1a');
RETURN 1;
END|delimiter ;|SELECT fn1();
DROP FUNCTION fn1;
SET sql_mode= default;
CREATE FUNCTION crc(_text TEXT) RETURNS BIGINT(20) UNSIGNED DETERMINISTIC  RETURN CONV(LEFT(MD5(_text),16),16,10);
CREATE TABLE t1 (  id bigint(20) UNSIGNED NOT NULL);
INSERT INTO t1 (id) VALUES (crc('photos'));
INSERT INTO t1 (id) VALUES (crc('photos1'));
ALTER TABLE t1 ADD INDEX idx (id);
SELECT * FROM t1 FORCE INDEX (idx) WHERE (id = crc('photos')) AND TRUE;
SELECT * FROM t1 IGNORE INDEX (idx) WHERE (id = crc('photos')) AND TRUE;
DROP FUNCTION crc;
DROP TABLE t1;
CREATE TABLE t1(a INTEGER, b INTEGER);
DELIMITER |;
CREATE TRIGGER tr1 AFTER INSERT ON t1 FOR EACH ROWBEGIN     CALL proc(NEW.a,NEW.b);
END |CREATE PROCEDURE proc(IN aa INTEGER)BEGINEND |DELIMITER ;|INSERT INTO t1 VALUES (1,10);
DROP PROCEDURE proc;
DROP TABLE t1;
SET NAMES utf8;
CREATE PROCEDURE cafe() BEGIN END;
CREATE PROCEDURE café() BEGIN END;
CREATE PROCEDURE CAFE() BEGIN END;
DROP PROCEDURE CaFé;
CREATE PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_e() BEGIN END;
CREATE PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é() BEGIN END;
CREATE PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_E() BEGIN END;
SHOW CREATE PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é;
DROP PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é;
CREATE FUNCTION cafe() RETURNS INT return 15081947;
CREATE FUNCTION café() RETURNS INT return 15081947;
CREATE FUNCTION CAFE() RETURNS INT return 15081947;
SHOW CREATE FUNCTION CaFé;
DROP FUNCTION CaFé;
CREATE FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_e() RETURNS INT return 15081947;
CREATE FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é() RETURNS INT return 15081947;
CREATE FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_E() RETURNS INT return 15081947;
SHOW CREATE FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é;
DROP FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é;
SET NAMES default;
DELIMITER //;
CREATE FUNCTION myfunc(dt VARCHAR(50)) RETURNS VARCHAR(32) DETERMINISTICBEGIN  DECLARE dt_local TIMESTAMP(0);
  SET dt_local = dt;
  RETURN CONCAT(UNIX_TIMESTAMP(dt_local));
END; //DELIMITER ;//SELECT myfunc('2019-01-01 00:00:00');
SELECT myfunc('2019-01-01 00:00:71');
SELECT myfunc('2019-01-01 00:00:00');
DROP FUNCTION myfunc;
PREPARE stmt FROM 'SELECT CONCAT(UNIX_TIMESTAMP(?))';
SET @var = '2019-01-01 00:00:00';
EXECUTE stmt USING @var;
SET @var = '2019-01-01 00:00:71';
EXECUTE stmt USING @var;
SET @var = '2019-01-01 00:00:00';
EXECUTE stmt USING @var;
DEALLOCATE PREPARE stmt;
DELIMITER |;
CREATE FUNCTION func1() RETURNS INTBEGIN  DECLARE EXIT HANDLER FOR SQLEXCEPTION RETURN NULL;
  SELECT * INTO @a FROM fake_table;
RETURN 1;
END|CREATE FUNCTION func2() RETURNS INTBEGIN  DECLARE EXIT HANDLER FOR SQLEXCEPTION RETURN NULL;
  SELECT * INTO @a FROM fake_db.fake_table;
RETURN 1;
END|DELIMITER ;|SELECT func1();
SELECT func2();
DROP FUNCTION func1;
DROP FUNCTION func2;
DELIMITER $;
CREATE PROCEDURE p()BEGIN  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN END;
  SET @x = 0;
  WHILE @x < 2 DO    CASE((SELECT q > 1)) WHEN 1 THEN SELECT 1; END CASE;
    SET @x = @x + 1;
  END WHILE;
END$DELIMITER ;$CALL p();
DROP PROCEDURE p;
CREATE SCHEMA testdb;
USE testdb;
DELIMITER |;
CREATE FUNCTION f2 () RETURNS INTEGERBEGIN   DECLARE CONTINUE HANDLER FOR SQLSTATE '42000' SET @aux = 1;
   RETURN f_not_exists () ;
END|CREATE PROCEDURE p3 ( arg1 VARCHAR(32) )BEGIN   CALL p_not_exists ( );
END|DELIMITER ;|CALL p3 ( f2 () );
DROP SCHEMA testdb;
CREATE SCHEMA testdb;
USE testdb;
DELIMITER |;
CREATE FUNCTION f2 () RETURNS INTEGERBEGIN   DECLARE CONTINUE HANDLER FOR SQLSTATE '42000' SET @aux = 1;
   RETURN f_not_exists () ;
END|CREATE PROCEDURE p3 ( arg2 INTEGER )BEGIN   CALL p_not_exists ( );
END|DELIMITER ;|CALL p3 ( f2 () );
DROP SCHEMA testdb;
CREATE SCHEMA testdb;
USE testdb;
DELIMITER |;
CREATE FUNCTION f2 () RETURNS INTEGERBEGIN   DECLARE CONTINUE HANDLER FOR SQLSTATE '42000' SET @aux = 1;
   RETURN f_not_exists () ;
END|DELIMITER ;|SELECT f2 ();
DROP SCHEMA testdb;
USE test;
DROP TABLE IF EXISTS t1;
DROP TRIGGER IF EXISTS tr1;
DROP PROCEDURE IF EXISTS p1;
CREATE TABLE t1 (f1 INTEGER);
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW SET @aux = 1;
CREATE PROCEDURE p1 () DROP TRIGGER tr1;
CALL p1 ();
CALL p1 ();
DROP TABLE t1;
DROP PROCEDURE p1;
DROP TABLE IF EXISTS t1;
DROP TRIGGER IF EXISTS tr1;
DROP PROCEDURE IF EXISTS p1;
CREATE TABLE t1 (f1 INTEGER);
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW SET @aux = 1;
CREATE PROCEDURE p1 () DROP TRIGGER tr1;
CALL p1 ();
CALL p1 ();
DROP TABLE t1;
DROP PROCEDURE p1;
SET @@SQL_MODE = 'STRICT_ALL_TABLES';
DROP DATABASE IF EXISTS db1;
CREATE DATABASE db1;
USE db1;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (c1 int NOT NULL PRIMARY KEY);
INSERT INTO t1 VALUES (1);
DELIMITER $$;
CREATE FUNCTION f1 (	some_value intRETURNS smallintDETERMINISTICBEGIN	INSERT INTO t1 SET c1 = some_value;
        RETURN(LAST_INSERT_ID());
END$$DELIMITER ;$$DROP DATABASE IF EXISTS db2;
CREATE DATABASE db2;
USE db2;
SELECT DATABASE();
SELECT db1.f1(1);
SELECT DATABASE();
USE test;
DROP FUNCTION db1.f1;
DROP TABLE db1.t1;
DROP DATABASE db1;
DROP DATABASE db2;
DROP DATABASE IF EXISTS testdb;
CREATE DATABASE testdb;
USE testdb;
CREATE TABLE t1 (id1 INT PRIMARY KEY);
DELIMITER $;
CREATE PROCEDURE `p1`()BEGIN    CREATE TABLE IF NOT EXISTS t2(id INT PRIMARY KEY,    CONSTRAINT FK FOREIGN KEY (id) REFERENCES t1( id1 ));
END$DELIMITER ;$CALL p1();
CALL p1(); DROP DATABASE testdb;
USE test;
CREATE FUNCTION sf() RETURNS BLOB RETURN "";
SELECT sf();
DROP FUNCTION sf;
SET @@SQL_MODE = '';
DELIMITER $;
CREATE FUNCTION testf_bug11763507() RETURNS INTBEGIN    RETURN 0;
ENDCREATE PROCEDURE testp_bug11763507()BEGIN    SELECT "PROCEDURE testp_bug11763507";
ENDDELIMITER ;$SELECT testf_bug11763507();
SELECT TESTF_bug11763507();
SHOW FUNCTION STATUS LIKE  'testf_bug11763507';
SHOW FUNCTION STATUS WHERE NAME='testf_bug11763507';
SHOW FUNCTION STATUS LIKE  'TESTF_bug11763507';
SHOW FUNCTION STATUS WHERE NAME='TESTF_bug11763507';
SHOW CREATE FUNCTION testf_bug11763507;
SHOW CREATE FUNCTION TESTF_bug11763507;
CALL testp_bug11763507();
CALL TESTP_bug11763507();
SHOW PROCEDURE STATUS LIKE  'testp_bug11763507';
SHOW PROCEDURE STATUS WHERE NAME='testp_bug11763507';
SHOW PROCEDURE STATUS LIKE  'TESTP_bug11763507';
SHOW PROCEDURE STATUS WHERE NAME='TESTP_bug11763507';
SHOW CREATE PROCEDURE testp_bug11763507;
SHOW CREATE PROCEDURE TESTP_bug11763507;
SELECT specific_name FROM INFORMATION_SCHEMA.ROUTINES WHERE specific_name LIKE 'testf_bug11763507';
SELECT specific_name FROM INFORMATION_SCHEMA.ROUTINES WHERE specific_name LIKE 'TESTF_bug11763507';
SELECT specific_name FROM INFORMATION_SCHEMA.ROUTINES WHERE specific_name='testf_bug11763507';
SELECT specific_name FROM INFORMATION_SCHEMA.ROUTINES WHERE specific_name='TESTF_bug11763507';
DROP PROCEDURE testp_bug11763507;
DROP FUNCTION testf_bug11763507;
SET sql_mode='NO_ENGINE_SUBSTITUTION';
delimiter |;
CREATE FUNCTION f1(arg TINYINT UNSIGNED) RETURNS TINYINTBEGIN  RETURN abs('1abcd');
END|delimiter ;|SELECT f1(-25);
SELECT f1(25);
SET sql_mode=default;
SELECT f1(-25);
SELECT f1(10);
DROP FUNCTION f1;
SET sql_mode='NO_ENGINE_SUBSTITUTION';
delimiter |;
CREATE PROCEDURE f1(IN arg TINYINT UNSIGNED)BEGIN  DECLARE arg1 TINYINT;
  select abs('1abcd') into arg;
END|delimiter ;|CALL f1(-25);
CALL f1(25);
SET sql_mode=default;
CALL f1(-25);
CALL f1(10);
DROP PROCEDURE f1;
SELECT SUBTIME('2006-07-16' , '05:05:02.040778');
SELECT abs('1bcd');
delimiter |;
CREATE PROCEDURE sp1()BEGINSELECT SUBTIME('2006-07-16' , '05:05:02.040778');
END|CREATE PROCEDURE sp2()BEGINDECLARE v1 TINYINT DEFAULT 450000;
END|delimiter ;|CALL sp1();
CALL sp2();
DROP PROCEDURE sp1;
DROP PROCEDURE sp2;
CREATE FUNCTION fn1(arg TINYINT UNSIGNED) RETURNS float deterministic RETURN abs('1abcd');
delimiter |;
CREATE FUNCTION fn2() RETURNS tinyintBEGINDECLARE v1 TINYINT DEFAULT 450000;
RETURN v1;
END|delimiter ;|SELECT fn1(25);
SELECT fn1(-25);
SELECT fn2();
SET sql_mode='NO_ENGINE_SUBSTITUTION';
SELECT fn1(-25);
DROP FUNCTION fn1;
DROP FUNCTION fn2;
CREATE FUNCTION fn1() RETURNS float deterministic RETURN floor('1.1a');
SET sql_mode=default;
CREATE TABLE t1(a INT);
CREATE FUNCTION fn2() RETURNS float deterministic RETURN floor('1.1a');
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW SET @a=fn2();
INSERT INTO t1 VALUES(1);
DROP TRIGGER tr1;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW SET @a=fn1();
INSERT INTO t1 VALUES(1);
DROP FUNCTION fn1;
DROP FUNCTION fn2;
DROP TRIGGER tr1;
DROP TABLE t1;
SET sql_mode=traditional;
SELECT 1/0;
SET sql_mode='';
delimiter |;
CREATE PROCEDURE proc_c()BEGIN  DECLARE div_zero INTEGER;
  SET SQL_MODE='TRADITIONAL';
  SELECT 1/0;
END|delimiter ;|CALL proc_c();
DROP PROCEDURE proc_c;
SET sql_mode=traditional;
delimiter |;
CREATE FUNCTION fn1() RETURNS TINYINTBEGINSET  @x=floor('1a');
RETURN 1;
END|delimiter ;|SELECT fn1();
DROP FUNCTION fn1;
SET sql_mode= default;
CREATE FUNCTION crc(_text TEXT) RETURNS BIGINT(20) UNSIGNED DETERMINISTIC  RETURN CONV(LEFT(MD5(_text),16),16,10);
CREATE TABLE t1 (  id bigint(20) UNSIGNED NOT NULL);
INSERT INTO t1 (id) VALUES (crc('photos'));
INSERT INTO t1 (id) VALUES (crc('photos1'));
ALTER TABLE t1 ADD INDEX idx (id);
SELECT * FROM t1 FORCE INDEX (idx) WHERE (id = crc('photos')) AND TRUE;
SELECT * FROM t1 IGNORE INDEX (idx) WHERE (id = crc('photos')) AND TRUE;
DROP FUNCTION crc;
DROP TABLE t1;
CREATE TABLE t1(a INTEGER, b INTEGER);
DELIMITER |;
CREATE TRIGGER tr1 AFTER INSERT ON t1 FOR EACH ROWBEGIN     CALL proc(NEW.a,NEW.b);
END |CREATE PROCEDURE proc(IN aa INTEGER)BEGINEND |DELIMITER ;|INSERT INTO t1 VALUES (1,10);
DROP PROCEDURE proc;
DROP TABLE t1;
SET NAMES utf8;
CREATE PROCEDURE cafe() BEGIN END;
CREATE PROCEDURE café() BEGIN END;
CREATE PROCEDURE CAFE() BEGIN END;
DROP PROCEDURE CaFé;
CREATE PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_e() BEGIN END;
CREATE PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é() BEGIN END;
CREATE PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_E() BEGIN END;
SHOW CREATE PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é;
DROP PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é;
CREATE FUNCTION cafe() RETURNS INT return 15081947;
CREATE FUNCTION café() RETURNS INT return 15081947;
CREATE FUNCTION CAFE() RETURNS INT return 15081947;
SHOW CREATE FUNCTION CaFé;
DROP FUNCTION CaFé;
CREATE FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_e() RETURNS INT return 15081947;
CREATE FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é() RETURNS INT return 15081947;
CREATE FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_E() RETURNS INT return 15081947;
SHOW CREATE FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é;
DROP FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é;
SET NAMES default;
DELIMITER //;
CREATE FUNCTION myfunc(dt VARCHAR(50)) RETURNS VARCHAR(32) DETERMINISTICBEGIN  DECLARE dt_local TIMESTAMP(0);
  SET dt_local = dt;
  RETURN CONCAT(UNIX_TIMESTAMP(dt_local));
END; //DELIMITER ;//SELECT myfunc('2019-01-01 00:00:00');
SELECT myfunc('2019-01-01 00:00:71');
SELECT myfunc('2019-01-01 00:00:00');
DROP FUNCTION myfunc;
PREPARE stmt FROM 'SELECT CONCAT(UNIX_TIMESTAMP(?))';
SET @var = '2019-01-01 00:00:00';
EXECUTE stmt USING @var;
SET @var = '2019-01-01 00:00:71';
EXECUTE stmt USING @var;
SET @var = '2019-01-01 00:00:00';
EXECUTE stmt USING @var;
DEALLOCATE PREPARE stmt;
DELIMITER |;
CREATE FUNCTION func1() RETURNS INTBEGIN  DECLARE EXIT HANDLER FOR SQLEXCEPTION RETURN NULL;
  SELECT * INTO @a FROM fake_table;
RETURN 1;
END|CREATE FUNCTION func2() RETURNS INTBEGIN  DECLARE EXIT HANDLER FOR SQLEXCEPTION RETURN NULL;
  SELECT * INTO @a FROM fake_db.fake_table;
RETURN 1;
END|DELIMITER ;|SELECT func1();
SELECT func2();
DROP FUNCTION func1;
DROP FUNCTION func2;
DELIMITER $;
CREATE PROCEDURE p()BEGIN  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN END;
  SET @x = 0;
  WHILE @x < 2 DO    CASE((SELECT q > 1)) WHEN 1 THEN SELECT 1; END CASE;
    SET @x = @x + 1;
  END WHILE;
END$DELIMITER ;$CALL p();
DROP PROCEDURE p;
CREATE SCHEMA testdb;
USE testdb;
DELIMITER |;
CREATE FUNCTION f2 () RETURNS INTEGERBEGIN   DECLARE CONTINUE HANDLER FOR SQLSTATE '42000' SET @aux = 1;
   RETURN f_not_exists () ;
END|CREATE PROCEDURE p3 ( arg1 VARCHAR(32) )BEGIN   CALL p_not_exists ( );
END|DELIMITER ;|CALL p3 ( f2 () );
DROP SCHEMA testdb;
CREATE SCHEMA testdb;
USE testdb;
DELIMITER |;
CREATE FUNCTION f2 () RETURNS INTEGERBEGIN   DECLARE CONTINUE HANDLER FOR SQLSTATE '42000' SET @aux = 1;
   RETURN f_not_exists () ;
END|CREATE PROCEDURE p3 ( arg2 INTEGER )BEGIN   CALL p_not_exists ( );
END|DELIMITER ;|CALL p3 ( f2 () );
DROP SCHEMA testdb;
CREATE SCHEMA testdb;
USE testdb;
DELIMITER |;
CREATE FUNCTION f2 () RETURNS INTEGERBEGIN   DECLARE CONTINUE HANDLER FOR SQLSTATE '42000' SET @aux = 1;
   RETURN f_not_exists () ;
END|DELIMITER ;|SELECT f2 ();
DROP SCHEMA testdb;
USE test;
DROP TABLE IF EXISTS t1;
DROP TRIGGER IF EXISTS tr1;
DROP PROCEDURE IF EXISTS p1;
CREATE TABLE t1 (f1 INTEGER);
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW SET @aux = 1;
CREATE PROCEDURE p1 () DROP TRIGGER tr1;
CALL p1 ();
CALL p1 ();
DROP TABLE t1;
DROP PROCEDURE p1;
DROP TABLE IF EXISTS t1;
DROP TRIGGER IF EXISTS tr1;
DROP PROCEDURE IF EXISTS p1;
CREATE TABLE t1 (f1 INTEGER);
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW SET @aux = 1;
CREATE PROCEDURE p1 () DROP TRIGGER tr1;
CALL p1 ();
CALL p1 ();
DROP TABLE t1;
DROP PROCEDURE p1;
SET @@SQL_MODE = 'STRICT_ALL_TABLES';
DROP DATABASE IF EXISTS db1;
CREATE DATABASE db1;
USE db1;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (c1 int NOT NULL PRIMARY KEY);
INSERT INTO t1 VALUES (1);
DELIMITER $$;
CREATE FUNCTION f1 (	some_value intRETURNS smallintDETERMINISTICBEGIN	INSERT INTO t1 SET c1 = some_value;
        RETURN(LAST_INSERT_ID());
END$$DELIMITER ;$$DROP DATABASE IF EXISTS db2;
CREATE DATABASE db2;
USE db2;
SELECT DATABASE();
SELECT db1.f1(1);
SELECT DATABASE();
USE test;
DROP FUNCTION db1.f1;
DROP TABLE db1.t1;
DROP DATABASE db1;
DROP DATABASE db2;
DROP DATABASE IF EXISTS testdb;
CREATE DATABASE testdb;
USE testdb;
CREATE TABLE t1 (id1 INT PRIMARY KEY);
DELIMITER $;
CREATE PROCEDURE `p1`()BEGIN    CREATE TABLE IF NOT EXISTS t2(id INT PRIMARY KEY,    CONSTRAINT FK FOREIGN KEY (id) REFERENCES t1( id1 ));
END$DELIMITER ;$CALL p1();
CALL p1(); DROP DATABASE testdb;
USE test;
CREATE FUNCTION sf() RETURNS BLOB RETURN "";
SELECT sf();
DROP FUNCTION sf;
SET @@SQL_MODE = '';
DELIMITER $;
CREATE FUNCTION testf_bug11763507() RETURNS INTBEGIN    RETURN 0;
ENDCREATE PROCEDURE testp_bug11763507()BEGIN    SELECT "PROCEDURE testp_bug11763507";
ENDDELIMITER ;$SELECT testf_bug11763507();
SELECT TESTF_bug11763507();
SHOW FUNCTION STATUS LIKE  'testf_bug11763507';
SHOW FUNCTION STATUS WHERE NAME='testf_bug11763507';
SHOW FUNCTION STATUS LIKE  'TESTF_bug11763507';
SHOW FUNCTION STATUS WHERE NAME='TESTF_bug11763507';
SHOW CREATE FUNCTION testf_bug11763507;
SHOW CREATE FUNCTION TESTF_bug11763507;
CALL testp_bug11763507();
CALL TESTP_bug11763507();
SHOW PROCEDURE STATUS LIKE  'testp_bug11763507';
SHOW PROCEDURE STATUS WHERE NAME='testp_bug11763507';
SHOW PROCEDURE STATUS LIKE  'TESTP_bug11763507';
SHOW PROCEDURE STATUS WHERE NAME='TESTP_bug11763507';
SHOW CREATE PROCEDURE testp_bug11763507;
SHOW CREATE PROCEDURE TESTP_bug11763507;
SELECT specific_name FROM INFORMATION_SCHEMA.ROUTINES WHERE specific_name LIKE 'testf_bug11763507';
SELECT specific_name FROM INFORMATION_SCHEMA.ROUTINES WHERE specific_name LIKE 'TESTF_bug11763507';
SELECT specific_name FROM INFORMATION_SCHEMA.ROUTINES WHERE specific_name='testf_bug11763507';
SELECT specific_name FROM INFORMATION_SCHEMA.ROUTINES WHERE specific_name='TESTF_bug11763507';
DROP PROCEDURE testp_bug11763507;
DROP FUNCTION testf_bug11763507;
SET sql_mode='NO_ENGINE_SUBSTITUTION';
delimiter |;
CREATE FUNCTION f1(arg TINYINT UNSIGNED) RETURNS TINYINTBEGIN  RETURN abs('1abcd');
END|delimiter ;|SELECT f1(-25);
SELECT f1(25);
SET sql_mode=default;
SELECT f1(-25);
SELECT f1(10);
DROP FUNCTION f1;
SET sql_mode='NO_ENGINE_SUBSTITUTION';
delimiter |;
CREATE PROCEDURE f1(IN arg TINYINT UNSIGNED)BEGIN  DECLARE arg1 TINYINT;
  select abs('1abcd') into arg;
END|delimiter ;|CALL f1(-25);
CALL f1(25);
SET sql_mode=default;
CALL f1(-25);
CALL f1(10);
DROP PROCEDURE f1;
SELECT SUBTIME('2006-07-16' , '05:05:02.040778');
SELECT abs('1bcd');
delimiter |;
CREATE PROCEDURE sp1()BEGINSELECT SUBTIME('2006-07-16' , '05:05:02.040778');
END|CREATE PROCEDURE sp2()BEGINDECLARE v1 TINYINT DEFAULT 450000;
END|delimiter ;|CALL sp1();
CALL sp2();
DROP PROCEDURE sp1;
DROP PROCEDURE sp2;
CREATE FUNCTION fn1(arg TINYINT UNSIGNED) RETURNS float deterministic RETURN abs('1abcd');
delimiter |;
CREATE FUNCTION fn2() RETURNS tinyintBEGINDECLARE v1 TINYINT DEFAULT 450000;
RETURN v1;
END|delimiter ;|SELECT fn1(25);
SELECT fn1(-25);
SELECT fn2();
SET sql_mode='NO_ENGINE_SUBSTITUTION';
SELECT fn1(-25);
DROP FUNCTION fn1;
DROP FUNCTION fn2;
CREATE FUNCTION fn1() RETURNS float deterministic RETURN floor('1.1a');
SET sql_mode=default;
CREATE TABLE t1(a INT);
CREATE FUNCTION fn2() RETURNS float deterministic RETURN floor('1.1a');
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW SET @a=fn2();
INSERT INTO t1 VALUES(1);
DROP TRIGGER tr1;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW SET @a=fn1();
INSERT INTO t1 VALUES(1);
DROP FUNCTION fn1;
DROP FUNCTION fn2;
DROP TRIGGER tr1;
DROP TABLE t1;
SET sql_mode=traditional;
SELECT 1/0;
SET sql_mode='';
delimiter |;
CREATE PROCEDURE proc_c()BEGIN  DECLARE div_zero INTEGER;
  SET SQL_MODE='TRADITIONAL';
  SELECT 1/0;
END|delimiter ;|CALL proc_c();
DROP PROCEDURE proc_c;
SET sql_mode=traditional;
delimiter |;
CREATE FUNCTION fn1() RETURNS TINYINTBEGINSET  @x=floor('1a');
RETURN 1;
END|delimiter ;|SELECT fn1();
DROP FUNCTION fn1;
SET sql_mode= default;
CREATE FUNCTION crc(_text TEXT) RETURNS BIGINT(20) UNSIGNED DETERMINISTIC  RETURN CONV(LEFT(MD5(_text),16),16,10);
CREATE TABLE t1 (  id bigint(20) UNSIGNED NOT NULL);
INSERT INTO t1 (id) VALUES (crc('photos'));
INSERT INTO t1 (id) VALUES (crc('photos1'));
ALTER TABLE t1 ADD INDEX idx (id);
SELECT * FROM t1 FORCE INDEX (idx) WHERE (id = crc('photos')) AND TRUE;
SELECT * FROM t1 IGNORE INDEX (idx) WHERE (id = crc('photos')) AND TRUE;
DROP FUNCTION crc;
DROP TABLE t1;
CREATE TABLE t1(a INTEGER, b INTEGER);
DELIMITER |;
CREATE TRIGGER tr1 AFTER INSERT ON t1 FOR EACH ROWBEGIN     CALL proc(NEW.a,NEW.b);
END |CREATE PROCEDURE proc(IN aa INTEGER)BEGINEND |DELIMITER ;|INSERT INTO t1 VALUES (1,10);
DROP PROCEDURE proc;
DROP TABLE t1;
SET NAMES utf8;
CREATE PROCEDURE cafe() BEGIN END;
CREATE PROCEDURE café() BEGIN END;
CREATE PROCEDURE CAFE() BEGIN END;
DROP PROCEDURE CaFé;
CREATE PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_e() BEGIN END;
CREATE PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é() BEGIN END;
CREATE PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_E() BEGIN END;
SHOW CREATE PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é;
DROP PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é;
CREATE FUNCTION cafe() RETURNS INT return 15081947;
CREATE FUNCTION café() RETURNS INT return 15081947;
CREATE FUNCTION CAFE() RETURNS INT return 15081947;
SHOW CREATE FUNCTION CaFé;
DROP FUNCTION CaFé;
CREATE FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_e() RETURNS INT return 15081947;
CREATE FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é() RETURNS INT return 15081947;
CREATE FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_E() RETURNS INT return 15081947;
SHOW CREATE FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é;
DROP FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é;
SET NAMES default;
DELIMITER //;
CREATE FUNCTION myfunc(dt VARCHAR(50)) RETURNS VARCHAR(32) DETERMINISTICBEGIN  DECLARE dt_local TIMESTAMP(0);
  SET dt_local = dt;
  RETURN CONCAT(UNIX_TIMESTAMP(dt_local));
END; //DELIMITER ;//SELECT myfunc('2019-01-01 00:00:00');
SELECT myfunc('2019-01-01 00:00:71');
SELECT myfunc('2019-01-01 00:00:00');
DROP FUNCTION myfunc;
PREPARE stmt FROM 'SELECT CONCAT(UNIX_TIMESTAMP(?))';
SET @var = '2019-01-01 00:00:00';
EXECUTE stmt USING @var;
SET @var = '2019-01-01 00:00:71';
EXECUTE stmt USING @var;
SET @var = '2019-01-01 00:00:00';
EXECUTE stmt USING @var;
DEALLOCATE PREPARE stmt;
DELIMITER |;
CREATE FUNCTION func1() RETURNS INTBEGIN  DECLARE EXIT HANDLER FOR SQLEXCEPTION RETURN NULL;
  SELECT * INTO @a FROM fake_table;
RETURN 1;
END|CREATE FUNCTION func2() RETURNS INTBEGIN  DECLARE EXIT HANDLER FOR SQLEXCEPTION RETURN NULL;
  SELECT * INTO @a FROM fake_db.fake_table;
RETURN 1;
END|DELIMITER ;|SELECT func1();
SELECT func2();
DROP FUNCTION func1;
DROP FUNCTION func2;
DELIMITER $;
CREATE PROCEDURE p()BEGIN  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN END;
  SET @x = 0;
  WHILE @x < 2 DO    CASE((SELECT q > 1)) WHEN 1 THEN SELECT 1; END CASE;
    SET @x = @x + 1;
  END WHILE;
END$DELIMITER ;$CALL p();
DROP PROCEDURE p;
CREATE SCHEMA testdb;
USE testdb;
DELIMITER |;
CREATE FUNCTION f2 () RETURNS INTEGERBEGIN   DECLARE CONTINUE HANDLER FOR SQLSTATE '42000' SET @aux = 1;
   RETURN f_not_exists () ;
END|CREATE PROCEDURE p3 ( arg1 VARCHAR(32) )BEGIN   CALL p_not_exists ( );
END|DELIMITER ;|CALL p3 ( f2 () );
DROP SCHEMA testdb;
CREATE SCHEMA testdb;
USE testdb;
DELIMITER |;
CREATE FUNCTION f2 () RETURNS INTEGERBEGIN   DECLARE CONTINUE HANDLER FOR SQLSTATE '42000' SET @aux = 1;
   RETURN f_not_exists () ;
END|CREATE PROCEDURE p3 ( arg2 INTEGER )BEGIN   CALL p_not_exists ( );
END|DELIMITER ;|CALL p3 ( f2 () );
DROP SCHEMA testdb;
CREATE SCHEMA testdb;
USE testdb;
DELIMITER |;
CREATE FUNCTION f2 () RETURNS INTEGERBEGIN   DECLARE CONTINUE HANDLER FOR SQLSTATE '42000' SET @aux = 1;
   RETURN f_not_exists () ;
END|DELIMITER ;|SELECT f2 ();
DROP SCHEMA testdb;
USE test;
DROP TABLE IF EXISTS t1;
DROP TRIGGER IF EXISTS tr1;
DROP PROCEDURE IF EXISTS p1;
CREATE TABLE t1 (f1 INTEGER);
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW SET @aux = 1;
CREATE PROCEDURE p1 () DROP TRIGGER tr1;
CALL p1 ();
CALL p1 ();
DROP TABLE t1;
DROP PROCEDURE p1;
DROP TABLE IF EXISTS t1;
DROP TRIGGER IF EXISTS tr1;
DROP PROCEDURE IF EXISTS p1;
CREATE TABLE t1 (f1 INTEGER);
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW SET @aux = 1;
CREATE PROCEDURE p1 () DROP TRIGGER tr1;
CALL p1 ();
CALL p1 ();
DROP TABLE t1;
DROP PROCEDURE p1;
SET @@SQL_MODE = 'STRICT_ALL_TABLES';
DROP DATABASE IF EXISTS db1;
CREATE DATABASE db1;
USE db1;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (c1 int NOT NULL PRIMARY KEY);
INSERT INTO t1 VALUES (1);
DELIMITER $$;
CREATE FUNCTION f1 (	some_value intRETURNS smallintDETERMINISTICBEGIN	INSERT INTO t1 SET c1 = some_value;
        RETURN(LAST_INSERT_ID());
END$$DELIMITER ;$$DROP DATABASE IF EXISTS db2;
CREATE DATABASE db2;
USE db2;
SELECT DATABASE();
SELECT db1.f1(1);
SELECT DATABASE();
USE test;
DROP FUNCTION db1.f1;
DROP TABLE db1.t1;
DROP DATABASE db1;
DROP DATABASE db2;
DROP DATABASE IF EXISTS testdb;
CREATE DATABASE testdb;
USE testdb;
CREATE TABLE t1 (id1 INT PRIMARY KEY);
DELIMITER $;
CREATE PROCEDURE `p1`()BEGIN    CREATE TABLE IF NOT EXISTS t2(id INT PRIMARY KEY,    CONSTRAINT FK FOREIGN KEY (id) REFERENCES t1( id1 ));
END$DELIMITER ;$CALL p1();
CALL p1(); DROP DATABASE testdb;
USE test;
CREATE FUNCTION sf() RETURNS BLOB RETURN "";
SELECT sf();
DROP FUNCTION sf;
SET @@SQL_MODE = '';
DELIMITER $;
CREATE FUNCTION testf_bug11763507() RETURNS INTBEGIN    RETURN 0;
ENDCREATE PROCEDURE testp_bug11763507()BEGIN    SELECT "PROCEDURE testp_bug11763507";
ENDDELIMITER ;$SELECT testf_bug11763507();
SELECT TESTF_bug11763507();
SHOW FUNCTION STATUS LIKE  'testf_bug11763507';
SHOW FUNCTION STATUS WHERE NAME='testf_bug11763507';
SHOW FUNCTION STATUS LIKE  'TESTF_bug11763507';
SHOW FUNCTION STATUS WHERE NAME='TESTF_bug11763507';
SHOW CREATE FUNCTION testf_bug11763507;
SHOW CREATE FUNCTION TESTF_bug11763507;
CALL testp_bug11763507();
CALL TESTP_bug11763507();
SHOW PROCEDURE STATUS LIKE  'testp_bug11763507';
SHOW PROCEDURE STATUS WHERE NAME='testp_bug11763507';
SHOW PROCEDURE STATUS LIKE  'TESTP_bug11763507';
SHOW PROCEDURE STATUS WHERE NAME='TESTP_bug11763507';
SHOW CREATE PROCEDURE testp_bug11763507;
SHOW CREATE PROCEDURE TESTP_bug11763507;
SELECT specific_name FROM INFORMATION_SCHEMA.ROUTINES WHERE specific_name LIKE 'testf_bug11763507';
SELECT specific_name FROM INFORMATION_SCHEMA.ROUTINES WHERE specific_name LIKE 'TESTF_bug11763507';
SELECT specific_name FROM INFORMATION_SCHEMA.ROUTINES WHERE specific_name='testf_bug11763507';
SELECT specific_name FROM INFORMATION_SCHEMA.ROUTINES WHERE specific_name='TESTF_bug11763507';
DROP PROCEDURE testp_bug11763507;
DROP FUNCTION testf_bug11763507;
SET sql_mode='NO_ENGINE_SUBSTITUTION';
delimiter |;
CREATE FUNCTION f1(arg TINYINT UNSIGNED) RETURNS TINYINTBEGIN  RETURN abs('1abcd');
END|delimiter ;|SELECT f1(-25);
SELECT f1(25);
SET sql_mode=default;
SELECT f1(-25);
SELECT f1(10);
DROP FUNCTION f1;
SET sql_mode='NO_ENGINE_SUBSTITUTION';
delimiter |;
CREATE PROCEDURE f1(IN arg TINYINT UNSIGNED)BEGIN  DECLARE arg1 TINYINT;
  select abs('1abcd') into arg;
END|delimiter ;|CALL f1(-25);
CALL f1(25);
SET sql_mode=default;
CALL f1(-25);
CALL f1(10);
DROP PROCEDURE f1;
SELECT SUBTIME('2006-07-16' , '05:05:02.040778');
SELECT abs('1bcd');
delimiter |;
CREATE PROCEDURE sp1()BEGINSELECT SUBTIME('2006-07-16' , '05:05:02.040778');
END|CREATE PROCEDURE sp2()BEGINDECLARE v1 TINYINT DEFAULT 450000;
END|delimiter ;|CALL sp1();
CALL sp2();
DROP PROCEDURE sp1;
DROP PROCEDURE sp2;
CREATE FUNCTION fn1(arg TINYINT UNSIGNED) RETURNS float deterministic RETURN abs('1abcd');
delimiter |;
CREATE FUNCTION fn2() RETURNS tinyintBEGINDECLARE v1 TINYINT DEFAULT 450000;
RETURN v1;
END|delimiter ;|SELECT fn1(25);
SELECT fn1(-25);
SELECT fn2();
SET sql_mode='NO_ENGINE_SUBSTITUTION';
SELECT fn1(-25);
DROP FUNCTION fn1;
DROP FUNCTION fn2;
CREATE FUNCTION fn1() RETURNS float deterministic RETURN floor('1.1a');
SET sql_mode=default;
CREATE TABLE t1(a INT);
CREATE FUNCTION fn2() RETURNS float deterministic RETURN floor('1.1a');
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW SET @a=fn2();
INSERT INTO t1 VALUES(1);
DROP TRIGGER tr1;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW SET @a=fn1();
INSERT INTO t1 VALUES(1);
DROP FUNCTION fn1;
DROP FUNCTION fn2;
DROP TRIGGER tr1;
DROP TABLE t1;
SET sql_mode=traditional;
SELECT 1/0;
SET sql_mode='';
delimiter |;
CREATE PROCEDURE proc_c()BEGIN  DECLARE div_zero INTEGER;
  SET SQL_MODE='TRADITIONAL';
  SELECT 1/0;
END|delimiter ;|CALL proc_c();
DROP PROCEDURE proc_c;
SET sql_mode=traditional;
delimiter |;
CREATE FUNCTION fn1() RETURNS TINYINTBEGINSET  @x=floor('1a');
RETURN 1;
END|delimiter ;|SELECT fn1();
DROP FUNCTION fn1;
SET sql_mode= default;
CREATE FUNCTION crc(_text TEXT) RETURNS BIGINT(20) UNSIGNED DETERMINISTIC  RETURN CONV(LEFT(MD5(_text),16),16,10);
CREATE TABLE t1 (  id bigint(20) UNSIGNED NOT NULL);
INSERT INTO t1 (id) VALUES (crc('photos'));
INSERT INTO t1 (id) VALUES (crc('photos1'));
ALTER TABLE t1 ADD INDEX idx (id);
SELECT * FROM t1 FORCE INDEX (idx) WHERE (id = crc('photos')) AND TRUE;
SELECT * FROM t1 IGNORE INDEX (idx) WHERE (id = crc('photos')) AND TRUE;
DROP FUNCTION crc;
DROP TABLE t1;
CREATE TABLE t1(a INTEGER, b INTEGER);
DELIMITER |;
CREATE TRIGGER tr1 AFTER INSERT ON t1 FOR EACH ROWBEGIN     CALL proc(NEW.a,NEW.b);
END |CREATE PROCEDURE proc(IN aa INTEGER)BEGINEND |DELIMITER ;|INSERT INTO t1 VALUES (1,10);
DROP PROCEDURE proc;
DROP TABLE t1;
SET NAMES utf8;
CREATE PROCEDURE cafe() BEGIN END;
CREATE PROCEDURE café() BEGIN END;
CREATE PROCEDURE CAFE() BEGIN END;
DROP PROCEDURE CaFé;
CREATE PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_e() BEGIN END;
CREATE PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é() BEGIN END;
CREATE PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_E() BEGIN END;
SHOW CREATE PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é;
DROP PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é;
CREATE FUNCTION cafe() RETURNS INT return 15081947;
CREATE FUNCTION café() RETURNS INT return 15081947;
CREATE FUNCTION CAFE() RETURNS INT return 15081947;
SHOW CREATE FUNCTION CaFé;
DROP FUNCTION CaFé;
CREATE FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_e() RETURNS INT return 15081947;
CREATE FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é() RETURNS INT return 15081947;
CREATE FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_E() RETURNS INT return 15081947;
SHOW CREATE FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é;
DROP FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é;
SET NAMES default;
DELIMITER //;
CREATE FUNCTION myfunc(dt VARCHAR(50)) RETURNS VARCHAR(32) DETERMINISTICBEGIN  DECLARE dt_local TIMESTAMP(0);
  SET dt_local = dt;
  RETURN CONCAT(UNIX_TIMESTAMP(dt_local));
END; //DELIMITER ;//SELECT myfunc('2019-01-01 00:00:00');
SELECT myfunc('2019-01-01 00:00:71');
SELECT myfunc('2019-01-01 00:00:00');
DROP FUNCTION myfunc;
PREPARE stmt FROM 'SELECT CONCAT(UNIX_TIMESTAMP(?))';
SET @var = '2019-01-01 00:00:00';
EXECUTE stmt USING @var;
SET @var = '2019-01-01 00:00:71';
EXECUTE stmt USING @var;
SET @var = '2019-01-01 00:00:00';
EXECUTE stmt USING @var;
DEALLOCATE PREPARE stmt;
DELIMITER |;
CREATE FUNCTION func1() RETURNS INTBEGIN  DECLARE EXIT HANDLER FOR SQLEXCEPTION RETURN NULL;
  SELECT * INTO @a FROM fake_table;
RETURN 1;
END|CREATE FUNCTION func2() RETURNS INTBEGIN  DECLARE EXIT HANDLER FOR SQLEXCEPTION RETURN NULL;
  SELECT * INTO @a FROM fake_db.fake_table;
RETURN 1;
END|DELIMITER ;|SELECT func1();
SELECT func2();
DROP FUNCTION func1;
DROP FUNCTION func2;
DELIMITER $;
CREATE PROCEDURE p()BEGIN  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN END;
  SET @x = 0;
  WHILE @x < 2 DO    CASE((SELECT q > 1)) WHEN 1 THEN SELECT 1; END CASE;
    SET @x = @x + 1;
  END WHILE;
END$DELIMITER ;$CALL p();
DROP PROCEDURE p;
CREATE SCHEMA testdb;
USE testdb;
DELIMITER |;
CREATE FUNCTION f2 () RETURNS INTEGERBEGIN   DECLARE CONTINUE HANDLER FOR SQLSTATE '42000' SET @aux = 1;
   RETURN f_not_exists () ;
END|CREATE PROCEDURE p3 ( arg1 VARCHAR(32) )BEGIN   CALL p_not_exists ( );
END|DELIMITER ;|CALL p3 ( f2 () );
DROP SCHEMA testdb;
CREATE SCHEMA testdb;
USE testdb;
DELIMITER |;
CREATE FUNCTION f2 () RETURNS INTEGERBEGIN   DECLARE CONTINUE HANDLER FOR SQLSTATE '42000' SET @aux = 1;
   RETURN f_not_exists () ;
END|CREATE PROCEDURE p3 ( arg2 INTEGER )BEGIN   CALL p_not_exists ( );
END|DELIMITER ;|CALL p3 ( f2 () );
DROP SCHEMA testdb;
CREATE SCHEMA testdb;
USE testdb;
DELIMITER |;
CREATE FUNCTION f2 () RETURNS INTEGERBEGIN   DECLARE CONTINUE HANDLER FOR SQLSTATE '42000' SET @aux = 1;
   RETURN f_not_exists () ;
END|DELIMITER ;|SELECT f2 ();
DROP SCHEMA testdb;
USE test;
DROP TABLE IF EXISTS t1;
DROP TRIGGER IF EXISTS tr1;
DROP PROCEDURE IF EXISTS p1;
CREATE TABLE t1 (f1 INTEGER);
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW SET @aux = 1;
CREATE PROCEDURE p1 () DROP TRIGGER tr1;
CALL p1 ();
CALL p1 ();
DROP TABLE t1;
DROP PROCEDURE p1;
DROP TABLE IF EXISTS t1;
DROP TRIGGER IF EXISTS tr1;
DROP PROCEDURE IF EXISTS p1;
CREATE TABLE t1 (f1 INTEGER);
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW SET @aux = 1;
CREATE PROCEDURE p1 () DROP TRIGGER tr1;
CALL p1 ();
CALL p1 ();
DROP TABLE t1;
DROP PROCEDURE p1;
SET @@SQL_MODE = 'STRICT_ALL_TABLES';
DROP DATABASE IF EXISTS db1;
CREATE DATABASE db1;
USE db1;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (c1 int NOT NULL PRIMARY KEY);
INSERT INTO t1 VALUES (1);
DELIMITER $$;
CREATE FUNCTION f1 (	some_value intRETURNS smallintDETERMINISTICBEGIN	INSERT INTO t1 SET c1 = some_value;
        RETURN(LAST_INSERT_ID());
END$$DELIMITER ;$$DROP DATABASE IF EXISTS db2;
CREATE DATABASE db2;
USE db2;
SELECT DATABASE();
SELECT db1.f1(1);
SELECT DATABASE();
USE test;
DROP FUNCTION db1.f1;
DROP TABLE db1.t1;
DROP DATABASE db1;
DROP DATABASE db2;
DROP DATABASE IF EXISTS testdb;
CREATE DATABASE testdb;
USE testdb;
CREATE TABLE t1 (id1 INT PRIMARY KEY);
DELIMITER $;
CREATE PROCEDURE `p1`()BEGIN    CREATE TABLE IF NOT EXISTS t2(id INT PRIMARY KEY,    CONSTRAINT FK FOREIGN KEY (id) REFERENCES t1( id1 ));
END$DELIMITER ;$CALL p1();
CALL p1(); DROP DATABASE testdb;
USE test;
CREATE FUNCTION sf() RETURNS BLOB RETURN "";
SELECT sf();
DROP FUNCTION sf;
SET @@SQL_MODE = '';
DELIMITER $;
CREATE FUNCTION testf_bug11763507() RETURNS INTBEGIN    RETURN 0;
ENDCREATE PROCEDURE testp_bug11763507()BEGIN    SELECT "PROCEDURE testp_bug11763507";
ENDDELIMITER ;$SELECT testf_bug11763507();
SELECT TESTF_bug11763507();
SHOW FUNCTION STATUS LIKE  'testf_bug11763507';
SHOW FUNCTION STATUS WHERE NAME='testf_bug11763507';
SHOW FUNCTION STATUS LIKE  'TESTF_bug11763507';
SHOW FUNCTION STATUS WHERE NAME='TESTF_bug11763507';
SHOW CREATE FUNCTION testf_bug11763507;
SHOW CREATE FUNCTION TESTF_bug11763507;
CALL testp_bug11763507();
CALL TESTP_bug11763507();
SHOW PROCEDURE STATUS LIKE  'testp_bug11763507';
SHOW PROCEDURE STATUS WHERE NAME='testp_bug11763507';
SHOW PROCEDURE STATUS LIKE  'TESTP_bug11763507';
SHOW PROCEDURE STATUS WHERE NAME='TESTP_bug11763507';
SHOW CREATE PROCEDURE testp_bug11763507;
SHOW CREATE PROCEDURE TESTP_bug11763507;
SELECT specific_name FROM INFORMATION_SCHEMA.ROUTINES WHERE specific_name LIKE 'testf_bug11763507';
SELECT specific_name FROM INFORMATION_SCHEMA.ROUTINES WHERE specific_name LIKE 'TESTF_bug11763507';
SELECT specific_name FROM INFORMATION_SCHEMA.ROUTINES WHERE specific_name='testf_bug11763507';
SELECT specific_name FROM INFORMATION_SCHEMA.ROUTINES WHERE specific_name='TESTF_bug11763507';
DROP PROCEDURE testp_bug11763507;
DROP FUNCTION testf_bug11763507;
SET sql_mode='NO_ENGINE_SUBSTITUTION';
delimiter |;
CREATE FUNCTION f1(arg TINYINT UNSIGNED) RETURNS TINYINTBEGIN  RETURN abs('1abcd');
END|delimiter ;|SELECT f1(-25);
SELECT f1(25);
SET sql_mode=default;
SELECT f1(-25);
SELECT f1(10);
DROP FUNCTION f1;
SET sql_mode='NO_ENGINE_SUBSTITUTION';
delimiter |;
CREATE PROCEDURE f1(IN arg TINYINT UNSIGNED)BEGIN  DECLARE arg1 TINYINT;
  select abs('1abcd') into arg;
END|delimiter ;|CALL f1(-25);
CALL f1(25);
SET sql_mode=default;
CALL f1(-25);
CALL f1(10);
DROP PROCEDURE f1;
SELECT SUBTIME('2006-07-16' , '05:05:02.040778');
SELECT abs('1bcd');
delimiter |;
CREATE PROCEDURE sp1()BEGINSELECT SUBTIME('2006-07-16' , '05:05:02.040778');
END|CREATE PROCEDURE sp2()BEGINDECLARE v1 TINYINT DEFAULT 450000;
END|delimiter ;|CALL sp1();
CALL sp2();
DROP PROCEDURE sp1;
DROP PROCEDURE sp2;
CREATE FUNCTION fn1(arg TINYINT UNSIGNED) RETURNS float deterministic RETURN abs('1abcd');
delimiter |;
CREATE FUNCTION fn2() RETURNS tinyintBEGINDECLARE v1 TINYINT DEFAULT 450000;
RETURN v1;
END|delimiter ;|SELECT fn1(25);
SELECT fn1(-25);
SELECT fn2();
SET sql_mode='NO_ENGINE_SUBSTITUTION';
SELECT fn1(-25);
DROP FUNCTION fn1;
DROP FUNCTION fn2;
CREATE FUNCTION fn1() RETURNS float deterministic RETURN floor('1.1a');
SET sql_mode=default;
CREATE TABLE t1(a INT);
CREATE FUNCTION fn2() RETURNS float deterministic RETURN floor('1.1a');
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW SET @a=fn2();
INSERT INTO t1 VALUES(1);
DROP TRIGGER tr1;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW SET @a=fn1();
INSERT INTO t1 VALUES(1);
DROP FUNCTION fn1;
DROP FUNCTION fn2;
DROP TRIGGER tr1;
DROP TABLE t1;
SET sql_mode=traditional;
SELECT 1/0;
SET sql_mode='';
delimiter |;
CREATE PROCEDURE proc_c()BEGIN  DECLARE div_zero INTEGER;
  SET SQL_MODE='TRADITIONAL';
  SELECT 1/0;
END|delimiter ;|CALL proc_c();
DROP PROCEDURE proc_c;
SET sql_mode=traditional;
delimiter |;
CREATE FUNCTION fn1() RETURNS TINYINTBEGINSET  @x=floor('1a');
RETURN 1;
END|delimiter ;|SELECT fn1();
DROP FUNCTION fn1;
SET sql_mode= default;
CREATE FUNCTION crc(_text TEXT) RETURNS BIGINT(20) UNSIGNED DETERMINISTIC  RETURN CONV(LEFT(MD5(_text),16),16,10);
CREATE TABLE t1 (  id bigint(20) UNSIGNED NOT NULL);
INSERT INTO t1 (id) VALUES (crc('photos'));
INSERT INTO t1 (id) VALUES (crc('photos1'));
ALTER TABLE t1 ADD INDEX idx (id);
SELECT * FROM t1 FORCE INDEX (idx) WHERE (id = crc('photos')) AND TRUE;
SELECT * FROM t1 IGNORE INDEX (idx) WHERE (id = crc('photos')) AND TRUE;
DROP FUNCTION crc;
DROP TABLE t1;
CREATE TABLE t1(a INTEGER, b INTEGER);
DELIMITER |;
CREATE TRIGGER tr1 AFTER INSERT ON t1 FOR EACH ROWBEGIN     CALL proc(NEW.a,NEW.b);
END |CREATE PROCEDURE proc(IN aa INTEGER)BEGINEND |DELIMITER ;|INSERT INTO t1 VALUES (1,10);
DROP PROCEDURE proc;
DROP TABLE t1;
SET NAMES utf8;
CREATE PROCEDURE cafe() BEGIN END;
CREATE PROCEDURE café() BEGIN END;
CREATE PROCEDURE CAFE() BEGIN END;
DROP PROCEDURE CaFé;
CREATE PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_e() BEGIN END;
CREATE PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é() BEGIN END;
CREATE PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_E() BEGIN END;
SHOW CREATE PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é;
DROP PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é;
CREATE FUNCTION cafe() RETURNS INT return 15081947;
CREATE FUNCTION café() RETURNS INT return 15081947;
CREATE FUNCTION CAFE() RETURNS INT return 15081947;
SHOW CREATE FUNCTION CaFé;
DROP FUNCTION CaFé;
CREATE FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_e() RETURNS INT return 15081947;
CREATE FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é() RETURNS INT return 15081947;
CREATE FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_E() RETURNS INT return 15081947;
SHOW CREATE FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é;
DROP FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é;
SET NAMES default;
DELIMITER //;
CREATE FUNCTION myfunc(dt VARCHAR(50)) RETURNS VARCHAR(32) DETERMINISTICBEGIN  DECLARE dt_local TIMESTAMP(0);
  SET dt_local = dt;
  RETURN CONCAT(UNIX_TIMESTAMP(dt_local));
END; //DELIMITER ;//SELECT myfunc('2019-01-01 00:00:00');
SELECT myfunc('2019-01-01 00:00:71');
SELECT myfunc('2019-01-01 00:00:00');
DROP FUNCTION myfunc;
PREPARE stmt FROM 'SELECT CONCAT(UNIX_TIMESTAMP(?))';
SET @var = '2019-01-01 00:00:00';
EXECUTE stmt USING @var;
SET @var = '2019-01-01 00:00:71';
EXECUTE stmt USING @var;
SET @var = '2019-01-01 00:00:00';
EXECUTE stmt USING @var;
DEALLOCATE PREPARE stmt;
DELIMITER |;
CREATE FUNCTION func1() RETURNS INTBEGIN  DECLARE EXIT HANDLER FOR SQLEXCEPTION RETURN NULL;
  SELECT * INTO @a FROM fake_table;
RETURN 1;
END|CREATE FUNCTION func2() RETURNS INTBEGIN  DECLARE EXIT HANDLER FOR SQLEXCEPTION RETURN NULL;
  SELECT * INTO @a FROM fake_db.fake_table;
RETURN 1;
END|DELIMITER ;|SELECT func1();
SELECT func2();
DROP FUNCTION func1;
DROP FUNCTION func2;
DELIMITER $;
CREATE PROCEDURE p()BEGIN  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN END;
  SET @x = 0;
  WHILE @x < 2 DO    CASE((SELECT q > 1)) WHEN 1 THEN SELECT 1; END CASE;
    SET @x = @x + 1;
  END WHILE;
END$DELIMITER ;$CALL p();
DROP PROCEDURE p;
