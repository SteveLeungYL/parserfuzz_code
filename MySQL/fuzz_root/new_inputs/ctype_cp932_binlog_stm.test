  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          perl;
  # Compute relay log filename.  my $index_file= $ENV{'_RGEORL_INDEX_FILE'};
  my $channel_name= $ENV{'_RGEORL_CHANNEL_NAME'};
  # Remove the single quotes from $channel_name  $channel_name=~ s/\'//g;
  if ($channel_name) {    $index_file =~ s/(.*)(\.index)/$1-$channel_name$2/;
  }  # Read relay log filename.  open FILE, "$index_file" or die "Error $? opening $index_file: $!";
  my $relay_log_file= '';
  while (<FILE>) {    $relay_log_file= $_;
  }  chomp($relay_log_file);
  $relay_log_file =~ s{^\.[/\\]}{};
  close FILE or die "Error $? closing $index_file: $!";
  # Get relay log size.  my $datadir= $ENV{'_RGEORL_DATADIR'};
  my $relay_log_size= (stat("$datadir/$relay_log_file"))[7];
  # Write output file.  my $output_file= $ENV{'_RGEORL_OUTPUT_FILE'};
  open FILE, "> $output_file" or die "Error $? opening $output_file: $!";
  printf FILE "% 10d%s", $relay_log_size, $relay_log_file or die "Error $? writing to $output_file: $!";
  close FILE or die "Error $? writing to $output_file: $!";
EOF      if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                                    perl;
  use strict;
  my $stmt= $ENV{'_WRTF_STATEMENT'};
  # Connecting mysql to same mysqld as current connectiona  # by overriding port and socket  my $mysql= $ENV{'MYSQL'};
  my $server_port= $ENV{'_WRTF_SERVER_PORT'};
  my $server_socket= $ENV{'_WRTF_SERVER_SOCKET'};
  my $redirection_type= $ENV{'_WRTF_APPEND'} ? '>>' : '>';
  $mysql .= "   my $outfile = $ENV{'_WRTF_OUTPUT_FILE'};
  open MYSQL, "| $mysql $redirection_type $outfile" or die "Error $? opening MYSQL pipe '| $mysql > $outfile': $!";
  print MYSQL $stmt, ';' or die "Error $? printing statement '$stmt' to MYSQL pipe '| $mysql > $outfile': $!";
  close MYSQL or $ENV{'_WRTF_ALLOW_ERROR'} or die "Error $? closing MYSQL pipe '| $mysql > $outfile' reading '$stmt': $!";
EOF  if (!$include_silent)  {      }            perl;
  my $pre_script = $ENV{'_FF_PRE_SCRIPT'};
  $pre_script =~ s/DOLLAR/\$/g;
  my $script = $ENV{'_FF_SCRIPT'};
  $script =~ s/DOLLAR/\$/g;
  my $input_file = $ENV{'_FF_INPUT_FILE'};
  my $output_file = $ENV{'_FF_OUTPUT_FILE'};
  my $select_columns = $ENV{'_FF_SELECT_COLUMNS'};
  my $mask_columns = $ENV{'_FF_MASK_COLUMNS'};
  my $debug = $ENV{'_FF_DEBUG'};
  if ($select_columns)  {    chomp($select_columns);
    $select_columns =~ s/[, ]+/,/g;
    $script = '    chomp;
    my @cols = split(/\t/, $_);
    $_ = join("\t", map { $cols[$_ - 1] } ('.$select_columns.'));
    ' . $script;
  }  if ($mask_columns)  {    chomp($mask_columns);
    my $last_col = 0;
    my $regex = '';
    my $pending_tab = '';
    my $replacement = '';
    my $n = 1;
    for my $col (split(/\s*,\s*/, $mask_columns)) {      $regex .= '(' . $pending_tab . '[^\t]*\t' x ($col - $last_col - 1) . ')';
      $regex .= '(?:[^\t]*)';
      $pending_tab = '\t';
      $replacement .= '$' . $n . '#';
      $n++;
      $last_col = $col;
    }    $script = "s/$regex/$replacement/;
    $script";
  }  unless ($keep_quotes)  {    $pre_script = 'my %unquote = ("n"=>"\n","t"=>"\t","\\\\"=>"\\\\");' . $pre_script;
    $script .= ';s{\\\\(.)}{$unquote{$1}}ge;';
  }  if ($debug)  {    $script = 'print "BEFORE:\'$_\'";' . $script . 'print "AFTER:\'$_\'";'  }  # Generate a script (perl is faster if we avoid many calls to eval).  my $full_script =  open FILE, "< $input_file" or die "Error opening $input_file: $!";
  my $filtered_contents = "";
  my %column_names = ();
  '.$pre_script.';
  while (<FILE>)  {    chomp;
    s/\015?\012?$//;
    if ($mask_columns && !%column_names)    {      my $n = 1;
      %column_names = map { $_ => $n++ } split(/\t/, $_);
    }    else    {      ' . $script . '    }    if (length($_) > 0)    {      $filtered_contents .= $_."\n";
    }  }  close FILE or die "Error closing $input_file: $!";
  open FILE, "> $output_file" or die "Error opening $output_file: $!";
  binmode FILE;
  print FILE $filtered_contents or die "Error writing filtered contents to $output_file: $!";
  close FILE or die "Error closing $output_file: $!";
  return 0;
';
  if ($debug)  {    print STDOUT "full_script=<<END_OF_SCRIPT\n${full_script}END_OF_SCRIPT\n"  }  my $eval_ret = eval($full_script);
  defined($eval_ret) or die "Parse error or 'die' invoked when evaluating perl script '$full_script': $@";
  $eval_ret == 0 or die "Non-zero exit value $eval_ret from script '$script'";
EOF      if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                    if ($rpl_channel_name)  {      }    if ($rpl_channel_name)  {      }    if ($binlog_file == 'LAST')  {    if ($is_relay_log)    {          }    if (!$is_relay_log)    {          }  }      # If $binlog_start is not set, we will set it as the second event's  # position.  The first event(Description Event) is always ignored. For  # description event's length might be changed because of adding new events,  # 'SHOW BINLOG EVENTS LIMIT 1' is used to get the right value.                s{/\* xid=.* \*/}{/\* XID # \*/};
  s{COMMIT /\* XID # \*/}{COMMIT /\* XID \*/};
  s{table_id: [0-9]+}{table_id: #};
  s{file_id=[0-9]+}{file_id=#};
  s{block_len=[0-9]+}{block_len=#};
  s{Server ver:.*DOLLAR}{SERVER_VERSION, BINLOG_VERSION};
  s{SQL_LOAD-[a-z,0-9,-]*.[a-z]*}{SQL_LOAD-<SERVER UUID>-<MASTER server-id>-<file-id>.<extension>};
  s{rand_seed1=[0-9]*,rand_seed2=[0-9]*}{rand_seed1=<seed 1>,rand_seed2=<seed 2>};
  s{((?:master|slave|slave-relay)-bin\.[0-9]{6};pos=)[0-9]+DOLLAR}{DOLLAR1POS};
  s{(binlog\.[0-9]{6};pos=)[0-9]+DOLLAR}{DOLLAR1POS};
  s{SONAME ".*"}{SONAME "LIB"};
  s{DOLLARmysqltest_vardir}{MYSQLTEST_VARDIR}g;
||    let $pre_script= $pre_script    my DOLLARdec_size_regex = '(decompressed_size=[0-9]+ bytes)';
  ||        let $pre_script= $pre_script    my DOLLARuuid_regex = '[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}';
    my DOLLARuuid_gno_regex = DOLLARuuid_regex.'(?::[0-9]+(?:-[0-9]+)?)+';
  ||                  if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                  CREATE TABLE t1 (a CHAR(1)) CHARACTER SET utf8;
INSERT INTO t1 VALUES ('0'),('1'),('2'),('3'),('4'),('5'),('6'),('7');
INSERT INTO t1 VALUES ('8'),('9'),('A'),('B'),('C'),('D'),('E'),('F');
CREATE TEMPORARY TABLE head   AS SELECT concat(b1.a, b2.a) AS head   FROM t1 b1, t1 b2;
CREATE TEMPORARY TABLE tail   AS SELECT concat(b1.a, b2.a) AS tail   FROM t1 b1, t1 b2;
CREATE TEMPORARY TABLE middle AS SELECT concat(b1.a, b2.a) AS middle FROM t1 b1, t1 b2;
DROP TABLE t1;
CREATE TABLE t1 (a varchar(1)) CHARACTER SET utf8;
INSERT INTO t1 SELECT UNHEX(head)FROM head WHERE (head BETWEEN '00' AND '7F') ORDER BY head;
INSERT INTO t1SELECT UNHEX(CONCAT(head,tail))FROM head, tailWHERE (head BETWEEN 'C2' AND 'DF') AND (tail BETWEEN '80' AND 'BF')ORDER BY head, tail;
INSERT INTO t1SELECT UNHEX(CONCAT(head, middle, tail))FROM head, middle, tailWHERE (head BETWEEN 'E0' AND 'EF') AND (middle BETWEEN '80' AND 'BF')AND (tail BETWEEN '80' AND 'BF')AND NOT (head='E0' AND middle BETWEEN '80' AND '9F')AND NOT (head='ED' AND middle BETWEEN 'A0' AND 'BF')ORDER BY head, middle, tail;
SELECT count(*) FROM t1;
select @@collation_connection;
select hex(weight_string('a'));
select hex(weight_string('A'));
select hex(weight_string('abc'));
select hex(weight_string('abc' as char(2)));
select hex(weight_string('abc' as char(3)));
select hex(weight_string('abc' as char(5)));
select hex(weight_string('abc', 1, 2, 0xC0));
select hex(weight_string('abc', 2, 2, 0xC0));
select hex(weight_string('abc', 3, 2, 0xC0));
select hex(weight_string('abc', 4, 2, 0xC0));
select hex(weight_string('abc', 5, 2, 0xC0));
select hex(weight_string('abc',25, 2, 0xC0));
select hex(weight_string('abc', 1, 3, 0xC0));
select hex(weight_string('abc', 2, 3, 0xC0));
select hex(weight_string('abc', 3, 3, 0xC0));
select hex(weight_string('abc', 4, 3, 0xC0));
select hex(weight_string('abc', 5, 3, 0xC0));
select hex(weight_string('abc',25, 3, 0xC0));
select hex(weight_string('abc', 1, 4, 0xC0));
select hex(weight_string('abc', 2, 4, 0xC0));
select hex(weight_string('abc', 3, 4, 0xC0));
select hex(weight_string('abc', 4, 4, 0xC0));
select hex(weight_string('abc', 5, 4, 0xC0));
select hex(weight_string('abc',25, 4, 0xC0));
select collation(cast(0x8140 as char));
select hex(weight_string(cast(0x6141 as char)));
select hex(weight_string(cast(0x8140 as char)));
select hex(weight_string(cast(0x8140 as char) as char(1)));
select hex(weight_string(cast(0x81408140 as char) as char(1)));
select hex(weight_string(cast(0x8140 as char) as char(3)));
select hex(weight_string(cast(0x81408140 as char) as char(3)));
select hex(weight_string(cast(0x408140 as char) as char(3)));
select hex(weight_string(cast(0x4081408140 as char) as char(3)));
select hex(weight_string(cast(0x40814081408140 as char) as char(3)));
select hex(weight_string(cast(0x4040814081408140 as char) as char(3)));
select hex(weight_string(cast(0x814081408140 as char), 1, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 1, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 1, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 4, 0xC0));
select @@collation_connection;
select hex(weight_string('a'));
select hex(weight_string('A'));
select hex(weight_string('abc'));
select hex(weight_string('abc' as char(2)));
select hex(weight_string('abc' as char(3)));
select hex(weight_string('abc' as char(5)));
select hex(weight_string('abc', 1, 2, 0xC0));
select hex(weight_string('abc', 2, 2, 0xC0));
select hex(weight_string('abc', 3, 2, 0xC0));
select hex(weight_string('abc', 4, 2, 0xC0));
select hex(weight_string('abc', 5, 2, 0xC0));
select hex(weight_string('abc',25, 2, 0xC0));
select hex(weight_string('abc', 1, 3, 0xC0));
select hex(weight_string('abc', 2, 3, 0xC0));
select hex(weight_string('abc', 3, 3, 0xC0));
select hex(weight_string('abc', 4, 3, 0xC0));
select hex(weight_string('abc', 5, 3, 0xC0));
select hex(weight_string('abc',25, 3, 0xC0));
select hex(weight_string('abc', 1, 4, 0xC0));
select hex(weight_string('abc', 2, 4, 0xC0));
select hex(weight_string('abc', 3, 4, 0xC0));
select hex(weight_string('abc', 4, 4, 0xC0));
select hex(weight_string('abc', 5, 4, 0xC0));
select hex(weight_string('abc',25, 4, 0xC0));
select collation(cast(0x8140 as char));
select hex(weight_string(cast(0x6141 as char)));
select hex(weight_string(cast(0x8140 as char)));
select hex(weight_string(cast(0x8140 as char) as char(1)));
select hex(weight_string(cast(0x81408140 as char) as char(1)));
select hex(weight_string(cast(0x8140 as char) as char(3)));
select hex(weight_string(cast(0x81408140 as char) as char(3)));
select hex(weight_string(cast(0x408140 as char) as char(3)));
select hex(weight_string(cast(0x4081408140 as char) as char(3)));
select hex(weight_string(cast(0x40814081408140 as char) as char(3)));
select hex(weight_string(cast(0x4040814081408140 as char) as char(3)));
select hex(weight_string(cast(0x814081408140 as char), 1, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 1, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 1, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 4, 0xC0));
SET @@GLOBAL.binlog_format=@previous_binlog_format__htnt542nh;
CREATE TABLE t4 (s1 CHAR(50) CHARACTER SET latin1,                 s2 CHAR(50) CHARACTER SET cp932,                 d DECIMAL(10,2))|CREATE PROCEDURE bug18293 (IN ins1 CHAR(50),                           IN ins2 CHAR(50) CHARACTER SET cp932,                           IN ind DECIMAL(10,2))  BEGIN    INSERT INTO t4 VALUES (ins1, ins2, ind);
  END|CALL bug18293("Foo's a Bar", _cp932 0xED40ED41ED42, 47.93);
SELECT HEX(s1),HEX(s2),d FROM t4;
DROP PROCEDURE bug18293;
DROP TABLE t4;
CREATE TABLE t1 (a varchar(16)) character set cp932;
INSERT INTO t1 VALUES (0x8372835E),(0x8352835E);
SELECT hex(a), hex(lower(a)), hex(upper(a)) FROM t1 ORDER BY binary(a);
DROP TABLE t1;
SET NAMES utf8;
SET collation_connection=cp932_japanese_ci;
CREATE TABLE t1 (b VARCHAR(2));
INSERT INTO t1 VALUES ('0'),('1'),('2'),('3'),('4'),('5'),('6'),('7');
INSERT INTO t1 VALUES ('8'),('9'),('A'),('B'),('C'),('D'),('E'),('F');
CREATE TEMPORARY TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2;
CREATE TEMPORARY TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2;
DROP TABLE t1;
CREATE TABLE t1 ASSELECT concat(head, tail) AS code, ' ' AS aFROM head, tailWHERE (head BETWEEN '80' AND 'FF') AND (head NOT BETWEEN 'A1' AND 'DF')AND (tail BETWEEN '20' AND 'FF')ORDER BY head, tail;
INSERT t1 (code) SELECT head FROM headWHERE (head BETWEEN 'A1' AND 'DF')ORDER BY head;
DROP TEMPORARY TABLE head, tail;
SHOW CREATE TABLE t1;
SET @@session.max_error_count = 64;
UPDATE IGNORE t1 SET a=unhex(code) ORDER BY code;
SET @@session.max_error_count = default;
SELECT COUNT(*) FROM t1;
SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=1;
SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=2;
SELECT code, hex(upper(a)), hex(lower(a)),a, upper(a), lower(a) FROM t1WHERE hex(a)<>hex(upper(a)) OR hex(a)<>hex(lower(a))ORDER BY code;
SELECT * FROM t1WHERE HEX(CAST(LOWER(a) AS CHAR CHARACTER SET utf8)) <>      HEX(LOWER(CAST(a AS CHAR CHARACTER SET utf8))) ORDER BY code;
SELECT * FROM t1WHERE HEX(CAST(UPPER(a) AS CHAR CHARACTER SET utf8)) <>      HEX(UPPER(CAST(a AS CHAR CHARACTER SET utf8))) ORDER BY code;
SELECT HEX(a), HEX(CONVERT(a USING utf8)) as b FROM t1WHERE a<>'' HAVING b<>'3F' ORDER BY code;
DROP TABLE t1;
SELECT HEX(a), HEX(CONVERT(a using cp932)) as b FROM t1 HAVING b<>'3F' ORDER BY BINARY a;
DROP TABLE t1;
set names cp932;
set collation_connection=cp932_bin;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          perl;
  # Compute relay log filename.  my $index_file= $ENV{'_RGEORL_INDEX_FILE'};
  my $channel_name= $ENV{'_RGEORL_CHANNEL_NAME'};
  # Remove the single quotes from $channel_name  $channel_name=~ s/\'//g;
  if ($channel_name) {    $index_file =~ s/(.*)(\.index)/$1-$channel_name$2/;
  }  # Read relay log filename.  open FILE, "$index_file" or die "Error $? opening $index_file: $!";
  my $relay_log_file= '';
  while (<FILE>) {    $relay_log_file= $_;
  }  chomp($relay_log_file);
  $relay_log_file =~ s{^\.[/\\]}{};
  close FILE or die "Error $? closing $index_file: $!";
  # Get relay log size.  my $datadir= $ENV{'_RGEORL_DATADIR'};
  my $relay_log_size= (stat("$datadir/$relay_log_file"))[7];
  # Write output file.  my $output_file= $ENV{'_RGEORL_OUTPUT_FILE'};
  open FILE, "> $output_file" or die "Error $? opening $output_file: $!";
  printf FILE "% 10d%s", $relay_log_size, $relay_log_file or die "Error $? writing to $output_file: $!";
  close FILE or die "Error $? writing to $output_file: $!";
EOF      if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                                    perl;
  use strict;
  my $stmt= $ENV{'_WRTF_STATEMENT'};
  # Connecting mysql to same mysqld as current connectiona  # by overriding port and socket  my $mysql= $ENV{'MYSQL'};
  my $server_port= $ENV{'_WRTF_SERVER_PORT'};
  my $server_socket= $ENV{'_WRTF_SERVER_SOCKET'};
  my $redirection_type= $ENV{'_WRTF_APPEND'} ? '>>' : '>';
  $mysql .= "   my $outfile = $ENV{'_WRTF_OUTPUT_FILE'};
  open MYSQL, "| $mysql $redirection_type $outfile" or die "Error $? opening MYSQL pipe '| $mysql > $outfile': $!";
  print MYSQL $stmt, ';' or die "Error $? printing statement '$stmt' to MYSQL pipe '| $mysql > $outfile': $!";
  close MYSQL or $ENV{'_WRTF_ALLOW_ERROR'} or die "Error $? closing MYSQL pipe '| $mysql > $outfile' reading '$stmt': $!";
EOF  if (!$include_silent)  {      }            perl;
  my $pre_script = $ENV{'_FF_PRE_SCRIPT'};
  $pre_script =~ s/DOLLAR/\$/g;
  my $script = $ENV{'_FF_SCRIPT'};
  $script =~ s/DOLLAR/\$/g;
  my $input_file = $ENV{'_FF_INPUT_FILE'};
  my $output_file = $ENV{'_FF_OUTPUT_FILE'};
  my $select_columns = $ENV{'_FF_SELECT_COLUMNS'};
  my $mask_columns = $ENV{'_FF_MASK_COLUMNS'};
  my $debug = $ENV{'_FF_DEBUG'};
  if ($select_columns)  {    chomp($select_columns);
    $select_columns =~ s/[, ]+/,/g;
    $script = '    chomp;
    my @cols = split(/\t/, $_);
    $_ = join("\t", map { $cols[$_ - 1] } ('.$select_columns.'));
    ' . $script;
  }  if ($mask_columns)  {    chomp($mask_columns);
    my $last_col = 0;
    my $regex = '';
    my $pending_tab = '';
    my $replacement = '';
    my $n = 1;
    for my $col (split(/\s*,\s*/, $mask_columns)) {      $regex .= '(' . $pending_tab . '[^\t]*\t' x ($col - $last_col - 1) . ')';
      $regex .= '(?:[^\t]*)';
      $pending_tab = '\t';
      $replacement .= '$' . $n . '#';
      $n++;
      $last_col = $col;
    }    $script = "s/$regex/$replacement/;
    $script";
  }  unless ($keep_quotes)  {    $pre_script = 'my %unquote = ("n"=>"\n","t"=>"\t","\\\\"=>"\\\\");' . $pre_script;
    $script .= ';s{\\\\(.)}{$unquote{$1}}ge;';
  }  if ($debug)  {    $script = 'print "BEFORE:\'$_\'";' . $script . 'print "AFTER:\'$_\'";'  }  # Generate a script (perl is faster if we avoid many calls to eval).  my $full_script =  open FILE, "< $input_file" or die "Error opening $input_file: $!";
  my $filtered_contents = "";
  my %column_names = ();
  '.$pre_script.';
  while (<FILE>)  {    chomp;
    s/\015?\012?$//;
    if ($mask_columns && !%column_names)    {      my $n = 1;
      %column_names = map { $_ => $n++ } split(/\t/, $_);
    }    else    {      ' . $script . '    }    if (length($_) > 0)    {      $filtered_contents .= $_."\n";
    }  }  close FILE or die "Error closing $input_file: $!";
  open FILE, "> $output_file" or die "Error opening $output_file: $!";
  binmode FILE;
  print FILE $filtered_contents or die "Error writing filtered contents to $output_file: $!";
  close FILE or die "Error closing $output_file: $!";
  return 0;
';
  if ($debug)  {    print STDOUT "full_script=<<END_OF_SCRIPT\n${full_script}END_OF_SCRIPT\n"  }  my $eval_ret = eval($full_script);
  defined($eval_ret) or die "Parse error or 'die' invoked when evaluating perl script '$full_script': $@";
  $eval_ret == 0 or die "Non-zero exit value $eval_ret from script '$script'";
EOF      if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                    if ($rpl_channel_name)  {      }    if ($rpl_channel_name)  {      }    if ($binlog_file == 'LAST')  {    if ($is_relay_log)    {          }    if (!$is_relay_log)    {          }  }      # If $binlog_start is not set, we will set it as the second event's  # position.  The first event(Description Event) is always ignored. For  # description event's length might be changed because of adding new events,  # 'SHOW BINLOG EVENTS LIMIT 1' is used to get the right value.                s{/\* xid=.* \*/}{/\* XID # \*/};
  s{COMMIT /\* XID # \*/}{COMMIT /\* XID \*/};
  s{table_id: [0-9]+}{table_id: #};
  s{file_id=[0-9]+}{file_id=#};
  s{block_len=[0-9]+}{block_len=#};
  s{Server ver:.*DOLLAR}{SERVER_VERSION, BINLOG_VERSION};
  s{SQL_LOAD-[a-z,0-9,-]*.[a-z]*}{SQL_LOAD-<SERVER UUID>-<MASTER server-id>-<file-id>.<extension>};
  s{rand_seed1=[0-9]*,rand_seed2=[0-9]*}{rand_seed1=<seed 1>,rand_seed2=<seed 2>};
  s{((?:master|slave|slave-relay)-bin\.[0-9]{6};pos=)[0-9]+DOLLAR}{DOLLAR1POS};
  s{(binlog\.[0-9]{6};pos=)[0-9]+DOLLAR}{DOLLAR1POS};
  s{SONAME ".*"}{SONAME "LIB"};
  s{DOLLARmysqltest_vardir}{MYSQLTEST_VARDIR}g;
||    let $pre_script= $pre_script    my DOLLARdec_size_regex = '(decompressed_size=[0-9]+ bytes)';
  ||        let $pre_script= $pre_script    my DOLLARuuid_regex = '[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}';
    my DOLLARuuid_gno_regex = DOLLARuuid_regex.'(?::[0-9]+(?:-[0-9]+)?)+';
  ||                  if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                  CREATE TABLE t1 (a CHAR(1)) CHARACTER SET utf8;
INSERT INTO t1 VALUES ('0'),('1'),('2'),('3'),('4'),('5'),('6'),('7');
INSERT INTO t1 VALUES ('8'),('9'),('A'),('B'),('C'),('D'),('E'),('F');
CREATE TEMPORARY TABLE head   AS SELECT concat(b1.a, b2.a) AS head   FROM t1 b1, t1 b2;
CREATE TEMPORARY TABLE tail   AS SELECT concat(b1.a, b2.a) AS tail   FROM t1 b1, t1 b2;
CREATE TEMPORARY TABLE middle AS SELECT concat(b1.a, b2.a) AS middle FROM t1 b1, t1 b2;
DROP TABLE t1;
CREATE TABLE t1 (a varchar(1)) CHARACTER SET utf8;
INSERT INTO t1 SELECT UNHEX(head)FROM head WHERE (head BETWEEN '00' AND '7F') ORDER BY head;
INSERT INTO t1SELECT UNHEX(CONCAT(head,tail))FROM head, tailWHERE (head BETWEEN 'C2' AND 'DF') AND (tail BETWEEN '80' AND 'BF')ORDER BY head, tail;
INSERT INTO t1SELECT UNHEX(CONCAT(head, middle, tail))FROM head, middle, tailWHERE (head BETWEEN 'E0' AND 'EF') AND (middle BETWEEN '80' AND 'BF')AND (tail BETWEEN '80' AND 'BF')AND NOT (head='E0' AND middle BETWEEN '80' AND '9F')AND NOT (head='ED' AND middle BETWEEN 'A0' AND 'BF')ORDER BY head, middle, tail;
SELECT count(*) FROM t1;
select @@collation_connection;
select hex(weight_string('a'));
select hex(weight_string('A'));
select hex(weight_string('abc'));
select hex(weight_string('abc' as char(2)));
select hex(weight_string('abc' as char(3)));
select hex(weight_string('abc' as char(5)));
select hex(weight_string('abc', 1, 2, 0xC0));
select hex(weight_string('abc', 2, 2, 0xC0));
select hex(weight_string('abc', 3, 2, 0xC0));
select hex(weight_string('abc', 4, 2, 0xC0));
select hex(weight_string('abc', 5, 2, 0xC0));
select hex(weight_string('abc',25, 2, 0xC0));
select hex(weight_string('abc', 1, 3, 0xC0));
select hex(weight_string('abc', 2, 3, 0xC0));
select hex(weight_string('abc', 3, 3, 0xC0));
select hex(weight_string('abc', 4, 3, 0xC0));
select hex(weight_string('abc', 5, 3, 0xC0));
select hex(weight_string('abc',25, 3, 0xC0));
select hex(weight_string('abc', 1, 4, 0xC0));
select hex(weight_string('abc', 2, 4, 0xC0));
select hex(weight_string('abc', 3, 4, 0xC0));
select hex(weight_string('abc', 4, 4, 0xC0));
select hex(weight_string('abc', 5, 4, 0xC0));
select hex(weight_string('abc',25, 4, 0xC0));
select collation(cast(0x8140 as char));
select hex(weight_string(cast(0x6141 as char)));
select hex(weight_string(cast(0x8140 as char)));
select hex(weight_string(cast(0x8140 as char) as char(1)));
select hex(weight_string(cast(0x81408140 as char) as char(1)));
select hex(weight_string(cast(0x8140 as char) as char(3)));
select hex(weight_string(cast(0x81408140 as char) as char(3)));
select hex(weight_string(cast(0x408140 as char) as char(3)));
select hex(weight_string(cast(0x4081408140 as char) as char(3)));
select hex(weight_string(cast(0x40814081408140 as char) as char(3)));
select hex(weight_string(cast(0x4040814081408140 as char) as char(3)));
select hex(weight_string(cast(0x814081408140 as char), 1, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 1, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 1, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 4, 0xC0));
select @@collation_connection;
select hex(weight_string('a'));
select hex(weight_string('A'));
select hex(weight_string('abc'));
select hex(weight_string('abc' as char(2)));
select hex(weight_string('abc' as char(3)));
select hex(weight_string('abc' as char(5)));
select hex(weight_string('abc', 1, 2, 0xC0));
select hex(weight_string('abc', 2, 2, 0xC0));
select hex(weight_string('abc', 3, 2, 0xC0));
select hex(weight_string('abc', 4, 2, 0xC0));
select hex(weight_string('abc', 5, 2, 0xC0));
select hex(weight_string('abc',25, 2, 0xC0));
select hex(weight_string('abc', 1, 3, 0xC0));
select hex(weight_string('abc', 2, 3, 0xC0));
select hex(weight_string('abc', 3, 3, 0xC0));
select hex(weight_string('abc', 4, 3, 0xC0));
select hex(weight_string('abc', 5, 3, 0xC0));
select hex(weight_string('abc',25, 3, 0xC0));
select hex(weight_string('abc', 1, 4, 0xC0));
select hex(weight_string('abc', 2, 4, 0xC0));
select hex(weight_string('abc', 3, 4, 0xC0));
select hex(weight_string('abc', 4, 4, 0xC0));
select hex(weight_string('abc', 5, 4, 0xC0));
select hex(weight_string('abc',25, 4, 0xC0));
select collation(cast(0x8140 as char));
select hex(weight_string(cast(0x6141 as char)));
select hex(weight_string(cast(0x8140 as char)));
select hex(weight_string(cast(0x8140 as char) as char(1)));
select hex(weight_string(cast(0x81408140 as char) as char(1)));
select hex(weight_string(cast(0x8140 as char) as char(3)));
select hex(weight_string(cast(0x81408140 as char) as char(3)));
select hex(weight_string(cast(0x408140 as char) as char(3)));
select hex(weight_string(cast(0x4081408140 as char) as char(3)));
select hex(weight_string(cast(0x40814081408140 as char) as char(3)));
select hex(weight_string(cast(0x4040814081408140 as char) as char(3)));
select hex(weight_string(cast(0x814081408140 as char), 1, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 1, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 1, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 4, 0xC0));
SET @@GLOBAL.binlog_format=@previous_binlog_format__htnt542nh;
CREATE TABLE t4 (s1 CHAR(50) CHARACTER SET latin1,                 s2 CHAR(50) CHARACTER SET cp932,                 d DECIMAL(10,2))|CREATE PROCEDURE bug18293 (IN ins1 CHAR(50),                           IN ins2 CHAR(50) CHARACTER SET cp932,                           IN ind DECIMAL(10,2))  BEGIN    INSERT INTO t4 VALUES (ins1, ins2, ind);
  END|CALL bug18293("Foo's a Bar", _cp932 0xED40ED41ED42, 47.93);
SELECT HEX(s1),HEX(s2),d FROM t4;
DROP PROCEDURE bug18293;
DROP TABLE t4;
CREATE TABLE t1 (a varchar(16)) character set cp932;
INSERT INTO t1 VALUES (0x8372835E),(0x8352835E);
SELECT hex(a), hex(lower(a)), hex(upper(a)) FROM t1 ORDER BY binary(a);
DROP TABLE t1;
SET NAMES utf8;
SET collation_connection=cp932_japanese_ci;
CREATE TABLE t1 (b VARCHAR(2));
INSERT INTO t1 VALUES ('0'),('1'),('2'),('3'),('4'),('5'),('6'),('7');
INSERT INTO t1 VALUES ('8'),('9'),('A'),('B'),('C'),('D'),('E'),('F');
CREATE TEMPORARY TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2;
CREATE TEMPORARY TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2;
DROP TABLE t1;
CREATE TABLE t1 ASSELECT concat(head, tail) AS code, ' ' AS aFROM head, tailWHERE (head BETWEEN '80' AND 'FF') AND (head NOT BETWEEN 'A1' AND 'DF')AND (tail BETWEEN '20' AND 'FF')ORDER BY head, tail;
INSERT t1 (code) SELECT head FROM headWHERE (head BETWEEN 'A1' AND 'DF')ORDER BY head;
DROP TEMPORARY TABLE head, tail;
SHOW CREATE TABLE t1;
SET @@session.max_error_count = 64;
UPDATE IGNORE t1 SET a=unhex(code) ORDER BY code;
SET @@session.max_error_count = default;
SELECT COUNT(*) FROM t1;
SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=1;
SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=2;
SELECT code, hex(upper(a)), hex(lower(a)),a, upper(a), lower(a) FROM t1WHERE hex(a)<>hex(upper(a)) OR hex(a)<>hex(lower(a))ORDER BY code;
SELECT * FROM t1WHERE HEX(CAST(LOWER(a) AS CHAR CHARACTER SET utf8)) <>      HEX(LOWER(CAST(a AS CHAR CHARACTER SET utf8))) ORDER BY code;
SELECT * FROM t1WHERE HEX(CAST(UPPER(a) AS CHAR CHARACTER SET utf8)) <>      HEX(UPPER(CAST(a AS CHAR CHARACTER SET utf8))) ORDER BY code;
SELECT HEX(a), HEX(CONVERT(a USING utf8)) as b FROM t1WHERE a<>'' HAVING b<>'3F' ORDER BY code;
DROP TABLE t1;
SELECT HEX(a), HEX(CONVERT(a using cp932)) as b FROM t1 HAVING b<>'3F' ORDER BY BINARY a;
DROP TABLE t1;
set names cp932;
set collation_connection=cp932_bin;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          perl;
  # Compute relay log filename.  my $index_file= $ENV{'_RGEORL_INDEX_FILE'};
  my $channel_name= $ENV{'_RGEORL_CHANNEL_NAME'};
  # Remove the single quotes from $channel_name  $channel_name=~ s/\'//g;
  if ($channel_name) {    $index_file =~ s/(.*)(\.index)/$1-$channel_name$2/;
  }  # Read relay log filename.  open FILE, "$index_file" or die "Error $? opening $index_file: $!";
  my $relay_log_file= '';
  while (<FILE>) {    $relay_log_file= $_;
  }  chomp($relay_log_file);
  $relay_log_file =~ s{^\.[/\\]}{};
  close FILE or die "Error $? closing $index_file: $!";
  # Get relay log size.  my $datadir= $ENV{'_RGEORL_DATADIR'};
  my $relay_log_size= (stat("$datadir/$relay_log_file"))[7];
  # Write output file.  my $output_file= $ENV{'_RGEORL_OUTPUT_FILE'};
  open FILE, "> $output_file" or die "Error $? opening $output_file: $!";
  printf FILE "% 10d%s", $relay_log_size, $relay_log_file or die "Error $? writing to $output_file: $!";
  close FILE or die "Error $? writing to $output_file: $!";
EOF      if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                                    perl;
  use strict;
  my $stmt= $ENV{'_WRTF_STATEMENT'};
  # Connecting mysql to same mysqld as current connectiona  # by overriding port and socket  my $mysql= $ENV{'MYSQL'};
  my $server_port= $ENV{'_WRTF_SERVER_PORT'};
  my $server_socket= $ENV{'_WRTF_SERVER_SOCKET'};
  my $redirection_type= $ENV{'_WRTF_APPEND'} ? '>>' : '>';
  $mysql .= "   my $outfile = $ENV{'_WRTF_OUTPUT_FILE'};
  open MYSQL, "| $mysql $redirection_type $outfile" or die "Error $? opening MYSQL pipe '| $mysql > $outfile': $!";
  print MYSQL $stmt, ';' or die "Error $? printing statement '$stmt' to MYSQL pipe '| $mysql > $outfile': $!";
  close MYSQL or $ENV{'_WRTF_ALLOW_ERROR'} or die "Error $? closing MYSQL pipe '| $mysql > $outfile' reading '$stmt': $!";
EOF  if (!$include_silent)  {      }            perl;
  my $pre_script = $ENV{'_FF_PRE_SCRIPT'};
  $pre_script =~ s/DOLLAR/\$/g;
  my $script = $ENV{'_FF_SCRIPT'};
  $script =~ s/DOLLAR/\$/g;
  my $input_file = $ENV{'_FF_INPUT_FILE'};
  my $output_file = $ENV{'_FF_OUTPUT_FILE'};
  my $select_columns = $ENV{'_FF_SELECT_COLUMNS'};
  my $mask_columns = $ENV{'_FF_MASK_COLUMNS'};
  my $debug = $ENV{'_FF_DEBUG'};
  if ($select_columns)  {    chomp($select_columns);
    $select_columns =~ s/[, ]+/,/g;
    $script = '    chomp;
    my @cols = split(/\t/, $_);
    $_ = join("\t", map { $cols[$_ - 1] } ('.$select_columns.'));
    ' . $script;
  }  if ($mask_columns)  {    chomp($mask_columns);
    my $last_col = 0;
    my $regex = '';
    my $pending_tab = '';
    my $replacement = '';
    my $n = 1;
    for my $col (split(/\s*,\s*/, $mask_columns)) {      $regex .= '(' . $pending_tab . '[^\t]*\t' x ($col - $last_col - 1) . ')';
      $regex .= '(?:[^\t]*)';
      $pending_tab = '\t';
      $replacement .= '$' . $n . '#';
      $n++;
      $last_col = $col;
    }    $script = "s/$regex/$replacement/;
    $script";
  }  unless ($keep_quotes)  {    $pre_script = 'my %unquote = ("n"=>"\n","t"=>"\t","\\\\"=>"\\\\");' . $pre_script;
    $script .= ';s{\\\\(.)}{$unquote{$1}}ge;';
  }  if ($debug)  {    $script = 'print "BEFORE:\'$_\'";' . $script . 'print "AFTER:\'$_\'";'  }  # Generate a script (perl is faster if we avoid many calls to eval).  my $full_script =  open FILE, "< $input_file" or die "Error opening $input_file: $!";
  my $filtered_contents = "";
  my %column_names = ();
  '.$pre_script.';
  while (<FILE>)  {    chomp;
    s/\015?\012?$//;
    if ($mask_columns && !%column_names)    {      my $n = 1;
      %column_names = map { $_ => $n++ } split(/\t/, $_);
    }    else    {      ' . $script . '    }    if (length($_) > 0)    {      $filtered_contents .= $_."\n";
    }  }  close FILE or die "Error closing $input_file: $!";
  open FILE, "> $output_file" or die "Error opening $output_file: $!";
  binmode FILE;
  print FILE $filtered_contents or die "Error writing filtered contents to $output_file: $!";
  close FILE or die "Error closing $output_file: $!";
  return 0;
';
  if ($debug)  {    print STDOUT "full_script=<<END_OF_SCRIPT\n${full_script}END_OF_SCRIPT\n"  }  my $eval_ret = eval($full_script);
  defined($eval_ret) or die "Parse error or 'die' invoked when evaluating perl script '$full_script': $@";
  $eval_ret == 0 or die "Non-zero exit value $eval_ret from script '$script'";
EOF      if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                    if ($rpl_channel_name)  {      }    if ($rpl_channel_name)  {      }    if ($binlog_file == 'LAST')  {    if ($is_relay_log)    {          }    if (!$is_relay_log)    {          }  }      # If $binlog_start is not set, we will set it as the second event's  # position.  The first event(Description Event) is always ignored. For  # description event's length might be changed because of adding new events,  # 'SHOW BINLOG EVENTS LIMIT 1' is used to get the right value.                s{/\* xid=.* \*/}{/\* XID # \*/};
  s{COMMIT /\* XID # \*/}{COMMIT /\* XID \*/};
  s{table_id: [0-9]+}{table_id: #};
  s{file_id=[0-9]+}{file_id=#};
  s{block_len=[0-9]+}{block_len=#};
  s{Server ver:.*DOLLAR}{SERVER_VERSION, BINLOG_VERSION};
  s{SQL_LOAD-[a-z,0-9,-]*.[a-z]*}{SQL_LOAD-<SERVER UUID>-<MASTER server-id>-<file-id>.<extension>};
  s{rand_seed1=[0-9]*,rand_seed2=[0-9]*}{rand_seed1=<seed 1>,rand_seed2=<seed 2>};
  s{((?:master|slave|slave-relay)-bin\.[0-9]{6};pos=)[0-9]+DOLLAR}{DOLLAR1POS};
  s{(binlog\.[0-9]{6};pos=)[0-9]+DOLLAR}{DOLLAR1POS};
  s{SONAME ".*"}{SONAME "LIB"};
  s{DOLLARmysqltest_vardir}{MYSQLTEST_VARDIR}g;
||    let $pre_script= $pre_script    my DOLLARdec_size_regex = '(decompressed_size=[0-9]+ bytes)';
  ||        let $pre_script= $pre_script    my DOLLARuuid_regex = '[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}';
    my DOLLARuuid_gno_regex = DOLLARuuid_regex.'(?::[0-9]+(?:-[0-9]+)?)+';
  ||                  if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                  CREATE TABLE t1 (a CHAR(1)) CHARACTER SET utf8;
INSERT INTO t1 VALUES ('0'),('1'),('2'),('3'),('4'),('5'),('6'),('7');
INSERT INTO t1 VALUES ('8'),('9'),('A'),('B'),('C'),('D'),('E'),('F');
CREATE TEMPORARY TABLE head   AS SELECT concat(b1.a, b2.a) AS head   FROM t1 b1, t1 b2;
CREATE TEMPORARY TABLE tail   AS SELECT concat(b1.a, b2.a) AS tail   FROM t1 b1, t1 b2;
CREATE TEMPORARY TABLE middle AS SELECT concat(b1.a, b2.a) AS middle FROM t1 b1, t1 b2;
DROP TABLE t1;
CREATE TABLE t1 (a varchar(1)) CHARACTER SET utf8;
INSERT INTO t1 SELECT UNHEX(head)FROM head WHERE (head BETWEEN '00' AND '7F') ORDER BY head;
INSERT INTO t1SELECT UNHEX(CONCAT(head,tail))FROM head, tailWHERE (head BETWEEN 'C2' AND 'DF') AND (tail BETWEEN '80' AND 'BF')ORDER BY head, tail;
INSERT INTO t1SELECT UNHEX(CONCAT(head, middle, tail))FROM head, middle, tailWHERE (head BETWEEN 'E0' AND 'EF') AND (middle BETWEEN '80' AND 'BF')AND (tail BETWEEN '80' AND 'BF')AND NOT (head='E0' AND middle BETWEEN '80' AND '9F')AND NOT (head='ED' AND middle BETWEEN 'A0' AND 'BF')ORDER BY head, middle, tail;
SELECT count(*) FROM t1;
select @@collation_connection;
select hex(weight_string('a'));
select hex(weight_string('A'));
select hex(weight_string('abc'));
select hex(weight_string('abc' as char(2)));
select hex(weight_string('abc' as char(3)));
select hex(weight_string('abc' as char(5)));
select hex(weight_string('abc', 1, 2, 0xC0));
select hex(weight_string('abc', 2, 2, 0xC0));
select hex(weight_string('abc', 3, 2, 0xC0));
select hex(weight_string('abc', 4, 2, 0xC0));
select hex(weight_string('abc', 5, 2, 0xC0));
select hex(weight_string('abc',25, 2, 0xC0));
select hex(weight_string('abc', 1, 3, 0xC0));
select hex(weight_string('abc', 2, 3, 0xC0));
select hex(weight_string('abc', 3, 3, 0xC0));
select hex(weight_string('abc', 4, 3, 0xC0));
select hex(weight_string('abc', 5, 3, 0xC0));
select hex(weight_string('abc',25, 3, 0xC0));
select hex(weight_string('abc', 1, 4, 0xC0));
select hex(weight_string('abc', 2, 4, 0xC0));
select hex(weight_string('abc', 3, 4, 0xC0));
select hex(weight_string('abc', 4, 4, 0xC0));
select hex(weight_string('abc', 5, 4, 0xC0));
select hex(weight_string('abc',25, 4, 0xC0));
select collation(cast(0x8140 as char));
select hex(weight_string(cast(0x6141 as char)));
select hex(weight_string(cast(0x8140 as char)));
select hex(weight_string(cast(0x8140 as char) as char(1)));
select hex(weight_string(cast(0x81408140 as char) as char(1)));
select hex(weight_string(cast(0x8140 as char) as char(3)));
select hex(weight_string(cast(0x81408140 as char) as char(3)));
select hex(weight_string(cast(0x408140 as char) as char(3)));
select hex(weight_string(cast(0x4081408140 as char) as char(3)));
select hex(weight_string(cast(0x40814081408140 as char) as char(3)));
select hex(weight_string(cast(0x4040814081408140 as char) as char(3)));
select hex(weight_string(cast(0x814081408140 as char), 1, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 1, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 1, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 4, 0xC0));
select @@collation_connection;
select hex(weight_string('a'));
select hex(weight_string('A'));
select hex(weight_string('abc'));
select hex(weight_string('abc' as char(2)));
select hex(weight_string('abc' as char(3)));
select hex(weight_string('abc' as char(5)));
select hex(weight_string('abc', 1, 2, 0xC0));
select hex(weight_string('abc', 2, 2, 0xC0));
select hex(weight_string('abc', 3, 2, 0xC0));
select hex(weight_string('abc', 4, 2, 0xC0));
select hex(weight_string('abc', 5, 2, 0xC0));
select hex(weight_string('abc',25, 2, 0xC0));
select hex(weight_string('abc', 1, 3, 0xC0));
select hex(weight_string('abc', 2, 3, 0xC0));
select hex(weight_string('abc', 3, 3, 0xC0));
select hex(weight_string('abc', 4, 3, 0xC0));
select hex(weight_string('abc', 5, 3, 0xC0));
select hex(weight_string('abc',25, 3, 0xC0));
select hex(weight_string('abc', 1, 4, 0xC0));
select hex(weight_string('abc', 2, 4, 0xC0));
select hex(weight_string('abc', 3, 4, 0xC0));
select hex(weight_string('abc', 4, 4, 0xC0));
select hex(weight_string('abc', 5, 4, 0xC0));
select hex(weight_string('abc',25, 4, 0xC0));
select collation(cast(0x8140 as char));
select hex(weight_string(cast(0x6141 as char)));
select hex(weight_string(cast(0x8140 as char)));
select hex(weight_string(cast(0x8140 as char) as char(1)));
select hex(weight_string(cast(0x81408140 as char) as char(1)));
select hex(weight_string(cast(0x8140 as char) as char(3)));
select hex(weight_string(cast(0x81408140 as char) as char(3)));
select hex(weight_string(cast(0x408140 as char) as char(3)));
select hex(weight_string(cast(0x4081408140 as char) as char(3)));
select hex(weight_string(cast(0x40814081408140 as char) as char(3)));
select hex(weight_string(cast(0x4040814081408140 as char) as char(3)));
select hex(weight_string(cast(0x814081408140 as char), 1, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 1, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 1, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 4, 0xC0));
SET @@GLOBAL.binlog_format=@previous_binlog_format__htnt542nh;
CREATE TABLE t4 (s1 CHAR(50) CHARACTER SET latin1,                 s2 CHAR(50) CHARACTER SET cp932,                 d DECIMAL(10,2))|CREATE PROCEDURE bug18293 (IN ins1 CHAR(50),                           IN ins2 CHAR(50) CHARACTER SET cp932,                           IN ind DECIMAL(10,2))  BEGIN    INSERT INTO t4 VALUES (ins1, ins2, ind);
  END|CALL bug18293("Foo's a Bar", _cp932 0xED40ED41ED42, 47.93);
SELECT HEX(s1),HEX(s2),d FROM t4;
DROP PROCEDURE bug18293;
DROP TABLE t4;
CREATE TABLE t1 (a varchar(16)) character set cp932;
INSERT INTO t1 VALUES (0x8372835E),(0x8352835E);
SELECT hex(a), hex(lower(a)), hex(upper(a)) FROM t1 ORDER BY binary(a);
DROP TABLE t1;
SET NAMES utf8;
SET collation_connection=cp932_japanese_ci;
CREATE TABLE t1 (b VARCHAR(2));
INSERT INTO t1 VALUES ('0'),('1'),('2'),('3'),('4'),('5'),('6'),('7');
INSERT INTO t1 VALUES ('8'),('9'),('A'),('B'),('C'),('D'),('E'),('F');
CREATE TEMPORARY TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2;
CREATE TEMPORARY TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2;
DROP TABLE t1;
CREATE TABLE t1 ASSELECT concat(head, tail) AS code, ' ' AS aFROM head, tailWHERE (head BETWEEN '80' AND 'FF') AND (head NOT BETWEEN 'A1' AND 'DF')AND (tail BETWEEN '20' AND 'FF')ORDER BY head, tail;
INSERT t1 (code) SELECT head FROM headWHERE (head BETWEEN 'A1' AND 'DF')ORDER BY head;
DROP TEMPORARY TABLE head, tail;
SHOW CREATE TABLE t1;
SET @@session.max_error_count = 64;
UPDATE IGNORE t1 SET a=unhex(code) ORDER BY code;
SET @@session.max_error_count = default;
SELECT COUNT(*) FROM t1;
SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=1;
SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=2;
SELECT code, hex(upper(a)), hex(lower(a)),a, upper(a), lower(a) FROM t1WHERE hex(a)<>hex(upper(a)) OR hex(a)<>hex(lower(a))ORDER BY code;
SELECT * FROM t1WHERE HEX(CAST(LOWER(a) AS CHAR CHARACTER SET utf8)) <>      HEX(LOWER(CAST(a AS CHAR CHARACTER SET utf8))) ORDER BY code;
SELECT * FROM t1WHERE HEX(CAST(UPPER(a) AS CHAR CHARACTER SET utf8)) <>      HEX(UPPER(CAST(a AS CHAR CHARACTER SET utf8))) ORDER BY code;
SELECT HEX(a), HEX(CONVERT(a USING utf8)) as b FROM t1WHERE a<>'' HAVING b<>'3F' ORDER BY code;
DROP TABLE t1;
SELECT HEX(a), HEX(CONVERT(a using cp932)) as b FROM t1 HAVING b<>'3F' ORDER BY BINARY a;
DROP TABLE t1;
set names cp932;
set collation_connection=cp932_bin;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          perl;
  # Compute relay log filename.  my $index_file= $ENV{'_RGEORL_INDEX_FILE'};
  my $channel_name= $ENV{'_RGEORL_CHANNEL_NAME'};
  # Remove the single quotes from $channel_name  $channel_name=~ s/\'//g;
  if ($channel_name) {    $index_file =~ s/(.*)(\.index)/$1-$channel_name$2/;
  }  # Read relay log filename.  open FILE, "$index_file" or die "Error $? opening $index_file: $!";
  my $relay_log_file= '';
  while (<FILE>) {    $relay_log_file= $_;
  }  chomp($relay_log_file);
  $relay_log_file =~ s{^\.[/\\]}{};
  close FILE or die "Error $? closing $index_file: $!";
  # Get relay log size.  my $datadir= $ENV{'_RGEORL_DATADIR'};
  my $relay_log_size= (stat("$datadir/$relay_log_file"))[7];
  # Write output file.  my $output_file= $ENV{'_RGEORL_OUTPUT_FILE'};
  open FILE, "> $output_file" or die "Error $? opening $output_file: $!";
  printf FILE "% 10d%s", $relay_log_size, $relay_log_file or die "Error $? writing to $output_file: $!";
  close FILE or die "Error $? writing to $output_file: $!";
EOF      if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                                    perl;
  use strict;
  my $stmt= $ENV{'_WRTF_STATEMENT'};
  # Connecting mysql to same mysqld as current connectiona  # by overriding port and socket  my $mysql= $ENV{'MYSQL'};
  my $server_port= $ENV{'_WRTF_SERVER_PORT'};
  my $server_socket= $ENV{'_WRTF_SERVER_SOCKET'};
  my $redirection_type= $ENV{'_WRTF_APPEND'} ? '>>' : '>';
  $mysql .= "   my $outfile = $ENV{'_WRTF_OUTPUT_FILE'};
  open MYSQL, "| $mysql $redirection_type $outfile" or die "Error $? opening MYSQL pipe '| $mysql > $outfile': $!";
  print MYSQL $stmt, ';' or die "Error $? printing statement '$stmt' to MYSQL pipe '| $mysql > $outfile': $!";
  close MYSQL or $ENV{'_WRTF_ALLOW_ERROR'} or die "Error $? closing MYSQL pipe '| $mysql > $outfile' reading '$stmt': $!";
EOF  if (!$include_silent)  {      }            perl;
  my $pre_script = $ENV{'_FF_PRE_SCRIPT'};
  $pre_script =~ s/DOLLAR/\$/g;
  my $script = $ENV{'_FF_SCRIPT'};
  $script =~ s/DOLLAR/\$/g;
  my $input_file = $ENV{'_FF_INPUT_FILE'};
  my $output_file = $ENV{'_FF_OUTPUT_FILE'};
  my $select_columns = $ENV{'_FF_SELECT_COLUMNS'};
  my $mask_columns = $ENV{'_FF_MASK_COLUMNS'};
  my $debug = $ENV{'_FF_DEBUG'};
  if ($select_columns)  {    chomp($select_columns);
    $select_columns =~ s/[, ]+/,/g;
    $script = '    chomp;
    my @cols = split(/\t/, $_);
    $_ = join("\t", map { $cols[$_ - 1] } ('.$select_columns.'));
    ' . $script;
  }  if ($mask_columns)  {    chomp($mask_columns);
    my $last_col = 0;
    my $regex = '';
    my $pending_tab = '';
    my $replacement = '';
    my $n = 1;
    for my $col (split(/\s*,\s*/, $mask_columns)) {      $regex .= '(' . $pending_tab . '[^\t]*\t' x ($col - $last_col - 1) . ')';
      $regex .= '(?:[^\t]*)';
      $pending_tab = '\t';
      $replacement .= '$' . $n . '#';
      $n++;
      $last_col = $col;
    }    $script = "s/$regex/$replacement/;
    $script";
  }  unless ($keep_quotes)  {    $pre_script = 'my %unquote = ("n"=>"\n","t"=>"\t","\\\\"=>"\\\\");' . $pre_script;
    $script .= ';s{\\\\(.)}{$unquote{$1}}ge;';
  }  if ($debug)  {    $script = 'print "BEFORE:\'$_\'";' . $script . 'print "AFTER:\'$_\'";'  }  # Generate a script (perl is faster if we avoid many calls to eval).  my $full_script =  open FILE, "< $input_file" or die "Error opening $input_file: $!";
  my $filtered_contents = "";
  my %column_names = ();
  '.$pre_script.';
  while (<FILE>)  {    chomp;
    s/\015?\012?$//;
    if ($mask_columns && !%column_names)    {      my $n = 1;
      %column_names = map { $_ => $n++ } split(/\t/, $_);
    }    else    {      ' . $script . '    }    if (length($_) > 0)    {      $filtered_contents .= $_."\n";
    }  }  close FILE or die "Error closing $input_file: $!";
  open FILE, "> $output_file" or die "Error opening $output_file: $!";
  binmode FILE;
  print FILE $filtered_contents or die "Error writing filtered contents to $output_file: $!";
  close FILE or die "Error closing $output_file: $!";
  return 0;
';
  if ($debug)  {    print STDOUT "full_script=<<END_OF_SCRIPT\n${full_script}END_OF_SCRIPT\n"  }  my $eval_ret = eval($full_script);
  defined($eval_ret) or die "Parse error or 'die' invoked when evaluating perl script '$full_script': $@";
  $eval_ret == 0 or die "Non-zero exit value $eval_ret from script '$script'";
EOF      if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                    if ($rpl_channel_name)  {      }    if ($rpl_channel_name)  {      }    if ($binlog_file == 'LAST')  {    if ($is_relay_log)    {          }    if (!$is_relay_log)    {          }  }      # If $binlog_start is not set, we will set it as the second event's  # position.  The first event(Description Event) is always ignored. For  # description event's length might be changed because of adding new events,  # 'SHOW BINLOG EVENTS LIMIT 1' is used to get the right value.                s{/\* xid=.* \*/}{/\* XID # \*/};
  s{COMMIT /\* XID # \*/}{COMMIT /\* XID \*/};
  s{table_id: [0-9]+}{table_id: #};
  s{file_id=[0-9]+}{file_id=#};
  s{block_len=[0-9]+}{block_len=#};
  s{Server ver:.*DOLLAR}{SERVER_VERSION, BINLOG_VERSION};
  s{SQL_LOAD-[a-z,0-9,-]*.[a-z]*}{SQL_LOAD-<SERVER UUID>-<MASTER server-id>-<file-id>.<extension>};
  s{rand_seed1=[0-9]*,rand_seed2=[0-9]*}{rand_seed1=<seed 1>,rand_seed2=<seed 2>};
  s{((?:master|slave|slave-relay)-bin\.[0-9]{6};pos=)[0-9]+DOLLAR}{DOLLAR1POS};
  s{(binlog\.[0-9]{6};pos=)[0-9]+DOLLAR}{DOLLAR1POS};
  s{SONAME ".*"}{SONAME "LIB"};
  s{DOLLARmysqltest_vardir}{MYSQLTEST_VARDIR}g;
||    let $pre_script= $pre_script    my DOLLARdec_size_regex = '(decompressed_size=[0-9]+ bytes)';
  ||        let $pre_script= $pre_script    my DOLLARuuid_regex = '[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}';
    my DOLLARuuid_gno_regex = DOLLARuuid_regex.'(?::[0-9]+(?:-[0-9]+)?)+';
  ||                  if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                  CREATE TABLE t1 (a CHAR(1)) CHARACTER SET utf8;
INSERT INTO t1 VALUES ('0'),('1'),('2'),('3'),('4'),('5'),('6'),('7');
INSERT INTO t1 VALUES ('8'),('9'),('A'),('B'),('C'),('D'),('E'),('F');
CREATE TEMPORARY TABLE head   AS SELECT concat(b1.a, b2.a) AS head   FROM t1 b1, t1 b2;
CREATE TEMPORARY TABLE tail   AS SELECT concat(b1.a, b2.a) AS tail   FROM t1 b1, t1 b2;
CREATE TEMPORARY TABLE middle AS SELECT concat(b1.a, b2.a) AS middle FROM t1 b1, t1 b2;
DROP TABLE t1;
CREATE TABLE t1 (a varchar(1)) CHARACTER SET utf8;
INSERT INTO t1 SELECT UNHEX(head)FROM head WHERE (head BETWEEN '00' AND '7F') ORDER BY head;
INSERT INTO t1SELECT UNHEX(CONCAT(head,tail))FROM head, tailWHERE (head BETWEEN 'C2' AND 'DF') AND (tail BETWEEN '80' AND 'BF')ORDER BY head, tail;
INSERT INTO t1SELECT UNHEX(CONCAT(head, middle, tail))FROM head, middle, tailWHERE (head BETWEEN 'E0' AND 'EF') AND (middle BETWEEN '80' AND 'BF')AND (tail BETWEEN '80' AND 'BF')AND NOT (head='E0' AND middle BETWEEN '80' AND '9F')AND NOT (head='ED' AND middle BETWEEN 'A0' AND 'BF')ORDER BY head, middle, tail;
SELECT count(*) FROM t1;
select @@collation_connection;
select hex(weight_string('a'));
select hex(weight_string('A'));
select hex(weight_string('abc'));
select hex(weight_string('abc' as char(2)));
select hex(weight_string('abc' as char(3)));
select hex(weight_string('abc' as char(5)));
select hex(weight_string('abc', 1, 2, 0xC0));
select hex(weight_string('abc', 2, 2, 0xC0));
select hex(weight_string('abc', 3, 2, 0xC0));
select hex(weight_string('abc', 4, 2, 0xC0));
select hex(weight_string('abc', 5, 2, 0xC0));
select hex(weight_string('abc',25, 2, 0xC0));
select hex(weight_string('abc', 1, 3, 0xC0));
select hex(weight_string('abc', 2, 3, 0xC0));
select hex(weight_string('abc', 3, 3, 0xC0));
select hex(weight_string('abc', 4, 3, 0xC0));
select hex(weight_string('abc', 5, 3, 0xC0));
select hex(weight_string('abc',25, 3, 0xC0));
select hex(weight_string('abc', 1, 4, 0xC0));
select hex(weight_string('abc', 2, 4, 0xC0));
select hex(weight_string('abc', 3, 4, 0xC0));
select hex(weight_string('abc', 4, 4, 0xC0));
select hex(weight_string('abc', 5, 4, 0xC0));
select hex(weight_string('abc',25, 4, 0xC0));
select collation(cast(0x8140 as char));
select hex(weight_string(cast(0x6141 as char)));
select hex(weight_string(cast(0x8140 as char)));
select hex(weight_string(cast(0x8140 as char) as char(1)));
select hex(weight_string(cast(0x81408140 as char) as char(1)));
select hex(weight_string(cast(0x8140 as char) as char(3)));
select hex(weight_string(cast(0x81408140 as char) as char(3)));
select hex(weight_string(cast(0x408140 as char) as char(3)));
select hex(weight_string(cast(0x4081408140 as char) as char(3)));
select hex(weight_string(cast(0x40814081408140 as char) as char(3)));
select hex(weight_string(cast(0x4040814081408140 as char) as char(3)));
select hex(weight_string(cast(0x814081408140 as char), 1, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 1, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 1, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 4, 0xC0));
select @@collation_connection;
select hex(weight_string('a'));
select hex(weight_string('A'));
select hex(weight_string('abc'));
select hex(weight_string('abc' as char(2)));
select hex(weight_string('abc' as char(3)));
select hex(weight_string('abc' as char(5)));
select hex(weight_string('abc', 1, 2, 0xC0));
select hex(weight_string('abc', 2, 2, 0xC0));
select hex(weight_string('abc', 3, 2, 0xC0));
select hex(weight_string('abc', 4, 2, 0xC0));
select hex(weight_string('abc', 5, 2, 0xC0));
select hex(weight_string('abc',25, 2, 0xC0));
select hex(weight_string('abc', 1, 3, 0xC0));
select hex(weight_string('abc', 2, 3, 0xC0));
select hex(weight_string('abc', 3, 3, 0xC0));
select hex(weight_string('abc', 4, 3, 0xC0));
select hex(weight_string('abc', 5, 3, 0xC0));
select hex(weight_string('abc',25, 3, 0xC0));
select hex(weight_string('abc', 1, 4, 0xC0));
select hex(weight_string('abc', 2, 4, 0xC0));
select hex(weight_string('abc', 3, 4, 0xC0));
select hex(weight_string('abc', 4, 4, 0xC0));
select hex(weight_string('abc', 5, 4, 0xC0));
select hex(weight_string('abc',25, 4, 0xC0));
select collation(cast(0x8140 as char));
select hex(weight_string(cast(0x6141 as char)));
select hex(weight_string(cast(0x8140 as char)));
select hex(weight_string(cast(0x8140 as char) as char(1)));
select hex(weight_string(cast(0x81408140 as char) as char(1)));
select hex(weight_string(cast(0x8140 as char) as char(3)));
select hex(weight_string(cast(0x81408140 as char) as char(3)));
select hex(weight_string(cast(0x408140 as char) as char(3)));
select hex(weight_string(cast(0x4081408140 as char) as char(3)));
select hex(weight_string(cast(0x40814081408140 as char) as char(3)));
select hex(weight_string(cast(0x4040814081408140 as char) as char(3)));
select hex(weight_string(cast(0x814081408140 as char), 1, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 1, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 1, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 4, 0xC0));
SET @@GLOBAL.binlog_format=@previous_binlog_format__htnt542nh;
CREATE TABLE t4 (s1 CHAR(50) CHARACTER SET latin1,                 s2 CHAR(50) CHARACTER SET cp932,                 d DECIMAL(10,2))|CREATE PROCEDURE bug18293 (IN ins1 CHAR(50),                           IN ins2 CHAR(50) CHARACTER SET cp932,                           IN ind DECIMAL(10,2))  BEGIN    INSERT INTO t4 VALUES (ins1, ins2, ind);
  END|CALL bug18293("Foo's a Bar", _cp932 0xED40ED41ED42, 47.93);
SELECT HEX(s1),HEX(s2),d FROM t4;
DROP PROCEDURE bug18293;
DROP TABLE t4;
CREATE TABLE t1 (a varchar(16)) character set cp932;
INSERT INTO t1 VALUES (0x8372835E),(0x8352835E);
SELECT hex(a), hex(lower(a)), hex(upper(a)) FROM t1 ORDER BY binary(a);
DROP TABLE t1;
SET NAMES utf8;
SET collation_connection=cp932_japanese_ci;
CREATE TABLE t1 (b VARCHAR(2));
INSERT INTO t1 VALUES ('0'),('1'),('2'),('3'),('4'),('5'),('6'),('7');
INSERT INTO t1 VALUES ('8'),('9'),('A'),('B'),('C'),('D'),('E'),('F');
CREATE TEMPORARY TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2;
CREATE TEMPORARY TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2;
DROP TABLE t1;
CREATE TABLE t1 ASSELECT concat(head, tail) AS code, ' ' AS aFROM head, tailWHERE (head BETWEEN '80' AND 'FF') AND (head NOT BETWEEN 'A1' AND 'DF')AND (tail BETWEEN '20' AND 'FF')ORDER BY head, tail;
INSERT t1 (code) SELECT head FROM headWHERE (head BETWEEN 'A1' AND 'DF')ORDER BY head;
DROP TEMPORARY TABLE head, tail;
SHOW CREATE TABLE t1;
SET @@session.max_error_count = 64;
UPDATE IGNORE t1 SET a=unhex(code) ORDER BY code;
SET @@session.max_error_count = default;
SELECT COUNT(*) FROM t1;
SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=1;
SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=2;
SELECT code, hex(upper(a)), hex(lower(a)),a, upper(a), lower(a) FROM t1WHERE hex(a)<>hex(upper(a)) OR hex(a)<>hex(lower(a))ORDER BY code;
SELECT * FROM t1WHERE HEX(CAST(LOWER(a) AS CHAR CHARACTER SET utf8)) <>      HEX(LOWER(CAST(a AS CHAR CHARACTER SET utf8))) ORDER BY code;
SELECT * FROM t1WHERE HEX(CAST(UPPER(a) AS CHAR CHARACTER SET utf8)) <>      HEX(UPPER(CAST(a AS CHAR CHARACTER SET utf8))) ORDER BY code;
SELECT HEX(a), HEX(CONVERT(a USING utf8)) as b FROM t1WHERE a<>'' HAVING b<>'3F' ORDER BY code;
DROP TABLE t1;
SELECT HEX(a), HEX(CONVERT(a using cp932)) as b FROM t1 HAVING b<>'3F' ORDER BY BINARY a;
DROP TABLE t1;
set names cp932;
set collation_connection=cp932_bin;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          perl;
  # Compute relay log filename.  my $index_file= $ENV{'_RGEORL_INDEX_FILE'};
  my $channel_name= $ENV{'_RGEORL_CHANNEL_NAME'};
  # Remove the single quotes from $channel_name  $channel_name=~ s/\'//g;
  if ($channel_name) {    $index_file =~ s/(.*)(\.index)/$1-$channel_name$2/;
  }  # Read relay log filename.  open FILE, "$index_file" or die "Error $? opening $index_file: $!";
  my $relay_log_file= '';
  while (<FILE>) {    $relay_log_file= $_;
  }  chomp($relay_log_file);
  $relay_log_file =~ s{^\.[/\\]}{};
  close FILE or die "Error $? closing $index_file: $!";
  # Get relay log size.  my $datadir= $ENV{'_RGEORL_DATADIR'};
  my $relay_log_size= (stat("$datadir/$relay_log_file"))[7];
  # Write output file.  my $output_file= $ENV{'_RGEORL_OUTPUT_FILE'};
  open FILE, "> $output_file" or die "Error $? opening $output_file: $!";
  printf FILE "% 10d%s", $relay_log_size, $relay_log_file or die "Error $? writing to $output_file: $!";
  close FILE or die "Error $? writing to $output_file: $!";
EOF      if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                                    perl;
  use strict;
  my $stmt= $ENV{'_WRTF_STATEMENT'};
  # Connecting mysql to same mysqld as current connectiona  # by overriding port and socket  my $mysql= $ENV{'MYSQL'};
  my $server_port= $ENV{'_WRTF_SERVER_PORT'};
  my $server_socket= $ENV{'_WRTF_SERVER_SOCKET'};
  my $redirection_type= $ENV{'_WRTF_APPEND'} ? '>>' : '>';
  $mysql .= "   my $outfile = $ENV{'_WRTF_OUTPUT_FILE'};
  open MYSQL, "| $mysql $redirection_type $outfile" or die "Error $? opening MYSQL pipe '| $mysql > $outfile': $!";
  print MYSQL $stmt, ';' or die "Error $? printing statement '$stmt' to MYSQL pipe '| $mysql > $outfile': $!";
  close MYSQL or $ENV{'_WRTF_ALLOW_ERROR'} or die "Error $? closing MYSQL pipe '| $mysql > $outfile' reading '$stmt': $!";
EOF  if (!$include_silent)  {      }            perl;
  my $pre_script = $ENV{'_FF_PRE_SCRIPT'};
  $pre_script =~ s/DOLLAR/\$/g;
  my $script = $ENV{'_FF_SCRIPT'};
  $script =~ s/DOLLAR/\$/g;
  my $input_file = $ENV{'_FF_INPUT_FILE'};
  my $output_file = $ENV{'_FF_OUTPUT_FILE'};
  my $select_columns = $ENV{'_FF_SELECT_COLUMNS'};
  my $mask_columns = $ENV{'_FF_MASK_COLUMNS'};
  my $debug = $ENV{'_FF_DEBUG'};
  if ($select_columns)  {    chomp($select_columns);
    $select_columns =~ s/[, ]+/,/g;
    $script = '    chomp;
    my @cols = split(/\t/, $_);
    $_ = join("\t", map { $cols[$_ - 1] } ('.$select_columns.'));
    ' . $script;
  }  if ($mask_columns)  {    chomp($mask_columns);
    my $last_col = 0;
    my $regex = '';
    my $pending_tab = '';
    my $replacement = '';
    my $n = 1;
    for my $col (split(/\s*,\s*/, $mask_columns)) {      $regex .= '(' . $pending_tab . '[^\t]*\t' x ($col - $last_col - 1) . ')';
      $regex .= '(?:[^\t]*)';
      $pending_tab = '\t';
      $replacement .= '$' . $n . '#';
      $n++;
      $last_col = $col;
    }    $script = "s/$regex/$replacement/;
    $script";
  }  unless ($keep_quotes)  {    $pre_script = 'my %unquote = ("n"=>"\n","t"=>"\t","\\\\"=>"\\\\");' . $pre_script;
    $script .= ';s{\\\\(.)}{$unquote{$1}}ge;';
  }  if ($debug)  {    $script = 'print "BEFORE:\'$_\'";' . $script . 'print "AFTER:\'$_\'";'  }  # Generate a script (perl is faster if we avoid many calls to eval).  my $full_script =  open FILE, "< $input_file" or die "Error opening $input_file: $!";
  my $filtered_contents = "";
  my %column_names = ();
  '.$pre_script.';
  while (<FILE>)  {    chomp;
    s/\015?\012?$//;
    if ($mask_columns && !%column_names)    {      my $n = 1;
      %column_names = map { $_ => $n++ } split(/\t/, $_);
    }    else    {      ' . $script . '    }    if (length($_) > 0)    {      $filtered_contents .= $_."\n";
    }  }  close FILE or die "Error closing $input_file: $!";
  open FILE, "> $output_file" or die "Error opening $output_file: $!";
  binmode FILE;
  print FILE $filtered_contents or die "Error writing filtered contents to $output_file: $!";
  close FILE or die "Error closing $output_file: $!";
  return 0;
';
  if ($debug)  {    print STDOUT "full_script=<<END_OF_SCRIPT\n${full_script}END_OF_SCRIPT\n"  }  my $eval_ret = eval($full_script);
  defined($eval_ret) or die "Parse error or 'die' invoked when evaluating perl script '$full_script': $@";
  $eval_ret == 0 or die "Non-zero exit value $eval_ret from script '$script'";
EOF      if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                    if ($rpl_channel_name)  {      }    if ($rpl_channel_name)  {      }    if ($binlog_file == 'LAST')  {    if ($is_relay_log)    {          }    if (!$is_relay_log)    {          }  }      # If $binlog_start is not set, we will set it as the second event's  # position.  The first event(Description Event) is always ignored. For  # description event's length might be changed because of adding new events,  # 'SHOW BINLOG EVENTS LIMIT 1' is used to get the right value.                s{/\* xid=.* \*/}{/\* XID # \*/};
  s{COMMIT /\* XID # \*/}{COMMIT /\* XID \*/};
  s{table_id: [0-9]+}{table_id: #};
  s{file_id=[0-9]+}{file_id=#};
  s{block_len=[0-9]+}{block_len=#};
  s{Server ver:.*DOLLAR}{SERVER_VERSION, BINLOG_VERSION};
  s{SQL_LOAD-[a-z,0-9,-]*.[a-z]*}{SQL_LOAD-<SERVER UUID>-<MASTER server-id>-<file-id>.<extension>};
  s{rand_seed1=[0-9]*,rand_seed2=[0-9]*}{rand_seed1=<seed 1>,rand_seed2=<seed 2>};
  s{((?:master|slave|slave-relay)-bin\.[0-9]{6};pos=)[0-9]+DOLLAR}{DOLLAR1POS};
  s{(binlog\.[0-9]{6};pos=)[0-9]+DOLLAR}{DOLLAR1POS};
  s{SONAME ".*"}{SONAME "LIB"};
  s{DOLLARmysqltest_vardir}{MYSQLTEST_VARDIR}g;
||    let $pre_script= $pre_script    my DOLLARdec_size_regex = '(decompressed_size=[0-9]+ bytes)';
  ||        let $pre_script= $pre_script    my DOLLARuuid_regex = '[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}';
    my DOLLARuuid_gno_regex = DOLLARuuid_regex.'(?::[0-9]+(?:-[0-9]+)?)+';
  ||                  if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                  CREATE TABLE t1 (a CHAR(1)) CHARACTER SET utf8;
INSERT INTO t1 VALUES ('0'),('1'),('2'),('3'),('4'),('5'),('6'),('7');
INSERT INTO t1 VALUES ('8'),('9'),('A'),('B'),('C'),('D'),('E'),('F');
CREATE TEMPORARY TABLE head   AS SELECT concat(b1.a, b2.a) AS head   FROM t1 b1, t1 b2;
CREATE TEMPORARY TABLE tail   AS SELECT concat(b1.a, b2.a) AS tail   FROM t1 b1, t1 b2;
CREATE TEMPORARY TABLE middle AS SELECT concat(b1.a, b2.a) AS middle FROM t1 b1, t1 b2;
DROP TABLE t1;
CREATE TABLE t1 (a varchar(1)) CHARACTER SET utf8;
INSERT INTO t1 SELECT UNHEX(head)FROM head WHERE (head BETWEEN '00' AND '7F') ORDER BY head;
INSERT INTO t1SELECT UNHEX(CONCAT(head,tail))FROM head, tailWHERE (head BETWEEN 'C2' AND 'DF') AND (tail BETWEEN '80' AND 'BF')ORDER BY head, tail;
INSERT INTO t1SELECT UNHEX(CONCAT(head, middle, tail))FROM head, middle, tailWHERE (head BETWEEN 'E0' AND 'EF') AND (middle BETWEEN '80' AND 'BF')AND (tail BETWEEN '80' AND 'BF')AND NOT (head='E0' AND middle BETWEEN '80' AND '9F')AND NOT (head='ED' AND middle BETWEEN 'A0' AND 'BF')ORDER BY head, middle, tail;
SELECT count(*) FROM t1;
select @@collation_connection;
select hex(weight_string('a'));
select hex(weight_string('A'));
select hex(weight_string('abc'));
select hex(weight_string('abc' as char(2)));
select hex(weight_string('abc' as char(3)));
select hex(weight_string('abc' as char(5)));
select hex(weight_string('abc', 1, 2, 0xC0));
select hex(weight_string('abc', 2, 2, 0xC0));
select hex(weight_string('abc', 3, 2, 0xC0));
select hex(weight_string('abc', 4, 2, 0xC0));
select hex(weight_string('abc', 5, 2, 0xC0));
select hex(weight_string('abc',25, 2, 0xC0));
select hex(weight_string('abc', 1, 3, 0xC0));
select hex(weight_string('abc', 2, 3, 0xC0));
select hex(weight_string('abc', 3, 3, 0xC0));
select hex(weight_string('abc', 4, 3, 0xC0));
select hex(weight_string('abc', 5, 3, 0xC0));
select hex(weight_string('abc',25, 3, 0xC0));
select hex(weight_string('abc', 1, 4, 0xC0));
select hex(weight_string('abc', 2, 4, 0xC0));
select hex(weight_string('abc', 3, 4, 0xC0));
select hex(weight_string('abc', 4, 4, 0xC0));
select hex(weight_string('abc', 5, 4, 0xC0));
select hex(weight_string('abc',25, 4, 0xC0));
select collation(cast(0x8140 as char));
select hex(weight_string(cast(0x6141 as char)));
select hex(weight_string(cast(0x8140 as char)));
select hex(weight_string(cast(0x8140 as char) as char(1)));
select hex(weight_string(cast(0x81408140 as char) as char(1)));
select hex(weight_string(cast(0x8140 as char) as char(3)));
select hex(weight_string(cast(0x81408140 as char) as char(3)));
select hex(weight_string(cast(0x408140 as char) as char(3)));
select hex(weight_string(cast(0x4081408140 as char) as char(3)));
select hex(weight_string(cast(0x40814081408140 as char) as char(3)));
select hex(weight_string(cast(0x4040814081408140 as char) as char(3)));
select hex(weight_string(cast(0x814081408140 as char), 1, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 1, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 1, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 4, 0xC0));
select @@collation_connection;
select hex(weight_string('a'));
select hex(weight_string('A'));
select hex(weight_string('abc'));
select hex(weight_string('abc' as char(2)));
select hex(weight_string('abc' as char(3)));
select hex(weight_string('abc' as char(5)));
select hex(weight_string('abc', 1, 2, 0xC0));
select hex(weight_string('abc', 2, 2, 0xC0));
select hex(weight_string('abc', 3, 2, 0xC0));
select hex(weight_string('abc', 4, 2, 0xC0));
select hex(weight_string('abc', 5, 2, 0xC0));
select hex(weight_string('abc',25, 2, 0xC0));
select hex(weight_string('abc', 1, 3, 0xC0));
select hex(weight_string('abc', 2, 3, 0xC0));
select hex(weight_string('abc', 3, 3, 0xC0));
select hex(weight_string('abc', 4, 3, 0xC0));
select hex(weight_string('abc', 5, 3, 0xC0));
select hex(weight_string('abc',25, 3, 0xC0));
select hex(weight_string('abc', 1, 4, 0xC0));
select hex(weight_string('abc', 2, 4, 0xC0));
select hex(weight_string('abc', 3, 4, 0xC0));
select hex(weight_string('abc', 4, 4, 0xC0));
select hex(weight_string('abc', 5, 4, 0xC0));
select hex(weight_string('abc',25, 4, 0xC0));
select collation(cast(0x8140 as char));
select hex(weight_string(cast(0x6141 as char)));
select hex(weight_string(cast(0x8140 as char)));
select hex(weight_string(cast(0x8140 as char) as char(1)));
select hex(weight_string(cast(0x81408140 as char) as char(1)));
select hex(weight_string(cast(0x8140 as char) as char(3)));
select hex(weight_string(cast(0x81408140 as char) as char(3)));
select hex(weight_string(cast(0x408140 as char) as char(3)));
select hex(weight_string(cast(0x4081408140 as char) as char(3)));
select hex(weight_string(cast(0x40814081408140 as char) as char(3)));
select hex(weight_string(cast(0x4040814081408140 as char) as char(3)));
select hex(weight_string(cast(0x814081408140 as char), 1, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 2, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 1, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 3, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 1, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 2, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 3, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 4, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char), 5, 4, 0xC0));
select hex(weight_string(cast(0x814081408140 as char),25, 4, 0xC0));
SET @@GLOBAL.binlog_format=@previous_binlog_format__htnt542nh;
CREATE TABLE t4 (s1 CHAR(50) CHARACTER SET latin1,                 s2 CHAR(50) CHARACTER SET cp932,                 d DECIMAL(10,2))|CREATE PROCEDURE bug18293 (IN ins1 CHAR(50),                           IN ins2 CHAR(50) CHARACTER SET cp932,                           IN ind DECIMAL(10,2))  BEGIN    INSERT INTO t4 VALUES (ins1, ins2, ind);
  END|CALL bug18293("Foo's a Bar", _cp932 0xED40ED41ED42, 47.93);
SELECT HEX(s1),HEX(s2),d FROM t4;
DROP PROCEDURE bug18293;
DROP TABLE t4;
CREATE TABLE t1 (a varchar(16)) character set cp932;
INSERT INTO t1 VALUES (0x8372835E),(0x8352835E);
SELECT hex(a), hex(lower(a)), hex(upper(a)) FROM t1 ORDER BY binary(a);
DROP TABLE t1;
SET NAMES utf8;
SET collation_connection=cp932_japanese_ci;
CREATE TABLE t1 (b VARCHAR(2));
INSERT INTO t1 VALUES ('0'),('1'),('2'),('3'),('4'),('5'),('6'),('7');
INSERT INTO t1 VALUES ('8'),('9'),('A'),('B'),('C'),('D'),('E'),('F');
CREATE TEMPORARY TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2;
CREATE TEMPORARY TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2;
DROP TABLE t1;
CREATE TABLE t1 ASSELECT concat(head, tail) AS code, ' ' AS aFROM head, tailWHERE (head BETWEEN '80' AND 'FF') AND (head NOT BETWEEN 'A1' AND 'DF')AND (tail BETWEEN '20' AND 'FF')ORDER BY head, tail;
INSERT t1 (code) SELECT head FROM headWHERE (head BETWEEN 'A1' AND 'DF')ORDER BY head;
DROP TEMPORARY TABLE head, tail;
SHOW CREATE TABLE t1;
SET @@session.max_error_count = 64;
UPDATE IGNORE t1 SET a=unhex(code) ORDER BY code;
SET @@session.max_error_count = default;
SELECT COUNT(*) FROM t1;
SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=1;
SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=2;
SELECT code, hex(upper(a)), hex(lower(a)),a, upper(a), lower(a) FROM t1WHERE hex(a)<>hex(upper(a)) OR hex(a)<>hex(lower(a))ORDER BY code;
SELECT * FROM t1WHERE HEX(CAST(LOWER(a) AS CHAR CHARACTER SET utf8)) <>      HEX(LOWER(CAST(a AS CHAR CHARACTER SET utf8))) ORDER BY code;
SELECT * FROM t1WHERE HEX(CAST(UPPER(a) AS CHAR CHARACTER SET utf8)) <>      HEX(UPPER(CAST(a AS CHAR CHARACTER SET utf8))) ORDER BY code;
SELECT HEX(a), HEX(CONVERT(a USING utf8)) as b FROM t1WHERE a<>'' HAVING b<>'3F' ORDER BY code;
DROP TABLE t1;
SELECT HEX(a), HEX(CONVERT(a using cp932)) as b FROM t1 HAVING b<>'3F' ORDER BY BINARY a;
DROP TABLE t1;
set names cp932;
set collation_connection=cp932_bin;
