  eval CREATE TABLE t (a INT, b INT, c INT, d INT, e INT, PRIMARY KEY(a, b, c, d), KEY(b, d)) ENGINE=$engine;
CREATE TEMPORARY TABLE a (a INT);
while ($i)    dec $i;
CREATE TEMPORARY TABLE b (a INT);
while ($i)    dec $i;
CREATE TEMPORARY TABLE c (a INT);
while ($i)    dec $i;
CREATE TEMPORARY TABLE d (a INT);
while ($i)    dec $i;
INSERT INTO t SELECT a.a, b.a, c.a, d.a, d.a FROM a, b, c, d  ORDER BY a.a, b.a, c.a, d.a;
DROP TEMPORARY TABLE a, b, c, d;
ANALYZE TABLE t;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }    if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                          while ($_dt_tables)      # Parse connection, if any    if ($_dt_colon_index)  {              }  # Parse database name, if any    if ($_dt_database_index)  {          }  if (!$_dt_database_index)  {      }  if ($rpl_debug)  {          }  # We need to sort the output files so that diff_files does not think  # the tables are different just because the rows are differently  # ordered.  To this end, we first generate a string containing a  # comma-separated list of all column names. This is used in the  # ORDER BY clause of the following SELECT statement. We get the  # column names from INFORMATION_SCHEMA.COLUMNS, and we concatenate  # them with GROUP_CONCAT. Since GROUP_CONCAT is limited by the  # @@SESSION.group_concat_max_len, which is only 1024 by default, we  # first compute the total size of all columns and then increase this  # limit if needed. We restore the limit afterwards so as not to  # interfere with the test case.  # Compute length of ORDER BY clause.  let $_dt_order_by_length=    `SELECT SUM(LENGTH(column_name) + 3) FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'JSON'                  $mask_column_clause`;
  if (!$_dt_order_by_length)  {          }    # Increase group_concat_max_len if needed.  if (`SELECT $_dt_order_by_length > @@SESSION.group_concat_max_len`)  {            if ($rpl_debug)    {          }  }  # Generate ORDER BY clause.  # It would be better to do GROUP_CONCAT(CONCAT('`', column_name, '`')) but  # BUG#58087 prevents us from returning strings that begin with backticks.  let $_dt_column_list=    `SELECT GROUP_CONCAT(column_name ORDER BY ORDINAL_POSITION SEPARATOR '`,`')            FROM information_schema.columns            WHERE table_schema = '$_dt_database' AND                  table_name = '$_dt_table' AND                  column_type != 'json'                  $mask_column_clause`;
  # Restore group_concat_max_len.  if ($_dt_old_group_concat_max_len)  {      }  if ($rpl_debug)  {      }  # Now that we have the comma-separated list of columns, we can write  # the table to a file.      # Certain columns which contain current timestamps can be masked out.  # $mask_column_list can be set in the test. If it is not defined,  # all the columns can be written to the file.  if ($mask_column_list) {      }  if (!$mask_column_list) {      }  if ($rpl_debug)  {      }  set @save_sbs = @@sort_buffer_size;
  set @@sort_buffer_size = 1048576;
    set @@sort_buffer_size = @save_sbs;
  # Compare files.  if ($_dt_prev_outfile)  {    if ($rpl_debug)    {          }        # Remove previous outfile. Keep current file for comparison with next table.      }  set optimizer_switch = 'skip_scan=on';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
set optimizer_switch = 'skip_scan=off';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
FLUSH STATUS;
SHOW STATUS LIKE 'handler_read%';
DROP TABLE skip_scan, no_skip_scan, hint_skip_scan;
    ALTER TABLE t DROP PRIMARY KEY;
  ALTER TABLE t DROP KEY b;
  ALTER TABLE t ADD PRIMARY KEY(a DESC, b, c DESC, d);
  ANALYZE TABLE t;
                            set optimizer_switch = default;
DROP TABLE t;
    CREATE TABLE t1 (a INT, b INT, c INT, d INT, e INT);
  INSERT INTO t1 VALUES  (NULL, 1, 1, 3, 4), (NULL, 2, 1, 4, 5),  (1, 2, 1, 3, 4), (2, 2, 1, 4, 5),  (5, 2, 3, 3, 4), (2, 2, 1, 4, 11),  (8, 2, 1, 3, 4), (7, 2, 1, 4, 9);
  INSERT INTO t1 SELECT * FROM t1;
  INSERT INTO t1 SELECT * FROM t1;
  INSERT INTO t1 SELECT * FROM t1;
  ALTER TABLE t1 ADD KEY k1(a DESC, b, c DESC, d, e DESC);
  ANALYZE TABLE t1;
      ALTER TABLE t1 DROP KEY k1;
  ALTER TABLE t1 ADD KEY k1(a, b DESC, c, d DESC, e);
  ANALYZE TABLE t1;
      set optimizer_switch = default;
  DROP TABLE t1;
