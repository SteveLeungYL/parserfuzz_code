SET @old_log_output=@@global.log_output;
SET GLOBAL log_output="FILE,TABLE";
drop table if exists t1,t2,t3,t4;
drop database if exists client_test_db;
create table t1  a int primary key,  b char(10));
insert into t1 values (1,'one');
insert into t1 values (2,'two');
insert into t1 values (3,'three');
insert into t1 values (4,'four');
set @a=2;
prepare stmt1 from 'select * from t1 where a <= ?';
execute stmt1 using @a;
set @a=3;
execute stmt1 using @a;
deallocate prepare no_such_statement;
execute stmt1;
prepare stmt2 from 'prepare nested_stmt from "select 1"';
prepare stmt2 from 'execute stmt1';
prepare stmt2 from 'deallocate prepare z';
prepare stmt3 from 'insert into t1 values (?,?)';
set @arg1=5, @arg2='five';
execute stmt3 using @arg1, @arg2;
select * from t1 where a>3;
prepare stmt4 from 'update t1 set a=? where b=?';
set @arg1=55, @arg2='five';
execute stmt4 using @arg1, @arg2;
select * from t1 where a>3;
prepare stmt4 from 'create table t2 (a int)';
execute stmt4;
prepare stmt4 from 'drop table t2';
execute stmt4;
execute stmt4;
prepare stmt5 from 'select ? + a from t1';
set @a=1;
execute stmt5 using @a;
execute stmt5 using @no_such_var;
set @nullvar=1;
set @nullvar=NULL;
execute stmt5 using @nullvar;
set @nullvar2=NULL;
execute stmt5 using @nullvar2;
prepare stmt6 from 'select 1; select2';
prepare stmt6 from 'insert into t1 values (5,"five"); select2';
explain prepare stmt6 from 'insert into t1 values (5,"five"); select2';
create table t2  a int);
insert into t2 values (0);
set @arg00=NULL ;
prepare stmt1 from 'select 1 FROM t2 where a=?' ;
execute stmt1 using @arg00 ;
prepare stmt1 from @nosuchvar;
set @ivar= 1234;
prepare stmt1 from @ivar;
set @fvar= 123.4567;
prepare stmt1 from @fvar;
drop table t1,t2;
deallocate prepare stmt3;
deallocate prepare stmt4;
deallocate prepare stmt5;
PREPARE stmt1 FROM "select _utf8 'A' collate utf8_bin = ?";
set @var='A';
EXECUTE stmt1 USING @var;
DEALLOCATE PREPARE stmt1;
create table t1 (id int);
prepare stmt1 from "select FOUND_ROWS()";
select SQL_CALC_FOUND_ROWS * from t1;
execute stmt1;
insert into t1 values (1);
select SQL_CALC_FOUND_ROWS * from t1;
execute stmt1;
execute stmt1;
deallocate prepare stmt1;
drop table t1;
create table t1   c1  tinyint, c2  smallint, c3  mediumint, c4  int,  c5  integer, c6  bigint, c7  float, c8  double,  c9  double precision, c10 real, c11 decimal(7, 4), c12 numeric(8, 4),  c13 date, c14 datetime, c15 timestamp, c16 time,  c17 year, c18 bit, c19 bool, c20 char,  c21 char(10), c22 varchar(30), c23 tinyblob, c24 tinytext,  c25 blob, c26 text, c27 mediumblob, c28 mediumtext,  c29 longblob, c30 longtext, c31 enum('one', 'two', 'three'),  c32 set('monday', 'tuesday', 'wednesday')) engine = MYISAM ;
create table t2 like t1;
set @stmt= ' explain SELECT (SELECT SUM(c1 + c12 + 0.0) FROM t2 where (t1.c2 - 0e-3) = t2.c2 GROUP BY t1.c15 LIMIT 1) as scalar_s, exists (select 1.0e+0 from t2 where t2.c3 * 9.0000000000 = t1.c4) as exists_s, c5 * 4 in (select c6 + 0.3e+1 from t2) as in_s, (c7 - 4, c8 - 4) in (select c9 + 4.0, c10 + 40e-1 from t2) as in_row_s FROM t1, (select c25 x, c32 y from t2) tt WHERE x * 1 = c25 ' ;
prepare stmt1 from @stmt ;
execute stmt1 ;
execute stmt1 ;
explain SELECT (SELECT SUM(c1 + c12 + 0.0) FROM t2 where (t1.c2 - 0e-3) = t2.c2 GROUP BY t1.c15 LIMIT 1) as scalar_s, exists (select 1.0e+0 from t2 where t2.c3 * 9.0000000000 = t1.c4) as exists_s, c5 * 4 in (select c6 + 0.3e+1 from t2) as in_s, (c7 - 4, c8 - 4) in (select c9 + 4.0, c10 + 40e-1 from t2) as in_row_s FROM t1, (select c25 x, c32 y from t2) tt WHERE x * 1 = c25;
deallocate prepare stmt1;
drop tables t1,t2;
set @arg00=1;
prepare stmt1 from ' create table t1 (m int) as select 1 as m ' ;
execute stmt1 ;
select m from t1;
drop table t1;
prepare stmt1 from ' create table t1 (m int) as select ? as m ' ;
execute stmt1 using @arg00;
select m from t1;
deallocate prepare stmt1;
drop table t1;
create table t1 (id int(10) unsigned NOT NULL default '0',                 name varchar(64) NOT NULL default '',                 PRIMARY KEY  (id), UNIQUE KEY `name` (`name`));
insert into t1 values (1,'1'),(2,'2'),(3,'3'),(4,'4'),(5,'5'),(6,'6'),(7,'7');
prepare stmt1 from 'select name from t1 where id=? or id=?';
set @id1=1,@id2=6;
execute stmt1 using @id1, @id2;
select name from t1 where id=1 or id=6;
deallocate prepare stmt1;
drop table t1;
create table t1 ( a int primary key, b varchar(30)) engine = MYISAM ;
analyze table t1;
prepare stmt1 from ' show table status from test like ''t1%'' ';
execute stmt1;
show table status from test like 't1%' ;
deallocate prepare stmt1 ;
drop table t1;
create table t1(a varchar(2), b varchar(3));
prepare stmt1 from "select a, b from t1 where (not (a='aa' and b < 'zzz'))";
execute stmt1;
execute stmt1;
deallocate prepare stmt1;
drop table t1;
prepare stmt1 from "select 1 into @var";
execute stmt1;
execute stmt1;
prepare stmt1 from "create table t1 select 1 as i";
execute stmt1;
drop table t1;
execute stmt1;
prepare stmt1 from "insert into t1 select i from t1";
execute stmt1;
execute stmt1;
eval prepare stmt1 from "select * from t1 into outfile '$outfile'";
execute stmt1;
deallocate prepare stmt1;
drop table t1;
prepare stmt1 from 'select 1';
prepare STMT1 from 'select 2';
execute sTmT1;
deallocate prepare StMt1;
deallocate prepare Stmt1;
set names utf8;
prepare `ü` from 'select 1234';
execute `ü` ;
set names latin1;
execute ``;
deallocate prepare ``;
set names default;
create table t1 (a varchar(10)) charset=utf8;
insert into t1 (a) values ('yahoo');
set character_set_connection=latin1;
prepare stmt from 'select a from t1 where a like ?';
set @var='google';
execute stmt using @var;
execute stmt using @var;
deallocate prepare stmt;
drop table t1;
create table t1 (a bigint(20) not null primary key auto_increment);
insert into t1 (a) values (null);
select * from t1;
prepare stmt from "insert into t1 (a) values (?)";
set @var=null;
execute stmt using @var;
select * from t1;
drop table t1;
create table t1 (a timestamp not null);
prepare stmt from "insert into t1 (a) values (CURRENT_TIMESTAMP)";
execute stmt;
select * from t1;
deallocate prepare stmt;
drop table t1;
prepare stmt from "select 'abc' like convert('abc' using utf8)";
execute stmt;
execute stmt;
deallocate prepare stmt;
create table t1 ( a bigint );
prepare stmt from 'select a from t1 where a between ? and ?';
set @a=1;
execute stmt using @a, @a;
execute stmt using @a, @a;
execute stmt using @a, @a;
drop table t1;
deallocate prepare stmt;
create table t1 (a int);
prepare stmt from "select * from t1 where 1 > (1 in (SELECT * FROM t1))";
execute stmt;
execute stmt;
execute stmt;
drop table t1;
deallocate prepare stmt;
create table t1 (a int, b int) engine = myisam;
insert into t1 (a, b) values (1,1), (1,2), (2,1), (2,2);
prepare stmt from"explain select * from t1 where t1.a=2 and t1.a=t1.b and t1.b > 1 + ?";
set @v=5;
execute stmt using @v;
set @v=0;
execute stmt using @v;
set @v=5;
execute stmt using @v;
drop table t1;
deallocate prepare stmt;
create table t1 (a int);
insert into t1 (a) values (1), (2), (3), (4);
set @precision=10000000000;
select rand(),        cast(rand(10)*@precision as unsigned integer) from t1;
prepare stmt from"select rand(),         cast(rand(10)*@precision as unsigned integer),        cast(rand(?)*@precision as unsigned integer) from t1";
set @var=1;
execute stmt using @var;
set @var=2;
execute stmt using @var;
set @var=3;
execute stmt using @var;
drop table t1;
deallocate prepare stmt;
create database mysqltest1;
create table t1 (a int);
create table mysqltest1.t1 (a int);
select * from t1, mysqltest1.t1;
prepare stmt from "select * from t1, mysqltest1.t1";
execute stmt;
execute stmt;
execute stmt;
drop table t1;
drop table mysqltest1.t1;
drop database mysqltest1;
deallocate prepare stmt; select '1.1' as a, '1.2' as a UNION SELECT '2.1', '2.2';
prepare stmt from"select '1.1' as a, '1.2' as a UNION SELECT '2.1', '2.2'";
execute stmt;
execute stmt;
execute stmt;
deallocate prepare stmt;
create table t1 (a int); insert into t1 values (1),(2),(3);
create table t2 select * from t1;
prepare stmt FROM 'create table t2 select * from t1';
drop table t2;
execute stmt;
drop table t2;
execute stmt;
execute stmt;
drop table t2;
execute stmt;
drop table t1,t2;
deallocate prepare stmt;
create table t1 (a int);
insert into t1 (a) values (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
prepare stmt from "select sql_calc_found_rows * from t1 limit 2";
execute stmt;
select found_rows();
execute stmt;
select found_rows();
execute stmt;
select found_rows();
deallocate prepare stmt;
drop table t1;
CREATE TABLE t1 (N int, M tinyint); INSERT INTO t1 VALUES (1,0),(1,0),(2,0),(2,0),(3,0);
PREPARE stmt FROM 'UPDATE t1 AS P1 INNER JOIN (SELECT N FROM t1 GROUP BY N HAVING COUNT(M) > 1) AS P2 ON P1.N = P2.N SET P1.M = 2';
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
DROP TABLE t1;
prepare stmt from "select ? is null, ? is not null, ?";
select @no_such_var is null, @no_such_var is not null, @no_such_var;
execute stmt using @no_such_var, @no_such_var, @no_such_var;
set @var='abc';
select @var is null, @var is not null, @var;
execute stmt using @var, @var, @var;
set @var=null;
select @var is null, @var is not null, @var;
execute stmt using @var, @var, @var;
create table t1 (pnum char(3));
create table t2 (pnum char(3));
prepare stmt from "select pnum from t2 having pnum in (select 'p1' from t1)";
execute stmt;
execute stmt;
execute stmt;
deallocate prepare stmt;
drop table t1, t2;
drop table if exists t1;
create temporary table if not exists t1 (a1 int);
prepare stmt from "delete t1 from t1 where (cast(a1/3 as unsigned) * 3) = a1";
drop temporary table t1;
create temporary table if not exists t1 (a1 int);
execute stmt;
drop temporary table t1;
create temporary table if not exists t1 (a1 int);
execute stmt;
drop temporary table t1;
create temporary table if not exists t1 (a1 int);
execute stmt;
drop temporary table t1;
deallocate prepare stmt;
create table t1 (a varchar(20)); insert into t1 values ('foo'); prepare stmt FROM 'SELECT char_length (a) FROM t1'; prepare stmt2 FROM 'SELECT not_a_function (a) FROM t1'; drop table t1;
prepare stmt from "SELECT SQL_CALC_FOUND_ROWS 'foo' UNION SELECT 'bar' LIMIT 0";
execute stmt;
SELECT FOUND_ROWS();
execute stmt;                                                                   SELECT FOUND_ROWS();                                                            deallocate prepare stmt;
drop table if exists t1;
create table t1 (c1 int(11) not null, c2 int(11) not null,             primary key  (c1,c2), key c2 (c2), key c1 (c1));
insert into t1 values (200887, 860);
insert into t1 values (200887, 200887);
select * from t1 where (c1=200887 and c2=200887) or c2=860;
prepare stmt from"select * from t1 where (c1=200887 and c2=200887) or c2=860";
execute stmt;
prepare stmt from"select * from t1 where (c1=200887 and c2=?) or c2=?";
set @a=200887, @b=860;
execute stmt using @a, @b;
deallocate prepare stmt;
drop table t1;
create table t1 (   id bigint(20) not null auto_increment,   code varchar(20) character set utf8 collate utf8_bin not null default '',   company_name varchar(250) character set utf8 collate utf8_bin default null,   setup_mode tinyint(4) default null,   start_date datetime default null,   primary key  (id), unique key code (code));
create table t2 (   id bigint(20) not null auto_increment,   email varchar(250) character set utf8 collate utf8_bin default null,   name varchar(250) character set utf8 collate utf8_bin default null,   t1_id bigint(20) default null,   password varchar(250) character set utf8 collate utf8_bin default null,   primary_contact tinyint(4) not null default '0',   email_opt_in tinyint(4) not null default '1',   primary key  (id), unique key email (email), key t1_id (t1_id),   constraint t2_fk1 foreign key (t1_id) references t1 (id));
insert into t1 values(1, 'demo', 'demo s', 0, current_date()),(2, 'code2', 'name 2', 0, current_date()),(3, 'code3', 'name 3', 0, current_date());
insert into t2 values(2, 'email1', 'name1', 3, 'password1', 0, 0),(3, 'email2', 'name1', 1, 'password2', 1, 0),(5, 'email3', 'name3', 2, 'password3', 0, 0);
prepare stmt from 'select t2.id from t2, t1 where (t1.id=? and t2.t1_id=t1.id)';
set @a=1;
execute stmt using @a;
select t2.id from t2, t1 where (t1.id=1 and t2.t1_id=t1.id);
deallocate prepare stmt;
drop table t2, t1;
create table t1 (id int);
prepare stmt from "insert into t1 (id) select id from t1 union select id from t1";
execute stmt;
execute stmt;
deallocate prepare stmt;
drop table t1;
create table t1 (  id int(11) unsigned not null primary key auto_increment,  partner_id varchar(35) not null,  t1_status_id int(10) unsigned);
insert into t1 values ("1", "partner1", "10"), ("2", "partner2", "10"),                      ("3", "partner3", "10"), ("4", "partner4", "10");
create table t2 (  id int(11) unsigned not null default '0',  t1_line_id int(11) unsigned not null default '0',  article_id varchar(20),  sequence int(11) not null default '0',  primary key  (id,t1_line_id));
insert into t2 values ("1", "1", "sup", "0"), ("2", "1", "sup", "1"),                      ("2", "2", "sup", "2"), ("2", "3", "sup", "3"),                      ("2", "4", "imp", "4"), ("3", "1", "sup", "0"),                      ("4", "1", "sup", "0");
create table t3 (  id int(11) not null default '0',  preceding_id int(11) not null default '0',  primary key  (id,preceding_id));
create table t4 (  user_id varchar(50) not null,  article_id varchar(20) not null,  primary key  (user_id,article_id));
insert into t4 values("nicke", "imp");
prepare stmt from'select distinct t1.partner_idfrom t1 left join t3 on t1.id = t3.id     left join t1 pp on pp.id = t3.preceding_idwhere  exists (    select *    from t2 as pl_inner    where pl_inner.id = t1.id    and pl_inner.sequence <= (      select min(sequence) from t2 pl_seqnr      where pl_seqnr.id = t1.id    )    and exists (      select * from t4      where t4.article_id = pl_inner.article_id      and t4.user_id = ?    )  )  and t1.id = ?group by t1.idhaving count(pp.id) = 0';
set @user_id = 'nicke';
set @id = '2';
execute stmt using @user_id, @id;
execute stmt using @user_id, @id;
deallocate prepare stmt;
drop table t1, t2, t3, t4;
prepare stmt from 'select ?=?';
set @a='CHRISTINE           ';
set @b='CHRISTINE';
execute stmt using @a, @b;
execute stmt using @a, @b;
set @a=1, @b=2;
execute stmt using @a, @b;
set @a='CHRISTINE           ';
set @b='CHRISTINE';
execute stmt using @a, @b;
deallocate prepare stmt;
create table t1 (a int);
prepare stmt from "select ??";
prepare stmt from "select ?FROM t1";
prepare stmt from "select FROM t1 WHERE?=1";
prepare stmt from "update t1 set a=a+?WHERE 1";
select ?;
select ??;
select ? from t1;
drop table t1;
prepare stmt from "select @@time_zone";
execute stmt;
set @@time_zone:='Japan';
execute stmt;
prepare stmt from "select @@transaction_isolation";
execute stmt;
set transaction isolation level read committed;
execute stmt;
set transaction isolation level serializable;
execute stmt;
set @@transaction_isolation=default;
execute stmt;
deallocate prepare stmt;
prepare stmt from "create temporary table t1 (letter enum('','a','b','c')not null)";
execute stmt;
drop table t1;
execute stmt;
drop table t1;
execute stmt;
drop table t1;
set names latin1;
prepare stmt from "create table t1 (a enum('test') default 'test') character set utf8";
execute stmt;
drop table t1;
execute stmt;
drop table t1;
execute stmt;
drop table t1;
set names default;
deallocate prepare stmt;
create table t1 (  word_id mediumint(8) unsigned not null default '0',  formatted varchar(20) not null default '');
insert into t1 values  (80,'pendant'), (475,'pretendants'), (989,'tendances'),  (1019,'cependant'),(1022,'abondance'),(1205,'independants'),  (13,'lessiver'),(25,'lambiner'),(46,'situer'),(71,'terminer'),  (82,'decrocher');
select count(*) from t1 where formatted like '%NDAN%';
select count(*) from t1 where formatted like '%ER';
prepare stmt from "select count(*) from t1 where formatted like ?";
set @like="%NDAN%";
execute stmt using @like;
set @like="%ER";
execute stmt using @like;
set @like="%NDAN%";
execute stmt using @like;
set @like="%ER";
execute stmt using @like;
deallocate prepare stmt;
drop table t1;
SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
prepare stmt from 'create table t1 (a varchar(10) character set utf8)';
execute stmt;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }insert into t1 (a) values (repeat('a', 20));
select length(a) from t1;
drop table t1;
execute stmt;
insert into t1 (a) values (repeat('a', 20));
select length(a) from t1;
drop table t1;
deallocate prepare stmt;
SET sql_mode = default;
create table t1 (col1 integer, col2 integer);
insert into t1 values(100,100),(101,101),(102,102),(103,103);
prepare stmt from 'select col1, col2 from t1 where (col1, col2) in ((?,?))';
set @a=100, @b=100;
execute stmt using @a,@b;
set @a=101, @b=101;
execute stmt using @a,@b;
set @a=102, @b=102;
execute stmt using @a,@b;
set @a=102, @b=103;
execute stmt using @a,@b;
deallocate prepare stmt;
drop table t1;
set @old_max_prepared_stmt_count= @@max_prepared_stmt_count;
show variables like 'max_prepared_stmt_count';
show status like 'prepared_stmt_count';
select @@max_prepared_stmt_count;
set global max_prepared_stmt_count=-1;
select @@max_prepared_stmt_count;
set global max_prepared_stmt_count=10000000000000000;
select @@max_prepared_stmt_count;
set global max_prepared_stmt_count=default;
select @@max_prepared_stmt_count;
set @@max_prepared_stmt_count=1;
set max_prepared_stmt_count=1;
set local max_prepared_stmt_count=1;
set global max_prepared_stmt_count=1;
select @@max_prepared_stmt_count;
set global max_prepared_stmt_count=0;
select @@max_prepared_stmt_count;
show status like 'prepared_stmt_count';
prepare stmt from "select 1";
show status like 'prepared_stmt_count';
set global max_prepared_stmt_count=1;
prepare stmt from "select 1";
show status like 'prepared_stmt_count';
prepare stmt1 from "select 1";
show status like 'prepared_stmt_count';
deallocate prepare stmt;
show status like 'prepared_stmt_count';
prepare stmt from "select 1";
show status like 'prepared_stmt_count';
prepare stmt from "select 2";
show status like 'prepared_stmt_count';
show status like 'prepared_stmt_count';
select @@max_prepared_stmt_count;
set global max_prepared_stmt_count=0;
prepare stmt from "select 1";
execute stmt;
show status like 'prepared_stmt_count';
prepare stmt from "select 1";
show status like 'prepared_stmt_count';
set global max_prepared_stmt_count=3;
select @@max_prepared_stmt_count;
show status like 'prepared_stmt_count';
prepare stmt from "select 1";
connect (con1,localhost,root,,);
connection con1;
prepare stmt from "select 2";
prepare stmt1 from "select 3";
prepare stmt2 from "select 4";
connection default;
prepare stmt2 from "select 4";
select @@max_prepared_stmt_count;
show status like 'prepared_stmt_count';
disconnect con1;
connection default;
deallocate prepare stmt;
select @@max_prepared_stmt_count;
show status like 'prepared_stmt_count';
set global max_prepared_stmt_count= @old_max_prepared_stmt_count;
drop table if exists t1;
create temporary table if not exists t1 (a1 int);
prepare stmt from "delete t1 from t1 where (cast(a1/3 as unsigned) * 3) = a1";
drop temporary table t1;
create temporary table if not exists t1 (a1 int);
execute stmt;
drop temporary table t1;
create temporary table if not exists t1 (a1 int);
execute stmt;
drop temporary table t1;
create temporary table if not exists t1 (a1 int);
execute stmt;
drop temporary table t1;
deallocate prepare stmt;
CREATE TABLE t1(  ID int(10) unsigned NOT NULL auto_increment,  Member_ID varchar(15) NOT NULL default '',  Action varchar(12) NOT NULL,  Action_Date datetime NOT NULL,  Track varchar(15) default NULL,  User varchar(12) default NULL,  Date_Updated timestamp NOT NULL default CURRENT_TIMESTAMP on update    CURRENT_TIMESTAMP,  PRIMARY KEY (ID),  KEY Action (Action),  KEY Action_Date (Action_Date));
INSERT INTO t1(Member_ID, Action, Action_Date, Track) VALUES  ('111111', 'Disenrolled', '2006-03-01', 'CAD' ),  ('111111', 'Enrolled', '2006-03-01', 'CAD' ),  ('111111', 'Disenrolled', '2006-07-03', 'CAD' ),  ('222222', 'Enrolled', '2006-03-07', 'CAD' ),  ('222222', 'Enrolled', '2006-03-07', 'CHF' ),  ('222222', 'Disenrolled', '2006-08-02', 'CHF' ),  ('333333', 'Enrolled', '2006-03-01', 'CAD' ),  ('333333', 'Disenrolled', '2006-03-01', 'CAD' ),  ('444444', 'Enrolled', '2006-03-01', 'CAD' ),  ('555555', 'Disenrolled', '2006-03-01', 'CAD' ),  ('555555', 'Enrolled', '2006-07-21', 'CAD' ),  ('555555', 'Disenrolled', '2006-03-01', 'CHF' ),  ('666666', 'Enrolled', '2006-02-09', 'CAD' ),  ('666666', 'Enrolled', '2006-05-12', 'CHF' ),  ('666666', 'Disenrolled', '2006-06-01', 'CAD' );
PREPARE STMT FROM"SELECT GROUP_CONCAT(Track SEPARATOR ', ') FROM t1  WHERE Member_ID=? AND Action='Enrolled' AND        (Track,Action_Date) IN (SELECT Track, MAX(Action_Date) FROM t1                                  WHERE Member_ID=?                                    GROUP BY Track                                       HAVING Track>='CAD' AND                                             MAX(Action_Date)>'2006-03-01')";
SET @id='111111';
EXECUTE STMT USING @id,@id;
SET @id='222222';
EXECUTE STMT USING @id,@id;
DEALLOCATE PREPARE STMT;
DROP TABLE t1;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (i INT, INDEX(i));
INSERT INTO t1 VALUES (1);
PREPARE stmt FROM "SELECT (COUNT(i) = 1), COUNT(i) FROM t1 WHERE i = ?";
SET @a = 0;
EXECUTE stmt USING @a;
SET @a = 1;
EXECUTE stmt USING @a;
SET @a = 0;
EXECUTE stmt USING @a;
PREPARE stmt FROM "SELECT (AVG(i) = 1), AVG(i) FROM t1 WHERE i = ?";
SET @a = 0;
EXECUTE stmt USING @a;
SET @a = 1;
EXECUTE stmt USING @a;
SET @a = 0;
EXECUTE stmt USING @a;
PREPARE stmt FROM "SELECT (VARIANCE(i) = 1), VARIANCE(i) FROM t1 WHERE i = ?";
SET @a = 0;
EXECUTE stmt USING @a;
SET @a = 1;
EXECUTE stmt USING @a;
SET @a = 0;
EXECUTE stmt USING @a;
PREPARE stmt FROM "SELECT (STDDEV(i) = 1), STDDEV(i) FROM t1 WHERE i = ?";
SET @a = 0;
EXECUTE stmt USING @a;
SET @a = 1;
EXECUTE stmt USING @a;
SET @a = 0;
EXECUTE stmt USING @a;
PREPARE stmt FROM "SELECT (BIT_OR(i) = 1), BIT_OR(i) FROM t1 WHERE i = ?";
SET @a = 0;
EXECUTE stmt USING @a;
SET @a = 1;
EXECUTE stmt USING @a;
SET @a = 0;
EXECUTE stmt USING @a;
PREPARE stmt FROM "SELECT (BIT_AND(i) = 1), BIT_AND(i) FROM t1 WHERE i = ?";
SET @a = 0;
EXECUTE stmt USING @a;
SET @a = 1;
EXECUTE stmt USING @a;
SET @a = 0;
EXECUTE stmt USING @a;
PREPARE stmt FROM "SELECT (BIT_XOR(i) = 1), BIT_XOR(i) FROM t1 WHERE i = ?";
SET @a = 0;
EXECUTE stmt USING @a;
SET @a = 1;
EXECUTE stmt USING @a;
SET @a = 0;
EXECUTE stmt USING @a;
DEALLOCATE PREPARE stmt;
DROP TABLE t1;
CREATE TABLE t1 (i INT);
PREPARE st_19182FROM "CREATE TABLE t2 (i INT, j INT, KEY (i), KEY(j)) SELECT i FROM t1";
EXECUTE st_19182;
DESC t2;
DROP TABLE t2;
EXECUTE st_19182;
DESC t2;
DEALLOCATE PREPARE st_19182;
DROP TABLE t2, t1;
drop database if exists mysqltest;
drop table if exists t1, t2;
create database mysqltest character set utf8;
prepare stmt1 from "create table mysqltest.t1 (c char(10))";
prepare stmt2 from "create table mysqltest.t2 select 'test'";
execute stmt1;
execute stmt2;
show create table mysqltest.t1;
show create table mysqltest.t2;
drop table mysqltest.t1;
drop table mysqltest.t2;
alter database mysqltest character set latin1;
execute stmt1;
execute stmt2;
show create table mysqltest.t1;
show create table mysqltest.t2;
drop database mysqltest;
deallocate prepare stmt1;
deallocate prepare stmt2;
eval prepare stmt from "create table t1 (c char(10)) data directory='$MYSQLTEST_VARDIR/tmp'";
execute stmt;
show create table t1;
drop table t1;
execute stmt;
show create table t1;
drop table t1;
deallocate prepare stmt;
CREATE TABLE t1(a int);
INSERT INTO t1 VALUES (2), (3), (1);
PREPARE st1 FROM  '(SELECT a FROM t1) UNION (SELECT a+10 FROM t1) ORDER BY RAND()*0+a';
EXECUTE st1;
EXECUTE st1;
DEALLOCATE PREPARE st1;
DROP TABLE t1;
create table t1 (a int, b tinyint);
prepare st1 from 'update t1 set b= (str_to_date(a, a))';
execute st1;
deallocate prepare st1;
drop table t1;
create table t1 (a varchar(20)); insert into t1 values ('foo'); prepare stmt FROM 'SELECT char_length (a) FROM t1'; prepare stmt2 FROM 'SELECT not_a_function (a) FROM t1'; drop table t1;
create table t1 (a char(3) not null, b char(3) not null,                 c char(3) not null, primary key  (a, b, c));
create table t2 like t1;
prepare stmt from  "select t1.a from (t1 left outer join t2 on t2.a=1 and t1.b=t2.b)  where t1.a=1";
execute stmt;
execute stmt;
execute stmt;
prepare stmt from"select t1.a, t1.b, t1.c, t2.a, t2.b, t2.c from(t1 left outer join t2 on t2.a=? and t1.b=t2.b)left outer join t2 t3 on t3.a=? where t1.a=?";
set @a:=1, @b:=1, @c:=1;
execute stmt using @a, @b, @c;
execute stmt using @a, @b, @c;
execute stmt using @a, @b, @c;
deallocate prepare stmt;
drop table t1,t2;
eval SET @aux= "SELECT COUNT(*)                FROM INFORMATION_SCHEMA.COLUMNS A,                INFORMATION_SCHEMA.COLUMNS B                WHERE A.TABLE_SCHEMA = B.TABLE_SCHEMA                AND A.TABLE_NAME = B.TABLE_NAME                AND A.COLUMN_NAME = B.COLUMN_NAME AND                A.TABLE_NAME = 'user'";
eval prepare my_stmt from @aux;
while ($exec_loop_count)  eval execute my_stmt;
  dec $exec_loop_count;
deallocate prepare my_stmt;
delimiter |;
drop procedure if exists p1|drop table if exists t1|create table t1 (id int)|insert into t1 values(1)|create procedure p1(a int, b int)begin  declare c int;
  select max(id)+1 into c from t1;
  insert into t1 select a+b;
  insert into t1 select a-b;
  insert into t1 select a-c;
end|set @a= 3, @b= 4|prepare stmt from "call p1(?, ?)"|execute stmt using @a, @b|execute stmt using @a, @b|select * from t1|deallocate prepare stmt|drop procedure p1|drop table t1|delimiter ;|create table t1 (a int);
insert into t1 (a) values (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
prepare stmt from "select * from t1 limit ?, ?";
set @offset=0, @limit=1;
execute stmt using @offset, @limit;
select * from t1 limit 0, 1;
set @offset=3, @limit=2;
execute stmt using @offset, @limit;
select * from t1 limit 3, 2;
prepare stmt from "select * from t1 limit ?";
execute stmt using @limit;
prepare stmt from "select * from t1 where a in (select a from t1 limit ?)";
prepare stmt from "select * from t1 union all select * from t1 limit ?, ?";
set @offset=9;
set @limit=2;
execute stmt using @offset, @limit;
prepare stmt from "(select * from t1 limit ?, ?) union all                   (select * from t1 limit ?, ?) order by a limit ?";
execute stmt using @offset, @limit, @offset, @limit, @limit;
drop table t1;
deallocate prepare stmt;
CREATE TABLE b12651_T1(a int) ENGINE=MYISAM;
CREATE TABLE b12651_T2(b int) ENGINE=MYISAM;
CREATE VIEW  b12651_V1 as SELECT b FROM b12651_T2;
PREPARE b12651 FROM 'SELECT 1 FROM b12651_T1 WHERE a IN (SELECT b FROM b12651_V1)';
EXECUTE b12651;
DROP VIEW b12651_V1;
DROP TABLE b12651_T1, b12651_T2;
DEALLOCATE PREPARE b12651;
create table t1 (id int);
prepare ins_call from "insert into t1 (id) values (1)";
execute ins_call;
select row_count();
drop table t1;
create table t1 (a int, b int);
insert into t1 (a,b) values (2,8),(1,9),(3,7);
prepare stmt from "select * from t1 order by ?";
set @a=NULL;
execute stmt using @a;
set @a=1;
execute stmt using @a;
set @a=2;
execute stmt using @a;
deallocate prepare stmt;
select * from t1 order by 1;
prepare stmt from "select * from t1 order by ?+1";
set @a=0;
execute stmt using @a;
set @a=1;
execute stmt using @a;
deallocate prepare stmt;
select * from t1 order by 1+1;
drop table t1;
create table t1 (a int) engine=myisam;
create table t2 like t1;
create table t3 like t2;
prepare stmt from "repair table t1";
execute stmt;
execute stmt;
prepare stmt from "optimize table t1";
execute stmt;
execute stmt;
prepare stmt from "analyze table t1";
execute stmt;
execute stmt;
prepare stmt from "repair table t1, t2, t3";
execute stmt;
execute stmt;
prepare stmt from "optimize table t1, t2, t3";
execute stmt;
execute stmt;
prepare stmt from "analyze table t1, t2, t3";
execute stmt;
execute stmt;
prepare stmt from "repair table t1, t4, t3";
execute stmt;
execute stmt;
prepare stmt from "optimize table t1, t3, t4";
execute stmt;
execute stmt;
prepare stmt from "analyze table t4, t1";
execute stmt;
execute stmt;
deallocate prepare stmt;
drop table t1, t2, t3;
create database mysqltest_long_database_name_to_thrash_heap;
use test;
create table t1 (i int);
prepare stmt from "alter table test.t1 rename t1";
use mysqltest_long_database_name_to_thrash_heap;
execute stmt;
show tables like 't1';
prepare stmt from "alter table test.t1 rename t1";
use test;
execute stmt;
show tables like 't1';
use mysqltest_long_database_name_to_thrash_heap;
show tables like 't1';
deallocate prepare stmt;
use mysqltest_long_database_name_to_thrash_heap; prepare stmt_create from "create table t1 (i int)";
prepare stmt_insert from "insert into t1 (i) values (1)";
prepare stmt_update from "update t1 set i=2";
prepare stmt_delete from "delete from t1 where i=2";
prepare stmt_select from "select * from t1";
prepare stmt_alter from "alter table t1 add column (b int)";
prepare stmt_alter1 from "alter table t1 drop column b";
prepare stmt_analyze from "analyze table t1";
prepare stmt_optimize from "optimize table t1";
prepare stmt_show from "show tables like 't1'";
prepare stmt_truncate from "truncate table t1";
prepare stmt_drop from "drop table t1";
drop table t1;
use test;
execute stmt_create;
show tables like 't1';
use mysqltest_long_database_name_to_thrash_heap;
show tables like 't1';
use test;
execute stmt_insert;
select * from mysqltest_long_database_name_to_thrash_heap.t1;
execute stmt_update;
select * from mysqltest_long_database_name_to_thrash_heap.t1;
execute stmt_delete;
execute stmt_select;
execute stmt_alter;
show columns from mysqltest_long_database_name_to_thrash_heap.t1;
execute stmt_alter1;
show columns from mysqltest_long_database_name_to_thrash_heap.t1;
execute stmt_analyze;
execute stmt_optimize;
execute stmt_show;
execute stmt_truncate;
execute stmt_drop;
show tables like 't1';
use mysqltest_long_database_name_to_thrash_heap;
show tables like 't1';
drop database mysqltest_long_database_name_to_thrash_heap;
prepare stmt_create from "create table t1 (i int)";
prepare stmt_insert from "insert into t1 (i) values (1)";
prepare stmt_update from "update t1 set i=2";
prepare stmt_delete from "delete from t1 where i=2";
prepare stmt_select from "select * from t1";
prepare stmt_alter from "alter table t1 add column (b int)";
prepare stmt_alter1 from "alter table t1 drop column b";
prepare stmt_analyze from "analyze table t1";
prepare stmt_optimize from "optimize table t1";
prepare stmt_show from "show tables like 't1'";
prepare stmt_truncate from "truncate table t1";
prepare stmt_drop from "drop table t1";
create temporary table t1 (i int);
use test;
CREATE TABLE t1 (i BIGINT, j BIGINT);
CREATE TABLE t2 (i BIGINT);
CREATE TABLE t3 (i BIGINT, j BIGINT);
PREPARE stmt FROM "SELECT * FROM t1 JOIN t2 ON (t2.i = t1.i)                   LEFT JOIN t3 ON ((t3.i, t3.j) = (t1.i, t1.j))                   WHERE t1.i = ?";
SET @a= 1;
EXECUTE stmt USING @a;
EXECUTE stmt USING @a;
DEALLOCATE PREPARE stmt;
DROP TABLE IF EXISTS t1, t2, t3;
CREATE TABLE t1 (i INT KEY);
CREATE TABLE t2 (i INT);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (1);
PREPARE stmt FROM "SELECT t2.i FROM t1 LEFT JOIN t2 ON t2.i = t1.i                   WHERE t1.i = ?";
SET @arg= 1;
EXECUTE stmt USING @arg;
SET @arg= 2;
EXECUTE stmt USING @arg;
SET @arg= 1;
EXECUTE stmt USING @arg;
DEALLOCATE PREPARE stmt;
DROP TABLE t1, t2;
CREATE TABLE t1 (i INT);
CREATE VIEW v1 AS SELECT * FROM t1;
INSERT INTO t1 VALUES (1), (2);
             WHERE EXISTS (SELECT * FROM t1 WHERE v1.i = 1);
eval $query;
eval PREPARE stmt FROM "$query";
EXECUTE stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
DROP VIEW v1;
DROP TABLE t1;
while ($iterations)    PREPARE stmt FROM "CREATE PROCEDURE p1()";
  dec $iterations;
CREATE TABLE t1 (a int);
INSERT INTO t1 VALUES (1), (2);
CREATE TABLE t2 (b int);
INSERT INTO t2 VALUES (NULL);
SELECT a FROM t1 WHERE (SELECT b FROM t2) IS NULL;
PREPARE stmt FROM 'SELECT a FROM t1 WHERE (SELECT b FROM t2) IS NULL';
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
PREPARE stmt FROM 'SELECT a FROM t1 WHERE (SELECT b FROM t2 limit ?) IS NULL';
SET @arg=1;
EXECUTE stmt USING @arg;
DEALLOCATE PREPARE stmt;
DROP TABLE t1,t2;
create table t1 (s1 char(20));
prepare stmt from "alter table t1 modify s1 int";
execute stmt;
execute stmt;
drop table t1;
deallocate prepare stmt;
create table t1 (a int, b int);
prepare s_6895 from "alter table t1 drop column b";
execute s_6895;
show columns from t1;
drop table t1;
create table t1 (a int, b int);
execute s_6895;
show columns from t1;
drop table t1;
create table t1 (a int, b int);
execute s_6895;
show columns from t1;
deallocate prepare s_6895;
drop table t1;
create table t1 (i int primary key auto_increment) comment='comment for table t1';
create table t2 (i int, j int, k int);
prepare stmt from "alter table t1 auto_increment=100";
execute stmt;
show create table t1;
flush tables;
select * from t2;
execute stmt;
show create table t1;
deallocate prepare stmt;
drop table t1, t2;
set @old_character_set_server= @@character_set_server;
set @@character_set_server= latin1; prepare stmt from "create database mysqltest_1";
execute stmt;
show create database mysqltest_1;
drop database mysqltest_1;
set @@character_set_server= utf8; execute stmt;
show create database mysqltest_1;
drop database mysqltest_1;
deallocate prepare stmt;
set @@character_set_server= @old_character_set_server;
create table t1 (id int primary key auto_increment, value varchar(10));
insert into t1 (id, value) values (1, 'FIRST'), (2, 'SECOND'), (3, 'THIRD');
prepare stmt from "insert into t1 (id, value) select * from (select 4 as i, 'FOURTH' as v) as y on duplicate key update v = 'DUP'";
prepare stmt from "insert into t1 (id, value) select * from (select 4 as id, 'FOURTH' as value) as y on duplicate key update y.value = 'DUP'";
drop tables t1;
prepare stmt from "create table t1 select ?";
set @a=1.0;
execute stmt using @a;
show create table t1;
drop table t1;
create table t1 (a bigint unsigned, b bigint(20) unsigned);
prepare stmt from "insert into t1 values (?,?)";
set @a= 9999999999999999;
set @b= 14632475938453979136;
insert into t1 values (@a, @b);
select * from t1 where a = @a and b = @b;
execute stmt using @a, @b;
select * from t1 where a = @a and b = @b;
deallocate prepare stmt;
drop table t1;
drop view if exists v1;
drop table if exists t1;
create table t1 (a int, b int);
insert into t1 values (1,1), (2,2), (3,3);
insert into t1 values (3,1), (1,2), (2,3);
prepare stmt from "create view v1 as select * from t1";
execute stmt;
drop table t1;
create table t1 (a int, b int);
drop view v1;
execute stmt;
show create view v1;
drop view v1;
prepare stmt from "create view v1 (c,d) as select a,b from t1";
execute stmt;
show create view v1;
select * from v1;
drop view v1;
execute stmt;
deallocate prepare stmt;
show create view v1;
select * from v1;
drop view v1;
prepare stmt from "create view v1 (c) as select b+1 from t1";
execute stmt;
show create view v1;
select * from v1;
drop view v1;
execute stmt;
deallocate prepare stmt;
show create view v1;
select * from v1;
drop view v1;
prepare stmt from "create view v1 (c,d,e,f) as select a,b,a in (select a+2 from t1), a = all (select a from t1) from t1";
execute stmt;
show create view v1;
select * from v1;
drop view v1;
execute stmt;
deallocate prepare stmt;
show create view v1;
select * from v1;
drop view v1;
prepare stmt from "create or replace view v1 as select 1";
execute stmt;
show create view v1;
select * from v1;
execute stmt;
show create view v1;
deallocate prepare stmt;
show create view v1;
select * from v1;
drop view v1;
prepare stmt from "create view v1 as select 1, 1";
execute stmt;
show create view v1;
select * from v1;
drop view v1;
execute stmt;
deallocate prepare stmt;
show create view v1;
select * from v1;
drop view v1;
prepare stmt from "create view v1 (x) as select a from t1 where a > 1";
execute stmt;
show create view v1;
select * from v1;
drop view v1;
execute stmt;
deallocate prepare stmt;
show create view v1;
select * from v1;
drop view v1;
prepare stmt from "create view v1 as select * from `t1` `b`";
execute stmt;
show create view v1;
select * from v1;
drop view v1;
execute stmt;
deallocate prepare stmt;
show create view v1;
select * from v1;
drop view v1;
prepare stmt from "create view v1 (a,b,c) as select * from t1";
drop table t1;
create temporary table t1 (a int, b int);
prepare stmt from "create view v1 as select * from t1";
execute stmt;
execute stmt;
deallocate prepare stmt;
drop table t1;
prepare stmt from "create view v1 as select * from t1";
prepare stmt from "create view v1 as select * from `t1` `b`";
prepare stmt from "select ?";
set @arg= 123456789.987654321;
select @arg;
execute stmt using @arg;
set @arg= "string";
select @arg;
execute stmt using @arg;
set @arg= 123456;
select @arg;
execute stmt using @arg;
set @arg= cast(-12345.54321 as decimal(20, 10));
select @arg;
execute stmt using @arg;
deallocate prepare stmt;
create table t1(b int);
insert into t1 values (0);
create view v1 AS select 1 as a from t1 where b;
prepare stmt from "select * from v1 where a";
execute stmt;
execute stmt;
deallocate prepare stmt;
drop table t1;
drop view v1;
create table t1(a bigint);
create table t2(b tinyint);
insert into t2 values (null);
prepare stmt from "select 1 from t1 join  t2 on a xor b where b > 1  and a =1";
execute stmt;
execute stmt;
deallocate prepare stmt;
drop table t1,t2;
CREATE TABLE t1(a INT PRIMARY KEY);
INSERT INTO t1 VALUES(0), (1);
PREPARE stmt FROM   "SELECT 1 FROM t1 JOIN t1 t2 USING(a) GROUP BY t2.a, t1.a";
EXECUTE stmt;
EXECUTE stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
DROP TABLE t1;
create procedure proc_1() reset master;
delimiter |;
create function func_1() returns int begin reset master; return 1; end|create function func_1() returns int begin call proc_1(); return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
drop procedure proc_1;
prepare abc from "reset master";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
create procedure proc_1() reset slave;
call proc_1();
call proc_1();
call proc_1();
delimiter |;
create function func_1() returns int begin reset slave; return 1; end|create function func_1() returns int begin call proc_1(); return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
drop procedure proc_1;
prepare abc from "reset slave";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
create procedure proc_1(a integer) kill a;
call proc_1(0);
call proc_1(0);
call proc_1(0);
drop procedure proc_1;
delimiter |;
create function func_1() returns int begin kill 0; return 1; end|delimiter ;|select func_1() from dual;
select func_1() from dual;
select func_1() from dual;
drop function func_1;
prepare abc from "kill 0";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
create procedure proc_1() flush hosts;
call proc_1();
call proc_1();
call proc_1();
call proc_1();
delimiter |;
create function func_1() returns int begin flush hosts; return 1; end|create function func_1() returns int begin call proc_1(); return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
drop procedure proc_1;
prepare abc from "flush hosts";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
create procedure proc_1() flush privileges;
call proc_1();
call proc_1();
call proc_1();
delimiter |;
create function func_1() returns int begin flush privileges; return 1; end|create function func_1() returns int begin call proc_1(); return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
drop procedure proc_1;
prepare abc from "flush privileges";
deallocate prepare abc;
create procedure proc_1() flush tables with read lock;
call proc_1();
unlock tables;
call proc_1();
unlock tables;
call proc_1();
unlock tables;
delimiter |;
create function func_1() returns int begin flush tables with read lock; return 1; end|create function func_1() returns int begin call proc_1(); return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
drop procedure proc_1;
prepare abc from "flush tables with read lock";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
unlock tables;
create procedure proc_1() flush tables;
call proc_1();
call proc_1();
call proc_1();
delimiter |;
create function func_1() returns int begin flush tables; return 1; end|create function func_1() returns int begin call proc_1(); return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
drop procedure proc_1;
prepare abc from "flush tables";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
create procedure proc_1() flush tables;
flush tables;
show open tables from mysql;
select Host, User from mysql.user limit 0;
select Host, Db from mysql.db limit 0;
show open tables from mysql;
call proc_1();
show open tables from mysql;
select Host, User from mysql.user limit 0;
select Host, Db from mysql.db limit 0;
show open tables from mysql;
call proc_1();
show open tables from mysql;
select Host, User from mysql.user limit 0;
select Host, Db from mysql.db limit 0;
show open tables from mysql;
call proc_1();
show open tables from mysql;
select Host, User from mysql.user limit 0;
select Host, Db from mysql.db limit 0;
show open tables from mysql;
flush tables;
delimiter |;
create function func_1() returns int begin flush tables; return 1; end|create function func_1() returns int begin call proc_1(); return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
drop procedure proc_1;
flush tables;
select Host, User from mysql.user limit 0;
select Host, Db from mysql.db limit 0;
show open tables from mysql;
prepare abc from "flush tables";
execute abc;
show open tables from mysql;
select Host, User from mysql.user limit 0;
select Host, Db from mysql.db limit 0;
show open tables from mysql;
execute abc;
show open tables from mysql;
select Host, User from mysql.user limit 0;
select Host, Db from mysql.db limit 0;
show open tables from mysql;
execute abc;
show open tables from mysql;
select Host, User from mysql.user limit 0;
select Host, Db from mysql.db limit 0;
show open tables from mysql;
flush tables;
deallocate prepare abc;
create procedure proc_1() flush logs;
call proc_1();
call proc_1();
call proc_1();
delimiter |;
create function func_1() returns int begin flush logs; return 1; end|create function func_1() returns int begin call proc_1(); return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
drop procedure proc_1;
prepare abc from "flush logs";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
create procedure proc_1() flush status;
call proc_1();
call proc_1();
call proc_1();
delimiter |;
create function func_1() returns int begin flush status; return 1; end|create function func_1() returns int begin call proc_1(); return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
drop procedure proc_1;
prepare abc from "flush status";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
create procedure proc_1() flush user_resources;
call proc_1();
call proc_1();
call proc_1();
delimiter |;
create function func_1() returns int begin flush user_resources; return 1; end|create function func_1() returns int begin call proc_1(); return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
drop procedure proc_1;
prepare abc from "flush user_resources";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
create procedure proc_1() start slave;
drop procedure proc_1;
delimiter |;
create function func_1() returns int begin start slave; return 1; end|delimiter ;|prepare abc from "start slave";
deallocate prepare abc;
create procedure proc_1() stop slave;
drop procedure proc_1;
delimiter |;
create function func_1() returns int begin stop slave; return 1; end|delimiter ;|prepare abc from "stop slave";
deallocate prepare abc;
create procedure proc_1() show binlog events;
drop procedure proc_1;
delimiter |;
create function func_1() returns int begin show binlog events; return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
prepare abc from "show binlog events";
deallocate prepare abc;
create procedure proc_1() show slave status;
drop procedure proc_1;
delimiter |;
create function func_1() returns int begin show slave status; return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
prepare abc from "show slave status";
deallocate prepare abc;
create procedure proc_1() show master status;
drop procedure proc_1;
delimiter |;
create function func_1() returns int begin show master status; return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
prepare abc from "show master status";
deallocate prepare abc;
create procedure proc_1() show master logs;
drop procedure proc_1;
delimiter |;
create function func_1() returns int begin show master logs; return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
prepare abc from "show master logs";
deallocate prepare abc;
create procedure proc_1() show events;
call proc_1();
call proc_1();
call proc_1();
drop procedure proc_1;
delimiter |;
create function func_1() returns int begin show events; return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
prepare abc from "show events";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
create procedure a() select 42;
create procedure proc_1(a char(2)) show create procedure a;
call proc_1("bb");
call proc_1("bb");
call proc_1("bb");
drop procedure proc_1;
delimiter |;
create function func_1() returns int begin show create procedure a; return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
prepare abc from "show create procedure a";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
drop procedure a;
create function a() returns int return 42+13;
create procedure proc_1(a char(2)) show create function a;
call proc_1("bb");
call proc_1("bb");
call proc_1("bb");
drop procedure proc_1;
delimiter |;
create function func_1() returns int begin show create function a; return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
prepare abc from "show create function a";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
drop function a;
create table tab1(a int, b char(1), primary key(a,b));
create procedure proc_1() show create table tab1;
call proc_1();
call proc_1();
call proc_1();
drop procedure proc_1;
delimiter |;
create function func_1() returns int begin show create table tab1; return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
prepare abc from "show create table tab1";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
drop table tab1;
drop view if exists v1;
drop table if exists t1;
create table t1(a int, b char(5));
insert into t1 values (1, "one"), (1, "edno"), (2, "two"), (2, "dve");
create view v1 as    (select a, count(*) from t1 group by a)    union all    (select b, count(*) from t1 group by b);
create procedure proc_1() show create view v1;
call proc_1();
call proc_1();
call proc_1();
drop procedure proc_1;
delimiter |;
create function func_1() returns int begin show create view v1; return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
prepare abc from "show create view v1";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
drop view v1;
drop table t1;
create procedure proc_1() install plugin my_plug soname 'some_plugin.so';
call proc_1();
call proc_1();
call proc_1();
drop procedure proc_1;
delimiter |;
create function func_1() returns int begin install plugin my_plug soname '/tmp/plugin'; return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
prepare abc from "install plugin my_plug soname 'some_plugin.so'";
deallocate prepare abc;
create procedure proc_1() uninstall plugin my_plug;
call proc_1();
call proc_1();
call proc_1();
drop procedure proc_1;
delimiter |;
create function func_1() returns int begin uninstall plugin my_plug; return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
prepare abc from "uninstall plugin my_plug";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
create procedure proc_1() create database mysqltest_xyz;
call proc_1();
drop database if exists mysqltest_xyz;
call proc_1();
call proc_1();
drop database if exists mysqltest_xyz;
call proc_1();
drop database if exists mysqltest_xyz;
drop procedure proc_1;
delimiter |;
  if (!$include_silent)  {      }      # Print this text (just once) to prevent checking in result files containing  # debug info.  if (!$printed_this_should_not_be_checked_in)  {          }        if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }          if ($rpl_connection_silent_if_same)  {    if ($rpl_connection_name == $CURRENT_CONNECTION)    {          }  }  if ($rpl_connection_silent)  {      }      if ($_tmp != $ENABLE_WARNINGS) {    # Enable all the disabled warnings      }  if ($_include_file_disable_warnings_list) {            # Check if there exist any disabled warnings    if ($_include_file_disable_warnings) {      # Disabled warnings are present, enable all the warings if $ENABLE_WARNINGS      # is not set and then disable only the warnings present in disabld warning list.      if (!$ENABLE_WARNINGS) {              }          }    if (!$_include_file_disable_warnings) {      # No disabled warnings exist, check if any enabled warnings present                  if ($_include_file_enable_warnings) {        # Enabled warnings exist, disable all the warnings first if $ENABLE_WARNINGS        # is set and then enable only the warnings present in enabled warnings list.        if ($ENABLE_WARNINGS) {                  }              }      if (!$_include_file_enable_warnings) {        # There exist no disabled or enabled warnings, disable all        # the warnings.              }    }  }                      while ($_eval_rbracket)  # Get position of right bracket    if ($_eval_lbracket == 0)  {                  }  # Get sub-statement from statement. Preserve escapes for single quotes.    # Get connection from sub-statement        if ($_eval_colon)  {        # Preserve escapes for single quotes.      }  # Interpolate escapes before using expression outside string context.    # Change connection  if ($_eval_connection)  {    if ($rpl_debug)    {          }      }  if (!$_eval_connection)  {    if ($rpl_debug)    {          }  }  # Execute and get result from sub-statement.  # Can't use dollar to denote end of string because mtr will try to  # interpolate it.    if ($selected_row_col)  {      }  if (!$selected_row_col)  {      }  # Change back connection  if ($_eval_connection)  {      }  if ($rpl_debug)  {      }  # Replace sub-statement by its result    # Replace result references by result              while ($_rpl_server) {      send SET SESSION debug = 'd,crash_now';
  while ($_rpl_server) {            while ($_rpl_server)  if (!$_rpl_is_first_server)  {      }          SHOW WARNINGS;
      query_vertical  SELECT NOW(), @@SERVER_ID, @@SERVER_UUID, @@PORT;
      query_vertical  SELECT @@GLOBAL.GTID_MODE, @@GLOBAL.GTID_EXECUTED, @@GLOBAL.GTID_PURGED, @@GLOBAL.GTID_OWNED, @@SESSION.GTID_OWNED;
      query_vertical   SHOW SLAVE STATUS;
      query_vertical  SELECT * FROM performance_schema.replication_connection_status;
  if($rpl_group_replication)  {            query_vertical    SELECT * FROM performance_schema.replication_group_members;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_stats;
            query_vertical    SELECT * FROM performance_schema.replication_group_configuration_version;
            query_vertical    SELECT * FROM performance_schema.replication_group_member_actions;
            query_vertical    SELECT * FROM performance_schema.replication_group_communication_information;
            query_vertical    SELECT * FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
  }      query_vertical  SELECT * FROM performance_schema.replication_applier_status;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_worker;
      query_vertical  SELECT * FROM performance_schema.replication_applier_status_by_coordinator;
      query_vertical  SELECT * FROM performance_schema.replication_applier_configuration;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover;
      query_vertical  SELECT * FROM performance_schema.replication_asynchronous_connection_failover_managed;
      query_vertical  SHOW MASTER STATUS;
      query_vertical  SHOW SLAVE HOSTS;
      SHOW PROCESSLIST;
      SELECT * FROM performance_schema.threads;
      SHOW BINARY LOGS;
      let $binlog_name= query_get_value("SHOW MASTER STATUS", File, 1);
    eval SHOW BINLOG EVENTS IN '$binlog_name';
      let $relaylog_name= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1);
    eval SHOW RELAYLOG EVENTS IN '$relaylog_name';
      SELECT * FROM mysql.slave_relay_log_info;
      SELECT * FROM mysql.slave_master_info;
      SELECT * FROM mysql.gtid_executed;
  if ($extra_debug_table)  {                eval SHOW CREATE TABLE $extra_debug_table;
    eval SELECT * FROM $extra_debug_table;
  }  if ($extra_debug_sql != '') {                  }      # Don't use same connection twice.  if (`SELECT 'server_$_rpl_server' = '$_rpl_old_con'`)  {        if ($rpl_only_current_connection)    {          }  }        let $wait_counter= `SELECT $wait_timeout * 10`;
    while ($wait_counter)    let $success= `$wait_condition`;
    inc $wait_condition_reps;
    if ($success)    {        let $wait_counter= 0;
    }    if (!$success)    {        sleep 0.1;
        dec $wait_counter;
    }  if (!$silent_failure)  {    echo Timeout in wait_condition.inc for $wait_condition;
  }  if ($show_rpl_debug_info)  {      }create function func_1() returns int begin create database mysqltest_xyz; return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
prepare abc from "create database mysqltest_xyz";
execute abc;
drop database if exists mysqltest_xyz;
execute abc;
execute abc;
drop database if exists mysqltest_xyz;
execute abc;
drop database if exists mysqltest_xyz;
deallocate prepare abc;
create table t1 (a int, b char(5));
insert into t1 values (1, "one"), (2, "two"), (3, "three");
create procedure proc_1() checksum table xyz;
call proc_1();
call proc_1();
call proc_1();
drop procedure proc_1;
delimiter |;
create function func_1() returns int begin checksum table t1; return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
prepare abc from "checksum table t1";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
create procedure proc_1() create user pstest_xyz@localhost;
call proc_1();
drop user pstest_xyz@localhost;
call proc_1();
call proc_1();
drop user pstest_xyz@localhost;
call proc_1();
drop user pstest_xyz@localhost;
drop procedure proc_1;
delimiter |;
create function func_1() returns int begin create user pstest_xyz@localhost; return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
prepare abc from "create user pstest_xyz@localhost";
execute abc;
drop user pstest_xyz@localhost;
execute abc;
execute abc;
drop user pstest_xyz@localhost;
execute abc;
drop user pstest_xyz@localhost;
deallocate prepare abc;
delimiter |;
create function func_1() returns int begin create event xyz on schedule at now() do select 123; return 1; end|delimiter ;|select func_1(), func_1(), func_1() from dual;
drop function func_1;
prepare abc from "create event xyz on schedule at now() do select 123";
deallocate prepare abc;
drop event if exists xyz;
create event xyz on schedule every 5 minute disable do select 123;
create procedure proc_1() alter event xyz comment 'xyz';
call proc_1();
drop event xyz;
create event xyz on schedule every 5 minute disable do select 123;
call proc_1();
drop event xyz;
create event xyz on schedule every 5 minute disable do select 123;
call proc_1();
drop event xyz;
drop procedure proc_1;
delimiter |;
create function func_1() returns int begin alter event xyz comment 'xyz'; return 1; end|delimiter ;|prepare abc from "alter event xyz comment 'xyz'";
deallocate prepare abc;
drop event if exists xyz;
create event xyz on schedule every 5 minute disable do select 123;
create procedure proc_1() drop event xyz;
call proc_1();
create event xyz on schedule every 5 minute disable do select 123;
call proc_1();
call proc_1();
drop procedure proc_1;
delimiter |;
create function func_1() returns int begin drop event xyz; return 1; end|delimiter ;|prepare abc from "drop event xyz";
deallocate prepare abc;
drop table if exists t1;
create table t1 (a int, b char(5)) engine=myisam;
insert into t1 values (1, "one"), (2, "two"), (3, "three");
SET GLOBAL new_cache.key_buffer_size=128*1024;
create procedure proc_1() cache index t1 in new_cache;
call proc_1();
call proc_1();
call proc_1();
drop procedure proc_1;
SET GLOBAL second_cache.key_buffer_size=128*1024;
prepare abc from "cache index t1 in second_cache";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
drop table t1;
drop table if exists t1;
drop table if exists t2;
create table t1 (a int, b char(5)) engine=myisam;
insert into t1 values (1, "one"), (2, "two"), (3, "three");
create table t2 (a int, b char(5)) engine=myisam;
insert into t2 values (1, "one"), (2, "two"), (3, "three");
create procedure proc_1() load index into cache t1 ignore leaves;
call proc_1();
call proc_1();
call proc_1();
drop procedure proc_1;
delimiter |;
create function func_1() returns int begin load index into cache t1 ignore leaves; return 1; end|delimiter ;|prepare abc from "load index into cache t2 ignore leaves";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
drop table t1, t2;
create procedure proc_1() show errors;
call proc_1();
call proc_1();
call proc_1();
drop procedure proc_1;
delimiter |;
create function func_1() returns int begin show errors; return 1; end|delimiter ;|prepare abc from "show errors";
drop table if exists t1;
drop table if exists t2;
create procedure proc_1() show warnings;
drop table if exists t1;
call proc_1();
drop table if exists t2;
call proc_1();
drop table if exists t1, t2;
call proc_1();
drop procedure proc_1;
delimiter |;
create function func_1() returns int begin show warnings; return 1; end|delimiter ;|prepare abc from "show warnings";
set @to_format="123456789.123456789";
set @dec=0;
prepare stmt2 from 'select format(?, ?)';
execute stmt2 using @to_format, @dec;
set @dec=4;
execute stmt2 using @to_format, @dec;
set @dec=6;
execute stmt2 using @to_format, @dec;
set @dec=2;
execute stmt2 using @to_format, @dec;
set @to_format="100";
execute stmt2 using @to_format, @dec;
set @to_format="1000000";
execute stmt2 using @to_format, @dec;
set @to_format="10000";
execute stmt2 using @to_format, @dec;
deallocate prepare stmt2;
CREATE TABLE t1 (i INT);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2 (i INT);
INSERT INTO t2 VALUES (2);
LOCK TABLE t1 READ, t2 WRITE;
connect (conn1, localhost, root, , );
PREPARE stmt1 FROM "SELECT i FROM t1";
PREPARE stmt2 FROM "INSERT INTO t2 (i) VALUES (3)";
EXECUTE stmt1;
send EXECUTE stmt2;
connection default;
SELECT * FROM t2;
UNLOCK TABLES;
SELECT * FROM t2;
ALTER TABLE t1 ADD COLUMN j INT;
ALTER TABLE t2 ADD COLUMN j INT;
INSERT INTO t1 VALUES (4, 5);
INSERT INTO t2 VALUES (4, 5);
connection conn1;
reap;
EXECUTE stmt1;
EXECUTE stmt2;
SELECT * FROM t2;
disconnect conn1;
connection default;
DROP TABLE t1, t2;
drop table if exists t1;
prepare stmtfrom "create table t1 (c char(100) character set utf8, key (c(10)))";
execute stmt;
show create table t1;
drop table t1;
execute stmt;
show create table t1;
drop table t1;
create table t1 (a int, b int);
create table t2 like t1;
insert into t1 (a, b) values (1,1), (1,2), (1,3), (1,4), (1,5),       (2,2), (2,3), (2,1), (3,1), (4,1), (4,2), (4,3), (4,4), (4,5), (4,6);
insert into t2 select a, max(b) from t1 group by a;
prepare stmt from "delete from t2 where (select (select max(b) from t1 groupby a having a < 2) x from t1) > 10000";
delete from t2 where (select (select max(b) from t1 groupby a having a < 2) x from t1) > 10000;
execute stmt;
execute stmt;
deallocate prepare stmt;
drop table t1, t2;
CREATE TABLE t1 (a TIME NOT NULL, b TINYINT);
INSERT IGNORE INTO t1 VALUES (0, 0),(0, 0);
PREPARE stmt FROM "SELECT 1 FROM t1 WHEREROW(a, b) >= ROW('1', (SELECT 1 FROM t1 WHERE a > '1234abc'))";
EXECUTE stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
DROP TABLE t1;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1),(2);
PREPARE stmt FROM 'EXPLAIN SELECT 1 FROM t1 RIGHT JOIN t1 t2 ON 1';
EXECUTE stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
DROP TABLE t1;
CREATE TABLE t1(f1 INT);
INSERT INTO t1 VALUES (1),(1);
PREPARE stmt FROM 'EXPLAIN SELECT 1 FROM t1 WHERE (SELECT (SELECT 1 FROM t1 GROUP BY f1))';
EXECUTE stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
DROP TABLE t1;
DROP PROCEDURE IF EXISTS p_string;
DROP PROCEDURE IF EXISTS p_double;
DROP PROCEDURE IF EXISTS p_int;
DROP PROCEDURE IF EXISTS p_decimal;
delimiter |;
CREATE PROCEDURE p_string(  IN v0 INT,  OUT v1 CHAR(32),  IN v2 CHAR(32),  INOUT v3 CHAR(32))BEGIN  SET v0 = -1;
  SET v1 = 'test_v1';
  SET v2 = 'n/a';
  SET v3 = 'test_v3';
END|CREATE PROCEDURE p_double(  IN v0 INT,  OUT v1 DOUBLE(4, 2),  IN v2 DOUBLE(4, 2),  INOUT v3 DOUBLE(4, 2))BEGIN  SET v0 = -1;
  SET v1 = 12.34;
  SET v2 = 98.67;
  SET v3 = 56.78;
END|CREATE PROCEDURE p_int(  IN v0 CHAR(10),  OUT v1 INT,  IN v2 INT,  INOUT v3 INT)BEGIN  SET v0 = 'n/a';
  SET v1 = 1234;
  SET v2 = 9876;
  SET v3 = 5678;
END|CREATE PROCEDURE p_decimal(  IN v0 INT,  OUT v1 DECIMAL(4, 2),  IN v2 DECIMAL(4, 2),  INOUT v3 DECIMAL(4, 2))BEGIN  SET v0 = -1;
  SET v1 = 12.34;
  SET v2 = 98.67;
  SET v3 = 56.78;
END|delimiter ;|PREPARE stmt_str FROM 'CALL p_string(?, ?, ?, ?)';
PREPARE stmt_dbl FROM 'CALL p_double(?, ?, ?, ?)';
PREPARE stmt_int FROM 'CALL p_int(?, ?, ?, ?)';
CREATE PROCEDURE p1(OUT v TINYINT)  SET v = 127;
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = 127;
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v SMALLINT)  SET v = 32767;
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = 32767;
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v MEDIUMINT)  SET v = 8388607;
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = 8388607;
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v INT)  SET v = 2147483647;
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = 2147483647;
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v BIGINT)  SET v = 9223372036854775807;
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = 9223372036854775807;
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v BIT(11))  SET v = b'10100100101';
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = b'10100100101';
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v TIMESTAMP)  SET v = '2007-11-18 15:01:02';
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = '2007-11-18 15:01:02';
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v DATETIME)  SET v = '1234-11-12 12:34:59';
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = '1234-11-12 12:34:59';
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v TIME)  SET v = '123:45:01';
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = '123:45:01';
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v DATE)  SET v = '1234-11-12';
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = '1234-11-12';
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v YEAR)  SET v = 2010;
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = 2010;
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v FLOAT(7, 4))  SET v = 123.4567;
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a - 123.4567 < 0.00001;
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v DOUBLE(8, 5))  SET v = 123.45678;
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a - 123.45678 < 0.000001;
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v DECIMAL(9, 6))  SET v = 123.456789;
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = 123.456789;
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v CHAR(32))  SET v = REPEAT('a', 16);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = REPEAT('a', 16);
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v VARCHAR(32))  SET v = REPEAT('b', 16);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = REPEAT('b', 16);
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v TINYTEXT)  SET v = REPEAT('c', 16);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = REPEAT('c', 16);
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v TEXT)  SET v = REPEAT('d', 16);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = REPEAT('d', 16);
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v MEDIUMTEXT)  SET v = REPEAT('e', 16);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = REPEAT('e', 16);
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v LONGTEXT)  SET v = REPEAT('f', 16);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = REPEAT('f', 16);
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v BINARY(32))  SET v = REPEAT('g', 32);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = REPEAT('g', 32);
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v VARBINARY(32))  SET v = REPEAT('h', 16);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = REPEAT('h', 16);
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v TINYBLOB)  SET v = REPEAT('i', 16);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = REPEAT('i', 16);
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v BLOB)  SET v = REPEAT('j', 16);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = REPEAT('j', 16);
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v MEDIUMBLOB)  SET v = REPEAT('k', 16);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = REPEAT('k', 16);
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v LONGBLOB)  SET v = REPEAT('l', 16);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = REPEAT('l', 16);
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v SET('aaa', 'bbb'))  SET v = 'aaa';
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = 'aaa';
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
CREATE PROCEDURE p1(OUT v ENUM('aaa', 'bbb'))  SET v = 'aaa';
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
SELECT @a, @a = 'aaa';
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;
PREPARE stmt_dec FROM 'CALL p_decimal(?, ?, ?, ?)';
SET @x_str_1 = NULL;
SET @x_str_2 = NULL;
SET @x_str_3 = NULL;
SET @x_dbl_1 = NULL;
SET @x_dbl_2 = NULL;
SET @x_dbl_3 = NULL;
SET @x_int_1 = NULL;
SET @x_int_2 = NULL;
SET @x_int_3 = NULL;
SET @x_dec_1 = NULL;
SET @x_dec_2 = NULL;
SET @x_dec_3 = NULL;
EXECUTE stmt_str USING @x_int_1, @x_str_1, @x_str_2, @x_str_3;
SELECT @x_int_1, @x_str_1, @x_str_2, @x_str_3;
EXECUTE stmt_str USING @x_int_1, @x_str_1, @x_str_2, @x_str_3;
SELECT @x_int_1, @x_str_1, @x_str_2, @x_str_3;
EXECUTE stmt_dbl USING @x_int_1, @x_dbl_1, @x_dbl_2, @x_dbl_3;
SELECT @x_int_1, @x_dbl_1, @x_dbl_2, @x_dbl_3;
EXECUTE stmt_dbl USING @x_int_1, @x_dbl_1, @x_dbl_2, @x_dbl_3;
SELECT @x_int_1, @x_dbl_1, @x_dbl_2, @x_dbl_3;
EXECUTE stmt_int USING @x_str_1, @x_int_1, @x_int_2, @x_int_3;
SELECT @x_str_1, @x_int_1, @x_int_2, @x_int_3;
EXECUTE stmt_int USING @x_str_1, @x_int_1, @x_int_2, @x_int_3;
SELECT @x_str_1, @x_int_1, @x_int_2, @x_int_3;
EXECUTE stmt_dec USING @x_int_1, @x_dec_1, @x_dec_2, @x_dec_3;
SELECT @x_int_1, @x_dec_1, @x_dec_2, @x_dec_3;
EXECUTE stmt_dec USING @x_int_1, @x_dec_1, @x_dec_2, @x_dec_3;
SELECT @x_int_1, @x_dec_1, @x_dec_2, @x_dec_3;
DEALLOCATE PREPARE stmt_str;
DEALLOCATE PREPARE stmt_dbl;
DEALLOCATE PREPARE stmt_int;
DEALLOCATE PREPARE stmt_dec;
DROP PROCEDURE p_string;
DROP PROCEDURE p_double;
DROP PROCEDURE p_int;
DROP PROCEDURE p_decimal;
DROP PROCEDURE IF EXISTS p1;
DROP PROCEDURE IF EXISTS p2;
CREATE PROCEDURE p1(OUT v1 CHAR(10))  SET v1 = 'test1';
delimiter |;
CREATE PROCEDURE p2(OUT v2 CHAR(10))BEGIN  SET @query = 'CALL p1(?)';
  PREPARE stmt1 FROM @query;
  EXECUTE stmt1 USING @u1;
  DEALLOCATE PREPARE stmt1;
  SET v2 = @u1;
END|delimiter ;|CALL p2(@a);
SELECT @a;
DROP PROCEDURE p1;
DROP PROCEDURE p2;
CREATE TABLE t1 (a INT);
BEGIN;
SELECT * FROM t1;
PREPARE stmt1 FROM "CREATE TABLE t1 AS SELECT 1";
EXECUTE stmt1;
DEALLOCATE PREPARE stmt1;
DROP TABLE t1;
connect(con1,localhost,root,,);
connection default;
CREATE TABLE t1 (a INT);
connection con1;
BEGIN;
PREPARE stmt1 FROM "SELECT * FROM t1";
connection default;
DROP TABLE t1;
disconnect con1;
SELECT *FROM (SELECT 1 UNION SELECT 2) t;
PREPARE s1 FROM SELECT c1, t2.c2, count(c3)FROM  (  SELECT 3 as c2 FROM dual WHERE @x = 1  UNION  SELECT 2       FROM dual WHERE @x = 1 OR @x = 2  ) AS t1,  (  SELECT '2012-03-01 01:00:00' AS c1, 3 as c2, 1 as c3 FROM dual  UNION  SELECT '2012-03-01 02:00:00',       3,       2       FROM dual  UNION  SELECT '2012-03-01 01:00:00',       2,       1       FROM dual  ) AS t2WHERE t2.c2 = t1.c2GROUP BY c1,c2ORDER BY c1,c2";
SET @x = 1;
SELECT c1, t2.c2, count(c3)FROM  (  SELECT 3 as c2 FROM dual WHERE @x = 1  UNION  SELECT 2       FROM dual WHERE @x = 1 OR @x = 2  ) AS t1,  (  SELECT '2012-03-01 01:00:00' AS c1, 3 as c2, 1 as c3 FROM dual  UNION  SELECT '2012-03-01 02:00:00',       3,       2       FROM dual  UNION  SELECT '2012-03-01 01:00:00',       2,       1       FROM dual  ) AS t2WHERE t2.c2 = t1.c2GROUP BY c1, c2ORDER BY c1, c2;
EXECUTE s1;
SET @x = 2;
SELECT c1, t2.c2, count(c3)FROM  (  SELECT 3 as c2 FROM dual WHERE @x = 1  UNION  SELECT 2       FROM dual WHERE @x = 1 OR @x = 2  ) AS t1,  (  SELECT '2012-03-01 01:00:00' AS c1, 3 as c2, 1 as c3 FROM dual  UNION  SELECT '2012-03-01 02:00:00',       3,       2       FROM dual  UNION  SELECT '2012-03-01 01:00:00',       2,       1       FROM dual  ) AS t2WHERE t2.c2 = t1.c2GROUP BY c1, c2ORDER BY c1, c2;
EXECUTE s1;
SET @x = 1;
SELECT c1, t2.c2, count(c3)FROM  (  SELECT 3 as c2 FROM dual WHERE @x = 1  UNION  SELECT 2       FROM dual WHERE @x = 1 OR @x = 2  ) AS t1,  (  SELECT '2012-03-01 01:00:00' AS c1, 3 as c2, 1 as c3 FROM dual  UNION  SELECT '2012-03-01 02:00:00',       3,       2       FROM dual  UNION  SELECT '2012-03-01 01:00:00',       2,       1       FROM dual  ) AS t2WHERE t2.c2 = t1.c2GROUP BY c1, c2ORDER BY c1, c2;
EXECUTE s1;
DEALLOCATE PREPARE s1;
CREATE TABLE t1(a INTEGER);
CREATE TABLE t2(a INTEGER);
PREPARE stmt FROM 'SELECT (SELECT 1 FROM t2 WHERE ot.a) AS dFROM t1 AS otGROUP BY d';
EXECUTE stmt;
EXECUTE stmt;
INSERT INTO t1 VALUES (0),(1),(2);
INSERT INTO t2 VALUES (1);
EXECUTE stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
DROP TABLE t1, t2;
CREATE TABLE t1 (  pk INTEGER AUTO_INCREMENT,  col_int_nokey INTEGER,  col_int_key INTEGER,  col_varchar_key VARCHAR(1),  col_varchar_nokey VARCHAR(1),  PRIMARY KEY (pk),  KEY (col_int_key),  KEY (col_varchar_key, col_int_key));
INSERT INTO t1 (  col_int_key, col_int_nokey,  col_varchar_key, col_varchar_nokey) VALUES (4,    2, 'v', 'v'),(62, 150, 'v', 'v');
CREATE TABLE t2 (  pk INTEGER AUTO_INCREMENT,  col_int_nokey INTEGER,  col_int_key INTEGER,  col_varchar_key VARCHAR(1),  col_varchar_nokey VARCHAR(1),  PRIMARY KEY (pk),  KEY (col_int_key),  KEY (col_varchar_key, col_int_key));
INSERT INTO t2 (  col_int_key, col_int_nokey,  col_varchar_key, col_varchar_nokey) VALUES (8, NULL, 'x', 'x'),(7, 8,    'd', 'd');
PREPARE stmt FROM ' SELECT  ( SELECT MAX( SQ1_alias2 .col_int_nokey ) AS SQ1_field1    FROM ( t2 AS SQ1_alias1 RIGHT JOIN t1 AS SQ1_alias2           ON ( SQ1_alias2.col_varchar_key = SQ1_alias1.col_varchar_nokey )         )    WHERE SQ1_alias2.pk < alias1.col_int_nokey OR alias1.pk  ) AS field1FROM ( t1 AS alias1 JOIN t2 AS alias2 ON alias2.pk )GROUP BY field1';
EXECUTE stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
DROP TABLE t1, t2;
CREATE TABLE t1 (a INTEGER);
CREATE TABLE t2 (b INTEGER);
PREPARE s FROM "INSERT INTO t1 VALUES(1) ON DUPLICATE KEY UPDATE absent=2";
PREPARE s FROM "INSERT INTO t1 VALUES(1) ON DUPLICATE KEY UPDATE a=absent";
PREPARE s FROM "INSERT INTO t1 SELECT 1 ON DUPLICATE KEY UPDATE absent=2";
PREPARE s FROM "INSERT INTO t1 SELECT 1 ON DUPLICATE KEY UPDATE a=absent";
PREPARE s FROM "INSERT INTO t1(absent) VALUES(1) ON DUPLICATE KEY UPDATE a=1";
PREPARE s FROM "INSERT INTO t1(absent) SELECT 1 ON DUPLICATE KEY UPDATE a=1";
PREPARE s FROM "UPDATE t1 JOIN t2 ON t1.a=t2.b SET t1.a=absent";
PREPARE s FROM "UPDATE t1 JOIN t2 ON t1.a=t2.b SET t1.a=t1.absent";
PREPARE s FROM "UPDATE t1 JOIN t2 ON t1.a=t2.b SET t1.a=t2.absent";
PREPARE s FROM "UPDATE t1 JOIN t2 ON t1.a=t2.b SET t1.a=absent.absent";
DROP TABLE t1, t2;
CREATE TABLE bug19894382(f1 CHAR(64) DEFAULT 'slave',                         f2 TIME, f3 TIMESTAMP NULL, f4 DATETIME,                         f5 TIME(3), f6 TIMESTAMP(3) NULL, f7 DATETIME(3));
INSERT INTO bug19894382 SELECT * FROM client_test_db.bug19894382;
INSERT INTO bug19894382(f2, f3, f4, f5, f6, f7)  SELECT f2, f3, f4, f5, f6, f7 FROM client_test_db.bug19894382;
SELECT * FROM bug19894382 ORDER BY f2;
DROP TABLE bug19894382;
SET @a=repeat('a', 100000);
prepare s from "select length(?)";
execute s using @a;
DROP DATABASE client_test_db;
CREATE TABLE t1 (t time DEFAULT NULL);
INSERT INTO t1 VALUES ('16:07:44');
SET @var1 = 5;
PREPARE s FROM "DELETE FROM t1 WHERE t = ?";
EXECUTE s USING @var1;
DEALLOCATE PREPARE s;
DROP TABLE t1;
CREATE TABLE t1 (dt datetime DEFAULT NULL);
INSERT INTO t1 VALUES ('2018-11-11 16:07:44');
SET @var1 = 5;
PREPARE s FROM "DELETE FROM t1 WHERE dt = ?";
EXECUTE s USING @var1;
DEALLOCATE PREPARE s;
DROP TABLE t1;
CREATE TABLE t1 (d date DEFAULT NULL);
INSERT INTO t1 VALUES ('2018-11-11');
SET @var1 = 5;
PREPARE s FROM "DELETE FROM t1 WHERE d = ?";
EXECUTE s USING @var1;
DEALLOCATE PREPARE s;
DROP TABLE t1;
CREATE TABLE t(a INT, b INT);
INSERT INTO t VALUES (1, 1), (2, 2), (3, 3), (4, 4);
PREPARE ps FROM  'UPDATE t, (SELECT 1 FROM t UNION SELECT 2 FROM t) e SET a = 0 WHERE FALSE';
EXECUTE ps;
EXECUTE ps;  # The second execution used to fail.DROP PREPARE ps;
DROP TABLE t;
CREATE TABLE t1(c1 int);
INSERT INTO t1 VALUES(1),(2);
CREATE FUNCTION f1() returns INT deterministic return 1;
CREATE VIEW v1 AS SELECT c1 FROM t1 WHERE c1 = f1();
DROP FUNCTION f1;
PREPARE stmt FROM "SHOW CREATE VIEW v1";
EXECUTE stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (a char (64) character set latin1, b int unsigned);
PREPARE s FROM 'SELECT a FROM t1 WHERE a=? AND b=?';
SET @a = 'test';
SET @b = 2;
EXECUTE s USING @a, @b;
DEALLOCATE PREPARE s;
DROP TABLE t1;
CREATE TABLE t1 (a INTEGER);
PREPARE s FROM 'SELECT 1 FROM t1 WHERE TRUE OR ( SELECT 1 FROM (SELECT a) q ) = 1';
EXECUTE s;
DROP TABLE t1;
CREATE TABLE t1 ( pk INTEGER NOT NULL, a INTEGER );
PREPARE q FROM 'EXPLAIN FORMAT=tree SELECT * FROM t1 WHERE pk = ?';
SET @v = 2;
EXECUTE q USING @v;
DROP TABLE t1;
SET GLOBAL log_output=@old_log_output;
TRUNCATE TABLE mysql.general_log;
TRUNCATE TABLE mysql.slow_log;
