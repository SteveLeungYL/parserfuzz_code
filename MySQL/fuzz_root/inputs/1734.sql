SELECT @@max_heap_table_size INTO @old_max_heap_table_size;
SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
DROP TABLE no_such_table;
SHOW ERRORS;
SHOW WARNINGS;
SHOW COUNT(*) ERRORS;
SHOW COUNT(*) WARNINGS;
GET DIAGNOSTICS @n = NUMBER;
GET DIAGNOSTICS CONDITION 1 @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT;
SELECT @n, @err_no, @err_txt;
DROP TABLE no_such_table;
SELECT @@error_count;
SELECT @@error_count;
DROP TABLE no_such_table;
SELECT @@warning_count;
SELECT @@warning_count;
CREATE TABLE IF NOT EXISTS t2 (f1 INT);
CREATE TABLE IF NOT EXISTS t2 (f1 INT);
SELECT @@warning_count;
DROP TABLE t2;
DROP TABLE no_such_table;
GET DIAGNOSTICS;
GET DIAGNOSTICS @n = NUMBER;
GET DIAGNOSTICS CONDITION 1 @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT;
SELECT @n, @err_no, @err_txt;
SET GLOBAL wombat = 'pangolin';
CREATE PROCEDURE p0_proc_with_warning () BEGIN SELECT CAST('2001-01-01' AS SIGNED INT); END;
CREATE PROCEDURE p6_bubble_warning () BEGIN DECLARE CONTINUE HANDLER FOR NOT FOUND BEGIN /* Absurdly high CONDITION number will cause GET DIAG to fail. As it is the last statement, warning should bubble up to caller. */ GET DIAGNOSTICS CONDITION 99 @e6 = MYSQL_ERRNO, @t6 = MESSAGE_TEXT; END; SET @n2 = 0, @e2 = 0, @t2 = 'handler was not run or GET DIAGNOSTICS failed'; SIGNAL SQLSTATE '02000' SET MESSAGE_TEXT = 'signal message'; END;
CREATE PROCEDURE p3_non_diagnostics_stmt_clears () BEGIN DECLARE CONTINUE HANDLER FOR NOT FOUND BEGIN /* Do some stuff before using GET (CURRENT, not STACKED) DIAGNOSTICS. This will clear the DA. show that handler was run, even if GET DIAG below fails! */ SET @t3 = 'handler was run, but GET DIAGNOSTICS failed'; SELECT 1 FROM DUAL; GET CURRENT DIAGNOSTICS @n3 = NUMBER; GET CURRENT DIAGNOSTICS CONDITION 1 @e3 = MYSQL_ERRNO, @t3 = MESSAGE_TEXT; END; SET @n3 = 0, @e3 = 0, @t3 = 'handler was not run or GET DIAGNOSTICS failed'; SIGNAL SQLSTATE '02000' SET MESSAGE_TEXT = 'signal message'; /* Show handler was called. */ SELECT @n3, @e3, @t3; END;
CREATE PROCEDURE p4_unhandled_exception_returned () BEGIN /* This will throw an exception which we do not handle, so execution will abort, and the caller will see the error. */ DROP TABLE no_such_table; SELECT "we should never get here"; END;
CREATE PROCEDURE p7_show_warnings () BEGIN SHOW VARIABLES LIKE 'foo'; SHOW WARNINGS; SELECT "(SHOW WARNINGS does not have to come last)"; END;
CREATE PROCEDURE p8a_empty () BEGIN END;
CREATE PROCEDURE p8b_show_warnings () BEGIN SHOW WARNINGS; END;
CALL p0_proc_with_warning;
DROP PROCEDURE p0_proc_with_warning;
CALL p1_declare_handler_preserves;
DROP PROCEDURE p1_declare_handler_preserves;
CALL p2_declare_variable_clears;
DROP PROCEDURE p2_declare_variable_clears;
CALL p5_declare_variable_clears;
DROP PROCEDURE p5_declare_variable_clears;
CALL p6_bubble_warning;
DROP PROCEDURE p6_bubble_warning;
CALL p3_non_diagnostics_stmt_clears;
DROP PROCEDURE p3_non_diagnostics_stmt_clears;
CALL p4_unhandled_exception_returned;
DROP PROCEDURE p4_unhandled_exception_returned;
CALL p7_show_warnings;
DROP PROCEDURE p7_show_warnings;
DROP TABLE no_such_table;
CALL p8a_empty;
SHOW WARNINGS;
DROP PROCEDURE p8a_empty;
DROP TABLE no_such_table;
CALL p8b_show_warnings;
DROP PROCEDURE p8b_show_warnings;
CREATE FUNCTION f2_unseen_warnings() RETURNS INT BEGIN /* throw a warning */ SET @@max_heap_table_size= 1; /* RETURN counts as a statement as per the standard, so clears DA */ RETURN 1; END;
CREATE FUNCTION f3_stacking_warnings() RETURNS TEXT BEGIN /* throw a warning */ RETURN CAST('2001-01-01' AS SIGNED INT); END;
CREATE FUNCTION f4_show_warnings() RETURNS TEXT BEGIN SHOW WARNINGS; RETURN "yeah, not so much"; END;
SELECT f2_unseen_warnings();
SHOW WARNINGS;
SET @@max_heap_table_size= 1;
DROP FUNCTION f2_unseen_warnings;
SELECT f3_stacking_warnings(),f3_stacking_warnings(),f3_stacking_warnings();
DROP FUNCTION f3_stacking_warnings;
PREPARE stmt1 FROM 'create table if not exists t1 (f1 int)';
EXECUTE stmt1;
EXECUTE stmt1;
DEALLOCATE PREPARE stmt1;
DROP TABLE t1;
PREPARE stmt1 FROM 'create table if not exists t1 (f1 int)';
EXECUTE stmt1;
CREATE PROCEDURE p10_ps_with_warning () BEGIN DECLARE CONTINUE HANDLER FOR 1050 SELECT "a warn place"; EXECUTE stmt1; END;
CALL p10_ps_with_warning ();
DROP PROCEDURE p10_ps_with_warning;
DEALLOCATE PREPARE stmt1;
DROP TABLE t1;
PREPARE stmt1 FROM 'create table if not exists t1 (f1 year)';
EXECUTE stmt1;
EXECUTE stmt1;
DEALLOCATE PREPARE stmt1;
DROP TABLE t1;
