drop table if exists t1;
drop procedure if exists p1;
drop procedure if exists p2;
drop procedure if exists p3;
drop procedure if exists p4;
drop function if exists f1;
create table t1 (a int);
begin;
savepoint sv;
create procedure p1() begin end;
rollback to savepoint sv;
begin;
savepoint sv;
alter procedure p1 comment 'changed comment';
rollback to savepoint sv;
begin;
savepoint sv;
drop procedure p1;
rollback to savepoint sv;
begin;
savepoint sv;
create function f1() returns int return 1;
rollback to savepoint sv;
begin;
savepoint sv;
alter function f1 comment 'new comment';
rollback to savepoint sv;
begin;
savepoint sv;
drop function f1;
rollback to savepoint sv;
create procedure p1() begin end;
create function f1() returns int return 1;
lock table t1 write;
create procedure p2() begin end;
alter procedure p1 comment 'changed comment';
drop procedure p1;
create function f2() returns int return 1;
alter function f1 comment 'changed comment';
lock table t1 read;
create procedure p2() begin end;
alter procedure p1 comment 'changed comment';
drop procedure p1;
create function f2() returns int return 1;
alter function f1 comment 'changed comment';
unlock tables;
drop table t1;
create temporary table t1 (a int);
lock table t1 read;
create procedure p2() begin end;
alter procedure p1 comment 'changed comment';
drop procedure p1;
create function f2() returns int return 1;
alter function f1 comment 'changed comment';
unlock tables;
drop function f1;
drop procedure p1;
drop temporary table t1;
create procedure p1() begin end;
create function f1() returns int  begin call p1(); return 1; end;
begin;
select f1();
drop procedure p1;
select f1();
commit;
reap;
reap;
create procedure p1() begin end;
begin;
select f1();
create procedure p1() begin end;
select f1();
commit;
reap;
reap;
begin;
select f1();
alter procedure p1 contains sql;
select f1();
commit;
reap;
reap;
begin;
select f1();
drop function f1;
select f1();
commit;
reap;
reap;
create function f1() returns int return 1;
begin;
select f1();
create function f1() returns int return 2;
select f1();
commit;
reap;
reap;
begin;
select f1();
alter function f1 contains sql;
select f1();
commit;
reap;
reap;
drop function f1;
drop procedure p1;
create function f1() returns int return 1;
create table t1 (a int);
create table t2 (a int, b int);
create trigger t1_ai after insert on t1 for each row insert into t2 (a, b) values (new.a, f1());
begin;
insert into t1 (a) values (1);
drop function f1;
commit;
reap;
create function f1() returns int return 1;
create view v1 as select f1() as a;
begin;
select * from v1;
drop function f1;
commit;
reap;
create function f1() returns int begin declare v_out int; call p1(v_out); return v_out; end;
create procedure p1(out v_out int) set v_out=3;
begin;
select * from v1;
drop procedure p1;
commit;
reap;
create function f2() returns int return 4;
create procedure p1(out v_out int) set v_out=f2();
drop trigger t1_ai;
create trigger t1_ai after insert on t1 for each row insert into t2 (a, b) values (new.a, (select max(a) from v1));
begin;
insert into t1 (a) values (3);
drop function f2;
commit;
reap;
drop view v1;
drop function f1;
drop procedure p1;
drop table t1, t2;
create function f1() returns int return 7;
create table t1 (a int);
begin;
select * from t1;
select f1();
commit;
drop table t1;
drop function f1;
create function f1() returns varchar(20) return "f1()";
create function f2() returns varchar(20) return "f2()";
create view v1 as select f1() as a;
set @@session.autocommit=0;
lock table v1 read;
select * from v1;
savepoint sv;
select f2();
drop function f1;
drop function f2;
rollback to savepoint sv;
reap;
unlock tables;
reap;
drop function f1;
drop function f2;
drop view v1;
set @@session.autocommit=default;
create function f1() returns int return 1;
create function f2() returns int begin if @var is null then call p1(); end if; return 1; end;
create procedure p1() begin select f1() into @var; execute stmt; end;
prepare stmt from "select f2()";
begin;
select f1();
alter function f1 comment "comment";
call p1();
commit;
reap;
reap;
deallocate prepare stmt;
drop function f1;
drop function f2;
drop procedure p1;
create function f1() returns int return 1;
begin;
select f1();
alter function f1 comment "comment";
create function f2() returns int begin if @var is null then call p1(); end if; return 1; end;
create procedure p1() begin select f1() into @var; select f2() into @var; end;
call p1();
commit;
reap;
reap;
drop function f1;
drop function f2;
drop procedure p1;
create function f1() returns int return get_lock("30977", 100000);
create function f2() returns int return 2;
create function f3() returns varchar(255)  begin declare res varchar(255); declare c cursor for select routine_name from information_schema.routines where routine_name='f1'; select f1() into @var; open c; fetch c into res; close c; select f2() into @var; return res; end;
select get_lock("30977", 0);
select f3();
create function f4() returns int return  4;
drop function f4;
select release_lock("30977");
reap;
select @var;
drop function f1;
drop function f2;
drop function f3;
create function f1() returns int begin call p1(); return 1; end;
create procedure p1()  begin create view v1 as select 1; drop view v1; select f1() into @var; set @exec_count=@exec_count+1; end;
set @exec_count=0;
call p1();
select @exec_count;
set @@session.max_sp_recursion_depth=5;
set @exec_count=0;
call p1();
select @exec_count;
drop procedure p1;
drop function f1;
set @@session.max_sp_recursion_depth=default;
show session status;
show session status;
show session status;
CREATE PROCEDURE p1() BEGIN SHOW CREATE PROCEDURE p1; SELECT get_lock("test", 100000); SHOW CREATE PROCEDURE p1; END;
SELECT get_lock("test", 10);
CALL p1();
DROP PROCEDURE p1;
CREATE PROCEDURE p1() BEGIN END;
SELECT release_lock("test");
reap;
show session status;
show session status;
DROP PROCEDURE p1;
DROP DATABASE IF EXISTS db1;
DROP FUNCTION IF EXISTS f1;
CREATE DATABASE db1;
CREATE FUNCTION db1.f1() RETURNS INTEGER RETURN 1;
START TRANSACTION;
SELECT db1.f1();
DROP DATABASE db1;
COMMIT;
reap;
CREATE DATABASE db1;
CREATE PROCEDURE db1.p1() BEGIN END;
CREATE FUNCTION f1() RETURNS INTEGER BEGIN CALL db1.p1(); RETURN 1; END;
START TRANSACTION;
SELECT f1();
DROP DATABASE db1;
COMMIT;
reap;
CREATE DATABASE db1;
CREATE TABLE db1.t1 (a INT);
CREATE FUNCTION db1.f1() RETURNS INTEGER RETURN 1;
START TRANSACTION;
SELECT db1.f1();
DROP DATABASE db1;
SELECT * FROM db1.t1;
COMMIT;
reap;
CREATE DATABASE db1;
CREATE FUNCTION db1.f1() RETURNS INTEGER RETURN 1;
CREATE FUNCTION db1.f2() RETURNS INTEGER RETURN 2;
START TRANSACTION;
SELECT db1.f2();
DROP DATABASE db1;
ALTER FUNCTION db1.f1 COMMENT "test";
COMMIT;
reap;
show session status;
reap;
show session status;
DROP FUNCTION f1;
