create procedure syntaxerror(t int);
create procedure syntaxerror(t int);
create procedure syntaxerror(t int);
create table t3 ( x int );
insert into t3 values (2), (3);
create procedure bad_into(out param int) select x from t3 into param;
call bad_into(@x);
drop procedure bad_into;
drop table t3;
create procedure proc1() set @x = 42;
create function func1() returns int return 42;
create procedure foo() create procedure bar() set @x=3;
create procedure foo() create function bar() returns double return 2.3;
create procedure proc1() set @x = 42;
create function func1() returns int return 42;
drop procedure proc1;
drop function func1;
alter procedure foo;
alter function foo;
drop procedure foo;
drop function foo;
call foo();
drop procedure if exists foo;
show create procedure foo;
show create function foo;
create procedure foo() foo: loop leave bar; end loop;
create procedure foo() foo: loop iterate bar; end loop;
create procedure foo() foo: begin iterate foo; end;
create procedure foo() foo: loop foo: loop set @x=2; end loop foo; end loop foo;
create procedure foo() foo: loop set @x=2; end loop bar;
create procedure foo() return 42;
create procedure p(x int) set @x = x;
create function f(x int) returns int return x+42;
call p();
call p(1, 2);
select f();
select f(1, 2);
drop procedure p;
drop function f;
create procedure p(val int, out res int) begin declare x int default 0; declare continue handler for foo set x = 1; insert into test.t1 values (val); if (x) then set res = 0; else set res = 1; end if; end;
create procedure p(val int, out res int) begin declare x int default 0; declare foo condition for 1146; declare continue handler for bar set x = 1; insert into test.t1 values (val); if (x) then set res = 0; else set res = 1; end if; end;
create function f(val int) returns int begin declare x int; set x = val+3; end;
create function f(val int) returns int begin declare x int; set x = val+3; if x < 4 then return x; end if; end;
select f(10);
drop function f;
create procedure p() begin declare c cursor for insert into test.t1 values ("foo", 42); open c; close c; end;
create procedure p() begin declare x int; declare c cursor for select * into x from test.t limit 1; open c; close c; end;
create procedure p() begin declare c cursor for select * from test.t; open cc; close c; end;
create table t1 (val int);
create procedure p() begin declare c cursor for select * from test.t1; open c; open c; close c; end;
call p();
drop procedure p;
create procedure p() begin declare c cursor for select * from test.t1; open c; close c; close c; end;
call p();
drop procedure p;
alter procedure bar3 sql security invoker;
drop table t1;
create table t1 (val int, x float);
insert into t1 values (42, 3.1), (19, 1.2);
create procedure p() begin declare x int; declare c cursor for select * from t1; open c; fetch c into x, y; close c; end;
create procedure p() begin declare x int; declare c cursor for select * from t1; open c; fetch c into x; close c; end;
call p();
drop procedure p;
create procedure p() begin declare x int; declare y float; declare z int; declare c cursor for select * from t1; open c; fetch c into x, y, z; close c; end;
call p();
drop procedure p;
create procedure p(in x int, x char(10)) begin end;
create function p(x int, x char(10)) begin end;
create procedure p() begin declare x float; declare x int; end;
create procedure p() begin declare c condition for 1064; declare c condition for 1065; end;
create procedure p() begin declare c cursor for select * from t1; declare c cursor for select field from t1; end;
create procedure u() use sptmp;
create procedure p() begin declare c cursor for select * from t1; declare x int; end;
create procedure p() begin declare x int; declare continue handler for sqlstate '42S99' set x = 1; declare foo condition for sqlstate '42S99'; end;
create procedure p() begin declare x int; declare continue handler for sqlstate '42S99' set x = 1; declare c cursor for select * from t1; end;
create procedure p(in x int, inout y int, out z int) begin set y = x+y; set z = x+y; end;
set @tmp_x = 42;
set @tmp_y = 3;
set @tmp_z = 0;
call p(@tmp_x, @tmp_y, @tmp_z);
select @tmp_x, @tmp_y, @tmp_z;
call p(42, 43, @tmp_z);
call p(42, @tmp_y, 43);
drop procedure p;
create procedure p() begin end;
lock table t1 read;
call p();
unlock tables;
drop procedure p;
create function f1(i int) returns int begin insert into t1 (val) values (i); return 0; end;
select val, f1(val) from t1;
select val, f1(val) from t1 as tab;
select * from t1;
update t1 set val= f1(val);
select * from t1;
select f1(17);
select * from t1;
delete from t1 where val= 17;
drop function f1;
create procedure bug1965() begin declare c cursor for select val from t1 order by valname; open c; close c; end;
call bug1965();
drop procedure bug1965;
select 1 into a;
create table t3 (column_1_0 int);
create procedure bug1653() update t3 set column_1 = 0;
call bug1653();
drop table t3;
create table t3 (column_1 int);
call bug1653();
drop procedure bug1653;
drop table t3;
create procedure bug2259() begin declare v1 int; declare c1 cursor for select s1 from t1; fetch c1 into v1; end;
call bug2259();
drop procedure bug2259;
create procedure bug2272() begin declare v int; update t1 set v = 42; end;
insert into t1 values (666, 51.3);
call bug2272();
truncate table t1;
drop procedure bug2272;
create procedure bug2329_1() begin declare v int; insert into t1 (v) values (5); end;
create procedure bug2329_2() begin declare v int; replace t1 set v = 5; end;
call bug2329_1();
call bug2329_2();
drop procedure bug2329_1;
drop procedure bug2329_2;
create function bug3287() returns int begin declare v int default null; case when v is not null then return 1; end case; return 2; end;
select bug3287();
drop function bug3287;
create procedure bug3287(x int) case x when 0 then insert into test.t1 values (x, 0.1); when 1 then insert into test.t1 values (x, 1.1); end case;
call bug3287(2);
drop procedure bug3287;
create table t3 (s1 int, primary key (s1));
insert into t3 values (5),(6);
create procedure bug3279(out y int)  begin declare x int default 0; begin declare exit handler for sqlexception set x = x+1; insert into t3 values (5); end; if x < 2 then set x = x+1; insert into t3 values (6); end if; set y = x; end;
set @x = 0;
call bug3279(@x);
select @x;
drop procedure bug3279;
drop table t3;
create procedure nodb.bug3339() begin end;
create procedure bug2653_1(a int, out b int) set b = aa;
create procedure bug2653_2(a int, out b int) begin if aa < 0 then set b = - a; else set b = a; end if; end;
call bug2653_1(1, @b);
call bug2653_2(2, @b);
drop procedure bug2653_1;
drop procedure bug2653_2;
create procedure bug4344() drop procedure bug4344;
create procedure bug4344() drop function bug4344;
create procedure bug3294() begin declare continue handler for sqlexception drop table t5; drop table t5; drop table t5; end;
create table t5 (x int);
call bug3294();
drop procedure bug3294;
drop procedure if exists bug8776_1;
drop procedure if exists bug8776_2;
drop procedure if exists bug8776_3;
drop procedure if exists bug8776_4;
create procedure bug8776_1() begin declare continue handler for sqlstate '42S0200test' begin end; begin end; end;
create procedure bug8776_2() begin declare continue handler for sqlstate '4200' begin end; begin end; end;
create procedure bug8776_3() begin declare continue handler for sqlstate '420000' begin end; begin end; end;
create procedure bug8776_4() begin declare continue handler for sqlstate '42x00' begin end; begin end; end;
create procedure bug6600() check table t1;
create procedure bug6600() lock table t1 read;
create procedure bug6600() unlock table t1;
create procedure bug7299() begin declare v int; declare c cursor for select val from t1; declare exit handler for sqlexception select 'Error!';  open c; fetch c into v; end;
truncate table t1;
call bug7299();
drop procedure bug7299;
create procedure bug9073() begin declare continue handler for sqlexception select 1; declare continue handler for sqlexception select 2; end;
create procedure bug9073() begin declare condname1 condition for 1234; declare continue handler for condname1 select 1; declare exit handler for condname1 select 2; end;
create procedure bug9073() begin declare condname1 condition for sqlstate '42000'; declare condname2 condition for sqlstate '42000'; declare exit handler for condname1 select 1; declare continue handler for condname2 select 2; end;
create procedure bug9073() begin declare condname1 condition for sqlstate '42000'; declare exit handler for condname1 select 1; declare exit handler for sqlstate '42000' select 2; end;
create procedure bug9073() begin declare condname1 condition for sqlstate '42000'; declare continue handler for condname1 select 1; begin declare exit handler for sqlstate '42000' select 2; begin declare continue handler for sqlstate '42000' select 3; end; end; end;
drop procedure bug9073;
create procedure bug7047() alter procedure bug7047;
create function bug7047() returns int begin alter function bug7047; return 0; end;
create function bug8408() returns int begin select * from t1; return 0; end;
create function bug8408() returns int begin show warnings; return 0; end;
create function bug8408(a int) returns int begin declare b int; select b; return b; end;
drop function if exists bug8408_f;
drop procedure if exists bug8408_p;
create function bug8408_f() returns int begin call bug8408_p(); return 0; end;
create procedure bug8408_p() select * from t1;
call bug8408_p();
select bug8408_f();
drop procedure bug8408_p;
drop function bug8408_f;
create function bug8408() returns int begin declare n int default 0; select count(*) into n from t1; return n; end;
insert into t1 value (2, 2.7), (3, 3.14), (7, 7.0);
select *,bug8408() from t1;
drop function bug8408;
truncate table t1;
create procedure bug10537() load data local infile '/tmp/somefile' into table t1;
create function bug8409() returns int begin flush tables; return 5; end;
create function bug8409() returns int begin reset master; return 1; end;
create function bug8409() returns int begin reset slave; return 1; end;
create function bug8409() returns int begin flush hosts; return 1; end;
create function bug8409() returns int begin flush privileges; return 1; end;
create function bug8409() returns int begin flush tables with read lock; return 1; end;
create function bug8409() returns int begin flush tables; return 1; end;
create function bug8409() returns int begin flush logs; return 1; end;
create function bug8409() returns int begin flush status; return 1; end;
create function bug8409() returns int begin flush user_resources; return 1; end;
create procedure bug9529_901234567890123456789012345678901234567890123456789012345() begin end;
create procedure bug17015_0123456789012345678901234567890123456789012345678901234() begin end;
show procedure status like 'bug17015%';
drop procedure bug17015_0123456789012345678901234567890123456789012345678901234;
create procedure bug10969() begin declare s1 int default 0; select default(s1) from t30; end;
create procedure bug10969() begin declare s1 int default 0; select default(t30.s1) from t30; end;
drop procedure bug10969;
drop table t1;
create table t1(f1 int);
create table t2(f1 int);
CREATE PROCEDURE SP001() P1: BEGIN DECLARE ENDTABLE INT DEFAULT 0; DECLARE TEMP_NUM INT; DECLARE TEMP_SUM INT; DECLARE C1 CURSOR FOR SELECT F1 FROM t1; DECLARE C2 CURSOR FOR SELECT F1 FROM t2; DECLARE CONTINUE HANDLER FOR NOT FOUND SET ENDTABLE = 1; SET ENDTABLE=0; SET TEMP_SUM=0; SET TEMP_NUM=0; OPEN C1; FETCH C1 INTO TEMP_NUM; WHILE ENDTABLE = 0 DO SET TEMP_SUM=TEMP_NUM+TEMP_SUM; FETCH C1 INTO TEMP_NUM; END WHILE; SELECT TEMP_SUM; CLOSE C1; CLOSE C1; SELECT 'end of proc'; END P1;
call SP001();
drop procedure SP001;
drop table t1, t2;
drop function if exists bug11394;
drop function if exists bug11394_1;
drop function if exists bug11394_2;
drop procedure if exists bug11394;
create function bug11394(i int) returns int begin if i <= 0 then return 0; else return (i in (100, 200, bug11394(i-1), 400)); end if; end;
select bug11394(2);
drop function bug11394;
create function bug11394_1(i int) returns int begin if i <= 0 then return 0; else return (select bug11394_1(i-1)); end if; end;
select bug11394_1(2);
drop function bug11394_1;
create function bug11394_2(i int) returns int return i;
select bug11394_2(bug11394_2(10));
drop function bug11394_2;
create procedure bug11394(i int, j int) begin if i > 0 then call bug11394(i - 1,(select 1)); end if; end;
call bug11394(2, 1);
set @@max_sp_recursion_depth=10;
call bug11394(2, 1);
set @@max_sp_recursion_depth=default;
drop procedure bug11394;
CREATE PROCEDURE BUG_12490() HELP CONTENTS;
CREATE FUNCTION BUG_12490() RETURNS INT HELP CONTENTS;
CREATE TABLE t_bug_12490(a int);
CREATE TRIGGER BUG_12490 BEFORE UPDATE ON t_bug_12490 FOR EACH ROW HELP CONTENTS;
DROP TABLE t_bug_12490;
drop function if exists bug11834_1;
drop function if exists bug11834_2;
create function bug11834_1() returns int return 10;
create function bug11834_2() returns int return bug11834_1();
prepare stmt from "select bug11834_2()";
execute stmt;
execute stmt;
drop function bug11834_1;
execute stmt;
deallocate prepare stmt;
drop function bug11834_2;
CREATE FUNCTION bug12953() RETURNS INT BEGIN OPTIMIZE TABLE t1; RETURN 1; END;
CREATE FUNCTION bug12995() RETURNS INT BEGIN HANDLER t1 OPEN; RETURN 1; END;
CREATE FUNCTION bug12995() RETURNS INT BEGIN HANDLER t1 READ FIRST; RETURN 1; END;
CREATE FUNCTION bug12995() RETURNS INT BEGIN HANDLER t1 CLOSE; RETURN 1; END;
SELECT bug12995();
drop procedure if exists bug12712;
drop function if exists bug12712;
create procedure bug12712() set session autocommit = 0;
select @@autocommit;
set @au = @@autocommit;
call bug12712();
select @@autocommit;
set session autocommit = @au;
create function bug12712() returns int begin call bug12712(); return 0; end;
set @x = bug12712();
drop procedure bug12712;
drop function bug12712;
create function bug12712() returns int begin set session autocommit = 0; return 0; end;
create function bug12712() returns int begin set @@autocommit = 0; return 0; end;
create function bug12712() returns int begin set local autocommit = 0; return 0; end;
create trigger bug12712 before insert on t1 for each row set session autocommit = 0;
drop procedure if exists bug13510_1;
drop procedure if exists bug13510_2;
drop procedure if exists bug13510_3;
drop procedure if exists bug13510_4;
create procedure bug13510_1() begin declare password varchar(10); set password = 'foo1'; select password; end;
set names='foo2';
create procedure bug13510_2() begin declare names varchar(10); set names = 'foo2'; select names; end;
create procedure bug13510_3() begin declare password varchar(10); set `password` = 'foo3'; select password; end;
create procedure bug13510_4() begin declare names varchar(10); set `names` = 'foo4'; select names; end;
call bug13510_3();
call bug13510_4();
drop procedure bug13510_3;
drop procedure bug13510_4;
CREATE TABLE t1 (a int);
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN DROP TRIGGER test1; END ;
CREATE FUNCTION bug_13627_f() returns int BEGIN DROP TRIGGER test1; return 1; END ;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create table t2 (a int); END ;
CREATE FUNCTION bug_13627_f() returns int BEGIN create table t2 (a int); return 1; END ;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create index t1_i on t1 (a); END ;
CREATE FUNCTION bug_13627_f() returns int BEGIN create index t1_i on t1 (a); return 1; END ;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN alter table t1 add column  b int; END ;
CREATE FUNCTION bug_13627_f() returns int BEGIN alter table t1 add column  b int; return 1; END ;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN rename table t1 to t2; END ;
CREATE FUNCTION bug_13627_f() returns int BEGIN rename table t1 to t2; return 1; END ;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN truncate table t1; END ;
CREATE FUNCTION bug_13627_f() returns int BEGIN truncate table t1; return 1; END ;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop table t1; END ;
CREATE FUNCTION bug_13627_f() returns int BEGIN drop table t1; return 1; END ;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop index t1_i on t1; END ;
CREATE FUNCTION bug_13627_f() returns int BEGIN drop index t1_i on t1; return 1; END ;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN unlock tables; END ;
CREATE FUNCTION bug_13627_f() returns int BEGIN unlock tables; return 1; END ;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN LOCK TABLE t1 READ; END ;
CREATE FUNCTION bug_13627_f() returns int BEGIN LOCK TABLE t1 READ; return 1; END ;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create database mysqltest; END ;
CREATE FUNCTION bug_13627_f() returns int BEGIN create database mysqltest; return 1; END ;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop database mysqltest; END ;
CREATE FUNCTION bug_13627_f() returns int BEGIN drop database mysqltest; return 1; END ;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create user 'mysqltest_1'; END ;
CREATE FUNCTION bug_13627_f() returns int BEGIN create user 'mysqltest_1'; return 1; END ;
CREATE TRIGGER bug21975 BEFORE INSERT ON t1 FOR EACH ROW BEGIN grant select on t1 to 'mysqltest_1'; END ;
CREATE FUNCTION bug21975() returns int BEGIN grant select on t1 to 'mysqltest_1'; return 1; END ;
CREATE TRIGGER bug21975 BEFORE INSERT ON t1 FOR EACH ROW BEGIN revoke select on t1 from 'mysqltest_1'; END ;
CREATE FUNCTION bug21975() returns int BEGIN revoke select on t1 from 'mysqltest_1'; return 1; END ;
CREATE TRIGGER bug21975 BEFORE INSERT ON t1 FOR EACH ROW BEGIN revoke all privileges on *.* from 'mysqltest_1'; END ;
CREATE FUNCTION bug21975() returns int BEGIN revoke all privileges on *.* from 'mysqltest_1'; return 1; END ;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop user 'mysqltest_1'; END ;
CREATE FUNCTION bug_13627_f() returns int BEGIN drop user 'mysqltest_1'; return 1; END ;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN rename user 'mysqltest_2' to 'mysqltest_1'; END ;
CREATE FUNCTION bug_13627_f() returns int BEGIN rename user 'mysqltest_2' to 'mysqltest_1'; return 1; END ;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create view v1 as select 1; END ;
CREATE FUNCTION bug_13627_f() returns int BEGIN create view v1 as select 1; return 1; END ;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN alter view v1 as select 1; END ;
CREATE FUNCTION bug_13627_f() returns int BEGIN alter view v1 as select 1; return 1; END ;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop view v1; END ;
CREATE FUNCTION bug_13627_f() returns int BEGIN drop view v1; return 1; END ;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create trigger tr2 before insert on t1 for each row do select 1; END ;
CREATE FUNCTION bug_13627_f() returns int BEGIN create trigger tr2 before insert on t1 for each row do select 1; return 1; END ;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop function bug_13627_f; END ;
CREATE FUNCTION bug_13627_f() returns int BEGIN drop function bug_13627_f; return 1; END ;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create function f2 () returns int return 1; END ;
CREATE FUNCTION bug_13627_f() returns int BEGIN create function f2 () returns int return 1; return 1; END ;
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN CREATE TEMPORARY TABLE t2 (a int); DROP TEMPORARY TABLE t2; END ;
CREATE FUNCTION bug_13627_f() returns int BEGIN CREATE TEMPORARY TABLE t2 (a int); DROP TEMPORARY TABLE t2; return 1; END ;
drop table t1;
drop function bug_13627_f;
drop function if exists bug12329;
create table t1 as select 1 a;
create table t2 as select 1 a;
create function bug12329() returns int return (select a from t1);
prepare stmt1 from 'select bug12329()';
execute stmt1;
drop function bug12329;
create function bug12329() returns int return (select a+100 from t2);
select bug12329();
execute stmt1;
deallocate prepare stmt1;
drop function bug12329;
drop table t1, t2;
create database mysqltest1;
use mysqltest1;
drop database mysqltest1;
create function f1() returns int return 1;
create procedure p1(out param1 int) begin select count(*) into param1 from t3; end;
use test;
DROP PROCEDURE IF EXISTS bug13037_p1;
DROP PROCEDURE IF EXISTS bug13037_p2;
DROP PROCEDURE IF EXISTS bug13037_p3;
CREATE PROCEDURE bug13037_p1() BEGIN IF bug13037_foo THEN SELECT 1; END IF; END;
CREATE PROCEDURE bug13037_p2() BEGIN SET @bug13037_foo = bug13037_bar; END;
CREATE PROCEDURE bug13037_p3() BEGIN SELECT bug13037_foo; END;
CALL bug13037_p1();
CALL bug13037_p2();
CALL bug13037_p3();
CALL bug13037_p1();
CALL bug13037_p2();
CALL bug13037_p3();
DROP PROCEDURE bug13037_p1;
DROP PROCEDURE bug13037_p2;
DROP PROCEDURE bug13037_p3;
create database mysqltest1;
create database mysqltest2;
use mysqltest1;
drop database mysqltest1;
create procedure mysqltest2.p1() select version();
create procedure p2() select version();
use mysqltest2;
show procedure status like 'p1';
drop database mysqltest2;
use test;
CREATE FUNCTION bug13012() RETURNS INT BEGIN REPAIR TABLE t1; RETURN 1; END;
create table t1 (a int);
CREATE PROCEDURE bug13012_1() REPAIR TABLE t1;
CREATE FUNCTION bug13012_2() RETURNS INT BEGIN CALL bug13012_1(); RETURN 1; END;
SELECT bug13012_2();
drop table t1;
drop procedure bug13012_1;
drop function bug13012_2;
drop function if exists bug11555_1;
drop function if exists bug11555_2;
drop view if exists v1, v2, v3, v4;
create function bug11555_1() returns int return (select max(i) from t1);
create function bug11555_2() returns int return bug11555_1();
create view v1 as select bug11555_1();
drop view v1;
create view v2 as select bug11555_2();
drop view v2;
create table t1 (i int);
create view v1 as select bug11555_1();
create view v2 as select bug11555_2();
create view v3 as select * from v1;
drop table t1;
select * from v1;
select * from v2;
select * from v3;
create view v4 as select * from v1;
drop view v1, v2, v3, v4;
drop function bug11555_1;
drop function bug11555_2;
create table t1 (i int);
create table t2 (i int);
create trigger t1_ai after insert on t1 for each row insert into t2 values (new.i);
create view v1 as select * from t1;
drop table t2;
insert into v1 values (1);
drop trigger t1_ai;
create function bug11555_1() returns int return (select max(i) from t2);
create trigger t1_ai after insert on t1 for each row set @a:=bug11555_1();
insert into v1 values (2);
drop function bug11555_1;
drop table t1;
drop view v1;
create procedure ``() select 1;
create procedure ` `() select 1;
create procedure `bug15658 `() select 1;
create procedure ``.bug15658() select 1;
create procedure `x `.bug15658() select 1;
create procedure ` bug15658`() select 1;
call ` bug15658`();
show procedure status like '%bug15658';
drop procedure ` bug15658`;
drop function if exists bug14270;
drop table if exists t1;
create table t1 (s1 int primary key);
create function bug14270() returns int begin load index into cache t1; return 1; end;
create function bug14270() returns int begin cache index t1 key (`primary`) in keycache1; return 1; end;
drop table t1;
create procedure bug15091() begin declare selectstr varchar(6000) default ' '; declare conditionstr varchar(5000)  default ''; set selectstr = concat(selectstr, ' and ', c.operatorid, 'in (',conditionstr, ')'); end;
call bug15091();
drop procedure bug15091;
create aggregate function bug16896() returns int return 1;
CREATE IF NOT EXISTS PROCEDURE bug14702() BEGIN END;
CREATE PROCEDURE IF NOT EXISTS bug14702() BEGIN END;
CREATE TABLE t1 (i INT);
CREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 INTO @a;
CREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 INTO DUMPFILE "file";
CREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 INTO OUTFILE "file";
CREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 FROM (SELECT 1) AS d1;
DROP PROCEDURE bug20953;
CREATE PROCEDURE bug20953(i INT) CREATE VIEW v AS SELECT i;
CREATE PROCEDURE bug20953() BEGIN DECLARE i INT; CREATE VIEW v AS SELECT i; END ;
PREPARE stmt FROM "CREATE VIEW v AS SELECT ?";
DROP TABLE t1;
drop tables if exists t1;
drop procedure if exists bug24491;
create table t1 (id int primary key auto_increment, value varchar(10));
insert into t1 (id, value) values (1, 'FIRST'), (2, 'SECOND'), (3, 'THIRD');
create procedure bug24491() insert into t1 (id, value) select * from (select 4 as i, 'FOURTH' as v) as y on duplicate key update v = 'DUP';
call bug24491();
call bug24491();
drop procedure bug24491;
create procedure bug24491() insert into t1 (id, value) select * from (select 4 as id, 'FOURTH' as value) as y on duplicate key update y.value = 'DUP';
call bug24491();
call bug24491();
drop procedure bug24491;
drop tables t1;
DROP FUNCTION IF EXISTS bug18914_f1;
DROP FUNCTION IF EXISTS bug18914_f2;
DROP PROCEDURE IF EXISTS bug18914_p1;
DROP PROCEDURE IF EXISTS bug18914_p2;
DROP TABLE IF EXISTS t1, t2;
CREATE TABLE t1 (i INT);
CREATE PROCEDURE bug18914_p1() CREATE TABLE t2 (i INT);
CREATE PROCEDURE bug18914_p2() DROP TABLE IF EXISTS no_such_table;
CREATE FUNCTION bug18914_f1() RETURNS INT BEGIN CALL bug18914_p1(); RETURN 1; END ;
CREATE FUNCTION bug18914_f2() RETURNS INT BEGIN CALL bug18914_p2(); RETURN 1; END ;
CREATE TRIGGER t1_bi BEFORE INSERT ON t1 FOR EACH ROW CALL bug18914_p1();
INSERT INTO t1 VALUES (1);
SELECT bug18914_f1();
SELECT bug18914_f2();
SELECT * FROM t2;
DROP FUNCTION bug18914_f1;
DROP FUNCTION bug18914_f2;
DROP PROCEDURE bug18914_p1;
DROP PROCEDURE bug18914_p2;
DROP TABLE t1;
drop table if exists bogus_table_20713;
drop function if exists func_20713_a;
drop function if exists func_20713_b;
create table bogus_table_20713( id int(10) not null primary key);
insert into bogus_table_20713 values (1), (2), (3);
create function func_20713_a() returns int(11) begin declare id int; declare continue handler for sqlexception set id=null; set @in_func := 1; set id = (select id from bogus_table_20713 where id = 3); set @in_func := 2; return id; end;
create function func_20713_b() returns int(11) begin declare id int; declare continue handler for sqlstate value '42S02' set id=null; set @in_func := 1; set id = (select id from bogus_table_20713 where id = 3); set @in_func := 2; return id; end;
set @in_func := 0;
select func_20713_a();
select @in_func;
set @in_func := 0;
select func_20713_b();
select @in_func;
drop table bogus_table_20713;
set @in_func := 0;
select func_20713_a();
select @in_func;
set @in_func := 0;
select func_20713_b();
select @in_func;
drop function if exists func_20713_a;
drop function if exists func_20713_b;
drop table if exists table_25345_a;
drop table if exists table_25345_b;
drop procedure if exists proc_25345;
drop function if exists func_25345;
drop function if exists func_25345_b;
create table table_25345_a (a int);
create table table_25345_b (b int);
create procedure proc_25345() begin declare c1 cursor for select a from table_25345_a; declare c2 cursor for select b from table_25345_b; select 1 as result; end ;
create function func_25345() returns int(11) begin call proc_25345(); return 1; end ;
create function func_25345_b() returns int(11) begin declare c1 cursor for select a from table_25345_a; declare c2 cursor for select b from table_25345_b; return 1; end ;
call proc_25345();
select func_25345();
select func_25345_b();
drop table table_25345_a;
call proc_25345();
select func_25345();
select func_25345_b();
drop table table_25345_b;
drop procedure proc_25345;
drop function func_25345;
drop function func_25345_b;
create function bug20701() returns varchar(25) binary return "test";
create function bug20701() returns varchar(25) return "test";
drop function bug20701;
create procedure proc_26503_error_1() begin retry: repeat begin declare continue handler for sqlexception begin iterate retry; end select "do something"; end until true end repeat retry; end;
create procedure proc_26503_error_2() begin retry: repeat begin declare continue handler for sqlexception iterate retry; select "do something"; end until true end repeat retry; end;
create procedure proc_26503_error_3() begin retry: repeat begin declare continue handler for sqlexception begin leave retry; end select "do something"; end until true end repeat retry; end;
create procedure proc_26503_error_4() begin retry: repeat begin declare continue handler for sqlexception leave retry; select "do something"; end until true end repeat retry; end;
CREATE PROCEDURE p1() BEGIN DECLARE c char(100); DECLARE cur1 CURSOR FOR SHOW TABLES; OPEN cur1; FETCH cur1 INTO c; select c; CLOSE cur1; END;
CREATE DATABASE mysqltest;
USE mysqltest;
DROP DATABASE mysqltest;
SELECT inexistent(), 1 + ,;
SELECT inexistent();
SELECT .inexistent();
SELECT ..inexistent();
USE test;
create function f1() returns int begin set password = 'foo'; return 1; end;
create trigger t1 before insert on t2 for each row set password = 'foo';;
drop function if exists f1;
drop function if exists f2;
drop table if exists t1, t2;
create function f1() returns int begin drop temporary table t1; return 1; end;
create temporary table t1 as select f1();
create function f2() returns int begin create temporary table t2 as select f1(); return 1; end;
create temporary table t1 as select f2();
drop function f1;
drop function f2;
create function f1() returns int begin drop temporary table t2,t1; return 1; end;
create function f2() returns int begin create temporary table t2 as select f1(); return 1; end;
create temporary table t1 as select f2();
drop function f1;
drop function f2;
create temporary table t2(a int);
select * from t2;
create function f2() returns int begin drop temporary table t2; return 1; end;
select f2();
drop function f2;
drop table t2;
drop procedure if exists proc_33983_a;
drop procedure if exists proc_33983_b;
drop procedure if exists proc_33983_c;
drop procedure if exists proc_33983_d;
create procedure proc_33983_a() begin label1: begin label2: begin select 1; end label1; end; end;
create procedure proc_33983_b() begin label1: repeat label2: repeat select 1; until FALSE end repeat label1; until FALSE end repeat; end;
create procedure proc_33983_c() begin label1: while TRUE do label2: while TRUE do select 1; end while label1; end while; end;
create procedure proc_33983_d() begin label1: loop label2: loop select 1; end loop label1; end loop; end;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1),(2);
CREATE PROCEDURE p1(a INT) BEGIN END;
CALL p1((SELECT * FROM t1));
DROP PROCEDURE IF EXISTS p1;
DROP TABLE t1;
create procedure p1() begin create table t1 (a int); drop table t1; end;
call p1();
call p1();
drop procedure p1;
create procedure proc_8759() begin declare should_be_illegal condition for sqlstate '00000'; declare continue handler for should_be_illegal set @x=0; end;
create procedure proc_8759() begin declare continue handler for sqlstate '00000' set @x=0; end;
create procedure proc_36510() begin declare should_be_illegal condition for sqlstate '00123'; declare continue handler for should_be_illegal set @x=0; end;
create procedure proc_36510() begin declare continue handler for sqlstate '00123' set @x=0; end;
create procedure proc_36510() begin declare should_be_illegal condition for 0; declare continue handler for should_be_illegal set @x=0; end;
create procedure proc_36510() begin declare continue handler for 0 set @x=0; end;
set @old_recursion_depth = @@max_sp_recursion_depth;
set @@max_sp_recursion_depth = 255;
create procedure p1(a int) begin declare continue handler for 1436 -- ER_STACK_OVERRUN_NEED_MORE select 'exception'; call p1(a+1); end;
call p1(1);
set @@max_sp_recursion_depth = @old_recursion_depth;
drop procedure p1;
CREATE TABLE t1 (a INT, b INT);
INSERT INTO t1 VALUES (1,1), (2,2);
SELECT MAX (a) FROM t1 WHERE b = 999999;
SELECT AVG (a) FROM t1 WHERE b = 999999;
SELECT non_existent (a) FROM t1 WHERE b = 999999;
DROP TABLE t1;
CREATE TABLE t1 ( f2 INTEGER, f3 INTEGER );
INSERT INTO t1 VALUES  ( 1, 1 );
CREATE FUNCTION func_1 () RETURNS INTEGER BEGIN INSERT INTO t1 SELECT * FROM t1 ; RETURN 1 ; END;
INSERT INTO t1 SELECT * FROM (SELECT 2 AS f1, 2 AS f2) AS A WHERE func_1() = 5;
DROP FUNCTION func_1;
DROP TABLE t1;
CREATE TABLE t1 (pk INT, b INT, KEY (b));
CREATE ALGORITHM = TEMPTABLE VIEW v1 AS SELECT * FROM t1;
CREATE PROCEDURE p1 (a int) UPDATE IGNORE v1 SET b = a;
CALL p1(5);
ALTER TABLE t1 CHANGE COLUMN b b2 INT;
CALL p1(7);
DROP PROCEDURE p1;
DROP VIEW v1;
DROP TABLE t1;
SELECT very_long_fn_name_1111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222225555555555555555555555555577777777777777777777777777777777777777777777777777777777777777777777777788888888999999999999999999999();
CALL very_long_pr_name_1111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222225555555555555555555555555577777777777777777777777777777777777777777777777777777777777777777777777788888888999999999999999999999();
SELECT very_long_db_name_1111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222225555555555555555555555555577777777777777777777777777777777777777777777777777777777777777777777777788888888999999999999999999999.simple_func();
CALL very_long_db_name_1111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222225555555555555555555555555577777777777777777777777777777777777777777777777777777777777777777777777788888888999999999999999999999.simple_proc();
SELECT db_name.very_long_fn_name_111111111111111111111111111111111111111111111111111111111111111111111111122222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999999999999999999();
CALL db_name.very_long_pr_name_111111111111111111111111111111111111111111111111111111111111111111111111122222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999999999999999999();
DROP PROCEDURE IF EXISTS p1;
DROP PROCEDURE IF EXISTS p2;
DROP PROCEDURE IF EXISTS p3;
DROP PROCEDURE IF EXISTS p4;
DROP PROCEDURE IF EXISTS p5;
DROP PROCEDURE IF EXISTS p6;
SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
CREATE PROCEDURE p1() BEGIN SELECT CAST('10x' as unsigned integer); SELECT 1; CALL p2(); END;
CREATE PROCEDURE p2() BEGIN SELECT CAST('10x' as unsigned integer); END;
CALL p1();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
CREATE TABLE t1(a INT);
CREATE PROCEDURE p1() BEGIN DECLARE c INT DEFAULT 0; DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN SET c = c + 1; SELECT 'Warning caught!' AS Msg; END; CALL p2(); # 1 warning CALL p3(); # 1 warning CALL p4(); # No warnings CALL p5(); # 1 warning SELECT c; SELECT @@warning_count; SHOW WARNINGS; END;
CREATE PROCEDURE p2() BEGIN SELECT CAST('2x' as unsigned integer); END;
CREATE PROCEDURE p3() BEGIN SELECT CAST('3x' as unsigned integer); GET DIAGNOSTICS @n = NUMBER; # does not clear the warning END;
CREATE PROCEDURE p4() BEGIN SELECT CAST('4x' as unsigned integer); INSERT INTO t1 VALUES(1); # Clears the warning END;
CREATE PROCEDURE p5() BEGIN SELECT CAST('5x' as unsigned integer); CALL p2(); END;
CREATE PROCEDURE p6() BEGIN SELECT CAST('6x' as unsigned integer); SHOW WARNINGS; END;
CREATE PROCEDURE p7() BEGIN DECLARE c INT DEFAULT 0; DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN SET c = c + 1; SELECT 'Warning caught!' AS Msg; END; CALL p6(); SELECT c; END;
CALL p1();
CALL p7();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP PROCEDURE p3;
DROP PROCEDURE p4;
DROP PROCEDURE p5;
DROP PROCEDURE p6;
DROP PROCEDURE p7;
DROP TABLE t1;
SET sql_mode = default;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1), (2), (3);
CREATE PROCEDURE p1() BEGIN DECLARE c CURSOR FOR SELECT a FROM t1; OPEN c; BEGIN DECLARE v1 INT; DECLARE v2 INT; DECLARE EXIT HANDLER FOR SQLEXCEPTION SELECT "Error caught (expected)"; DECLARE EXIT HANDLER FOR NOT FOUND SELECT "End of Result Set found!"; WHILE TRUE DO FETCH c INTO v1, v2; END WHILE; END; CLOSE c; SELECT a INTO @foo FROM t1 LIMIT 1; # Clear warning stack END;
CALL p1();
DROP PROCEDURE p1;
DROP TABLE t1;
DROP TABLE IF EXISTS t1;
DROP PROCEDURE IF EXISTS p1;
CREATE TABLE t1 (a INT, b INT NOT NULL);
CREATE PROCEDURE p1() BEGIN DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'warning'; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'exception'; INSERT INTO t1 VALUES (CAST('10 ' AS SIGNED), NULL); END;
CALL p1();
DROP TABLE t1;
DROP PROCEDURE p1;
SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE TRIGGER t1_bu BEFORE UPDATE ON t1 FOR EACH ROW BEGIN DECLARE EXIT HANDLER FOR SQLWARNING SET NEW.a = 10; SET NEW.a = 99999999999; END;
UPDATE t1 SET b = 20;
SHOW WARNINGS;
SELECT * FROM t1;
DROP TRIGGER t1_bu;
DROP TABLE t1;
SET sql_mode = default;
CREATE TABLE t1(a INT PRIMARY KEY);
INSERT INTO t1 VALUES(1);
SET @sql_mode_saved = @@sql_mode;
SET sql_mode = traditional;
CREATE PROCEDURE p1() BEGIN DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'warning caught (expected)'; INSERT IGNORE INTO t1 VALUES (1); END;
CREATE PROCEDURE p2() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'error caught (unexpected)'; INSERT IGNORE INTO t1 VALUES (1); END;
CALL p1();
SHOW WARNINGS;
CALL p2();
SHOW WARNINGS;
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
SET sql_mode = @sql_mode_saved;
SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
DROP TABLE IF EXISTS t1;
DROP TABLE IF EXISTS t2;
DROP PROCEDURE IF EXISTS p1;
CREATE TABLE t1(x SMALLINT, y SMALLINT, z SMALLINT);
CREATE TABLE t2(a SMALLINT, b SMALLINT, c SMALLINT, d SMALLINT, e SMALLINT, f SMALLINT);
CREATE TRIGGER t1_bi BEFORE INSERT ON t1 FOR EACH ROW INSERT INTO t2(a, b, c) VALUES(99999, 99999, 99999);
CREATE TRIGGER t1_ai AFTER INSERT ON t1 FOR EACH ROW INSERT INTO t2(d, e, f) VALUES(99999, 99999, 99999);
CREATE PROCEDURE p1() INSERT INTO t1 VALUES(99999, 99999, 99999);
CALL p1();
SHOW WARNINGS;
DROP TABLE t1;
DROP TABLE t2;
DROP PROCEDURE p1;
CREATE TABLE t1(x SMALLINT, y SMALLINT, z SMALLINT);
CREATE TABLE t2(a SMALLINT, b SMALLINT, c SMALLINT NOT NULL);
CREATE TRIGGER t1_bi BEFORE INSERT ON t1 FOR EACH ROW BEGIN INSERT INTO t2 VALUES( CAST('111111X' AS SIGNED), CAST('222222X' AS SIGNED), NULL); END;
CREATE PROCEDURE p1() INSERT INTO t1 VALUES(99999, 99999, 99999);
CALL p1();
SHOW WARNINGS;
DROP TABLE t1;
DROP TABLE t2;
DROP PROCEDURE p1;
SET sql_mode = default;
CREATE PROCEDURE p1() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H2' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should be handled by H2. END;
CALL p1();
CREATE PROCEDURE p2() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H2' AS HandlerId; BEGIN SELECT 'B1' AS BlockId; BEGIN SELECT 'B2' AS BlockId; BEGIN SELECT 'B3' AS BlockId; SIGNAL SQLSTATE '01000'; # Should be handled by H2. END; END; END; END;
CALL p2();
CREATE PROCEDURE p3() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'     SELECT 'H3' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should be handled by H3. END;
CALL p3();
CREATE PROCEDURE p4() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'     SELECT 'H2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H3' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should be handled by H2. END;
CALL p4();
CREATE PROCEDURE p5() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'     SELECT 'H2' AS HandlerId; BEGIN DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H3' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should be handled by H3. END; END;
CALL p5();
CREATE PROCEDURE p6() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN SELECT 'H1' AS HandlerId; SIGNAL SQLSTATE 'HY000'; # Should *not* be handled by H1. END; SELECT 'S1' AS SignalId; SIGNAL SQLSTATE 'HY000'; # Should be handled by H1. END;
CALL p6();
CREATE PROCEDURE p7() BEGIN DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN SELECT 'H1' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should *not* be handled by H1. END; SELECT 'S1' AS SignalId; SIGNAL SQLSTATE '01000'; # Should be handled by H1. END;
CALL p7();
CREATE PROCEDURE p8() BEGIN DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN SELECT 'H2' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should *not* be handled by H1. END; SELECT 'S1' AS SignalId; SIGNAL SQLSTATE 'HY000'; # Should be handled by H2. END;
CALL p8();
CREATE PROCEDURE p9() BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'     SELECT 'Wrong:H1:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H1:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'       SELECT 'Wrong:H2:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H2:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'         SELECT 'Wrong:H3:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H3:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'           SELECT 'Wrong:H4:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H4:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'             SELECT 'Wrong:H5:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H5:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'               SELECT 'Wrong:H6:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H6:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN SELECT 'H2' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should *not* be handled by H1. END; SELECT 'S6' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S5' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S4' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S3' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S2' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S1' AS SignalId; SIGNAL SQLSTATE 'HY000'; # Should be handled by H2. END;
CALL p9();
CREATE PROCEDURE p10() BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'     SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H2' AS HandlerId; BEGIN BEGIN BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'           SELECT 'Wrong:H1:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H1:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'             SELECT 'Wrong:H2:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H2:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'               SELECT 'Wrong:H3:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H3:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'                 SELECT 'Wrong:H4:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H4:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'                   SELECT 'Wrong:H5:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H5:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'                     SELECT 'Wrong:H6:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H6:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN SELECT 'H2' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should be handled by H1. END; SELECT 'S6' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S5' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S4' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S3' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S2' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S1' AS SignalId; SIGNAL SQLSTATE 'HY000'; # Should be handled by H2. END; END; END; END;
CALL p10();
CREATE PROCEDURE p11() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H2' AS HandlerId; BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000', 1249 BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'H3' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H4' AS HandlerId; BEGIN SELECT 'H5' AS HandlerId; SELECT 'S3' AS SignalId; SIGNAL SQLSTATE 'HY000'; # H3 SELECT 'S4' AS SignalId; SIGNAL SQLSTATE '22003'; # H3 SELECT 'S5' AS SignalId; SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1249; # H4 END; END; SELECT 'S6' AS SignalId; SIGNAL SQLSTATE 'HY000'; # H1 SELECT 'S7' AS SignalId; SIGNAL SQLSTATE '22003'; # H1 SELECT 'S8' AS SignalId; SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1249; # H5 END; SELECT 'S1' AS SignalId; SIGNAL SQLSTATE 'HY000'; # H1 SELECT 'S2' AS SignalId; SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1249; # H2 END;
CALL p11();
CREATE PROCEDURE p12() BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01001'   BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01001'     BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01001'       BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01001'         BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01001'           BEGIN SELECT 'H1:5' AS HandlerId; SIGNAL SQLSTATE '01002'; END; SELECT 'H1:4' AS HandlerId; SIGNAL SQLSTATE '01001'; END; SELECT 'H1:3' AS HandlerId; SIGNAL SQLSTATE '01001'; END; SELECT 'H1:2' AS HandlerId; SIGNAL SQLSTATE '01001'; END; SELECT 'H1:1' AS HandlerId; SIGNAL SQLSTATE '01001'; END; ######################################################### DECLARE CONTINUE HANDLER FOR SQLSTATE '01002'     SELECT 'OK' AS Msg; ######################################################### BEGIN DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN SELECT 'H2:5' AS HandlerId; SIGNAL SQLSTATE '01001'; END; SELECT 'H2:4' AS HandlerId; SIGNAL SQLSTATE '01000'; END; SELECT 'H2:3' AS HandlerId; SIGNAL SQLSTATE '01000'; END; SELECT 'H2:2' AS HandlerId; SIGNAL SQLSTATE '01000'; END; SELECT 'H2:1' AS HandlerId; SIGNAL SQLSTATE '01000'; END; ####################################################### SELECT 'Throw 01000' AS Msg; SIGNAL SQLSTATE '01000'; END; END;
CALL p12();
CREATE PROCEDURE p13() BEGIN DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN DECLARE EXIT HANDLER FOR SQLWARNING BEGIN SELECT 'EXIT handler 3' AS Msg; END; SELECT 'CONTINUE handler 2: 1' AS Msg; SIGNAL SQLSTATE '01000'; SELECT 'CONTINUE handler 2: 2' AS Msg; END; SELECT 'CONTINUE handler 1: 1' AS Msg; SIGNAL SQLSTATE '01000'; SELECT 'CONTINUE handler 1: 2' AS Msg; END; SELECT 'Throw 01000' AS Msg; SIGNAL SQLSTATE '01000'; END;
CALL p13();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP PROCEDURE p3;
DROP PROCEDURE p4;
DROP PROCEDURE p5;
DROP PROCEDURE p6;
DROP PROCEDURE p7;
DROP PROCEDURE p8;
DROP PROCEDURE p9;
DROP PROCEDURE p10;
DROP PROCEDURE p11;
DROP PROCEDURE p12;
DROP PROCEDURE p13;
SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
DROP FUNCTION IF EXISTS f1;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1(msg VARCHAR(255));
CREATE FUNCTION f1() RETURNS INT BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION               # handler 1 BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION             # handler 2 BEGIN INSERT INTO t1 VALUE('WRONG: Inside H2'); RETURN 2; END; INSERT INTO t1 VALUE('CORRECT: Inside H1'); RETURN 1; END; BEGIN DECLARE CONTINUE HANDLER FOR SQLWARNING               # handler 3 BEGIN INSERT INTO t1 VALUE('WRONG: Inside H3'); RETURN 3; END; INSERT INTO t1 VALUE('CORRECT: Calling f1()'); RETURN f1(); # -- exception here END; INSERT INTO t1 VALUE('WRONG: Returning 10'); RETURN 10; END;
SELECT f1();
SELECT * FROM t1;
DROP FUNCTION f1;
DROP TABLE t1;
DROP TABLE IF EXISTS t1;
DROP TABLE IF EXISTS t2;
DROP PROCEDURE IF EXISTS p1;
DROP PROCEDURE IF EXISTS p2;
DROP PROCEDURE IF EXISTS p3;
DROP PROCEDURE IF EXISTS p4;
DROP PROCEDURE IF EXISTS p5;
CREATE TABLE t1(a CHAR, b CHAR, c CHAR);
CREATE TABLE t2(a SMALLINT, b SMALLINT, c SMALLINT);
CREATE PROCEDURE p1() BEGIN DECLARE EXIT HANDLER FOR SQLWARNING SELECT 'Warning caught' AS msg; # The INSERT below raises 3 SQL-conditions (warnings). The EXIT HANDLER # above must be invoked once (for one condition), but all three conditions # must be cleared from the Diagnostics Area. INSERT INTO t1 VALUES('qqqq', 'ww', 'eee'); # The following INSERT will not be executed, because of the EXIT HANDLER. INSERT INTO t1 VALUES('zzz', 'xx', 'yyyy'); END;
CALL p1();
SELECT * FROM t1;
CREATE PROCEDURE p2() BEGIN DECLARE CONTINUE HANDLER FOR 1292 SELECT 'Warning 1292 caught' AS msg; # The following INSERT raises 6 SQL-warnings with code 1292, # and 3 SQL-warnings with code 1264. The CONTINUE HANDLER above must be # invoked once, and all nine SQL-warnings must be cleared from # the Diagnostics Area. INSERT INTO t2 SELECT CAST(CONCAT(CAST('1X' AS UNSIGNED INTEGER), '999999XX') AS SIGNED INTEGER), CAST(CONCAT(CAST('2X' AS UNSIGNED INTEGER), '999999XX') AS SIGNED INTEGER), CAST(CONCAT(CAST('3X' AS UNSIGNED INTEGER), '999999XX') AS SIGNED INTEGER); END;
CALL p2();
CREATE PROCEDURE p3() BEGIN DECLARE CONTINUE HANDLER FOR 1292 SELECT 'Warning 1292 caught' AS msg; DECLARE CONTINUE HANDLER FOR 1264 SELECT 'Warning 1264 caught' AS msg; # The following INSERT raises 6 SQL-warnings with code 1292, # and 3 SQL-warnings with code 1264. Only one of the CONTINUE HANDLERs above # must be called, and only once. The SQL Standard does not define, which one # should be invoked. INSERT INTO t2 SELECT CAST(CONCAT(CAST('1X' AS UNSIGNED INTEGER), '999999XX') AS SIGNED INTEGER), CAST(CONCAT(CAST('2X' AS UNSIGNED INTEGER), '999999XX') AS SIGNED INTEGER), CAST(CONCAT(CAST('3X' AS UNSIGNED INTEGER), '999999XX') AS SIGNED INTEGER); END;
CALL p3();
CREATE PROCEDURE p4() BEGIN DECLARE CONTINUE HANDLER FOR 1292 SELECT 'Warning 1292 caught' AS msg; DECLARE CONTINUE HANDLER FOR 1264 SELECT 'Warning 1264 caught' AS msg; # The following INSERT raises 4 SQL-warnings with code 1292, # and 3 SQL-warnings with code 1264. Only one of the CONTINUE HANDLERs above # must be called, and only once. The SQL Standard does not define, which one # should be invoked. INSERT INTO t2 SELECT CAST(999999 AS SIGNED INTEGER), CAST(CONCAT(CAST('2X' AS UNSIGNED INTEGER), '999999XX') AS SIGNED INTEGER), CAST(CONCAT(CAST('3X' AS UNSIGNED INTEGER), '999999XX') AS SIGNED INTEGER); END;
CALL p4();
CREATE PROCEDURE p5() BEGIN DECLARE EXIT HANDLER FOR 1292 BEGIN SELECT 'Handler for 1292' AS Msg; SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1234; SHOW WARNINGS; END; INSERT INTO t2 SELECT CAST(999999 AS SIGNED INTEGER), CAST(CONCAT(CAST('2X' AS UNSIGNED INTEGER), '999999XX') AS SIGNED INTEGER), CAST(CONCAT(CAST('3X' AS UNSIGNED INTEGER), '999999XX') AS SIGNED INTEGER); END;
CALL p5();
CREATE PROCEDURE p6() BEGIN DECLARE CONTINUE HANDLER FOR 1292 BEGIN SHOW WARNINGS; SELECT 'Handler for 1292' Msg; END; INSERT INTO t2 SELECT CAST(CONCAT(CAST('1X' AS UNSIGNED INTEGER), '999999XX') AS SIGNED INTEGER), CAST(CONCAT(CAST('2X' AS UNSIGNED INTEGER), '999999XX') AS SIGNED INTEGER), CAST(CONCAT(CAST('3X' AS UNSIGNED INTEGER), '999999XX') AS SIGNED INTEGER); END;
CALL p6();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP PROCEDURE p3;
DROP PROCEDURE p4;
DROP PROCEDURE p5;
DROP PROCEDURE p6;
DROP TABLE t1;
DROP TABLE t2;
SET sql_mode = default;
SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
DROP PROCEDURE IF EXISTS p1;
DROP PROCEDURE IF EXISTS p2;
CREATE PROCEDURE p1() BEGIN DECLARE var1 INTEGER DEFAULT 'string'; DECLARE EXIT HANDLER FOR SQLWARNING SELECT 'H1'; END;
CALL p1();
CREATE PROCEDURE p2() BEGIN DECLARE EXIT HANDLER FOR SQLWARNING SELECT 'H2'; CALL p1(); END;
CALL p2();
DROP PROCEDURE p1;
DROP PROCEDURE p2;
SET sql_mode = default;
DROP PROCEDURE IF EXISTS p1;
DROP PROCEDURE IF EXISTS p2;
CREATE PROCEDURE p1() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'triggered p1'; # This will trigger an error. SIGNAL SQLSTATE 'HY000'; END;
CREATE PROCEDURE p2() BEGIN DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'triggered p2'; # This will trigger a warning. SIGNAL SQLSTATE '01000'; END;
SET @old_max_error_count=  @@session.max_error_count;
SET SESSION max_error_count= 0;
CALL p1();
CALL p2();
SET SESSION max_error_count= @old_max_error_count;
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP FUNCTION IF EXISTS f1;
DROP FUNCTION IF EXISTS f2;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT, b INT);
INSERT INTO t1 VALUES (1, 2);
CREATE FUNCTION f1() RETURNS INTEGER BEGIN DECLARE v VARCHAR(5) DEFAULT -1; SELECT b FROM t1 WHERE a = 2 INTO v; RETURN v; END;
CREATE FUNCTION f2() RETURNS INTEGER BEGIN DECLARE v INTEGER; DECLARE CONTINUE HANDLER FOR NOT FOUND SET @msg = 'Handler activated.'; SELECT f1() INTO v; RETURN v; END;
SET @msg = '';
SELECT f2();
SELECT @msg;
DROP FUNCTION f1;
DROP FUNCTION f2;
DROP TABLE t1;
drop function f111111111122222222223333333333444444444455555555556666666666777777777788888888889999999999aaaaaaaaaabbbbbbbbbbccccccccccddddddddddeeeeeeeeeeffffffffffgggggggggghhhhhhhhhhiiiiiiiiiijjjjjjjjjjkk;
drop function test.f111111111122222222223333333333444444444455555555556666666666777777777788888888889999999999aaaaaaaaaabbbbbbbbbbccccccccccddddddddddeeeeeeeeeeffffffffffgggggggggghhhhhhhhhhiiiiiiiiiijjjjjjjjjjkk;
drop function mysqltest111111111122222222223333333333444444444455555555556666666666777777777788888888889999999999aaaaaaaaaabbbbbbbbbbccccccccccddddddddddeeeeeeeeeeffffffffffgggggggggghhhhhhhhhhiiiiiiiiiijjjj.test;
SET @orig_character_set_client = @@character_set_client;
SET character_set_client = utf8;
CREATE PROCEDURE oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo() SELECT 1 AS my_column;
ALTER PROCEDURE oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo COMMENT 'Changed';
CALL oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo();
DROP PROCEDURE oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo;
CREATE PROCEDURE ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo() SELECT 1 AS my_column;
ALTER PROCEDURE ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo COMMENT 'Changed';
CALL ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo();
DROP PROCEDURE ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo;
CREATE FUNCTION oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo() RETURNS INT RETURN 1;
ALTER FUNCTION oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo COMMENT 'Changed';
SELECT oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo() AS my_column;
DROP FUNCTION oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo;
CREATE FUNCTION ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo() RETURNS INT RETURN 1;
ALTER FUNCTION ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo COMMENT 'Changed';
SELECT ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo() AS my_column;
DROP FUNCTION ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo;
CREATE PROCEDURE test𝌆() SELECT 1;
CREATE FUNCTION test𝌆() RETURNS INT RETURN 1;
CREATE PROCEDURE p(IN oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo INT) SELECT 1 AS my_column;
DROP PROCEDURE p;
CREATE PROCEDURE p(IN ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo INT) SELECT 1 AS my_column;
CREATE FUNCTION f(oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo INT) RETURNS INT RETURN 1;
DROP FUNCTION f;
CREATE FUNCTION f(ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo INT) RETURNS INT RETURN 1;
CREATE PROCEDURE p(IN test𝌆 INT) SELECT 1;
CREATE FUNCTION f(test𝌆 INT) RETURNS INT RETURN 1;
DROP PROCEDURE p1;
DROP FUNCTION f1;
CREATE PROCEDURE p1() SELECT 1;
DROP PROCEDURE p1;
CREATE FUNCTION f1() RETURNS INT RETURN 1;
DROP FUNCTION f1;
CREATE PROCEDURE p2() COMMENT 'test𝌆' SELECT 1;
CREATE FUNCTION f2() RETURNS INT COMMENT 'test𝌆' RETURN 1;
CREATE PROCEDURE p2() SELECT 1;
ALTER PROCEDURE p2 COMMENT 'test𝌆';
DROP PROCEDURE p2;
CREATE FUNCTION f2() RETURNS INT RETURN 1;
ALTER FUNCTION f2 COMMENT 'test𝌆';
DROP FUNCTION f2;
SET character_set_client = @orig_character_set_client;
CREATE DATABASE mysqltest;
USE mysqltest;
DROP DATABASE mysqltest;
SELECT DATABASE();
CREATE DATABASE mysqltest;
CREATE FUNCTION mysqltest.f1() RETURNS INT RETURN 0;
CREATE FUNCTION mysqltest.f2() RETURNS INT RETURN f1();
USE mysqltest;
SELECT f1();
SELECT f2();
DROP FUNCTION IF EXISTS f2;
DROP FUNCTION IF EXISTS f1;
DROP DATABASE mysqltest;
